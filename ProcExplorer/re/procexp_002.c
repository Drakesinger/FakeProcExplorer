

//----- (00FAEEA0) --------------------------------------------------------
wchar_t *__thiscall sub_FAEEA0(int this, int a2, int a3, wchar_t *Dst, int a5)
{
  wchar_t *v5; // edi
  int v6; // eax
  CStringData *v7; // eax
  wchar_t *v8; // esi
  void **v9; // eax
  int v10; // edx
  volatile signed __int32 *v11; // esi

  v5 = Dst;
  *Dst = 0;
  switch ( a3 )
  {
    case 0:
      return *(this + 4);
    case 1:
      wcscat_s(v5, *a5, *(this + 20));
      break;
    case 2:
      v6 = *(this + 24);
      if ( *(v6 - 12) )
      {
        v7 = sub_FAB970((v6 - 16));
        v8 = &v7[1];
        Dst = &v7[1];
        if ( *a5 < v7->nDataLength + 1 )
        {
          v9 = sub_FAF790(&Dst, &a3, 0, *a5 - 4);
          sub_FAD840(&Dst, v9);
          v10 = a3 - 16;
          if ( _InterlockedDecrement((a3 - 16 + 12)) <= 0 )
            (*(**v10 + 4))(v10);
          sub_FADB40(&Dst, L"...");
          v8 = Dst;
        }
        wcscat_s(v5, *a5, v8);
        v11 = (v8 - 8);
        if ( _InterlockedDecrement(v11 + 3) <= 0 )
        {
          (*(**v11 + 4))(v11);
          return v5;
        }
      }
      break;
  }
  return v5;
}

//----- (00FAEFF0) --------------------------------------------------------
wchar_t *__thiscall sub_FAEFF0(int this, int a2, int a3, wchar_t *Dst, int a5)
{
  int v6; // eax
  wchar_t *v7; // esi
  int v8; // [esp-4h] [ebp-8h]

  if ( a3 )
  {
    if ( a3 != 1 || *(this + 20) == -3 )
    {
      *Dst = 0;
      return Dst;
    }
    v6 = *(this + 8);
    v8 = *(this + 12);
    v7 = Dst;
    if ( *(v6 - 12) )
    {
      swprintf_s(Dst, *a5, L"%s, %s", v6, v8);
      return Dst;
    }
    swprintf_s(Dst, *a5, L"%s", v8);
  }
  else
  {
    v7 = Dst;
    swprintf_s(Dst, *a5, L"CLR %s", *(this + 24));
  }
  return v7;
}

//----- (00FAF070) --------------------------------------------------------
wchar_t *__stdcall sub_FAF070(int a1, int a2, wchar_t *Dst, int a4)
{
  swprintf_s(Dst, *a4, &gszNullString);
  return Dst;
}

//----- (00FAF090) --------------------------------------------------------
const wchar_t *CResizer::GetName()
{
  return L"status";
}
// 103C890: using guessed type wchar_t aStatus[7];

//----- (00FAF0A0) --------------------------------------------------------
int __thiscall sub_FAF0A0(_DWORD *this, int a2)
{
  _DWORD *v2; // ebx
  _DWORD *v3; // edx
  Runtime *v4; // edi
  int v5; // esi
  int v6; // eax
  unsigned __int16 *v7; // esi
  Runtime *v8; // eax
  int v9; // edi
  _WORD *v10; // ebx
  wchar_t *v11; // eax
  int v12; // eax
  void **v13; // eax
  CString *v14; // ecx
  int v15; // eax
  void **v16; // eax
  CHAR *v17; // ecx
  CString *v18; // edi
  bool v19; // zf
  void *v20; // eax
  int v21; // ebx
  int v22; // edi
  int v23; // esi
  CString *v24; // esi
  UINT v25; // ebx
  int v26; // ebx
  int v27; // edi
  AppDomain *v28; // esi
  unsigned __int16 v29; // ax
  Runtime *v30; // eax
  CString *v31; // esi
  CHAR *v32; // ST18_4
  int v33; // ebx
  int v34; // edi
  AppDomain *v35; // esi
  unsigned __int16 v36; // ax
  Runtime *v37; // eax
  AppDomain *v38; // edi
  CString *v39; // esi
  CString *v40; // eax
  CHAR *v41; // ST14_4
  char v42; // bl
  CString *v43; // esi
  int v44; // esi
  unsigned __int16 v45; // ax
  Runtime *v46; // eax
  CString *v47; // edi
  _WORD *v48; // eax
  CHAR *v49; // ST18_4
  Runtime *v50; // eax
  Runtime *v51; // eax
  void *v52; // esi
  CString v54; // [esp+10h] [ebp-1834h]
  CString v55; // [esp+14h] [ebp-1830h]
  void *v56; // [esp+18h] [ebp-182Ch]
  CString v57; // [esp+1Ch] [ebp-1828h]
  void *v58; // [esp+20h] [ebp-1824h]
  Runtime *v59; // [esp+24h] [ebp-1820h]
  tagAccountInfo pInfo; // [esp+28h] [ebp-181Ch]
  wchar_t Dst; // [esp+834h] [ebp-1010h]
  wchar_t Src; // [esp+1034h] [ebp-810h]
  int v63; // [esp+1840h] [ebp-4h]

  v2 = this;
  v58 = this;
  pInfo.nMenuID = 0;
  v3 = this[6];
  *pInfo.szUserName = v3;
  v4 = *(a2 + 12);
  v5 = *(a2 + 40);
  v6 = *(a2 + 45);
  v59 = v4;
  if ( v4 == v3[1] )
  {
    if ( this[3] )
    {
      switch ( v5 )
      {
        case 145:
          v50 = **(a2 + 92);
          pInfo.bIsSystemUser = **(a2 + 92);
          v51 = sub_FAEBA0(v3, v4, v50);
          sub_FB01B0(v51);
          v52 = v2[8];
          sub_FACF50(&v58, v2[7], v2[8], &pInfo);
          if ( v58 != v52 )
            sub_FB0840(v2 + 7, &pInfo, v58);
          v19 = v2[7] == v2[8];
          goto LABEL_36;
        case 153:
          v44 = *(a2 + 92);
          v45 = sub_FAEA30(*(a2 + 92));
          v46 = sub_FAEBA0(*pInfo.szUserName, v4, v45);
          v47 = sub_FAE810(v46, *(v44 + 8), *(v44 + 12));
          if ( !v47 )
            return 0;
          if ( *(v44 + 16) & 2 )
            v48 = sub_FAEAB0(v44);
          else
            v48 = (v44 + 24);
          v49 = ATL::CStringT<wchar_t,ATL::StrTraitATL<wchar_t,ATL::ChTraitsCRT<wchar_t>>>::Format(&v57, v48)->pszData;
          v63 = 8;
          sub_FB00E0(v47, v49);
          v14 = &v57;
          goto LABEL_32;
        case 155:
          v33 = *(a2 + 92);
          v34 = *(v33 + 8);
          v35 = *(v33 + 12);
          v58 = *v33;
          pInfo.bIsSystemUser = *(v33 + 4);
          v36 = sub_FAEA10(v33);
          v37 = sub_FAEBA0(*pInfo.szUserName, v59, v36);
          v38 = sub_FAEAD0(v37, v34, v35);
          sub_FADC50(&Src, 0x400u, *(v33 + 24));
          v39 = operator new(0x20u);
          v56 = v39;
          v63 = 5;
          if ( v39 )
          {
            v40 = ATL::CStringT<wchar_t,ATL::StrTraitATL<wchar_t,ATL::ChTraitsCRT<wchar_t>>>::Format(&v55, v33 + 28);
            LOBYTE(v63) = 6;
            v41 = v40->pszData;
            v42 = 1;
            pInfo.nMenuID = 1;
            v43 = Assembly::Assembly(v39, v58, pInfo.bIsSystemUser, v41, &Src);
          }
          else
          {
            v42 = pInfo.nMenuID;
            v43 = 0;
          }
          v63 = -1;
          if ( v42 & 1 )
            ATL::CSimpleStringT<wchar_t,0>::~CSimpleStringT<wchar_t,0>(&v55);
          pInfo.bIsSystemUser = v43;
          std::vector<tagAccountInfo *,std::allocator<tagAccountInfo *>>::push_back((v38 + 28), &pInfo);
          break;
        case 157:
          v26 = *(a2 + 92);
          v27 = *v26;
          v28 = *(v26 + 4);
          v29 = sub_FAE9F0(v26);
          v30 = sub_FAEBA0(*pInfo.szUserName, v59, v29);
          v31 = sub_FAEAD0(v30, v27, v28);
          v31[4].pszData = sub_FAEA90(v26);
          v32 = ATL::CStringT<wchar_t,ATL::StrTraitATL<wchar_t,ATL::ChTraitsCRT<wchar_t>>>::Format(&v54, v26 + 12)->pszData;
          v63 = 4;
          sub_FB00E0(v31, v32);
          v63 = -1;
          ATL::CSimpleStringT<wchar_t,0>::~CSimpleStringT<wchar_t,0>(&v54);
          sub_FADB10(&Src, 0x400u, *(v26 + 8));
          sub_FAFEB0(v31, &Src);
          break;
        case 187:
          pInfo.nMenuID = *(a2 + 92);
          v20 = *pInfo.nMenuID;
          v21 = *(pInfo.nMenuID + 14);
          v22 = *(pInfo.nMenuID + 16);
          v23 = *(pInfo.nMenuID + 18);
          pInfo.bIsSystemUser = *(pInfo.nMenuID + 12);
          v56 = v20;
          v59 = sub_FAEBA0(*pInfo.szUserName, v59, v20);
          sub_FAFF00(v59, (pInfo.nMenuID + 25));
          sub_FB0880(v58 + 7, &v56);
          swprintf_s(&Dst, 0x400u, L"v%u.%u.%u.%u", pInfo.bIsSystemUser, v21, v22, v23);
          v24 = v59;
          sub_FB00E0(v59, &Dst);
          v25 = pInfo.nMenuID;
          sub_FAE970(&pInfo.szUserName[2], 0x400u, *(pInfo.nMenuID + 20), &unk_105D178, 15);
          sub_FAFF50(v24, &pInfo.szUserName[2]);
          sub_FB01D0(&Src, 0x400u, *(v25 + 24));
          sub_FAFFA0(v24, &Src);
          break;
        default:
          return 0;
      }
    }
    else if ( !v5 )
    {
      if ( v6 == 35 )
      {
        v7 = *(a2 + 92);
        v8 = sub_FAEBA0(v3, v4, 0xFFFD);
        v9 = *v7;
        v10 = v7 + 12;
        v59 = v8;
        ATL::CStringT<wchar_t,ATL::StrTraitATL<wchar_t,ATL::ChTraitsCRT<wchar_t>>>::Format(pInfo.szUserName, (v7 + 12));
        v63 = 0;
        v11 = wcsrchr(*pInfo.szUserName, 0x5Cu);
        if ( v11 )
        {
          v12 = (v11 - *pInfo.szUserName) >> 1;
          if ( v12 >= 0 )
          {
            v13 = sub_FAF760(pInfo.szUserName, &pInfo.nMenuID, v12 + 1);
            LOBYTE(v63) = 1;
            sub_FAD840(pInfo.szUserName, v13);
            LOBYTE(v63) = 0;
            ATL::CSimpleStringT<wchar_t,0>::~CSimpleStringT<wchar_t,0>(&pInfo.nMenuID);
          }
        }
        v14 = pInfo.szUserName;
        if ( *(*pInfo.szUserName - 12) )
        {
          v15 = sub_FAFE80(pInfo.szUserName, 0x2Eu);
          if ( v15 >= 0 )
          {
            v16 = sub_FAF790(pInfo.szUserName, &pInfo.nMenuID, 0, v15);
            LOBYTE(v63) = 2;
            sub_FAD840(pInfo.szUserName, v16);
            LOBYTE(v63) = 0;
            ATL::CSimpleStringT<wchar_t,0>::~CSimpleStringT<wchar_t,0>(&pInfo.nMenuID);
          }
          sub_FAE970(&Dst, 0x400u, v7[8], &dword_105D130, 4);
          v17 = operator new(0x20u);
          v57.pszData = v17;
          LOBYTE(v63) = 3;
          if ( v17 )
            v18 = Assembly::Assembly(v17, v9, v9 >> 31, &gszNullString, &Dst);
          else
            v18 = 0;
          LOBYTE(v63) = 0;
          sub_FAFF00(v18, *pInfo.szUserName);
          if ( *(v7 + 4) & 2 )
            v10 = sub_FAEAB0(v7);
          sub_FB00E0(v18, v10);
          pInfo.nMenuID = v18;
          std::vector<tagAccountInfo *,std::allocator<tagAccountInfo *>>::push_back((v59 + 44), (&pInfo + 4));
          ATL::CSimpleStringT<wchar_t,0>::~CSimpleStringT<wchar_t,0>(pInfo.szUserName);
        }
        else
        {
LABEL_32:
          ATL::CSimpleStringT<wchar_t,0>::~CSimpleStringT<wchar_t,0>(v14);
        }
      }
      else
      {
        v19 = v6 == 14;
LABEL_36:
        if ( v19 )
          CloseTrace(*(v2 + 2));
      }
    }
  }
  return 0;
}
// 105D130: using guessed type int dword_105D130;

//----- (00FAF690) --------------------------------------------------------
int __cdecl sub_FAF690(const unsigned __int16 *a1)
{
  signed int v1; // edi
  int v2; // esi
  signed int i; // edx
  unsigned int v4; // eax
  int v5; // eax

  v1 = 1;
  v2 = 0;
  for ( i = wcslen(a1) - 1; i >= 0; --i )
  {
    v4 = a1[i];
    if ( (v4 == 120 || v4 == 88) && a1[i - 1] == 48 )
      return v2;
    if ( v4 < 0x30 || v4 > 0x39 )
    {
      if ( v4 < 0x61 || v4 > 0x66 )
      {
        if ( v4 < 0x41 || v4 > 0x46 )
          continue;
        v5 = v4 - 55;
      }
      else
      {
        v5 = v4 - 87;
      }
    }
    else
    {
      v5 = v4 - 48;
    }
    v2 |= v5 * v1;
    v1 *= 16;
  }
  return v2;
}

//----- (00FAF710) --------------------------------------------------------
bool __cdecl sub_FAF710(int a1, int a2, int a3)
{
  return *(a1 + 8) == a2 && *(a1 + 12) == a3;
}

//----- (00FAF730) --------------------------------------------------------
bool __cdecl sub_FAF730(int a1, int a2)
{
  return *(a1 + 28) == *a2 && *(a1 + 20) == *(a2 + 4);
}

//----- (00FAF760) --------------------------------------------------------
void **__thiscall sub_FAF760(_DWORD *this, void **a2, int a3)
{
  sub_FAF790(this, a2, a3, *(*this - 12) - a3);
  return a2;
}

//----- (00FAF790) --------------------------------------------------------
void **__thiscall sub_FAF790(_DWORD *this, void **a2, int a3, int a4)
{
  int v4; // esi
  _DWORD *v5; // ebx
  int v6; // edi
  int v7; // edx
  int v8; // ecx
  CStringData *v9; // ecx
  void **result; // eax
  int v11; // ecx
  int v12; // eax
  IAtlStringMgr *v13; // eax

  v4 = a4;
  v5 = this;
  v6 = a3;
  if ( a3 < 0 )
    v6 = 0;
  if ( a4 < 0 )
    v4 = 0;
  if ( 0x7FFFFFFF - v6 < v4 )
    ATL::AtlThrowImpl(-2147024362);
  v7 = *this;
  v8 = *(*this - 12);
  if ( v6 + v4 > v8 )
    v4 = v8 - v6;
  if ( v6 > v8 )
    v4 = 0;
  if ( v6 || v4 != v8 )
  {
    v11 = *(v7 - 16);
    if ( !v11 || (v12 = (*(*v11 + 16))()) == 0 )
    {
      v13 = ATL::StrTraitATL<wchar_t,ATL::ChTraitsCRT<wchar_t>>::GetDefaultManager();
      v12 = (v13->vtptr->Clone)(v13);
    }
    sub_FACF80(a2, (*v5 + 2 * v6), v4, v12);
    result = a2;
  }
  else
  {
    v9 = sub_FAB970((v7 - 16)) + 1;
    result = a2;
    *a2 = v9;
  }
  return result;
}

//----- (00FAF840) --------------------------------------------------------
signed int __thiscall sub_FAF840(char *this, WCHAR *a2)
{
  char *v2; // edi
  int v3; // edi
  TRACEHANDLE v4; // rax
  signed int result; // eax
  struct _EVENT_TRACE_LOGFILEW Logfile; // [esp+8h] [ebp-1A4h]

  v2 = this;
  memset(&Logfile.LoggerName, 0, 0x19Cu);
  Logfile.Context = v2;
  Logfile.LogFileName = 0;
  Logfile.LoggerName = a2;
  v3 = (v2 + 16);
  Logfile.u.LogFileMode = 268435712;
  Logfile.BufferCallback = LogBufferCallback;
  Logfile.u2.EventCallback = sub_FAE7F0;
  v4 = OpenTraceW(&Logfile);
  *v3 = v4;
  if ( v4 == 0xFFFFFFFF )
  {
    result = GetLastError();
    if ( result > 0 )
      result = result | 0x80070000;
    *v3 = 0;
    *(v3 + 4) = 0;
  }
  else
  {
    result = ProcessTrace(v3, 1u, 0, 0);
    if ( result )
    {
      result = GetLastError();
      if ( result > 0 )
        result = result | 0x80070000;
    }
  }
  return result;
}

//----- (00FAF920) --------------------------------------------------------
BOOL __stdcall CResizer::EnumChildCallback(HWND hWnd, CResizer *a2)
{
  double v2; // xmm0_8
  int v3; // ecx
  int v4; // esi
  int v5; // eax
  __int32 v6; // eax
  int v7; // edx
  int v8; // esi
  double v9; // xmm5_8
  double v10; // xmm3_8
  tagResizerItem *pItem; // ecx
  HWND *v12; // eax
  int v13; // eax
  int v14; // eax
  LONG v15; // eax
  double v16; // xmm1_8
  int v17; // eax
  int v18; // eax
  double v20; // [esp+10h] [ebp-244h]
  int v21; // [esp+18h] [ebp-23Ch]
  int v22; // [esp+1Ch] [ebp-238h]
  double v23; // [esp+20h] [ebp-234h]
  double v24; // [esp+28h] [ebp-22Ch]
  LONG v25; // [esp+30h] [ebp-224h]
  char v26; // [esp+37h] [ebp-21Dh]
  struct tagRECT Rect; // [esp+38h] [ebp-21Ch]
  WCHAR szClassName[260]; // [esp+48h] [ebp-20Ch]

  v26 = 1;
  if ( GetParent(hWnd) == a2->m_OldWndProc )
  {
    GetWindowRect(hWnd, &Rect);
    ScreenToClient(a2->m_OldWndProc, &Rect);
    ScreenToClient(a2->m_OldWndProc, &Rect.right);
    v2 = 0.0;
    v3 = a2->m_ptMinTrackSize.y * a2->m_nYRatio;
    v4 = a2->m_ptMinTrackSize.x * a2->m_nXRatio / 100;
    v22 = v4;
    v5 = v3 / 100;
    v21 = v3 / 100;
    if ( Rect.left >= v4 )
      v24 = db_one;
    else
      v24 = 0.0;
    if ( Rect.right >= v4 )
      v23 = db_one;
    else
      v23 = 0.0;
    if ( Rect.top >= v5 )
      v20 = db_one;
    else
      v20 = 0.0;
    if ( Rect.bottom >= v5 )
      v2 = db_one;
    szClassName[0] = 0;
    memset(&szClassName[1], 0, 0x206u);
    GetClassNameW(hWnd, szClassName, 260);
    if ( !_wcsicmp(szClassName, L"Button") )
    {
      v6 = GetWindowLongW(hWnd, GWL_STYLE) & BS_TYPEMASK;
      if ( !v6 || v6 == BS_DEFPUSHBUTTON || v6 == BS_OWNERDRAW || v6 == BS_USERBUTTON )
        v26 = 0;
    }
    if ( !_wcsicmp(szClassName, L"Static") )
      InvalidateRect(hWnd, 0, 0);
    v7 = Rect.bottom;
    v8 = Rect.top;
    v25 = Rect.right;
    if ( v26 )
    {
      v10 = v2;
      v9 = v20;
    }
    else
    {
      if ( v22 - Rect.left < Rect.right - v22 )
        v24 = v23;
      else
        v23 = v24;
      if ( v21 - Rect.top < Rect.bottom - v21 )
      {
        v10 = v2;
        v9 = v2;
      }
      else
      {
        v9 = v20;
        v10 = v20;
      }
    }
    pItem = 0;
    if ( hWnd )
    {
      if ( a2->m_dwItemCount <= 0 )
      {
LABEL_34:
        pItem = 0;
      }
      else
      {
        v12 = &a2->m_pItem->m_hWnd;
        while ( *v12 != hWnd )
        {
          pItem = (pItem + 1);
          v12 += 14;
          if ( pItem >= a2->m_dwItemCount )
            goto LABEL_34;
        }
        pItem = &a2->m_pItem[pItem];
        if ( pItem )
        {
          if ( *&pItem->m_rect1.left >= 0.0 )
            v24 = *&pItem->m_rect1.left;
          if ( *&pItem->m_rect1.right >= 0.0 )
            v23 = *&pItem->m_rect1.right;
          if ( *&pItem->m_rect2.left >= 0.0 )
            v9 = *&pItem->m_rect2.left;
          if ( *&pItem->m_rect2.right >= 0.0 )
            v10 = *&pItem->m_rect2.right;
        }
      }
    }
    if ( v24 != 0.0 )
    {
      v13 = a2->m_nWidth3;
      if ( v24 == 1.0 )
        Rect.left += v13 - a2->m_ptMinTrackSize.x;
      else
        Rect.left = ((v13 - a2->m_nWidth) * *&pItem->m_rect1.left + pItem->m_rcWindow.left);
    }
    if ( v23 != 0.0 )
    {
      v14 = a2->m_nWidth3;
      if ( v23 == 1.0 )
      {
        v25 = v14 - a2->m_ptMinTrackSize.x + Rect.right;
        v15 = v14 - a2->m_ptMinTrackSize.x + Rect.right;
      }
      else
      {
        v16 = (v14 - a2->m_nWidth) * *&pItem->m_rect1.right + pItem->m_rcWindow.right;
        v15 = v16;
        v25 = v16;
      }
      Rect.right = v15;
    }
    if ( v9 != 0.0 )
    {
      v17 = a2->m_nHeight3;
      if ( v9 == 1.0 )
        v8 = v17 - a2->m_ptMinTrackSize.y + Rect.top;
      else
        v8 = ((v17 - a2->m_nHeight) * *&pItem->m_rect2.left + pItem->m_rcWindow.top);
      Rect.top = v8;
    }
    if ( v10 == 4.0 )
    {
      v7 = v8 + pItem->m_rcWindow.bottom - pItem->m_rcWindow.top;
    }
    else
    {
      if ( v10 == 0.0 )
      {
LABEL_65:
        a2->m_hDWP = DeferWindowPos(a2->m_hDWP, hWnd, 0, Rect.left, v8, v25 - Rect.left, v7 - v8, 4u);
        return 1;
      }
      v18 = a2->m_nHeight3;
      if ( v10 == 1.0 )
        v7 = v18 - a2->m_ptMinTrackSize.y + Rect.bottom;
      else
        v7 = ((v18 - a2->m_nHeight) * *&pItem->m_rect2.right + pItem->m_rcWindow.bottom);
    }
    Rect.bottom = v7;
    goto LABEL_65;
  }
  return 1;
}
// 103CB38: using guessed type double db_four;

//----- (00FAFD80) --------------------------------------------------------
int __thiscall CResizer::Refresh(CResizer *lParam)
{
  CResizer *v1; // ebx
  int result; // eax
  HDWP v3; // eax
  HWND v4; // ST00_4
  int v5; // edi
  int v6; // eax
  LONG v7; // ecx
  int v8; // ST08_4
  int v9; // eax
  HWND v10; // ST00_4
  struct tagRECT rcDst; // [esp+4h] [ebp-44h]
  struct tagRECT rc; // [esp+14h] [ebp-34h]
  struct tagRECT Rect; // [esp+24h] [ebp-24h]
  RECT rcSrc2; // [esp+34h] [ebp-14h]

  v1 = lParam;
  if ( lParam->m_ptMinTrackSize.y != lParam->m_nHeight3
    || (result = lParam->m_ptMinTrackSize.x, result != lParam->m_nWidth3) )
  {
    v3 = BeginDeferWindowPos(512);
    v4 = v1->m_OldWndProc;
    v1->m_hDWP = v3;
    EnumChildWindows(v4, CResizer::EnumChildCallback, v1);
    EndDeferWindowPos(v1->m_hDWP);
    GetClientRect(v1->m_OldWndProc, &Rect);
    v5 = GetSystemMetrics(SM_CXHSCROLL);
    v6 = GetSystemMetrics(SM_CYVSCROLL);
    rcSrc2.left = Rect.right - v5;
    v7 = Rect.bottom - v6;
    rcSrc2.right = Rect.right;
    v8 = v1->m_ptMinTrackSize.y - v1->m_nHeight3;
    v9 = v1->m_ptMinTrackSize.x - v1->m_nWidth3;
    rcSrc2.top = v7;
    rcSrc2.bottom = Rect.bottom;
    _mm_storeu_si128(&rc, _mm_loadu_si128(&rcSrc2));
    OffsetRect(&rc, v9, v8);
    UnionRect(&rcDst, &rc, &rcSrc2);
    InvalidateRect(v1->m_OldWndProc, &rcDst, TRUE);
    v10 = v1->m_OldWndProc;
    v1->m_ptMinTrackSize.x = v1->m_nWidth3;
    v1->m_ptMinTrackSize.y = v1->m_nHeight3;
    result = InvalidateRect(v10, 0, TRUE);
  }
  return result;
}

//----- (00FAFE80) --------------------------------------------------------
int __thiscall sub_FAFE80(const wchar_t **this, wchar_t a2)
{
  const wchar_t **v2; // esi
  wchar_t *v3; // eax
  int result; // eax

  v2 = this;
  v3 = wcsrchr(*this, a2);
  if ( v3 )
    result = v3 - *v2;
  else
    result = -1;
  return result;
}

//----- (00FAFEB0) --------------------------------------------------------
CStringData *__thiscall sub_FAFEB0(CString *this, void *Src)
{
  CStringData *result; // eax

  if ( Src )
    result = ATL::CSimpleStringT<wchar_t,0>::SetString(this + 5, Src, wcslen(Src));
  else
    result = ATL::CSimpleStringT<wchar_t,0>::SetString(this + 5, 0, 0);
  return result;
}

//----- (00FAFF00) --------------------------------------------------------
CStringData *__thiscall sub_FAFF00(CString *this, void *Src)
{
  CStringData *result; // eax

  if ( Src )
    result = ATL::CSimpleStringT<wchar_t,0>::SetString(this + 1, Src, wcslen(Src));
  else
    result = ATL::CSimpleStringT<wchar_t,0>::SetString(this + 1, 0, 0);
  return result;
}

//----- (00FAFF50) --------------------------------------------------------
CStringData *__thiscall sub_FAFF50(CString *this, void *Src)
{
  CStringData *result; // eax

  if ( Src )
    result = ATL::CSimpleStringT<wchar_t,0>::SetString(this + 2, Src, wcslen(Src));
  else
    result = ATL::CSimpleStringT<wchar_t,0>::SetString(this + 2, 0, 0);
  return result;
}

//----- (00FAFFA0) --------------------------------------------------------
CStringData *__thiscall sub_FAFFA0(CString *this, void *Src)
{
  CStringData *result; // eax

  if ( Src )
    result = ATL::CSimpleStringT<wchar_t,0>::SetString(this + 3, Src, wcslen(Src));
  else
    result = ATL::CSimpleStringT<wchar_t,0>::SetString(this + 3, 0, 0);
  return result;
}

//----- (00FAFFF0) --------------------------------------------------------
int __thiscall sub_FAFFF0(CString *this, void *Src)
{
  CString *v2; // edi
  unsigned __int16 *v3; // esi
  int v4; // edx
  CString *v5; // edi
  int v6; // ecx
  int result; // eax
  void **v8; // eax
  char *v9; // edx

  v2 = this;
  v3 = Src;
  if ( Src )
    v4 = wcslen(Src);
  else
    v4 = 0;
  ATL::CSimpleStringT<wchar_t,0>::SetString(this + 4, Src, v4);
  v5 = v2 + 1;
  if ( v3 )
    v6 = wcslen(v3);
  else
    v6 = 0;
  ATL::CSimpleStringT<wchar_t,0>::SetString(v5, v3, v6);
  result = v5->pszData;
  if ( *(v5->pszData - 3) > 0 )
  {
    result = wcschr(result, 0x2Cu);
    if ( result )
    {
      result = (result - v5->pszData) >> 1;
      if ( result >= 0 )
      {
        v8 = sub_FAF790(v5, &Src, 0, result);
        sub_FAD840(v5, v8);
        v9 = Src - 16;
        result = Src - 4;
        if ( _InterlockedDecrement(result) <= 0 )
          result = (*(**v9 + 4))(v9);
      }
    }
  }
  return result;
}

//----- (00FB00E0) --------------------------------------------------------
CStringData *__thiscall sub_FB00E0(CString *this, void *Src)
{
  CStringData *result; // eax

  if ( Src )
    result = ATL::CSimpleStringT<wchar_t,0>::SetString(this + 6, Src, wcslen(Src));
  else
    result = ATL::CSimpleStringT<wchar_t,0>::SetString(this + 6, 0, 0);
  return result;
}

//----- (00FB0130) --------------------------------------------------------
int __thiscall sub_FB0130(HWND *this)
{
  HWND *v1; // edi
  LONG v2; // ecx
  int v3; // ST10_4
  int v4; // ecx
  HWND v5; // ST00_4
  struct tagRECT Rect; // [esp+8h] [ebp-24h]
  struct tagRECT rcDst; // [esp+18h] [ebp-14h]

  v1 = this;
  GetClientRect(this[2], &Rect);
  CopyRect(&rcDst, &Rect);
  v2 = rcDst.right - 10;
  rcDst.bottom -= 10;
  rcDst.right = v2;
  v3 = rcDst.bottom - (rcDst.top + 10);
  v4 = v2 - (rcDst.left + 10);
  rcDst.left += 10;
  v5 = v1[1];
  rcDst.top += 10;
  MoveWindow(v5, rcDst.left, rcDst.top, v4, v3, 1);
  return rcDst.right - rcDst.left;
}

//----- (00FB01B0) --------------------------------------------------------
void *__thiscall sub_FB01B0(int this)
{
  return sub_FACC30(*(this + 32), *(this + 36), (*(this + 36) - *(this + 32)) >> 2, sub_FAE780);
}

//----- (00FB01D0) --------------------------------------------------------
int __cdecl sub_FB01D0(wchar_t *Dst, rsize_t SizeInWords, int a3)
{
  return sub_FAE970(Dst, SizeInWords, a3, &unk_105D150, 5);
}

//----- (00FB0200) --------------------------------------------------------
int __cdecl sub_FB0200(wchar_t *Src, int a2)
{
  signed int v2; // edi
  const wchar_t *v3; // ebx
  signed int v4; // esi
  const wchar_t *v5; // edi
  int result; // eax
  wchar_t Dst; // [esp+14h] [ebp-18h]
  __int16 v8; // [esp+18h] [ebp-14h]
  __int16 v9; // [esp+1Ch] [ebp-10h]
  __int16 v10; // [esp+24h] [ebp-8h]

  wcsncpy_s(&Dst, 0xAu, Src, 8u);
  v10 = 0;
  *a2 = sub_FAF690(&Dst);
  wcsncpy_s(&Dst, 0xAu, Src + 9, 4u);
  v9 = 0;
  *(a2 + 4) = sub_FAF690(&Dst);
  wcsncpy_s(&Dst, 0xAu, Src + 14, 4u);
  v9 = 0;
  *(a2 + 6) = sub_FAF690(&Dst);
  v2 = 0;
  v3 = Src + 19;
  do
  {
    wcsncpy_s(&Dst, 0xAu, v3, 2u);
    v8 = 0;
    *(a2 + 8 + v2++) = sub_FAF690(&Dst);
    v3 += 2;
  }
  while ( v2 < 2 );
  v4 = 2;
  v5 = Src + 24;
  do
  {
    wcsncpy_s(&Dst, 0xAu, v5, 2u);
    v8 = 0;
    result = sub_FAF690(&Dst);
    *(a2 + 8 + v4++) = result;
    v5 += 2;
  }
  while ( v4 < 8 );
  return result;
}

//----- (00FB0310) --------------------------------------------------------
LRESULT __stdcall CResizer::Proxy_WndProc(HWND hWnd, UINT Msg, WPARAM wParam, LPARAM lParam)
{
  LPARAM v4; // esi
  CResizer *v5; // eax
  WPARAM v6; // edx
  CResizer *v7; // edi
  UINT Msg_1; // eax
  LRESULT result; // eax
  int v10; // edx
  int v11; // ecx
  bool v12; // sf
  unsigned __int8 v13; // of
  int v14; // eax
  LRESULT v15; // edi
  POINT v16; // ST10_8
  LONG v17; // ecx
  HTHEME v18; // eax
  LRESULT (__stdcall *v19)(HWND, UINT, WPARAM, LPARAM); // esi
  HDC hdc; // [esp+Ch] [ebp-5Ch]
  struct tagPAINTSTRUCT Paint; // [esp+14h] [ebp-54h]
  struct tagRECT Rect; // [esp+54h] [ebp-14h]

  v4 = lParam;
  v5 = GetPropW(hWnd, L"ResizerClass");
  v6 = wParam;
  v7 = v5;
  Msg_1 = Msg;
  switch ( Msg )
  {
    case WM_DESTROY:
      v19 = v7->m_hWnd;
      SetWindowLongW(hWnd, GWLP_WNDPROC, v7->m_hWnd);
      CResizer::~CResizer(v7);
      j__free(v7);
      return CallWindowProcW(v19, hWnd, Msg, wParam, lParam);
    case WM_SIZE:
      if ( !v7->m_FixedBorder || wParam != SIZE_MAXIMIZED && wParam )
        goto LABEL_13;
      if ( GetWindowRect(hWnd, &Rect) )
      {
        v10 = Rect.right - Rect.left;
        v11 = Rect.bottom - Rect.top;
        if ( Rect.right - Rect.left < v7->m_nWidth )
          v10 = v7->m_nWidth;
        v13 = __OFSUB__(v11, v7->m_nHeight);
        v12 = v11 - v7->m_nHeight < 0;
        v7->m_nWidth3 = v10;
        if ( v12 ^ v13 )
          v11 = v7->m_nHeight;
        v7->m_nHeight3 = v11;
        CResizer::Refresh(v7);
      }
      goto LABEL_12;
    case WM_SETVISIBLE|WM_ACTIVATE:
      if ( !(GetWindowLongW(hWnd, GWL_STYLE) & WS_CHILD) && !IsZoomed(hWnd) )
      {
        hdc = BeginPaint(hWnd, &Paint);
        GetClientRect(hWnd, &Rect);
        Rect.left = Rect.right - GetSystemMetrics(21);
        v17 = Rect.bottom - GetSystemMetrics(20);
        v18 = v7->baseclass.m_hThemeHandle;
        Rect.top = v17;
        if ( v18 )
          gpfnDrawThemeBackground(v18, hdc, 3, 0, &Rect, 0);
        else
          DrawFrameControl(hdc, &Rect, 3u, 8u);
        EndPaint(hWnd, &Paint);
        v4 = lParam;
      }
LABEL_12:
      Msg_1 = Msg;
      goto LABEL_13;
    case 0x24u:
      *(lParam + 24) = v7->m_nWidth;
      *(lParam + 28) = v7->m_nHeight;
      result = 0;
      break;
    case WM_NCHITTEST:
      v15 = CallWindowProcW(v7->m_hWnd, hWnd, Msg, wParam, lParam);
      if ( GetWindowLongW(hWnd, GWL_STYLE) & WS_CHILD
        || v15 != 1
        || IsZoomed(hWnd)
        || (GetWindowRect(hWnd, &Rect),
            Rect.left = Rect.right - GetSystemMetrics(21),
            Rect.top = Rect.bottom - GetSystemMetrics(20),
            v16.y = SHIWORD(lParam),
            v16.x = lParam,
            !PtInRect(&Rect, v16)) )
      {
        result = v15;
      }
      else
      {
        result = 17;
      }
      break;
    default:
LABEL_13:
      if ( Msg_1 == WM_THEMECHANGED )
      {
        if ( v7->baseclass.m_hThemeHandle )
          gpfnCloseThemeData(v7->baseclass.m_hThemeHandle);
        v7->baseclass.m_hThemeHandle = 0;
        if ( gpfnIsThemeActive )
        {
          if ( gpfnIsThemeActive() )
          {
            v14 = (v7->baseclass.vtptr->GetName)(v7);
            v7->baseclass.m_hThemeHandle = gpfnOpenThemeData(hWnd, v14);
          }
        }
      }
      result = (v7->baseclass.vtptr->HandleMessage)(v7, v6, hWnd, Msg, wParam, v4);
      break;
  }
  return result;
}
// 1064D84: using guessed type int (__stdcall *gpfnIsThemeActive)();

//----- (00FB0650) --------------------------------------------------------
char *__thiscall sub_FB0650(const void **this, unsigned int a2)
{
  unsigned int v2; // ebx
  char *v3; // esi
  const void **v4; // edi
  char *result; // eax
  int v6; // [esp+14h] [ebp+8h]

  v2 = a2;
  v3 = 0;
  v4 = this;
  if ( a2 )
  {
    if ( a2 > 0x7FFFFFFF || (v3 = operator new(2 * a2)) == 0 )
      std::_Xbad_alloc();
  }
  memmove(v3, *v4, (v4[1] - *v4) & 0xFFFFFFFE);
  v6 = (v4[1] - *v4) >> 1;
  if ( *v4 )
    j__free(*v4);
  *v4 = v3;
  v4[2] = &v3[2 * v2];
  result = &v3[2 * v6];
  v4[1] = result;
  return result;
}

//----- (00FB06D0) --------------------------------------------------------
char *__thiscall std::vector<tagAccountInfo *,std::allocator<tagAccountInfo *>>::_Reallocate(std__vector *this, unsigned int a2)
{
  unsigned int v2; // ebx
  char *v3; // esi
  std__vector *v4; // edi
  char *result; // eax
  int v6; // [esp+14h] [ebp+8h]

  v2 = a2;
  v3 = 0;
  v4 = this;
  if ( a2 )
  {
    if ( a2 > 0x3FFFFFFF || (v3 = operator new(4 * a2)) == 0 )
      std::_Xbad_alloc();
  }
  memmove(
    v3,
    v4->baseclass_0._Mypair._Myval2._Myfirst,
    (v4->baseclass_0._Mypair._Myval2._Mylast - v4->baseclass_0._Mypair._Myval2._Myfirst) & 0xFFFFFFFC);
  v6 = (v4->baseclass_0._Mypair._Myval2._Mylast - v4->baseclass_0._Mypair._Myval2._Myfirst) >> 2;
  if ( v4->baseclass_0._Mypair._Myval2._Myfirst )
    j__free(v4->baseclass_0._Mypair._Myval2._Myfirst);
  v4->baseclass_0._Mypair._Myval2._Myfirst = v3;
  v4->baseclass_0._Mypair._Myval2._Myend = &v3[4 * v2];
  result = &v3[4 * v6];
  v4->baseclass_0._Mypair._Myval2._Mylast = result;
  return result;
}

//----- (00FB0750) --------------------------------------------------------
unsigned int __thiscall sub_FB0750(int this, unsigned int a2)
{
  int v2; // esi
  unsigned int result; // eax
  int v4; // esi
  unsigned int v5; // esi
  unsigned int v6; // edx
  unsigned int v7; // edx
  unsigned int v8; // edx

  v2 = *(this + 4);
  result = (*(this + 8) - v2) >> 1;
  if ( result < a2 )
  {
    v4 = (v2 - *this) >> 1;
    if ( 0x7FFFFFFF - v4 < a2 )
      std::_Xlength_error("vector<T> too long");
    v5 = a2 + v4;
    v6 = (*(this + 8) - *this) >> 1;
    if ( 0x7FFFFFFF - (v6 >> 1) >= v6 )
    {
      v8 = (v6 >> 1) + v6;
      if ( v8 < v5 )
        v8 = v5;
      result = sub_FB0650(this, v8);
    }
    else
    {
      v7 = 0;
      if ( v5 > 0 )
        v7 = v5;
      result = sub_FB0650(this, v7);
    }
  }
  return result;
}

//----- (00FB07C0) --------------------------------------------------------
unsigned int __thiscall std::vector<tagAccountInfo *,std::allocator<tagAccountInfo *>>::_Reserve(std__vector *this, unsigned int a2)
{
  void *v2; // esi
  unsigned int result; // eax
  signed int v4; // esi
  unsigned int v5; // esi
  unsigned int v6; // edx
  unsigned int v7; // edx
  unsigned int v8; // edx

  v2 = this->baseclass_0._Mypair._Myval2._Mylast;
  result = (this->baseclass_0._Mypair._Myval2._Myend - v2) >> 2;
  if ( result < a2 )
  {
    v4 = (v2 - this->baseclass_0._Mypair._Myval2._Myfirst) >> 2;
    if ( 0x3FFFFFFF - v4 < a2 )
      std::_Xlength_error("vector<T> too long");
    v5 = a2 + v4;
    v6 = (this->baseclass_0._Mypair._Myval2._Myend - this->baseclass_0._Mypair._Myval2._Myfirst) >> 2;
    if ( 0x3FFFFFFF - (v6 >> 1) >= v6 )
    {
      v8 = (v6 >> 1) + v6;
      if ( v8 < v5 )
        v8 = v5;
      result = std::vector<tagAccountInfo *,std::allocator<tagAccountInfo *>>::_Reallocate(this, v8);
    }
    else
    {
      v7 = 0;
      if ( v5 > 0 )
        v7 = v5;
      result = std::vector<tagAccountInfo *,std::allocator<tagAccountInfo *>>::_Reallocate(this, v7);
    }
  }
  return result;
}

//----- (00FB0840) --------------------------------------------------------
int __thiscall sub_FB0840(_DWORD *this, int a2, void *a3)
{
  _DWORD *v3; // edi
  int result; // eax

  v3 = this;
  memmove(a3, a3 + 2, (this[1] - (a3 + 2)) & 0xFFFFFFFE);
  result = a2;
  v3[1] -= 2;
  *a2 = a3;
  return result;
}

//----- (00FB0880) --------------------------------------------------------
__int16 __thiscall sub_FB0880(_DWORD *this, _WORD *a2)
{
  _DWORD *v2; // esi
  unsigned int v3; // eax
  int v4; // edi
  _WORD *v5; // ecx
  _WORD *v6; // ecx

  v2 = this;
  v3 = this[1];
  if ( a2 >= v3 || *this > a2 )
  {
    if ( v3 == this[2] )
      LOWORD(v3) = sub_FB0750(this, 1u);
    v6 = v2[1];
    if ( v6 )
    {
      LOWORD(v3) = *a2;
      *v6 = *a2;
    }
    goto LABEL_11;
  }
  v4 = (a2 - *this) >> 1;
  if ( v3 == this[2] )
    LOWORD(v3) = sub_FB0750(this, 1u);
  v5 = v2[1];
  if ( !v5 )
  {
LABEL_11:
    v2[1] += 2;
    return v3;
  }
  LOWORD(v3) = *(*v2 + 2 * v4);
  *v5 = v3;
  v2[1] += 2;
  return v3;
}

//----- (00FB08F0) --------------------------------------------------------
tagAccountInfo *__thiscall std::vector<tagAccountInfo *,std::allocator<tagAccountInfo *>>::push_back(std__vector *this, tagAccountInfo *pInfo)
{
  std__vector *v2; // esi
  tagAccountInfo *result; // eax
  int v4; // edi
  _DWORD *v5; // ecx
  _DWORD *v6; // ecx

  v2 = this;
  result = this->baseclass_0._Mypair._Myval2._Mylast;
  if ( pInfo >= result || this->baseclass_0._Mypair._Myval2._Myfirst > pInfo )
  {
    if ( result == this->baseclass_0._Mypair._Myval2._Myend )
      result = std::vector<tagAccountInfo *,std::allocator<tagAccountInfo *>>::_Reserve(this, 1u);
    v6 = v2->baseclass_0._Mypair._Myval2._Mylast;
    if ( v6 )
    {
      result = pInfo->bIsSystemUser;
      *v6 = pInfo->bIsSystemUser;
    }
  }
  else
  {
    v4 = (pInfo - this->baseclass_0._Mypair._Myval2._Myfirst) >> 2;
    if ( result == this->baseclass_0._Mypair._Myval2._Myend )
      result = std::vector<tagAccountInfo *,std::allocator<tagAccountInfo *>>::_Reserve(this, 1u);
    v5 = v2->baseclass_0._Mypair._Myval2._Mylast;
    if ( v5 )
    {
      result = *(v2->baseclass_0._Mypair._Myval2._Myfirst + v4);
      *v5 = result;
      v2->baseclass_0._Mypair._Myval2._Mylast = v2->baseclass_0._Mypair._Myval2._Mylast + 4;
      return result;
    }
  }
  v2->baseclass_0._Mypair._Myval2._Mylast = v2->baseclass_0._Mypair._Myval2._Mylast + 4;
  return result;
}

//----- (00FB0960) --------------------------------------------------------
bool __cdecl ProcessIsNetCclr_0(tagTREEVIEWLISTITEMPARAM *a1)
{
  int v1; // eax
  DWORD pdwFlags; // [esp+0h] [ebp-4h]

  pdwFlags = 0;
  v1 = a1->dwProcessId;
  if ( !v1 || !EnableTraceEx )
    return 0;
  ProcessIsNetCclr(v1, &pdwFlags);
  return pdwFlags != 0;
}

//----- (00FB09A0) --------------------------------------------------------
int __cdecl sub_FB09A0(wchar_t *Dst, int a2, __int64 a3)
{
  int result; // eax

  if ( gConfig.bShowCpuFractions )
    result = swprintf_s(Dst, 0x20u, L"%s%0.2f%%", a2, a3);
  else
    result = swprintf_s(Dst, 0x20u, L"%s%0.0f%%", a2, a3);
  return result;
}

//----- (00FB09F0) --------------------------------------------------------
int __cdecl sub_FB09F0(wchar_t *Dst, int a2, __int64 a3)
{
  int result; // eax

  if ( gConfig.bShowCpuFractions )
    result = swprintf_s(Dst, 0x400u, L"%s%0.2f%%", a2, a3);
  else
    result = swprintf_s(Dst, 0x400u, L"%s%0.0f%%", a2, a3);
  return result;
}

//----- (00FB0A40) --------------------------------------------------------
errno_t __cdecl sub_FB0A40(wchar_t *a1, int a2, __int64 a3)
{
  return sub_FB2410(a1, 0x400u, a2, a3);
}

//----- (00FB0A70) --------------------------------------------------------
int wsprintfW(wchar_t *Dst, wchar_t *Format, ...)
{
  va_list ArgList; // [esp+10h] [ebp+10h]

  va_start(ArgList, Format);
  return vswprintf_s(Dst, 0x400u, Format, ArgList);
}

//----- (00FB0A90) --------------------------------------------------------
int __thiscall sub_FB0A90(BitmapItem *this, int a2, int a3, int a4, int a5, unsigned int a6, int a7)
{
  char v7; // al
  int v8; // edx
  int v9; // edi
  int v10; // ebx
  int v11; // esi
  int result; // eax
  int v13; // ecx
  int v14; // edx
  int v15; // ebx
  int *v16; // eax
  bool v17; // zf
  int v18; // [esp+Ch] [ebp-10h]
  int v19; // [esp+10h] [ebp-Ch]
  int v20; // [esp+14h] [ebp-8h]
  BitmapItem *v21; // [esp+18h] [ebp-4h]
  signed int v22; // [esp+24h] [ebp+8h]
  signed int v23; // [esp+28h] [ebp+Ch]
  int v24; // [esp+2Ch] [ebp+10h]
  int v25; // [esp+30h] [ebp+14h]
  int *v26; // [esp+30h] [ebp+14h]
  int v27; // [esp+30h] [ebp+14h]

  v7 = a7;
  v21 = this;
  if ( a7 )
  {
    v7 = a7;
    v20 = (a6 + (256 - a6) / 2) | (((BYTE1(a6) + (256 - BYTE1(a6)) / 2) | ((BYTE2(a6) + (256 - BYTE2(a6)) / 2) << 8)) << 8);
    v8 = (a6 + (256 - a6) / 2) | (((BYTE1(a6) + (256 - BYTE1(a6)) / 2) | ((BYTE2(a6) + (256 - BYTE2(a6)) / 2) << 8)) << 8);
  }
  else
  {
    v8 = a7;
    v20 = a7;
  }
  v9 = a2;
  v10 = a4 - a2;
  v11 = a3;
  v25 = a5 - a3;
  if ( v7 )
    sub_FB0E50(this, a3, a2, a3, this->nHeight, v8, 0);
  else
    this->pBits[a3 + a2 * this->nWidth] = (a6 & 0xFF00) | (a6 << 16) | (a6 >> 16) & 0xFF;
  if ( v10 >= 0 )
  {
    v22 = 1;
  }
  else
  {
    v22 = -1;
    v10 = -v10;
  }
  result = v25;
  if ( v25 >= 0 )
  {
    v23 = 1;
  }
  else
  {
    v23 = -1;
    result = -v25;
  }
  v13 = 2 * v10;
  v14 = 2 * result;
  v19 = 2 * v10;
  v18 = 2 * result;
  if ( 2 * result < 2 * v10 )
  {
    if ( v10 > 0 )
    {
      v27 = v10;
      do
      {
        v9 += v22;
        v10 += v14;
        if ( v10 > v13 )
        {
          v11 += v23;
          v10 -= v13;
        }
        if ( a7 )
        {
          LOBYTE(result) = sub_FB0E50(v21, v11, v9, v11, v21->nHeight, v20, 0);
        }
        else
        {
          result = v21->pBits;
          *(result + 4 * (v11 + v9 * v21->nWidth)) = (a6 & 0xFF00) | (a6 << 16) | (a6 >> 16) & 0xFF;
        }
        v17 = v27-- == 1;
        v13 = v19;
        v14 = v18;
      }
      while ( !v17 );
    }
  }
  else if ( result > 0 )
  {
    v15 = result;
    v24 = result;
    do
    {
      v11 += v23;
      v16 = (v13 + result);
      v26 = v16;
      if ( v16 > v14 )
      {
        v9 += v22;
        v26 = (v16 - v14);
      }
      if ( a7 )
      {
        sub_FB0E50(v21, v11, v9, v11, v21->nHeight, v20, 0);
        v15 = v24;
      }
      else
      {
        v21->pBits[v11 + v9 * v21->nWidth] = (a6 & 0xFF00) | (a6 << 16) | (a6 >> 16) & 0xFF;
      }
      result = v26;
      --v15;
      v13 = v19;
      v14 = v18;
      v24 = v15;
    }
    while ( v15 );
  }
  return result;
}

//----- (00FB0CA0) --------------------------------------------------------
char __thiscall BitmapItem_Create(BitmapItem *this, LONG nWidth, signed int nHeight)
{
  BitmapItem *v3; // ST24_4
  HDC hDC; // ebx
  HDC v5; // eax
  void *v6; // ST14_4
  BITMAPINFO bi; // [esp+10h] [ebp-2Ch]

  v3 = this;
  hDC = GetDC(0);
  _mm_storeu_si128(&bi.bmiHeader.biWidth, 0i64);
  bi.bmiHeader.biClrImportant = 0;
  bi.bmiHeader.biSize = offsetof(BITMAPINFO, bmiColors);
  bi.bmiHeader.biHeight = -nHeight;
  bi.bmiHeader.biWidth = nWidth;
  *&bi.bmiHeader.biPlanes = 0x200001;
  _mm_storeu_si128(&bi.bmiHeader.biSizeImage, 0i64);
  bi.bmiHeader.biClrUsed = 0;
  bi.bmiHeader.biCompression = 0;
  bi.bmiHeader.biSizeImage = 0;
  v3->hBitmapHandle = CreateDIBSection(hDC, &bi, 0, &v3->pBits, 0, 0);
  v3->nHeight = nHeight;
  v3->nWidth = nWidth;
  v5 = CreateCompatibleDC(hDC);
  v6 = v3->hBitmapHandle;
  v3->CompatibleDC = v5;
  SelectObject(v5, v6);
  ReleaseDC(0, hDC);
  return 1;
}

//----- (00FB0D60) --------------------------------------------------------
char __thiscall BitmapItem_SetRectColor(BitmapItem *this, RECT *lprc, unsigned int color)
{
  RECT *v3; // edx
  LONG left; // esi
  BitmapItem *pItem; // ebx
  LONG top; // eax
  int right; // ecx
  LONG y; // edi
  LONG bottom; // eax
  int nHeight; // edx
  LONG x; // eax
  int nBit; // edx
  int i; // [esp+Ch] [ebp-8h]
  LONG left_1; // [esp+10h] [ebp-4h]
  RECT *nWidth; // [esp+1Ch] [ebp+8h]

  v3 = lprc;
  left = 0;
  pItem = this;
  if ( lprc->left > 0 )
    left = lprc->left;
  top = lprc->top;
  right = this->nWidth;
  left_1 = left;
  if ( lprc->right < right )
    right = lprc->right;
  y = 0;
  nWidth = right;
  if ( top > 0 )
    y = top;
  bottom = v3->bottom;
  nHeight = pItem->nHeight;
  if ( bottom < nHeight )
    nHeight = bottom;
  for ( i = nHeight; y < nHeight; ++y )
  {
    x = left;
    if ( left < right )
    {
      do
      {
        nBit = x++ + y * pItem->nWidth;
        pItem->pBits[nBit] = (color & 0xFF00) | (color << 16) | (color >> 16) & 0xFF;
        right = nWidth;
      }
      while ( x < nWidth );
      left = left_1;
      nHeight = i;
    }
  }
  return 1;
}

//----- (00FB0E00) --------------------------------------------------------
int __cdecl sub_FB0E00(wchar_t *Dst, size_t SizeInWords, int a3, __int64 a4)
{
  int result; // eax

  if ( gConfig.bShowCpuFractions )
    result = swprintf_s(Dst, SizeInWords, L"%s%0.2f%%", a3, a4);
  else
    result = swprintf_s(Dst, SizeInWords, L"%s%0.0f%%", a3, a4);
  return result;
}

//----- (00FB0E50) --------------------------------------------------------
char __thiscall sub_FB0E50(BitmapItem *this, int a2, int a3, int a4, int a5, unsigned int a6, int a7)
{
  int v7; // eax
  BitmapItem *v8; // esi
  int v9; // ecx
  int v10; // ecx
  int v11; // edx
  int v12; // edx
  int v13; // edi
  int v14; // edi
  int v15; // ebx

  v7 = a2;
  v8 = this;
  if ( a2 >= 0 )
  {
    v9 = this->nWidth;
    if ( a2 >= v9 )
      v7 = v9 - 1;
  }
  else
  {
    v7 = 0;
  }
  v10 = a4;
  if ( a4 >= 0 )
  {
    v11 = v8->nWidth;
    if ( a4 >= v11 )
      v10 = v11 - 1;
  }
  else
  {
    v10 = 0;
  }
  v12 = a3;
  if ( a3 >= 0 )
  {
    v13 = v8->nHeight;
    if ( a3 >= v13 )
      v12 = v13 - 1;
  }
  else
  {
    v12 = 0;
  }
  v14 = a5;
  if ( a5 >= 0 )
  {
    v15 = v8->nHeight;
    if ( a5 >= v15 )
      v14 = v15 - 1;
  }
  else
  {
    v14 = 0;
  }
  sub_FB0A90(v8, v12, v7, v14, v10, a6, a7);
  return 1;
}

//----- (00FB0ED0) --------------------------------------------------------
char __thiscall sub_FB0ED0(_DWORD *this, int a2, int a3, int a4, int a5, unsigned int a6, char a7)
{
  int v7; // esi
  _DWORD *v8; // ebx
  int v9; // eax
  int v10; // eax
  int v11; // ecx
  int v12; // edi
  int v13; // ecx
  int v14; // ecx
  int v15; // edx
  unsigned int v16; // ecx
  int v17; // edx
  int v18; // ecx
  unsigned int v20; // ecx
  int v21; // edx
  int v22; // ecx

  v7 = a2;
  v8 = this;
  if ( a2 >= 0 )
  {
    v9 = this[2];
    if ( a2 >= v9 )
      v7 = v9 - 1;
  }
  else
  {
    v7 = 0;
  }
  v10 = a4;
  if ( a4 >= 0 )
  {
    v11 = this[2];
    if ( a4 < v11 )
      goto LABEL_10;
    v10 = v11 - 1;
  }
  else
  {
    v10 = 0;
  }
  a4 = v10;
LABEL_10:
  v12 = a3;
  if ( a3 >= 0 )
  {
    v13 = v8[1];
    if ( a3 >= v13 )
      v12 = v13 - 1;
  }
  else
  {
    v12 = 0;
  }
  v14 = a5;
  if ( a5 >= 0 )
  {
    v15 = v8[1];
    if ( a5 < v15 )
      goto LABEL_19;
    v14 = v15 - 1;
  }
  else
  {
    v14 = 0;
  }
  a5 = v14;
LABEL_19:
  if ( v7 != v10 )
  {
    if ( v7 < v10 )
    {
      do
      {
        if ( a7 )
          v20 = (a6 >> 1) | (((BYTE1(a6) | ((BYTE2(a6) & 0xFE) << 8)) & 0xFFFE) << 7);
        else
          v20 = a6;
        v21 = (v20 & 0xFF00) | (v20 << 16) | (v20 >> 16) & 0xFF;
        v22 = v7++ + v12 * v8[2];
        *(v8[4] + 4 * v22) = v21;
      }
      while ( v7 < a4 );
    }
    return 1;
  }
  if ( v12 >= v14 )
    return 1;
  do
  {
    if ( a7 )
      v16 = (a6 >> 1) | (((BYTE1(a6) | ((BYTE2(a6) & 0xFE) << 8)) & 0xFFFE) << 7);
    else
      v16 = a6;
    v17 = (v16 & 0xFF00) | (v16 << 16) | (v16 >> 16) & 0xFF;
    v18 = v12++ * v8[2];
    *(v8[4] + 4 * (v7 + v18)) = v17;
  }
  while ( v12 < a5 );
  return 1;
}

//----- (00FB1020) --------------------------------------------------------
void __cdecl CGraphData_Update(CGraphData *pGraphData, FILETIME time, double dbMemorySize, double a5, wchar_t *a6)
{
  WCHAR *v5; // ebx
  WCHAR **v6; // edx
  int v7; // ecx
  int v8; // ecx
  WCHAR **v9; // eax
  double *v10; // ecx
  double dbMemorySize_1; // [esp+4h] [ebp-8h]

  if ( pGraphData )
  {
    dbMemorySize_1 = dbMemorySize;
    if ( pGraphData->m_nItemID )
    {
      if ( dbMemorySize > pGraphData->m_dbMemorySize )
        pGraphData->m_dbMemorySize = dbMemorySize * 1.200000047683716;
    }
    else if ( dbMemorySize <= pGraphData->m_dbMemorySize )
    {
      if ( dbMemorySize < 0.0 )
        dbMemorySize_1 = 0.0;
    }
    else
    {
      dbMemorySize_1 = pGraphData->m_dbMemorySize;
    }
    if ( a5 <= pGraphData->m_Item[0].dbMemorySize )
    {
      if ( a5 < 0.0 )
        a5 = 0.0;
    }
    else
    {
      a5 = db_onehundred;
    }
    v5 = _wcsdup(a6);
    EnterCriticalSection(&pGraphData->m_Lock.m_Lock);
    v6 = pGraphData->m_pBuffer;
    if ( v6 )
    {
      v7 = pGraphData->m_nWidth;
      if ( v6[v7] )
        free(v6[v7]);
      v8 = pGraphData->m_nWidth;
      v9 = pGraphData->m_pBuffer;
      if ( a6 )
        v9[v8] = v5;
      else
        v9[v8] = 0;
    }
    pGraphData->m_pBuffer1[pGraphData->m_nWidth] = (*&time - *&pGraphData->m_Time) / 10000000;
    pGraphData->m_Item[0].pBuffer[pGraphData->m_nWidth] = dbMemorySize_1;
    v10 = pGraphData->m_Item[1].pBuffer;
    if ( v10 )
      v10[pGraphData->m_nWidth] = a5;
    if ( ++pGraphData->m_nWidth >= gdwVirtualScreenWidth )
      pGraphData->m_nWidth = 0;
    LeaveCriticalSection(&pGraphData->m_Lock.m_Lock);
  }
}
// 103CDC0: using guessed type double db_onehundred;
// 1064E28: using guessed type int gdwVirtualScreenWidth;

//----- (00FB1160) --------------------------------------------------------
CGraphData *__cdecl InitGraphData(int nCount, int nChildID, BOOL fFlags)
{
  int nCount_1; // edi
  CGraphData *result; // eax
  UCHAR *pBuffer; // ebx
  void *v6; // eax
  void *v7; // eax
  UCHAR *v8; // esi
  int nChildID_1; // edi
  void *v10; // eax
  struct _FILETIME *lpSystemTimeAsFileTime; // [esp+4h] [ebp-8h]
  CGraphData *pGrahData; // [esp+8h] [ebp-4h]

  nCount_1 = nCount;
  result = malloc(sizeof(CGraphData) * nCount);
  pGrahData = result;
  if ( nCount > 0 )
  {
    lpSystemTimeAsFileTime = &result->m_Time;
    pBuffer = &result->m_pBuffer;
    do
    {
      memset(pBuffer - 2144, 0, sizeof(CGraphData));
      pGrahData->m_nChildID = nChildID;
      InitializeCriticalSection((pBuffer - 2144));
      GetSystemTimeAsFileTime(lpSystemTimeAsFileTime);
      v6 = malloc(4 * gdwVirtualScreenWidth);
      *(pBuffer + 3) = v6;
      memset(v6, 0, 4 * gdwVirtualScreenWidth);
      if ( fFlags )
      {
        v7 = malloc(4 * gdwVirtualScreenWidth);
        *pBuffer = v7;
        memset(v7, 0, 4 * gdwVirtualScreenWidth);
      }
      if ( nChildID > 0 )
      {
        // pItem = &ppGraphDatap[i]->m_Item
        v8 = pBuffer - 2092;
        nChildID_1 = nChildID;
        do
        {
          v10 = malloc(8 * gdwVirtualScreenWidth);
          *v8 = v10;
          memset(v10, 0, 8 * gdwVirtualScreenWidth);
          v8 += 24;
          // for(i = 0; i < nChildID;i++)
          // {
          // pItem[i].pBuffer = malloc(...);
          // ZeroMemory(pItem[i].pBuffer,...);
          // }
          --nChildID_1;
        }
        while ( nChildID_1 );
        nCount_1 = nCount;
      }
      pBuffer += sizeof(CGraphData);
      nCount = --nCount_1;
    }
    while ( nCount_1 );
    result = pGrahData;
  }
  return result;
}
// FB125E: CONTAINING_RECORD: no field 'UCHAR *' in struct 'CGraphData' at 2200
// 1064E28: using guessed type int gdwVirtualScreenWidth;

//----- (00FB1280) --------------------------------------------------------
void __cdecl GraphData_Release(CGraphData *pGraphData, int nCount)
{
  CGraphData *v2; // edi
  void **v3; // ebx
  int v4; // ecx
  int i; // esi
  signed int v6; // esi
  void **v7; // edi
  bool v8; // zf
  void **v9; // [esp+4h] [ebp-4h]

  v2 = pGraphData;
  if ( pGraphData )
  {
    if ( nCount > 0 )
    {
      v3 = &pGraphData->m_pBuffer;
      v9 = &pGraphData->m_pBuffer;
      do
      {
        free(v3[3]);
        if ( *v3 )
        {
          v4 = gdwVirtualScreenWidth;
          for ( i = 0; i < v4; ++i )
          {
            if ( *(*v3 + i) )
            {
              free(*(*v3 + i));
              v4 = gdwVirtualScreenWidth;
            }
          }
          free(*v3);
        }
        v6 = 0;
        if ( v2->m_nChildID > 0 )
        {
          v7 = v3 - 523;
          do
          {
            free(*v7);
            ++v6;
            v7 += 6;
          }
          while ( v6 < pGraphData->m_nChildID );
          v3 = v9;
          v2 = pGraphData;
        }
        DeleteCriticalSection((v3 - 536));
        v3 += 550;
        v8 = nCount-- == 1;
        v9 = v3;
      }
      while ( !v8 );
    }
    free(v2);
  }
}
// 1064E28: using guessed type int gdwVirtualScreenWidth;

//----- (00FB1340) --------------------------------------------------------
HWND __cdecl CreateGraphWindow(HWND hDlg, int nIDDlgItem, PVOID pParam)
{
  HWND v3; // eax
  HWND v4; // eax
  HWND hWnd; // eax
  struct tagRECT Rect; // [esp+Ch] [ebp-14h]

  v3 = GetDlgItem(hDlg, nIDDlgItem);
  GetWindowRect(v3, &Rect);
  MapWindowPoints(0, hDlg, &Rect, 2u);
  v4 = GetDlgItem(hDlg, nIDDlgItem);
  DestroyWindow(v4);
  if ( nIDDlgItem == IDC_SYSINFO_IO_STATIC_IO_CHART
    || nIDDlgItem == IDC_SYSINFO_SUM_STATIC_SYSTEM_COMMIT_CHART
    || nIDDlgItem == IDC_SYSINFO_SUM_STATIC_PHYSICAL_MEMORY_CHART
    || nIDDlgItem == IDC_SYSINFO_IOETW_STATIC_NETWORK_CHART
    || nIDDlgItem == IDC_SYSINFO_IOETW_STATIC_DISK_CHART
    || nIDDlgItem == IDC_SYSINFO_GPU_STATIC_GPU_DEDICATED_MEMORY_CHART
    || nIDDlgItem == IDC_SYSINFO_GPU_STATIC_GPU_SYSTEM_MEMORY_CHART
    || nIDDlgItem == 2603
    || nIDDlgItem >= IDC_SYSINFO_CPU_STATIC_CPU_CHART && nIDDlgItem < 2500
    || nIDDlgItem >= IDC_SYSINFO_GPU_NODES_STATIC_GRAPH && nIDDlgItem < 2600 )
  {
    hWnd = CreateWindowExW(
             0,
             L"CpuGraphClassGraph",
             &gszNullString,
             0x50000000u,
             Rect.left,
             Rect.top,
             Rect.right - Rect.left,
             Rect.bottom - Rect.top,
             hDlg,
             nIDDlgItem,
             ghInstance,
             pParam);
  }
  else
  {
    hWnd = CreateWindowExW(
             0,
             L"CpuGraphClassChart",
             &gszNullString,
             0x50000000u,
             Rect.left,
             Rect.top,
             Rect.right - Rect.left,
             Rect.bottom - Rect.top,
             hDlg,
             nIDDlgItem,
             ghInstance,
             pParam);
  }
  return hWnd;
}
// 103CB88: using guessed type wchar_t aCpugraphclassc[19];

//----- (00FB1470) --------------------------------------------------------
HGDIOBJ __cdecl GraphData_DrawGraph(CGraphData *pGraphData, HDC hDC, RECT *lprc)
{
  LONG v3; // edi
  int v4; // esi
  bool v5; // zf
  bool v6; // sf
  unsigned __int8 v7; // of
  double v8; // xmm0_8
  __int64 v9; // xmm0_8
  __int64 v10; // xmm0_8
  double v11; // xmm0_8
  int v12; // eax
  DWORD v13; // eax
  signed int v14; // edi
  signed int v15; // ecx
  LONG v16; // ebx
  double v17; // xmm2_8
  int v18; // edx
  double v19; // xmm3_8
  double v20; // xmm1_8
  CGraphData *v21; // eax
  LONG v22; // ecx
  signed int v23; // edi
  unsigned int v24; // edx
  int *v25; // ecx
  int v26; // eax
  int v27; // esi
  int v28; // edi
  int v29; // eax
  HBRUSH v30; // eax
  HBRUSH v31; // esi
  HGDIOBJ v32; // eax
  COLORREF v33; // eax
  HGDIOBJ result; // eax
  const wchar_t *v35; // [esp+4h] [ebp-108h]
  double v36; // [esp+14h] [ebp-F8h]
  int v37[2]; // [esp+1Ch] [ebp-F0h]
  unsigned int v38; // [esp+24h] [ebp-E8h]
  LONG v39; // [esp+28h] [ebp-E4h]
  HDC v40; // [esp+2Ch] [ebp-E0h]
  RECT *v41; // [esp+30h] [ebp-DCh]
  int v42; // [esp+34h] [ebp-D8h]
  double v43; // [esp+38h] [ebp-D4h]
  LONG v44; // [esp+40h] [ebp-CCh]
  CGraphData *v45; // [esp+44h] [ebp-C8h]
  HGDIOBJ ho; // [esp+48h] [ebp-C4h]
  int cy; // [esp+4Ch] [ebp-C0h]
  int v48; // [esp+50h] [ebp-BCh]
  HDC hdc; // [esp+54h] [ebp-B8h]
  void *v50; // [esp+58h] [ebp-B4h]
  __int64 v51; // [esp+5Ch] [ebp-B0h]
  int a2a; // [esp+64h] [ebp-A8h]
  struct tagRECT rc; // [esp+68h] [ebp-A4h]
  RECT rect; // [esp+78h] [ebp-94h]
  __int16 Dst[32]; // [esp+88h] [ebp-84h]
  __int16 chText[32]; // [esp+C8h] [ebp-44h]

  v40 = hDC;
  v45 = pGraphData;
  v3 = lprc->right - lprc->left;
  v42 = lprc->bottom - lprc->top;
  v41 = lprc;
  cy = 0;
  v48 = 0;
  hdc = 0;
  ho = 0;
  v39 = v3;
  BitmapItem_Create(&ho, v3, v42);
  EnterCriticalSection(&pGraphData->m_Lock.m_Lock);
  v4 = pGraphData->m_nWidth - 1;
  if ( v4 < 0 )
    v4 = gdwVirtualScreenWidth - 1;
  v7 = __OFSUB__(pGraphData->m_nChildID, 1);
  v5 = pGraphData->m_nChildID == 1;
  v6 = (pGraphData->m_nChildID - 1) < 0;
  v51 = *&pGraphData->m_Item[0].pBuffer[v4];
  if ( (v6 ^ v7) | v5 )
    v8 = v36;
  else
    v8 = pGraphData->m_Item[1].pBuffer[v4];
  v43 = v8;
  LeaveCriticalSection(&pGraphData->m_Lock.m_Lock);
  switch ( pGraphData->m_nItemID )
  {
    case 0u:
    case 4u:
      v9 = v51;
      if ( pGraphData->m_nChildID != 1 && *&v51 <= v43 )
        v9 = *&v43;
      sub_FB09A0(chText, &gszNullString, v9);
      goto LABEL_18;
    case 1u:
    case 3u:
    case 5u:
    case 6u:
    case 7u:
      wcscpy_s(Dst, 0x20u, L" KB");
      v10 = v51;
      if ( *&v51 <= 1048576.0 )
      {
        if ( *&v51 <= 1024.0 )
          goto LABEL_16;
        v11 = *&v51 * 0.0009765625;
        v35 = L" MB";
      }
      else
      {
        v11 = *&v51 * 0.00000095367431640625;
        v35 = L" GB";
      }
      *&v51 = v11;
      wcscpy_s(Dst, 0x20u, v35);
      v10 = v51;
LABEL_16:
      swprintf_s(chText, 0x20u, L"%s%0.1f", &gszNullString, v10, HIDWORD(v10));
      wcscat_s(chText, 0x20u, Dst);
LABEL_18:
      SetBkColor(hdc, 0);
      SetTextColor(hdc, 0);
      v12 = DrawTextW(hdc, chText, -1, &rc, DT_CALCRECT);
      rect.top = 0;
      rect.left = (v3 / 3.0 * 0.5);
      rect.right = v3 - rect.left;
      HIDWORD(v51) = v42 - v12;
      rect.bottom = v42 - v12 - 2;
      v13 = GetSysColor(5);
      if ( v50 && cy * v48 )
        memset32(v50, (v13 & 0xFF00) | (v13 << 16) | (v13 >> 16) & 0xFF, cy * v48);
      BitmapItem_SetRectColor(&ho, &rect, gConfig.ColorGraphBk);
      v14 = pGraphData->m_nChildID;
      v15 = 0;
      v16 = rect.top;
      v44 = rect.top;
      if ( v14 > 0 )
      {
        v17 = rect.bottom;
        v18 = &v45->m_dbMemorySize;
        v19 = (rect.bottom - rect.top);
        do
        {
          v20 = *(*(v18 + 12) + 8 * v4) / *v18;
          v18 += 24;
          v37[v15++] = (v17 - v20 * v19);
        }
        while ( v15 < v14 );
      }
      if ( v16 < rect.bottom )
      {
        v21 = v45;
        v22 = rect.bottom;
        while ( 1 )
        {
          v23 = 0;
          v24 = 0x828282;
          if ( v21->m_nChildID > 0 )
            break;
LABEL_52:
          v44 = ++v16;
          if ( v16 >= v22 )
            goto LABEL_53;
        }
        v25 = &v21->m_Color;
        a2a = &v21->m_Color;
        do
        {
          v26 = v37[v23];
          if ( v16 >= v26 )
          {
            v24 = *v25;
            HIDWORD(v43) = *v25;
            if ( v16 > v26 + 1 )
            {
              v38 = v24 >> 8;
              v25 = a2a;
              v16 = v44;
              v24 = (((BYTE1(v24) + (256 - BYTE1(v24)) / 2) | ((BYTE2(v24) + (256 - BYTE2(v24)) / 2) << 8)) << 8) | (BYTE4(v43) + (256 - BYTE4(v43)) / 2);
            }
          }
          v21 = v45;
          ++v23;
          v25 += 6;
          a2a = v25;
        }
        while ( v23 < v45->m_nChildID );
        if ( v24 == 0x828282 )
        {
LABEL_51:
          v22 = rect.bottom;
          goto LABEL_52;
        }
        v27 = rect.left;
        v28 = v16;
        v29 = rect.right;
        a2a = v16;
        if ( rect.left >= 0 )
        {
          if ( rect.left >= v48 )
            v27 = v48 - 1;
        }
        else
        {
          v27 = 0;
        }
        if ( rect.right >= 0 )
        {
          if ( rect.right >= v48 )
            v29 = v48 - 1;
        }
        else
        {
          v29 = 0;
        }
        if ( v16 >= 0 )
        {
          if ( v16 < cy )
          {
LABEL_46:
            if ( v16 >= 0 )
            {
              if ( v16 >= cy )
                v28 = cy - 1;
            }
            else
            {
              v28 = 0;
            }
            sub_FB0A90(&ho, a2a, v27, v28, v29, v24, 0);
            v21 = v45;
            goto LABEL_51;
          }
          a2a = cy - 1;
        }
        else
        {
          a2a = 0;
        }
        v16 = v44;
        goto LABEL_46;
      }
LABEL_53:
      v30 = CreateSolidBrush(0x828282u);
      ++rect.right;
      v31 = v30;
      FrameRect(hdc, &rect, v30);
      DeleteObject(v31);
      rc.top = HIDWORD(v51);
      rc.bottom = v42;
      rc.left = 0;
      rc.right = v39;
      v32 = GetStockObject(17);
      SelectObject(hdc, v32);
      v33 = GetSysColor(5);
      SetBkColor(hdc, v33);
      SetTextColor(hdc, 0);
      DrawTextW(hdc, chText, -1, &rc, 5u);
      BitBlt(v40, v41->left, v41->top, v48, cy, hdc, 0, 0, 0xCC0020u);
      if ( hdc )
        DeleteDC(hdc);
      result = ho;
      if ( ho )
        result = DeleteObject(ho);
      return result;
    case 2u:
    case 8u:
    case 9u:
      sub_FC3C40(chText, 0x20u, COERCE__INT64(*&v51 - v43 + v43));
      goto LABEL_18;
    default:
      goto LABEL_18;
  }
}
// 103CBE0: using guessed type wchar_t aGb[4];
// 1064E28: using guessed type int gdwVirtualScreenWidth;
// FB1470: using guessed type int var_F0[2];

//----- (00FB1A60) --------------------------------------------------------
HICON __cdecl GraphData_DrawChart(CGraphData *pGraphData, HDC hDC, RECT *lprc, COLORREF Color, DWORD dwValue, double dbValue)
{
  HDC hCompatibleDC; // eax
  LONG nWidth; // ebx
  signed int nHeight; // edx
  COLORREF Color_1; // ecx
  void (__stdcall *DeleteObject)(HGDIOBJ); // edi
  unsigned int nSize; // ecx
  CGraphData *pGraphData_1; // edi
  int gdwVirtualScreenWidth; // ecx
  int v14; // edx
  tagGraphItem *pItem; // esi
  bool v16; // sf
  unsigned __int8 v17; // of
  unsigned int v18; // edx
  unsigned int v19; // eax
  unsigned int v20; // edx
  unsigned int v21; // eax
  int v22; // edx
  int v23; // edi
  int v24; // esi
  double v25; // xmm2_8
  double v26; // xmm1_8
  double v27; // xmm1_8
  int v28; // esi
  int v29; // edx
  int v30; // ecx
  int v31; // eax
  LONG bottom_1; // eax
  LONG index; // edi
  int y; // esi
  int nChildID; // edx
  int v36; // edx
  int v37; // edi
  int v38; // edx
  int v39; // esi
  double v40; // xmm1_8
  double v41; // xmm1_8
  double v42; // xmm1_8
  int v43; // edi
  int v44; // eax
  signed int v45; // esi
  int v46; // edx
  int v47; // ecx
  int v48; // ebx
  int v49; // ecx
  int v50; // edx
  tagGraphItem *v51; // edi
  HBRUSH hBrush; // esi
  HICON v53; // esi
  ICONINFO piconinfo; // [esp+Ch] [ebp-80h]
  HDC hdc; // [esp+20h] [ebp-6Ch]
  unsigned int v57; // [esp+24h] [ebp-68h]
  unsigned int v58; // [esp+28h] [ebp-64h]
  double v59; // [esp+2Ch] [ebp-60h]
  int v60; // [esp+34h] [ebp-58h]
  int v61; // [esp+38h] [ebp-54h]
  int nGraphWidth; // [esp+3Ch] [ebp-50h]
  RECT *lprc_1; // [esp+40h] [ebp-4Ch]
  int v64; // [esp+44h] [ebp-48h]
  int v65; // [esp+48h] [ebp-44h]
  int v66; // [esp+4Ch] [ebp-40h]
  BitmapItem BitmapItem; // [esp+50h] [ebp-3Ch]
  LONG bottom; // [esp+64h] [ebp-28h]
  int right; // [esp+68h] [ebp-24h]
  unsigned int a6; // [esp+6Ch] [ebp-20h]
  tagGraphItem *pItem_1; // [esp+70h] [ebp-1Ch]
  int v72; // [esp+74h] [ebp-18h]
  RECT rc; // [esp+78h] [ebp-14h]
  COLORREF Colora; // [esp+A0h] [ebp+14h]

  hCompatibleDC = 0;
  lprc_1 = lprc;
  nWidth = lprc->right - lprc->left;
  nHeight = lprc->bottom - lprc->top;
  Color_1 = Color;
  if ( Color == -1 )
    Color_1 = gConfig.ColorGraphBk;
  hdc = hDC;
  BitmapItem.nHeight = 0;
  BitmapItem.nWidth = 0;
  BitmapItem.CompatibleDC = 0;
  BitmapItem.hBitmapHandle = 0;
  right = nWidth;
  bottom = nHeight;
  v59 = 0.0;
  Colora = Color_1;
  DeleteObject = ::DeleteObject;
  if ( hDC && (!nWidth || !nHeight) )
    goto LABEL_111;
  BitmapItem_Create(&BitmapItem, nWidth, nHeight);
  nSize = BitmapItem.nHeight * BitmapItem.nWidth;
  if ( BitmapItem.pBits && nSize )
    memset32(BitmapItem.pBits, (Colora & 0xFF00) | (Colora << 16) | (Colora >> 16) & 0xFF, nSize);
  pGraphData_1 = pGraphData;
  gdwVirtualScreenWidth = ::gdwVirtualScreenWidth;
  nGraphWidth = pGraphData->m_nWidth - 1;
  if ( nGraphWidth < 0 )
    nGraphWidth = ::gdwVirtualScreenWidth - 1;
  v14 = 0;
  for ( pItem = pGraphData->m_Item; ; ++pItem )
  {
    pItem_1 = pItem;
    v17 = __OFSUB__(v14, pGraphData_1->m_nChildID);
    v16 = (v14 - pGraphData_1->m_nChildID) < 0;
    v65 = v14;
    if ( !(v16 ^ v17) )
      break;
    v18 = pItem[-1].Color;
    a6 = pItem[-1].Color;
    if ( Colora && right <= 20 && bottom <= 20 )
    {
      v19 = v18;
      v20 = v18 >> 16;
      v21 = v19 >> 8;
      if ( v21 <= v20 )
        a6 = a6 < v20 ? 0xFF0000 : 255;
      else
        a6 = a6 < v21 ? 0xFF00 : 255;
    }
    v22 = 0;
    v23 = -1;
    v66 = 0;
    if ( gdwVirtualScreenWidth > 0 )
    {
      v24 = 0;
      v64 = 0;
      v72 = right - 1;
      do
      {
        if ( v24 >= right + 1 )
          break;
        v25 = pItem_1->pBuffer[(nGraphWidth + gdwVirtualScreenWidth - v22) % gdwVirtualScreenWidth];
        if ( v25 > v59 )
          v59 = pItem_1->pBuffer[(nGraphWidth + gdwVirtualScreenWidth - v22) % gdwVirtualScreenWidth];
        if ( dbValue == 0.0 )
          v26 = v25 / pItem_1[-1].dbMemorySize;
        else
          v26 = v25 / dbValue;
        v27 = v26 * bottom;
        v28 = bottom - v27;
        if ( v23 != -1 && v25 != 0.0 )
        {
          v29 = v72;
          v30 = bottom - v27;
          v31 = v72 + 2;
          if ( v72 >= 0 )
          {
            if ( v72 >= BitmapItem.nWidth )
              v29 = BitmapItem.nWidth - 1;
          }
          else
          {
            v29 = 0;
          }
          if ( v31 >= 0 )
          {
            if ( v31 >= BitmapItem.nWidth )
              v31 = BitmapItem.nWidth - 1;
          }
          else
          {
            v31 = 0;
          }
          if ( v28 >= 0 )
          {
            if ( v28 >= BitmapItem.nHeight )
              v30 = BitmapItem.nHeight - 1;
          }
          else
          {
            v30 = 0;
          }
          if ( v23 >= 0 )
          {
            if ( v23 >= BitmapItem.nHeight )
              v23 = BitmapItem.nHeight - 1;
          }
          else
          {
            v23 = 0;
          }
          sub_FB0A90(&BitmapItem, v30, v29, v23, v31, a6, 1);
          gdwVirtualScreenWidth = ::gdwVirtualScreenWidth;
        }
        v23 = v28;
        v22 = v66 + 1;
        v72 -= 2;
        v24 = v64 + 2;
        v66 = v22;
        v64 += 2;
      }
      while ( v22 < gdwVirtualScreenWidth );
      pItem = pItem_1;
    }
    pGraphData_1 = pGraphData;
    v14 = v65 + 1;
  }
  bottom_1 = bottom;
  if ( bottom > 60 )
  {
    index = 0;
    if ( lprc_1->bottom > 0 )
    {
      y = 0;
      do
      {
        if ( y >= bottom_1 )
          break;
        if ( !(index % 15) )
          sub_FB0ED0(&BitmapItem, 0, y, right, y, 0x828282u, 0);
        ++index;
        y += 2;
        bottom_1 = bottom;
      }
      while ( index < lprc_1->bottom );
      gdwVirtualScreenWidth = ::gdwVirtualScreenWidth;
    }
    pGraphData_1 = pGraphData;
  }
  nChildID = pGraphData_1->m_nChildID;
  while ( 1 )
  {
    v36 = nChildID - 1;
    v61 = v36;
    if ( v36 < 0 )
      break;
    v37 = pGraphData_1->m_nChildID - v36 - 1;
    v72 = -1;
    v38 = 0;
    v66 = v37;
    v64 = 0;
    if ( gdwVirtualScreenWidth > 0 )
    {
      v39 = 0;
      v60 = 0;
      a6 = right - 1;
      while ( 1 )
      {
        if ( v39 >= right + 1 )
          goto LABEL_108;
        v40 = pGraphData->m_Item[v37].pBuffer[(nGraphWidth + gdwVirtualScreenWidth - v38) % gdwVirtualScreenWidth];
        if ( v40 > v59 )
          v59 = pGraphData->m_Item[v37].pBuffer[(nGraphWidth + gdwVirtualScreenWidth - v38) % gdwVirtualScreenWidth];
        v41 = dbValue == 0.0 ? v40 / *(&pGraphData->m_dbMemorySize + 3 * v37) : v40 / dbValue;
        v42 = v41 * bottom;
        v43 = bottom - v42;
        v44 = v72;
        v65 = bottom - v42;
        if ( v72 != -1 )
          break;
LABEL_107:
        a6 -= 2;
        v39 = v60 + 2;
        v37 = v66;
        v72 = v65;
        v38 = v64 + 1;
        v60 += 2;
        v64 = v38;
        if ( v38 >= gdwVirtualScreenWidth )
          goto LABEL_108;
      }
      pItem_1 = a6;
      v45 = a6 + 2;
      v57 = a6 + 2;
      v46 = bottom - v42;
      v58 = *(&pGraphData->m_Color + 6 * v66);
      v47 = v72;
      if ( (a6 & 0x80000000) != 0 )
      {
        pItem_1 = 0;
        goto LABEL_73;
      }
      if ( a6 >= BitmapItem.nWidth )
      {
        pItem_1 = (BitmapItem.nWidth - 1);
LABEL_73:
        v44 = v72;
      }
      if ( v45 >= 0 )
      {
        if ( v45 < BitmapItem.nWidth )
          v48 = v57;
        else
          v48 = BitmapItem.nWidth - 1;
      }
      else
      {
        v48 = 0;
      }
      if ( v43 >= 0 )
      {
        if ( v43 >= BitmapItem.nHeight )
          v46 = BitmapItem.nHeight - 1;
      }
      else
      {
        v46 = 0;
      }
      if ( v44 >= 0 )
      {
        if ( v44 >= BitmapItem.nHeight )
          v47 = BitmapItem.nHeight - 1;
      }
      else
      {
        v47 = 0;
      }
      sub_FB0A90(&BitmapItem, v46, pItem_1, v47, v48, v58, 0);
      v49 = v43 + 1;
      if ( v43 + 1 < bottom )
      {
        v50 = v72 + 1;
        pItem_1 = a6;
        if ( (a6 & 0x80000000) != 0 )
        {
          v51 = 0;
          goto LABEL_92;
        }
        if ( a6 >= BitmapItem.nWidth )
        {
          v51 = (BitmapItem.nWidth - 1);
LABEL_92:
          pItem_1 = v51;
        }
        if ( v45 >= 0 )
        {
          if ( v45 >= BitmapItem.nWidth )
            v45 = BitmapItem.nWidth - 1;
        }
        else
        {
          v45 = 0;
        }
        if ( v49 >= 0 )
        {
          if ( v49 >= BitmapItem.nHeight )
            v49 = BitmapItem.nHeight - 1;
        }
        else
        {
          v49 = 0;
        }
        if ( v50 >= 0 )
        {
          if ( v50 >= BitmapItem.nHeight )
            v50 = BitmapItem.nHeight - 1;
        }
        else
        {
          v50 = 0;
        }
        sub_FB0A90(&BitmapItem, v49, pItem_1, v50, v45, *(&pGraphData->m_Color + 6 * v66), 0);
      }
      gdwVirtualScreenWidth = ::gdwVirtualScreenWidth;
      goto LABEL_107;
    }
LABEL_108:
    nChildID = v61;
    pGraphData_1 = pGraphData;
  }
  hBrush = CreateSolidBrush(0x828282u);
  rc.left = 0;
  rc.right = right;
  rc.bottom = bottom;
  rc.top = 0;
  FrameRect(BitmapItem.CompatibleDC, &rc, hBrush);
  DeleteObject = ::DeleteObject;
  ::DeleteObject(hBrush);
  if ( hdc )
  {
    BitBlt(
      hdc,
      lprc_1->left,
      lprc_1->top,
      BitmapItem.nWidth,
      BitmapItem.nHeight,
      BitmapItem.CompatibleDC,
      0,
      0,
      0xCC0020u);
    hCompatibleDC = BitmapItem.CompatibleDC;
LABEL_111:
    v53 = 0;
    goto __quit;
  }
  piconinfo.hbmColor = BitmapItem.hBitmapHandle;
  piconinfo.hbmMask = BitmapItem.hBitmapHandle;
  piconinfo.fIcon = 1;
  piconinfo.xHotspot = 0;
  piconinfo.yHotspot = 0;
  v53 = CreateIconIndirect(&piconinfo);
  hCompatibleDC = BitmapItem.CompatibleDC;
__quit:
  if ( hCompatibleDC )
    DeleteDC(hCompatibleDC);
  if ( BitmapItem.hBitmapHandle )
    DeleteObject(BitmapItem.hBitmapHandle);
  return v53;
}
// 1064E28: using guessed type int gdwVirtualScreenWidth;

//----- (00FB1FD0) --------------------------------------------------------
char *__cdecl sub_FB1FD0(FILETIME *a1, HDC hDC, RECT *lprc, COLORREF ColorBack)
{
  char *nWidth; // eax
  signed int nHeight; // ecx
  COLORREF Color; // ebx
  unsigned int nSize; // ecx
  float v8; // xmm0_4
  char *v9; // edi
  float v10; // xmm0_4
  LONG v11; // ebx
  HBRUSH hBrush; // esi
  RECT rect; // [esp+8h] [ebp-64h]
  struct _FILETIME FileTime; // [esp+18h] [ebp-54h]
  RECT *v15; // [esp+20h] [ebp-4Ch]
  char *nWidth_1; // [esp+24h] [ebp-48h]
  LONG nHeight_1; // [esp+28h] [ebp-44h]
  HDC hdc; // [esp+2Ch] [ebp-40h]
  BitmapItem BitmapItem; // [esp+30h] [ebp-3Ch]
  float v20; // [esp+44h] [ebp-28h]
  struct _SYSTEMTIME SystemTime; // [esp+48h] [ebp-24h]
  RECT rc; // [esp+58h] [ebp-14h]

  v20 = *&a1;
  nWidth = (lprc->right - lprc->left);
  nHeight = lprc->bottom - lprc->top;
  Color = ColorBack;
  if ( ColorBack == -1 )
    Color = gConfig.ColorGraphBk;
  hdc = hDC;
  v15 = lprc;
  BitmapItem.nHeight = 0;
  BitmapItem.nWidth = 0;
  BitmapItem.CompatibleDC = 0;
  BitmapItem.hBitmapHandle = 0;
  nWidth_1 = nWidth;
  nHeight_1 = nHeight;
  if ( !hDC || nWidth && nHeight )
  {
    BitmapItem_Create(&BitmapItem, nWidth, nHeight);
    nSize = BitmapItem.nHeight * BitmapItem.nWidth;
    if ( BitmapItem.pBits && nSize )
      memset32(BitmapItem.pBits, (Color & 0xFF00) | (Color << 16) | (Color >> 16) & 0xFF, nSize);
    GetSystemTime(&SystemTime);
    SystemTimeToFileTime(&SystemTime, &FileTime);
    rect.top = 0;
    v8 = (*&FileTime - *LODWORD(v20));
    v20 = v8;
    v9 = nWidth_1;
    v10 = (*&FileTime - *&gCreateTimeLast);
    v11 = nHeight_1;
    rect.right = nWidth_1;
    rect.bottom = nHeight_1;
    rect.left = &nWidth_1[-((v20 / v10) * nWidth_1)];
    BitmapItem_SetRectColor(&BitmapItem, &rect, 0x9ECA9Eu);
    hBrush = CreateSolidBrush(0x828282u);
    rc.left = 0;
    rc.top = 0;
    rc.right = v9;
    rc.bottom = v11;
    FrameRect(BitmapItem.CompatibleDC, &rc, hBrush);
    DeleteObject(hBrush);
    BitBlt(hdc, v15->left, v15->top, BitmapItem.nWidth, BitmapItem.nHeight, BitmapItem.CompatibleDC, 0, 0, 0xCC0020u);
    if ( BitmapItem.CompatibleDC )
      DeleteDC(BitmapItem.CompatibleDC);
    nWidth = BitmapItem.hBitmapHandle;
    if ( BitmapItem.hBitmapHandle )
      nWidth = DeleteObject(BitmapItem.hBitmapHandle);
  }
  return nWidth;
}

//----- (00FB21A0) --------------------------------------------------------
int __cdecl GraphData_QueryData(CGraphData *pGraphData, double *pArg1, double *pArg2)
{
  int nWidth; // edi

  EnterCriticalSection(&pGraphData->m_Lock.m_Lock);
  nWidth = pGraphData->m_nWidth - 1;
  if ( nWidth < 0 )
    nWidth = gdwVirtualScreenWidth - 1;
  *pArg1 = pGraphData->m_Item[0].pBuffer[nWidth];
  if ( pArg2 && pGraphData->m_nChildID > 1 )
    *pArg2 = pGraphData->m_Item[1].pBuffer[nWidth];
  LeaveCriticalSection(&pGraphData->m_Lock.m_Lock);
  return nWidth;
}
// 1064E28: using guessed type int gdwVirtualScreenWidth;

//----- (00FB2200) --------------------------------------------------------
int __cdecl sub_FB2200(char a1, wchar_t *a2, size_t SizeInWords, __int64 a4, __int64 a5, __int64 a6)
{
  char v6; // al
  char v7; // dl
  int v8; // esi
  __int64 v9; // xmm3_8
  __int64 v10; // xmm0_8
  __int64 v11; // xmm1_8
  __int64 v12; // xmm4_8
  __int64 v13; // xmm2_8
  double v14; // xmm0_8
  double v15; // xmm1_8
  signed int v16; // edi
  size_t v17; // ecx
  double v18; // xmm0_8
  int v19; // eax
  const wchar_t *v20; // eax
  char v22; // [esp+1Eh] [ebp-1Eh]
  char v23; // [esp+1Fh] [ebp-1Dh]
  __int64 v24; // [esp+20h] [ebp-1Ch]
  double v25; // [esp+28h] [ebp-14h]
  __int64 v26; // [esp+30h] [ebp-Ch]

  v6 = 0;
  v7 = 0;
  v22 = 0;
  v8 = 0;
  v23 = 0;
  if ( !a1 )
    return sub_FC3C40(a2, SizeInWords, COERCE__INT64(*&a4 + *&a5));
  v9 = a6;
  v10 = a5;
  if ( *&a6 <= *&a5 )
    v11 = a6;
  else
    v11 = a5;
  if ( *&a5 <= *&a6 )
    v10 = a6;
  v12 = a4;
  if ( *&v10 <= *&a4 )
    v13 = v10;
  else
    v13 = a4;
  if ( *&a4 > *&v10 )
    v10 = a4;
  v24 = v10;
  v14 = *&v13;
  if ( *&v11 <= *&v13 )
    v13 = v11;
  if ( v14 <= *&v11 )
    v14 = *&v11;
  v15 = *&dbl_103CDD8;
  *a2 = 0;
  v16 = 0;
  v17 = SizeInWords;
  v25 = v14;
  v26 = v13;
  do
  {
    v18 = *(&v24 + v16);
    if ( v18 != v15 )
    {
      if ( v8 > 0 )
      {
        v18 = *(&v24 + v16);
        v9 = a6;
        v8 += swprintf_s(&a2[v8], v17 - v8, L"\n");
        v15 = *&dbl_103CDD8;
        v12 = a4;
        v17 = SizeInWords;
        v6 = v22;
        v7 = v23;
      }
      if ( v18 != *&a5 || v7 )
      {
        if ( v18 != *&v12 || v6 )
        {
          v19 = swprintf_s(&a2[v8], v17 - v8, L"O: ");
        }
        else
        {
          v20 = L"R";
          if ( *&v9 == v15 )
            v20 = L"R+O";
          v19 = swprintf_s(&a2[v8], v17 - v8, L"%s: ", v20);
          v22 = 1;
        }
      }
      else
      {
        v19 = swprintf_s(&a2[v8], v17 - v8, L"W: ");
        v23 = 1;
      }
      v9 = a6;
      v15 = *&dbl_103CDD8;
      v8 += sub_FC3C40(&a2[v19 + v8], SizeInWords - (v19 + v8), *(&v24 + v16)) + v19;
      v12 = a4;
      v17 = SizeInWords;
      v6 = v22;
      v7 = v23;
    }
    ++v16;
  }
  while ( v16 < 3 );
  return v8;
}
// 103CBB8: using guessed type wchar_t aR[2];
// 103CBBC: using guessed type wchar_t aRO[4];

//----- (00FB2410) --------------------------------------------------------
errno_t __cdecl sub_FB2410(wchar_t *a1, rsize_t SizeInWords, int a3, __int64 a4)
{
  double v4; // xmm0_8
  const wchar_t *v6; // [esp+4h] [ebp-50h]
  wchar_t Dst; // [esp+10h] [ebp-44h]

  wcscpy_s(&Dst, 0x20u, L" KB");
  v4 = *&a4;
  if ( *&a4 > 1048576.0 )
  {
    v4 = *&a4 * 0.00000095367431640625;
    v6 = L" GB";
LABEL_5:
    wcscpy_s(&Dst, 0x20u, v6);
    goto LABEL_6;
  }
  if ( *&a4 > 1024.0 )
  {
    v4 = *&a4 * 0.0009765625;
    v6 = L" MB";
    goto LABEL_5;
  }
LABEL_6:
  swprintf_s(a1, SizeInWords, L"%s%0.1f", a3, LODWORD(v4), HIDWORD(v4));
  return wcscat_s(a1, SizeInWords, &Dst);
}
// 103CBE0: using guessed type wchar_t aGb[4];

//----- (00FB24C0) --------------------------------------------------------
void __cdecl sub_FB24C0(int a1)
{
  wchar_t *v1; // edi
  __int16 v2; // si
  int v3; // esi
  int v4; // edx
  _DWORD *v5; // edx
  int v6; // eax
  __int16 *v7; // ecx
  __int16 v8; // ax
  wchar_t *v9; // eax
  int v10; // ecx
  int v11; // eax
  int v12; // edx
  __int16 *v13; // ecx
  __int16 v14; // ax
  int v15; // ecx
  const wchar_t *v16; // eax
  int v17; // ecx
  __int64 v18; // ST14_8
  __int64 v19; // [esp+10h] [ebp-2D4h]
  int v20; // [esp+14h] [ebp-2D0h]
  int v21; // [esp+14h] [ebp-2D0h]
  struct _FILETIME LocalFileTime; // [esp+24h] [ebp-2C0h]
  FILETIME FileTime; // [esp+2Ch] [ebp-2B8h]
  int v24; // [esp+34h] [ebp-2B0h]
  struct _SYSTEMTIME SystemTime; // [esp+38h] [ebp-2ACh]
  struct tagRECT Rect; // [esp+48h] [ebp-29Ch]
  wchar_t Dst; // [esp+58h] [ebp-28Ch]
  WCHAR TimeStr; // [esp+260h] [ebp-84h]

  v1 = (a1 + 4);
  *(a1 + 4) = 0;
  GetClientRect(*a1, &Rect);
  v2 = *(a1 + 2052);
  if ( (Rect.right - v2 - 1) / 2 <= gdwVirtualScreenWidth )
  {
    EnterCriticalSection(*(a1 + 2056));
    v3 = (*(*(a1 + 2056) + 24) - (Rect.right - *(a1 + 2052)) / 2 + gdwVirtualScreenWidth - 1) % gdwVirtualScreenWidth;
    v4 = *(a1 + 2056);
    if ( !*(*(v4 + 2156) + 4 * v3) )
    {
LABEL_52:
      LeaveCriticalSection(*(a1 + 2056));
      *(a1 + 2052) += 20;
      *(a1 + 2054) += 20;
      goto LABEL_53;
    }
    switch ( *(v4 + 32) )
    {
      case 0:
        wsprintfW(v1, L"CPU\n");
        break;
      case 2:
        wsprintfW(v1, L"I/O\n");
        break;
      case 4:
        wsprintfW(v1, L"GPU\n");
        break;
      case 8:
        wsprintfW(v1, L"Disk\n");
        break;
      case 9:
        wsprintfW(v1, L"Network\n");
        break;
      default:
        break;
    }
    v5 = *(a1 + 2056);
    if ( v5[536] )
    {
      v6 = v5[8];
      if ( !v6 || v6 == 4 )
      {
        v7 = (a1 + 4);
        v24 = a1 + 6;
        do
        {
          v8 = *v7;
          ++v7;
        }
        while ( v8 );
        sub_FB0E00((a1 + 4 + 2 * ((v7 - v24) >> 1)), 1024 - ((v7 - v24) >> 1), &gszNullString, *(v5[13] + 8 * v3));
        wcscat_s(v1, 0x400u, L"\n");
      }
      v9 = *(*(*(a1 + 2056) + 2144) + 4 * v3);
      if ( !v9 || !*v9 )
        goto LABEL_51;
    }
    else
    {
      if ( !v5[543] )
      {
        *v1 = 0;
        if ( *(v5[539] + 4 * v3) )
        {
          v15 = v5[8];
          switch ( v15 )
          {
            case 0:
            case 4:
              v16 = L"GPU\n";
              v19 = *(v5[13] + 8 * v3);
              if ( v15 != 4 )
                v16 = L"CPU\n";
              sub_FB09F0(v1, v16, v19);
              break;
            case 1:
              sub_FB0A40(v1, L"System Commit\n", *(v5[13] + 8 * v3));
              break;
            case 2:
              wsprintfW(v1, L"I/O\n");
              goto LABEL_48;
            case 3:
              sub_FB0A40(v1, L"Physical Memory\n", *(v5[13] + 8 * v3));
              break;
            case 5:
              sub_FB0A40(v1, L"GPU System Memory\n", *(v5[13] + 8 * v3));
              break;
            case 6:
              sub_FB0A40(v1, L"GPU Dedicated Memory\n", *(v5[13] + 8 * v3));
              break;
            case 7:
              sub_FB0A40(v1, L"GPU Committed Memory\n", *(v5[13] + 8 * v3));
              break;
            case 8:
              wsprintfW(v1, L"Disk\n");
              goto LABEL_48;
            case 9:
              wsprintfW(v1, L"Network\n");
LABEL_48:
              v17 = *(a1 + 2056);
              v18 = *(*(v17 + 76) + 8 * v3);
              sub_FB2200(1, v1, 0x400u, COERCE__INT64(*(*(v17 + 52) + 8 * v3) - *&v18), v18, dbl_103CDD8);
              break;
            default:
              break;
          }
          if ( *v1 )
            wcscat_s(v1, 0x400u, L"\n");
        }
        goto LABEL_51;
      }
      v20 = v5[542];
      if ( v5[8] == 4 )
      {
        wsprintfW(v1, L"GPU Engine %d: ", v20);
      }
      else
      {
        v10 = wsprintfW(v1, L"CPU %d", v20);
        v11 = *(a1 + 2056);
        v12 = *(v11 + 2160);
        if ( v12 != -1 )
        {
          v21 = *(v11 + 2164);
          if ( v12 == 1 )
            swprintf_s((a1 + 4 + 2 * v10), 1024 - v10, L" (Node %d)", v21);
          else
            swprintf_s((a1 + 4 + 2 * v10), 1024 - v10, L" (Core %d)", v21);
        }
      }
      wcscat_s(v1, 0x400u, L" ");
      v13 = (a1 + 4);
      do
      {
        v14 = *v13;
        ++v13;
      }
      while ( v14 );
      sub_FB0E00(
        (a1 + 4 + 2 * ((v13 - a1 - 6) >> 1)),
        1024 - ((v13 - a1 - 6) >> 1),
        &gszNullString,
        *(*(*(a1 + 2056) + 52) + 8 * v3));
      if ( !*(*(*(*(a1 + 2056) + 2172) + 2144) + 4 * v3) )
      {
LABEL_51:
        FileTime = (*(*(a1 + 2056) + 2148) + 10000000i64 * *(*(*(a1 + 2056) + 2156) + 4 * v3));
        FileTimeToLocalFileTime(&FileTime, &LocalFileTime);
        FileTimeToSystemTime(&LocalFileTime, &SystemTime);
        GetTimeFormatW(0x400u, 0, &SystemTime, 0, &TimeStr, 64);
        wcscat_s(v1, 0x400u, &TimeStr);
        goto LABEL_52;
      }
      if ( *v1 )
        wcscat_s(v1, 0x400u, L"\n");
      wcscpy_s(&Dst, 0x104u, *(*(*(*(a1 + 2056) + 2172) + 2144) + 4 * v3));
      if ( wcschr(&Dst, 0xAu) )
        *wcschr(&Dst, 0xAu) = 32;
      v9 = &Dst;
    }
    wcscat_s(v1, 0x400u, v9);
    wcscat_s(v1, 0x400u, L"\n");
    goto LABEL_51;
  }
  *(a1 + 2054) += 10;
  *(a1 + 2052) = v2 + 10;
LABEL_53:
  *(a1 + 2060) = 1;
}
// 103CC54: using guessed type wchar_t aCpu[5];
// 103CC9C: using guessed type wchar_t aNodeD[11];
// 103CCCC: using guessed type wchar_t aPhysicalMemory[17];
// 103CCF0: using guessed type wchar_t aSystemCommit[15];
// 103CD10: using guessed type wchar_t aGpuDedicatedMe[22];
// 103CD3C: using guessed type wchar_t aGpuSystemMemor[19];
// 103CD64: using guessed type wchar_t aGpuCommittedMe[22];
// 1064E28: using guessed type int gdwVirtualScreenWidth;

//----- (00FB2A70) --------------------------------------------------------
int __cdecl sub_FB2A70(HWND hWnd)
{
  HWND v1; // esi
  HWND v2; // edi
  HWND i; // eax
  int result; // eax
  HWND v5; // [esp+Ch] [ebp-4h]

  v1 = hWnd;
  if ( GetParent(hWnd) )
  {
    v1 = GetParent(hWnd);
    v2 = GetParent(v1);
  }
  else
  {
    v2 = v5;
  }
  if ( !IsWindowVisible(v1) )
    goto LABEL_13;
  for ( i = GetFocus(); v1 != i; i = GetParent(i) )
  {
    if ( v2 == i )
      break;
    if ( !i )
      goto LABEL_13;
  }
  if ( i && (v1 == i || v2 == i) )
    result = 1;
  else
LABEL_13:
    result = 0;
  return result;
}

//----- (00FB2AE0) --------------------------------------------------------
PerformanceInfo *__thiscall PerformanceInfo::PerformanceInfo(PerformanceInfo *this, HKEY hSubKey)
{
  HKEY Flags; // eax
  PerformanceInfo *pThis; // edi
  const WCHAR *szPerfValueName; // esi
  const WCHAR *szValueName; // ebx
  BYTE *v7; // eax
  WCHAR **v8; // ecx
  const WCHAR *psz; // esi
  int i; // ebx
  unsigned int dwCounter; // eax
  const WCHAR *psz1; // esi
  DWORD cbData; // [esp+Ch] [ebp-8h]
  DWORD cbData_1; // [esp+10h] [ebp-4h]

  Flags = hSubKey;
  pThis = this;
  this->m_dwLastCounterOfLastHelp = 0;
  this->m_LastCounterOfLastHelp = 0;
  this->m_PerfValue = 0;
  if ( Flags )
  {
    if ( Flags != 1 )
      return pThis;
    szPerfValueName = L"Explain 009";
    szValueName = L"Last Help";
  }
  else
  {
    szPerfValueName = L"Counter 009";
    szValueName = L"Last Counter";
  }
  hSubKey = 0;
  cbData = 4;
  if ( !RegOpenKeyExW(
          HKEY_LOCAL_MACHINE,
          L"software\\microsoft\\windows nt\\currentversion\\perflib",
          0,
          KEY_READ,
          &hSubKey) )
  {
    if ( RegQueryValueExW(hSubKey, szValueName, 0, 0, pThis, &cbData) )
    {
      RegCloseKey(hSubKey);
      return pThis;
    }
    RegCloseKey(hSubKey);
    if ( !RegQueryValueExW(HKEY_PERFORMANCE_DATA, szPerfValueName, 0, 0, 0, &cbData_1) )
    {
      v7 = operator new[](2 * cbData_1);
      pThis->m_PerfValue = v7;
      if ( RegQueryValueExW(HKEY_PERFORMANCE_DATA, szPerfValueName, 0, 0, v7, &cbData_1)
        || (v8 = operator new[](4 * (pThis->m_dwLastCounterOfLastHelp + 1)), (pThis->m_LastCounterOfLastHelp = v8) == 0) )
      {
        j_j__free(pThis->m_PerfValue);
        return pThis;
      }
      memset(v8, 0, 4 * pThis->m_dwLastCounterOfLastHelp + 4);
      psz = pThis->m_PerfValue;
      for ( i = lstrlenW(pThis->m_PerfValue); i; i = lstrlenW(psz) )
      {
        dwCounter = _wtoi(psz);
        if ( dwCounter > pThis->m_dwLastCounterOfLastHelp )
          break;
        psz1 = &psz[i + 1];
        pThis->m_LastCounterOfLastHelp[dwCounter] = psz1;
        psz = &psz1[lstrlenW(psz1) + 1];
      }
    }
  }
  return pThis;
}
// 103CE14: using guessed type wchar_t aExplain009[12];
// 103CE2C: using guessed type wchar_t aLastHelp[10];

//----- (00FB2C80) --------------------------------------------------------
void __thiscall PerformanceInfo::~PerformanceInfo(void **this)
{
  void **v1; // esi
  void *v2; // ST00_4

  v1 = this;
  j_j__free(this[1]);
  v2 = v1[2];
  v1[1] = 0;
  j_j__free(v2);
  v1[2] = 0;
  *v1 = 0;
}

//----- (00FB2CB0) --------------------------------------------------------
int __thiscall PerformanceInfo::FindPerf(PerformanceInfo *pThis, LPCWSTR lpszName)
{
  PerformanceInfo *this; // edi
  signed int index; // esi

  this = pThis;
  if ( IsBadStringPtrW(lpszName, 0xFFFFFFFF) || !this->m_dwLastCounterOfLastHelp || !this->m_LastCounterOfLastHelp )
    return 0;
  index = 1;
  if ( this->m_dwLastCounterOfLastHelp < 1u )
    return 0;
  while ( !this->m_LastCounterOfLastHelp[index] || _wcsicmp(lpszName, this->m_LastCounterOfLastHelp[index]) )
  {
    if ( ++index > this->m_dwLastCounterOfLastHelp )
      return 0;
  }
  return index;
}

//----- (00FB2D20) --------------------------------------------------------
int __thiscall sub_FB2D20(unsigned int *this, unsigned int a2)
{
  int result; // eax

  if ( a2 <= *this )
    result = *(this[1] + 4 * a2);
  else
    result = 0;
  return result;
}

//----- (00FB2D40) --------------------------------------------------------
LRESULT __cdecl HandleCmdHandler(int a1, HWND hWnd, WPARAM wParam, LPARAM lParam)
{
  int v4; // ecx
  int v5; // esi
  LRESULT result; // eax

  v4 = 0;
  v5 = *(a1 + 4);
  if ( *a1 <= 0 )
  {
LABEL_4:
    switch ( *(a1 + 8) )
    {
      case 1:
        result = DefWindowProcW(hWnd, 0x111u, wParam, lParam);
        break;
      case 2:
        result = DefDlgProcW(hWnd, 0x111u, wParam, lParam);
        break;
      case 3:
        result = DefMDIChildProcW(hWnd, 0x111u, wParam, lParam);
        break;
      case 4:
        result = DefFrameProcW(hWnd, 0, 0x111u, wParam, lParam);
        break;
      default:
        result = 0;
        break;
    }
  }
  else
  {
    while ( *(v5 + 8 * v4) != wParam )
    {
      if ( ++v4 >= *a1 )
        goto LABEL_4;
    }
    result = (*(v5 + 8 * v4 + 4))(hWnd, wParam, wParam >> 16, lParam);
  }
  return result;
}

//----- (00FB2E00) --------------------------------------------------------
LRESULT __cdecl HandleMsgHandler(tagMSGHANDLER *pMsgHander, HWND hWnd, UINT Msg, WPARAM wParam, LPARAM lParam)
{
  int nIndex; // eax
  PMSGFUNC WindowMsgFunc; // esi
  LRESULT result; // eax

  nIndex = 0;
  WindowMsgFunc = pMsgHander->WindowMsgFunc;
  if ( pMsgHander->nLength <= 0 )
  {
LABEL_4:
    switch ( pMsgHander->Flags )
    {
      case 1:
        result = DefWindowProcW(hWnd, Msg, wParam, lParam);
        break;
      case 2:
        result = DefDlgProcW(hWnd, Msg, wParam, lParam);
        break;
      case 3:
        result = DefMDIChildProcW(hWnd, Msg, wParam, lParam);
        break;
      case 4:
        result = DefFrameProcW(hWnd, 0, Msg, wParam, lParam);
        break;
      default:
        result = 0;
        break;
    }
  }
  else
  {
    while ( WindowMsgFunc[nIndex].msg != Msg )
    {
      if ( ++nIndex >= pMsgHander->nLength )
        goto LABEL_4;
    }
    result = (WindowMsgFunc[nIndex].pfn)(hWnd, Msg, wParam, lParam);
  }
  return result;
}

//----- (00FB2EC0) --------------------------------------------------------
bool __cdecl CDriver::SaveDriverFromResource(LPCWSTR lpName, const wchar_t *lpszFileName)
{
  HRSRC hRsrc; // eax
  HRSRC hRsrc_1; // edi
  HGLOBAL hGlobal; // esi
  DWORD dwSize; // edi
  const void *pBuffer; // esi
  FILE *pFile; // [esp+4h] [ebp-4h]

  hRsrc = FindResourceW(0, lpName, L"BINRES");
  hRsrc_1 = hRsrc;
  if ( !hRsrc )
    return 0;
  hGlobal = LoadResource(0, hRsrc);
  dwSize = SizeofResource(0, hRsrc_1);
  pBuffer = LockResource(hGlobal);
  if ( _wfopen_s(&pFile, lpszFileName, L"wb") )
    return 0;
  fwrite(pBuffer, 1u, dwSize, pFile);
  fclose(pFile);
  return 1;
}

//----- (00FB2F50) --------------------------------------------------------
BOOL __cdecl CDriver::OpenEx(const WCHAR *lpszDriverName, WCHAR *lpszPathName, PHANDLE DriverHandle)
{
  BOOL result; // eax
  HMODULE v4; // eax
  FARPROC RtlInitUnicodeString; // eax
  HMODULE v6; // eax
  WCHAR *v7; // esi
  DWORD (__stdcall *v8)(LONG); // eax
  HMODULE v9; // eax
  DWORD v10; // eax
  HANDLE v11; // eax
  UNICODE_STRING strKeyName; // [esp+8h] [ebp-A40h]
  WCHAR *lpszPathName_1; // [esp+10h] [ebp-A38h]
  HKEY hKey; // [esp+14h] [ebp-A34h]
  DWORD dwValue; // [esp+18h] [ebp-A30h]
  WCHAR szSubKeyName[260]; // [esp+1Ch] [ebp-A2Ch]
  WCHAR szBuffer[260]; // [esp+224h] [ebp-824h]
  WCHAR FileName[260]; // [esp+42Ch] [ebp-61Ch]
  WCHAR pszBuffer[260]; // [esp+634h] [ebp-414h]
  WCHAR szKeyName[260]; // [esp+83Ch] [ebp-20Ch]

  lpszPathName_1 = lpszPathName;
  TmAdjustPrivilege(L"SeLoadDriverPrivilege");
  swprintf(szKeyName, L"System\\CurrentControlSet\\Services\\%s", lpszDriverName);
  if ( RegCreateKeyW(HKEY_LOCAL_MACHINE, szKeyName, &hKey) )
    return 0;
  dwValue = 1;
  RegSetValueExW(hKey, L"Type", 0, REG_DWORD, &dwValue, 4u);
  dwValue = 1;
  RegSetValueExW(hKey, L"ErrorControl", 0, REG_DWORD, &dwValue, 4u);
  dwValue = 3;
  RegSetValueExW(hKey, L"Start", 0, REG_DWORD, &dwValue, 4u);
  swprintf(szBuffer, L"\\??\\%s", lpszPathName_1);
  RegSetValueExW(hKey, L"ImagePath", 0, REG_SZ, szBuffer, 2 * wcslen(szBuffer));
  RegCloseKey(hKey);
  v4 = GetModuleHandleW(L"ntdll.dll");
  lpszPathName_1 = GetProcAddress(v4, "NtLoadDriver");
  swprintf(szSubKeyName, L"\\Registry\\Machine\\System\\CurrentControlSet\\Services\\%s", lpszDriverName);
  RtlInitUnicodeString = *gpfnRtlInitUnicodeString;
  if ( !*gpfnRtlInitUnicodeString )
  {
    v6 = GetModuleHandleW(L"ntdll.dll");
    RtlInitUnicodeString = GetProcAddress(v6, "RtlInitUnicodeString");
    *gpfnRtlInitUnicodeString = RtlInitUnicodeString;
  }
  (RtlInitUnicodeString)(&strKeyName, szSubKeyName);
  lpszPathName_1 = (lpszPathName_1)(&strKeyName);
  swprintf(pszBuffer, L"%s\\Enum", szKeyName);
  RegDeleteKeyW(HKEY_LOCAL_MACHINE, pszBuffer);
  swprintf(pszBuffer, L"%s\\Security", szKeyName);
  RegDeleteKeyW(HKEY_LOCAL_MACHINE, pszBuffer);
  RegDeleteKeyW(HKEY_LOCAL_MACHINE, szKeyName);
  v7 = lpszPathName_1;
  if ( lpszPathName_1 && lpszPathName_1 != STATUS_IMAGE_ALREADY_LOADED )
  {
    v8 = gpfnRtlNtStatusToDosError;
    if ( !gpfnRtlNtStatusToDosError )
    {
      v9 = GetModuleHandleW(L"ntdll.dll");
      v8 = GetProcAddress(v9, "RtlNtStatusToDosError");
      gpfnRtlNtStatusToDosError = v8;
    }
    v10 = v8(v7);
    SetLastError(v10);
    result = 0;
  }
  else
  {
    swprintf(FileName, L"\\\\.\\%s", lpszDriverName);
    v11 = CreateFileW(FileName, GENERIC_WRITE|GENERIC_READ, 0, 0, OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, 0);
    *DriverHandle = v11;
    if ( v11 == -1 )
    {
      swprintf(FileName, L"\\\\.\\Global\\%s", lpszDriverName);
      *DriverHandle = CreateFileW(FileName, GENERIC_WRITE|GENERIC_READ, 0, 0, OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, 0);
    }
    result = *DriverHandle + 1 != 0;
  }
  return result;
}

//----- (00FB3260) --------------------------------------------------------
BOOL __cdecl CDriver::Open(const WCHAR *lpszDriverName, PHANDLE DriverHandle)
{
  HANDLE Handle; // eax
  WCHAR szFileName[260]; // [esp+8h] [ebp-20Ch]

  swprintf(szFileName, L"\\\\.\\%s", lpszDriverName);
  Handle = CreateFileW(szFileName, GENERIC_WRITE|GENERIC_READ, 0, 0, OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, 0);
  *DriverHandle = Handle;
  if ( Handle == INVALID_HANDLE_VALUE )
  {
    swprintf(szFileName, L"\\\\.\\Global\\%s", lpszDriverName);
    *DriverHandle = CreateFileW(szFileName, GENERIC_WRITE|GENERIC_READ, 0, 0, OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, 0);
  }
  return *DriverHandle + 1 != 0;
}

//----- (00FB3310) --------------------------------------------------------
_DWORD *__stdcall sub_FB3310(_DWORD *a1, _DWORD *a2, _DWORD *a3)
{
  _DWORD *result; // eax

  result = sub_FB4360(a1, a2);
  if ( result != -8 )
  {
    result[2] = *a3;
    result[3] = a3[1];
  }
  return result;
}

//----- (00FB3340) --------------------------------------------------------
char __cdecl sub_FB3340(HANDLE ProcessHandle, int a2, int a3, int time, int time_4, tagTREEVIEWLISTITEMPARAM *pItemParam, WPARAM wParam)
{
  tagTREEVIEWLISTITEMPARAM *pItemParam_1; // ecx
  unsigned int v8; // edi
  std__list_node_for_AdapterLuid *_Node; // esi
  int v10; // ebx
  ULONG NodeIndex; // ebx
  signed int fDone; // edi
  int v13; // eax
  HANDLE ProcessHandle_1; // ebx
  ULONG NbSegmentIndex; // edi
  ULONG v16; // eax
  int v17; // esi
  int v18; // edx
  int v19; // eax
  float v20; // xmm2_4
  float v21; // xmm0_4
  float v22; // ST4C_4
  float v23; // ST40_4
  float v24; // xmm0_4
  HWND hWndTreeListView; // ST14_4
  bool v26; // al
  char v27; // ST57_1
  HWND v28; // ST14_4
  unsigned __int8 v29; // al
  char v30; // ST57_1
  float v31; // xmm0_4
  HWND v32; // ST14_4
  unsigned __int8 v33; // al
  char v34; // ST57_1
  float v35; // xmm0_4
  HWND v36; // ST14_4
  unsigned __int8 v37; // al
  char v38; // ST57_1
  float v39; // xmm0_4
  int v41; // [esp+24h] [ebp-FD0h]
  unsigned int NodeSum; // [esp+28h] [ebp-FCCh]
  int CommitLimitSum; // [esp+2Ch] [ebp-FC8h]
  ULONG NodeCount; // [esp+38h] [ebp-FBCh]
  int v45; // [esp+3Ch] [ebp-FB8h]
  int v46; // [esp+40h] [ebp-FB4h]
  int NbSegmentsSum; // [esp+44h] [ebp-FB0h]
  char v48; // [esp+4Fh] [ebp-FA5h]
  _D3DKMT_QUERYSTATISTICS Statistics3; // [esp+50h] [ebp-FA4h]
  _D3DKMT_QUERYSTATISTICS Statistics2; // [esp+370h] [ebp-C84h]
  _D3DKMT_QUERYSTATISTICS Statistics4; // [esp+690h] [ebp-964h]
  _D3DKMT_QUERYSTATISTICS Statistics5; // [esp+9B0h] [ebp-644h]
  _D3DKMT_QUERYSTATISTICS Statistics1; // [esp+CD0h] [ebp-324h]

  pItemParam_1 = pItemParam;
  v48 = 0;
  v8 = 0;
  _Node = gAdapterLuidList._Mypair._Myval2._Myhead->_Next;
  v10 = 0;
  NodeSum = 0;
  v46 = 0;
  v45 = 0;
  v41 = 0;
  if ( gAdapterLuidList._Mypair._Myval2._Myhead->_Next == gAdapterLuidList._Mypair._Myval2._Myhead )
  {
    v17 = 0;
  }
  else
  {
    CommitLimitSum = 0;
    NbSegmentsSum = 0;
    do
    {
      memset(&Statistics1, 0, sizeof(_D3DKMT_QUERYSTATISTICS));
      Statistics1.Type = 0;
      Statistics1.AdapterLuid.LowPart = _Node->_Myval.LowPart;
      Statistics1.AdapterLuid.HighPart = _Node->_Myval.HighPart;
      if ( !D3DKMTQueryStatistics(&Statistics1) )
      {
        NodeIndex = 0;
        NodeCount = Statistics1.QueryResult.AdapterInformation.NodeCount;
        if ( Statistics1.QueryResult.AdapterInformation.NodeCount )
        {
          fDone = 1;
          do
          {
            memset(&Statistics2, 0, sizeof(_D3DKMT_QUERYSTATISTICS));
            Statistics2.Type = D3DKMT_QUERYSTATISTICS_PROCESS_NODE;
            Statistics2.AdapterLuid.LowPart = _Node->_Myval.LowPart;
            Statistics2.AdapterLuid.HighPart = _Node->_Myval.HighPart;
            Statistics2.hProcess = ProcessHandle;
            Statistics2.QuerySegment.SegmentId = NodeIndex;
            if ( !D3DKMTQueryStatistics(&Statistics2) && fDone & gConfig.dwGpuNodeUsageMask )
            {
              ++NodeSum;
              v13 = (Statistics2.QueryResult.SegmentInformation.CommitLimit + __PAIR__(CommitLimitSum, NbSegmentsSum)) >> 32;
              NbSegmentsSum += Statistics2.QueryResult.AdapterInformation.NbSegments;
              CommitLimitSum = v13;
            }
            ++NodeIndex;
            fDone = __ROL4__(fDone, 1);
          }
          while ( NodeIndex < NodeCount );
        }
        if ( v48 )
        {
          ProcessHandle_1 = ProcessHandle;
        }
        else
        {
          memset(&Statistics3, 0, sizeof(_D3DKMT_QUERYSTATISTICS));
          ProcessHandle_1 = ProcessHandle;
          Statistics3.Type = D3DKMT_QUERYSTATISTICS_PROCESS;
          Statistics3.hProcess = ProcessHandle;
          Statistics3.AdapterLuid.LowPart = _Node->_Myval.LowPart;
          Statistics3.AdapterLuid.HighPart = _Node->_Myval.HighPart;
          if ( !D3DKMTQueryStatistics(&Statistics3) )
          {
            v41 = Statistics3.QueryResult.AdapterInformation.VidPnSourceCount >> 10;
            v48 = 1;
          }
        }
        NbSegmentIndex = 0;
        if ( Statistics1.QueryResult.AdapterInformation.NbSegments )
        {
          do
          {
            memset(&Statistics4, 0, sizeof(_D3DKMT_QUERYSTATISTICS));
            Statistics4.Type = D3DKMT_QUERYSTATISTICS_PROCESS_SEGMENT;
            Statistics4.hProcess = ProcessHandle_1;
            Statistics4.AdapterLuid.LowPart = _Node->_Myval.LowPart;
            Statistics4.AdapterLuid.HighPart = _Node->_Myval.HighPart;
            Statistics4.QuerySegment.SegmentId = NbSegmentIndex;
            if ( D3DKMTQueryStatistics(&Statistics4) )
              goto __Next;
            memset(&Statistics5, 0, sizeof(_D3DKMT_QUERYSTATISTICS));
            Statistics5.Type = D3DKMT_QUERYSTATISTICS_SEGMENT;
            Statistics5.AdapterLuid.LowPart = _Node->_Myval.LowPart;
            Statistics5.AdapterLuid.HighPart = _Node->_Myval.HighPart;
            Statistics5.QuerySegment.SegmentId = NbSegmentIndex;
            if ( D3DKMTQueryStatistics(&Statistics5) )
              goto __Next;
            v16 = Statistics4.QueryResult.AdapterInformation.NbSegments >> 10;
            if ( gdwVersion < 3 )
            {
              if ( Statistics5.QueryResult.SegmentInformationV1.Aperture )
              {
LABEL_22:
                v45 += v16;
                goto __Next;
              }
              v46 += v16;
            }
            else
            {
              if ( Statistics5.QueryResult.AdapterInformation.ReferenceDmaBuffer.NbCall )
                goto LABEL_22;
              v46 += v16;
            }
__Next:
            ++NbSegmentIndex;
          }
          while ( NbSegmentIndex < Statistics1.QueryResult.AdapterInformation.NbSegments );
        }
      }
      _Node = _Node->_Next;
    }
    while ( _Node != gAdapterLuidList._Mypair._Myval2._Myhead );
    v8 = NodeSum;
    v10 = CommitLimitSum;
    v17 = NbSegmentsSum;
    pItemParam_1 = pItemParam;
  }
  v18 = pItemParam_1->field_578;
  v19 = pItemParam_1->field_57C;
  if ( v17 != v18 || v10 != v19 )
  {
    v21 = (__PAIR__(v10, v17) - __PAIR__(v19, v18));
    v22 = v21;
    v23 = v8;
    v24 = __PAIR__(a3, a2);
    v20 = (v22 / (v23 * v24)) * 100.0;
    if ( v20 >= 0.0 )
    {
      if ( v20 > 100.0 )
        v20 = 100.0;
    }
    else
    {
      v20 = 0.0;
    }
  }
  else
  {
    v20 = 0.0;
  }
  pItemParam->field_578 = v17;
  pItemParam->field_57C = v10;
  hWndTreeListView = ghWndTreeListView;
  v26 = sub_FFF8F0(v20, &pItemParam->field_568);
  v27 = RedrawColumn(v26, hWndTreeListView, 1650, wParam);
  CGraphData_Update(pItemParam->pGraphData4, __PAIR__(time_4, time), *&pItemParam->field_568, 0.0, 0);
  v28 = ghWndTreeListView;
  v29 = sub_FFF920(v41, 0, &pItemParam->field_5A0);
  v30 = RedrawColumn(v29, v28, 1653, wParam) | v27;
  v31 = *&pItemParam->field_5A0;
  CGraphData_Update(pItemParam->pGraphData5, __PAIR__(time_4, time), v31, 0.0, 0);
  v32 = ghWndTreeListView;
  v33 = sub_FFF920(v45, 0, &pItemParam->field_580);
  v34 = RedrawColumn(v33, v32, 1651, wParam) | v30;
  v35 = *&pItemParam->field_580;
  CGraphData_Update(pItemParam->pGraphData6, __PAIR__(time_4, time), v35, 0.0, 0);
  v36 = ghWndTreeListView;
  v37 = sub_FFF920(v46, 0, &pItemParam->field_590);
  v38 = RedrawColumn(v37, v36, 1652, wParam) | v34;
  v39 = *&pItemParam->field_590;
  CGraphData_Update(pItemParam->pGraphData7, __PAIR__(time_4, time), v39, 0.0, 0);
  return v38;
}
// 103CDC0: using guessed type double db_onehundred;
// 1064E54: using guessed type int gdwVersion;

//----- (00FB38F0) --------------------------------------------------------
void __cdecl sub_FB38F0(FILETIME time, signed __int64 a2, int a3, int a4, int a5, CGraphData *a6, CGraphData *a7)
{
  unsigned int v7; // ecx
  unsigned int v8; // ebx
  std__list_node *v9; // esi
  unsigned int v10; // edi
  ULONG v11; // edi
  signed int v12; // ebx
  int v13; // eax
  bool v14; // zf
  ULONG v15; // ebx
  ULONG v16; // edi
  float v17; // xmm0_4
  float v18; // ST64_4
  float v19; // xmm0_4
  float v20; // xmm1_4
  int v21; // edi
  ULONG v22; // edi
  unsigned int v23; // eax
  ULONG v24; // ecx
  ULONG v25; // eax
  float v26; // xmm0_4
  float v27; // ST7C_4
  float v28; // ST58_4
  float v29; // xmm0_4
  float v30; // xmm0_4
  wchar_t *v31; // eax
  float v32; // xmm1_4
  float v33; // xmm1_4
  __int64 ArgList_4; // [esp+10h] [ebp-11D4h]
  int a5_4; // [esp+18h] [ebp-11CCh]
  int v36; // [esp+1Ch] [ebp-11C8h]
  ULONG v37; // [esp+38h] [ebp-11ACh]
  unsigned int v38; // [esp+40h] [ebp-11A4h]
  signed int v39; // [esp+48h] [ebp-119Ch]
  unsigned int v40; // [esp+50h] [ebp-1194h]
  ULONG v41; // [esp+58h] [ebp-118Ch]
  unsigned int v42; // [esp+5Ch] [ebp-1188h]
  unsigned int v43; // [esp+68h] [ebp-117Ch]
  unsigned int v44; // [esp+6Ch] [ebp-1178h]
  unsigned int v45; // [esp+70h] [ebp-1174h]
  int v46; // [esp+74h] [ebp-1170h]
  unsigned int v47; // [esp+78h] [ebp-116Ch]
  int v48; // [esp+7Ch] [ebp-1168h]
  float v49; // [esp+7Ch] [ebp-1168h]
  _D3DKMT_QUERYSTATISTICS v50; // [esp+80h] [ebp-1164h]
  _D3DKMT_QUERYSTATISTICS v51; // [esp+3A0h] [ebp-E44h]
  _D3DKMT_QUERYSTATISTICS v52; // [esp+6C0h] [ebp-B24h]
  wchar_t Dst; // [esp+9E0h] [ebp-804h]
  char v54; // [esp+9E2h] [ebp-802h]

  v40 = 0;
  Dst = 0;
  v46 = 0;
  memset(&v54, 0, 0x7FEu);
  v7 = 0;
  v8 = 0;
  v9 = gAdapterLuidList._Mypair._Myval2._Myhead->_Next;
  v10 = 0;
  v42 = 0;
  if ( gAdapterLuidList._Mypair._Myval2._Myhead->_Next == gAdapterLuidList._Mypair._Myval2._Myhead )
  {
    v43 = 0;
    v44 = 0;
    v49 = 0.0;
  }
  else
  {
    v45 = 0;
    v43 = 0;
    v44 = 0;
    v38 = 0;
    v47 = 0;
    do
    {
      memset(&v51, 0, 0x320u);
      v51.Type = 0;
      v51.AdapterLuid.LowPart = v9->_Myval;
      v51.AdapterLuid.HighPart = v9[1]._Next;
      if ( !D3DKMTQueryStatistics(&v51) )
      {
        v11 = 0;
        v41 = v51.QueryResult.AdapterInformation.NodeCount;
        v37 = 0;
        if ( v51.QueryResult.AdapterInformation.NodeCount )
        {
          v12 = 1;
          v39 = 1;
          v13 = a5 + 2184 + 2200 * v46;
          v46 += v51.QueryResult.NodeInformation.GlobalInformation.RunningTime.HighPart;
          v48 = v13;
          do
          {
            memset(&v50, 0, 0x320u);
            v50.Type = 5;
            v50.AdapterLuid.LowPart = v9->_Myval;
            v50.AdapterLuid.HighPart = v9[1]._Next;
            v50.QuerySegment.SegmentId = v11;
            if ( D3DKMTQueryStatistics(&v50) )
            {
              v15 = 0;
              v16 = 0;
            }
            else
            {
              v14 = (v12 & gConfig.dwGpuNodeUsageMask) == 0;
              v15 = v50.QueryResult.AdapterInformation.NodeCount;
              v16 = v50.QueryResult.AdapterInformation.NbSegments;
              if ( !v14 )
              {
                ++v40;
                v42 = (v50.QueryResult.SegmentInformation.CommitLimit + __PAIR__(v42, v45)) >> 32;
                v45 += v50.QueryResult.AdapterInformation.NbSegments;
              }
            }
            if ( a5 )
            {
              if ( v15 | v16 && *v48 )
              {
                v17 = (__PAIR__(v15, v16) - *v48);
                v18 = v17;
                v19 = a2;
                v20 = (v18 / v19) * 100.0;
              }
              else
              {
                v20 = 0.0;
              }
              if ( v20 > 100.0 )
                v20 = 100.0;
              *v48 = v16;
              v21 = v48;
              *(v48 + 4) = v15;
              CGraphData_Update((v48 - 2184), time, v20, 0.0, 0);
            }
            else
            {
              v21 = v48;
            }
            v48 = v21 + 2200;
            v11 = v37 + 1;
            v12 = __ROL4__(v39, 1);
            v37 = v11;
            v39 = __ROL4__(v39, 1);
          }
          while ( v11 < v41 );
          v8 = v38;
        }
        v22 = 0;
        if ( v51.QueryResult.AdapterInformation.NbSegments )
        {
          do
          {
            memset(&v52, 0, 0x320u);
            v52.Type = 3;
            v52.AdapterLuid.LowPart = v9->_Myval;
            v52.AdapterLuid.HighPart = v9[1]._Next;
            v52.QuerySegment.SegmentId = v22;
            if ( !D3DKMTQueryStatistics(&v52) )
            {
              if ( gdwVersion < 3 )
              {
                v25 = v52.QueryResult.AdapterInformation.VidPnSourceCount >> 10;
                if ( v52.QueryResult.SegmentInformationV1.Aperture )
                {
                  v43 = (v25 + __PAIR__(v43, v44)) >> 32;
                  v44 += v25;
                }
                else
                {
                  v8 = (v25 + __PAIR__(v8, v47)) >> 32;
                  v47 += v25;
                }
              }
              else
              {
                v23 = v52.QueryResult.SegmentInformationV1.Memory.TotalBytesEvicted >> 10;
                v24 = v52.QueryResult.NodeInformation.GlobalInformation.PreemptionStatistics.PreemptionCounter[2] >> 10;
                if ( v52.QueryResult.AdapterInformation.ReferenceDmaBuffer.NbCall )
                {
                  v43 = (__PAIR__(v24, v23) + __PAIR__(v43, v44)) >> 32;
                  v44 += v23;
                }
                else
                {
                  v8 = (__PAIR__(v24, v23) + __PAIR__(v8, v47)) >> 32;
                  v47 += v23;
                }
              }
            }
            ++v22;
          }
          while ( v22 < v51.QueryResult.AdapterInformation.NbSegments );
          v38 = v8;
        }
      }
      v9 = v9->_Next;
    }
    while ( v9 != gAdapterLuidList._Mypair._Myval2._Myhead );
    if ( v42 | v45 && *(a3 + 2184) )
    {
      v26 = (__PAIR__(v42, v45) - *(a3 + 2184));
      v27 = v26;
      v28 = v40;
      v29 = a2;
      v30 = (v27 / (v28 * v29)) * 100.0;
      v49 = v30;
      if ( v30 <= 100.0 )
      {
        if ( v30 < 0.0 )
          v49 = 0.0;
      }
      else
      {
        v49 = 100.0;
      }
      v10 = v47;
      v7 = v45;
    }
    else
    {
      v7 = v45;
      v10 = v47;
      v49 = 0.0;
    }
  }
  *(a3 + 2184) = v7;
  *(a3 + 2188) = v42;
  if ( a4 )
  {
    v36 = *(a4 + 68);
    a5_4 = *(a4 + 60);
    ArgList_4 = *(a4 + 1384);
    if ( gConfig.bShowCpuFractions )
      wsprintfW(&Dst, L"%02.02f%% %s:%d", ArgList_4, a5_4, v36);
    else
      wsprintfW(&Dst, L"%02.0f%% %s:%d", ArgList_4, a5_4, v36);
  }
  v31 = &Dst;
  if ( !a4 )
    v31 = 0;
  CGraphData_Update(a3, time, v49, 0.0, v31);
  v32 = __PAIR__(v43, v44);
  if ( v32 > a6->m_dbMemorySize )
    a6->m_dbMemorySize = (v32 * 1.2);
  CGraphData_Update(a6, time, v32, 0.0, 0);
  v33 = __PAIR__(v8, v10);
  if ( v33 > a6->m_dbMemorySize )
    a7->m_dbMemorySize = (v33 * 1.2);
  CGraphData_Update(a7, time, v33, 0.0, 0);
}
// 103CDC0: using guessed type double db_onehundred;
// 1064E54: using guessed type int gdwVersion;

//----- (00FB3FB0) --------------------------------------------------------
BOOL __cdecl Init3DStatistics(unsigned __int64 *a1, unsigned __int64 *a2)
{
  HMODULE v2; // eax
  HMODULE v3; // eax
  HMODULE v4; // eax
  HDEVINFO v5; // edi
  DWORD v6; // ebx
  struct _SP_DEVICE_INTERFACE_DETAIL_DATA_W *pData; // edi
  std__list_node *v8; // ebx
  std__list_node *v9; // eax
  unsigned int v10; // edi
  _DWORD *v11; // ebx
  signed int v12; // edi
  unsigned int v13; // edx
  ULONG v14; // eax
  unsigned __int64 *v15; // ebx
  int v16; // edx
  ULONG v17; // ecx
  char v18; // al
  D3DKMT_OPENADAPTERFROMDEVICENAME DeviceName; // [esp+Ch] [ebp-68Ch]
  HDEVINFO DeviceInfoSet; // [esp+1Ch] [ebp-67Ch]
  unsigned __int64 *v22; // [esp+20h] [ebp-678h]
  unsigned int v23; // [esp+24h] [ebp-674h]
  struct _SP_DEVICE_INTERFACE_DETAIL_DATA_W *v24; // [esp+28h] [ebp-670h]
  DWORD v25; // [esp+2Ch] [ebp-66Ch]
  DWORD RequiredSize; // [esp+30h] [ebp-668h]
  char v27; // [esp+37h] [ebp-661h]
  _D3DKMT_QUERYSTATISTICS StatisticsAdapter; // [esp+38h] [ebp-660h]
  _D3DKMT_QUERYSTATISTICS StatisticsSegment; // [esp+358h] [ebp-340h]
  struct _SP_DEVICE_INTERFACE_DATA DeviceInterfaceData; // [esp+678h] [ebp-20h]

  *a2 = 0i64;
  v22 = a1;
  *a1 = 0i64;
  v2 = LoadLibraryW(L"gdi32.dll");
  D3DKMTOpenAdapterFromDeviceName = GetProcAddress(v2, "D3DKMTOpenAdapterFromDeviceName");
  v3 = LoadLibraryW(L"gdi32.dll");
  D3DKMTCloseAdapter = GetProcAddress(v3, "D3DKMTCloseAdapter");
  v4 = LoadLibraryW(L"gdi32.dll");
  D3DKMTQueryStatistics = GetProcAddress(v4, "D3DKMTQueryStatistics");
  if ( D3DKMTOpenAdapterFromDeviceName )
  {
    DeviceInterfaceData.Reserved = 0;
    v5 = SetupDiGetClassDevsW(&CLSID_GUID_DISPLAY_DEVICE_ARRIVAL, 0, 0, 0x12u);
    *&DeviceInterfaceData.InterfaceClassGuid.Data4[4] = 0i64;
    v6 = 0;
    DeviceInfoSet = v5;
    _mm_storeu_si128(&DeviceInterfaceData, 0i64);
    DeviceInterfaceData.cbSize = 28;
    v27 = 0;
    v25 = 0;
    do
    {
      if ( SetupDiEnumDeviceInterfaces(v5, 0, &CLSID_GUID_DISPLAY_DEVICE_ARRIVAL, v6, &DeviceInterfaceData) )
      {
        RequiredSize = 0;
        if ( SetupDiGetDeviceInterfaceDetailW(v5, &DeviceInterfaceData, 0, 0, &RequiredSize, 0) || GetLastError() == 122 )
        {
          pData = operator new[](RequiredSize);
          v24 = pData;
          memset(pData, 0, RequiredSize);
          pData->cbSize = 6;
          SetupDiGetDeviceInterfaceDetailW(DeviceInfoSet, &DeviceInterfaceData, pData, RequiredSize, 0, 0);
          _mm_storeu_si128(&DeviceName, 0i64);
          DeviceName.pDeviceName = pData->DevicePath;
          if ( !D3DKMTOpenAdapterFromDeviceName(&DeviceName) )
          {
            memset(&StatisticsAdapter, 0, sizeof(_D3DKMT_QUERYSTATISTICS));
            StatisticsAdapter.AdapterLuid.LowPart = DeviceName.AdapterLuid.LowPart;
            StatisticsAdapter.AdapterLuid.HighPart = DeviceName.AdapterLuid.HighPart;
            StatisticsAdapter.Type = 0;
            if ( !D3DKMTQueryStatistics(&StatisticsAdapter) )
              gdwAdapterRuntingTime += StatisticsAdapter.QueryResult.NodeInformation.GlobalInformation.RunningTime.HighPart;
            v8 = gAdapterLuidList._Mypair._Myval2._Myhead;
            v9 = sub_FB3310(
                   &gAdapterLuidList._Mypair._Myval2._Myhead->_Next,
                   &gAdapterLuidList._Mypair._Myval2._Myhead->_Prev->_Next,
                   &DeviceName.AdapterLuid.LowPart);
            if ( 0xFFFFFFE - gAdapterLuidList._Mypair._Myval2._Mysize < 1 )
              std::_Xlength_error("list<T> too long");
            ++gAdapterLuidList._Mypair._Myval2._Mysize;
            v8->_Prev = v9;
            v9->_Prev->_Next = v9;
            v10 = 0;
            v23 = 0;
            if ( StatisticsAdapter.QueryResult.AdapterInformation.NbSegments )
            {
              do
              {
                memset(&StatisticsSegment, 0, sizeof(_D3DKMT_QUERYSTATISTICS));
                StatisticsSegment.AdapterLuid.LowPart = DeviceName.AdapterLuid.LowPart;
                StatisticsSegment.AdapterLuid.HighPart = DeviceName.AdapterLuid.HighPart;
                StatisticsSegment.Type = D3DKMT_QUERYSTATISTICS_SEGMENT;
                StatisticsSegment.QuerySegment.SegmentId = v10;
                if ( !D3DKMTQueryStatistics(&StatisticsSegment) )
                {
                  if ( gdwVersion < 3 )
                  {
                    v14 = StatisticsSegment.QueryResult.AdapterInformation.NbSegments >> 10;
                    if ( StatisticsSegment.QueryResult.SegmentInformationV1.Aperture )
                    {
                      v15 = v22;
                      v16 = *(v22 + 1);
                      v17 = *v22;
                      if ( v16 < 0 || v16 <= 0 && v17 <= v14 )
                      {
                        v17 = StatisticsSegment.QueryResult.AdapterInformation.NbSegments >> 10;
                        v16 = 0;
                      }
                      *v22 = v17;
                      *(v15 + 1) = v16;
                    }
                    else
                    {
                      *a2 += v14;
                    }
                  }
                  else if ( StatisticsSegment.QueryResult.AdapterInformation.ReferenceDmaBuffer.NbCall )
                  {
                    v11 = v22;
                    v12 = *(v22 + 1);
                    v13 = *v22;
                    if ( v12 < (StatisticsSegment.QueryResult.AdapterInformation.NodeCount >> 10)
                      || v12 <= (StatisticsSegment.QueryResult.AdapterInformation.NodeCount >> 10)
                      && v13 <= (StatisticsSegment.QueryResult.SegmentInformation.CommitLimit >> 10) )
                    {
                      v13 = StatisticsSegment.QueryResult.SegmentInformation.CommitLimit >> 10;
                      v12 = StatisticsSegment.QueryResult.AdapterInformation.NodeCount >> 10;
                    }
                    *(v22 + 1) = v12;
                    v10 = v23;
                    *v11 = v13;
                  }
                  else
                  {
                    *a2 += StatisticsSegment.QueryResult.SegmentInformation.CommitLimit >> 10;
                  }
                }
                v23 = ++v10;
              }
              while ( v10 < StatisticsAdapter.QueryResult.AdapterInformation.NbSegments );
            }
            pData = v24;
            v6 = v25;
          }
          j_j__free(pData);
          v5 = DeviceInfoSet;
        }
        v18 = v27;
      }
      else
      {
        v18 = 1;
        v27 = 1;
      }
      v25 = ++v6;
    }
    while ( !v18 );
    SetupDiDestroyDeviceInfoList(v5);
  }
  return gdwAdapterRuntingTime != 0;
}
// 1064E38: using guessed type int D3DKMTCloseAdapter;
// 1064E54: using guessed type int gdwVersion;

//----- (00FB4360) --------------------------------------------------------
_DWORD *__stdcall sub_FB4360(_DWORD *a1, _DWORD *a2)
{
  _DWORD *result; // eax
  _DWORD *v3; // ecx
  _DWORD *v4; // edx

  result = operator new(0x10u);
  if ( !result )
    std::_Xbad_alloc();
  v3 = a1;
  if ( a1 )
  {
    v4 = a2;
  }
  else
  {
    v3 = result;
    v4 = result;
  }
  *result = v3;
  if ( result != -4 )
    result[1] = v4;
  return result;
}

//----- (00FB43A0) --------------------------------------------------------
CGraphData *__thiscall sub_FB43A0(tagGraphInfo *pThis)
{
  tagGraphInfo *this; // esi
  CGraphData *pGraphData; // eax
  UINT v3; // ecx
  CGraphData *result; // eax

  this = pThis;
  pGraphData = InitGraphData(1, 2, 1);
  v3 = this->nItemID;
  this->pGraphData = pGraphData;
  pGraphData->m_nItemID = v3;
  this->pGraphData->m_dbMemorySize = db_onehundred;
  this->pGraphData->m_Buffer2 = 1;
  this->pGraphData->m_Color = 0xC83C1E;
  this->pGraphData->m_Item[0].nItemID = this->nItemID;
  this->pGraphData->m_Item[0].dbMemorySize = db_onehundred;
  result = this->pGraphData;
  result->m_Item[0].Color = 0xC83CC8;
  return result;
}
// 103CDC0: using guessed type double db_onehundred;

//----- (00FB4400) --------------------------------------------------------
signed __int64 __thiscall GraphInfo_Refresh(tagGraphInfo *pGrahInfo_1)
{
  int nIndex; // edx
  tagGraphInfo *pGrahInfo; // esi
  int i; // ecx
  CGraphData *pGraphData; // edi
  double v5; // xmm0_8
  signed int nChild; // edx
  signed int v7; // ecx
  signed __int64 result; // rax

  nIndex = 0;
  pGrahInfo = pGrahInfo_1;
  pGrahInfo_1->pGraphData->m_dbMemorySize = db_one;
  for ( i = gdwVirtualScreenWidth; nIndex < i; ++nIndex )
  {
    pGraphData = pGrahInfo->pGraphData;
    v5 = pGraphData->m_Item[0].pBuffer[nIndex];
    if ( v5 > pGraphData->m_dbMemorySize )
    {
      pGraphData->m_dbMemorySize = v5 * 1.200000047683716;
      i = gdwVirtualScreenWidth;
    }
  }
  nChild = 1;
  if ( pGrahInfo->pGraphData->m_nChildID > 1 )
  {
    v7 = 0x18;
    do
    {
      v7 += sizeof(tagGraphItem);
      ++nChild;
      *(&pGrahInfo->pGraphData->m_Lock.m_Lock.LockSemaphore + v7) = pGrahInfo->pGraphData->m_dbMemorySize;
    }
    while ( nChild < pGrahInfo->pGraphData->m_nChildID );
  }
  result = pGrahInfo->pGraphData->m_dbMemorySize;
  pGrahInfo->dbMemorySize = result;
  return result;
}
// 1064E28: using guessed type int gdwVirtualScreenWidth;

//----- (00FB44A0) --------------------------------------------------------
void __thiscall sub_FB44A0(tagGraphInfo *this, TreeList_Item1 *pItem)
{
  tagGraphInfo *pGraphInfo; // edi
  int v3; // esi
  __int64 v4; // kr10_8
  signed __int64 v5; // kr20_8
  float v6; // xmm0_4
  int v7; // eax
  float v8; // xmm0_4
  float v9; // xmm0_4
  __int64 v10; // ST1C_8
  float v11; // xmm0_4
  float v12; // xmm0_4
  __int64 v13; // ST1C_8
  float v14; // xmm0_4
  __int64 a5; // ST14_8
  float v16; // xmm0_4
  float v17; // xmm0_4
  __int64 v18; // ST1C_8
  float v19; // xmm0_4
  __int64 v20; // ST14_8
  float v21; // xmm0_4
  WCHAR szBuffer[1024]; // [esp+30h] [ebp-804h]

  szBuffer[0] = 0;
  pGraphInfo = this;
  memset(&szBuffer[1], 0, 2046u);
  if ( *&pItem->field_58 + *&pItem->field_50 + *&pItem->field_48 )
  {
    v3 = wsprintfW(szBuffer, L"%s:%d\n", *(pItem->field_60 + 60), *(pItem->field_60 + 68));
    sub_FB2200(
      1,
      &szBuffer[v3],
      1024 - v3,
      COERCE__INT64(*&pItem->field_50),
      COERCE__INT64(*&pItem->field_48),
      COERCE__INT64(*&pItem->field_58));
    v4 = *&pItem->field_58 + *&pItem->field_50 + *&pItem->field_48;
    if ( v4 > pGraphInfo->dbMemorySize )
      pGraphInfo->dbMemorySize = v4;
  }
  v5 = *&pItem->field_20 + *&pItem->field_18 + *&pItem->field_28;
  if ( v5 >= pGraphInfo->pGraphData->m_dbMemorySize )
  {
    v6 = v5;
    pGraphInfo->pGraphData->m_dbMemorySize = (v6 * 1.2);
    pGraphInfo->pGraphData->m_Item[0].dbMemorySize = pGraphInfo->pGraphData->m_dbMemorySize;
  }
  v7 = HIDWORD(pGraphInfo->dbMemorySize) | LODWORD(pGraphInfo->dbMemorySize);
  if ( !pGraphInfo->dbMemorySize )
  {
    LODWORD(pGraphInfo->dbMemorySize) = 1;
    HIDWORD(pGraphInfo->dbMemorySize) = v7;
  }
  v8 = pGraphInfo->dbMemorySize;
  pGraphInfo->pGraphData->m_dbMemorySize = v8;
  pGraphInfo->pGraphData->m_Item[0].dbMemorySize = pGraphInfo->pGraphData->m_dbMemorySize;
  CGraphData_Update(
    pGraphInfo->pGraphData,
    gTimeQuerySystemInfo,
    (*&pItem->field_20 + *&pItem->field_18 + *&pItem->field_28),
    *&pItem->field_18,
    szBuffer);
  if ( pGraphInfo == &gIOGraphInfo )
  {
    v9 = *&pItem->field_28;
    *&v10 = v9;
    v11 = *&pItem->field_20;
    sub_1000130(pGraphInfo->pGraphData, pItem->field_60, COERCE__INT64(*&pItem->field_18), *&v11, v10);
  }
  else if ( pGraphInfo == &gDiskGraphInfo )
  {
    v12 = *&pItem->field_28;
    *&v13 = v12;
    v14 = *&pItem->field_20;
    *&a5 = v14;
    v16 = *&pItem->field_18;
    sub_1000010(pGraphInfo->pGraphData, pItem->field_60, *&v16, a5, v13);
  }
  else if ( pGraphInfo == &gNetworkGraphInfo )
  {
    v17 = *&pItem->field_28;
    *&v18 = v17;
    v19 = *&pItem->field_20;
    *&v20 = v19;
    v21 = *&pItem->field_18;
    sub_1000250(pGraphInfo->pGraphData, pItem->field_60, *&v21, v20, v18);
  }
}

//----- (00FB47C0) --------------------------------------------------------
int __thiscall sub_FB47C0(_DWORD *this, int a2, _DWORD *a3)
{
  _DWORD *v3; // edx
  int v4; // eax
  unsigned __int8 v5; // cf
  int v6; // eax
  int v7; // eax
  int result; // eax
  int v9; // [esp+Ch] [ebp-4h]

  v3 = this;
  v3[1] += a3[4];
  *v3 += a3[12];
  v3[2] += a3[20];
  v4 = a3[14];
  v5 = __CFADD__(v4, this[6]);
  v3[6] += v4;
  v3[7] += a3[15] + v5;
  v6 = a3[6];
  v5 = __CFADD__(v6, this[8]);
  v3[8] += v6;
  v3[9] += a3[7] + v5;
  v7 = a3[22];
  v5 = __CFADD__(v7, this[10]);
  v3[10] += v7;
  v3[11] += a3[23] + v5;
  v9 = a3[15];
  result = (*(v3 + 9) + *(v3 + 11) + *(v3 + 10)) >> 32;
  if ( *(a3 + 7) + *(a3 + 11) + *(a3 + 3) > *(v3 + 9) + *(v3 + 11) + *(v3 + 10) )
  {
    this[18] = a3[14];
    this[19] = v9;
    this[20] = a3[6];
    this[21] = a3[7];
    this[22] = a3[22];
    this[23] = a3[23];
    result = a2;
    this[24] = a2;
  }
  return result;
}

//----- (00FB4870) --------------------------------------------------------
int __cdecl CMainWnd::Create(HINSTANCE hInstance, int nCmdShow)
{
  HANDLE v2; // eax
  int v3; // ST28_4
  int v4; // eax
  HWND hMainWnd; // esi
  HWND v7; // eax
  UINT showCmd; // eax
  int v9; // edi
  int v10; // edx
  LONG v11; // ecx
  LONG v12; // eax
  LONG v13; // ecx
  UINT v14; // eax
  int v15; // eax
  char v16; // cl
  WNDCLASSEXW wc; // [esp+8h] [ebp-30h]

  LoadStringW(hInstance, IDS_MAINCLASSNAME, &gszMainClassName, 9);
  LoadStringW(hInstance, IDS_MAINWINDOWNAME, &gszMainWindowName, 40);
  ghInstance = hInstance;
  InitDrawEngine();
  if ( gConfig.bAllOneInstance )
  {
    v2 = OpenEventW(SYNCHRONIZE, 0, L"ProcessExplorerElevating");
    if ( v2 )
    {
      CloseHandle(v2);
    }
    else
    {
      v7 = FindWindowW(&gszMainClassName, 0);
      if ( v7 )
      {
        PostMessageW(v7, WM_MSG_7F2, 0, 0);
        return 0;
      }
    }
  }
  if ( !OnBeforeInit() )
    return 0;
  ghWaitCursor = LoadCursorW(0, IDC_WAIT);
  wc.cbSize = 48;
  wc.style = 0;
  wc.lpfnWndProc = CMainWnd::MainWndProc;
  wc.cbClsExtra = 0;
  wc.cbWndExtra = 0;
  wc.hInstance = hInstance;
  wc.hIcon = LoadIconW(hInstance, 0x65);
  wc.hCursor = 0;
  wc.hbrBackground = 0;
  wc.lpszMenuName = L"PROCEXPLORER";
  wc.lpszClassName = &gszMainClassName;
  v3 = GetSystemMetrics(50);
  v4 = GetSystemMetrics(49);
  wc.hIconSm = LoadImageW(hInstance, 0x65, 1u, v4, v3, 0);
  if ( !RegisterClassExW(&wc) && !RegisterClassW(&wc.style) )
    return 0;
  memset(&wc, 0, sizeof(WNDCLASSEXW));
  wc.cbSize = sizeof(WNDCLASSEXW);
  wc.lpfnWndProc = CGraphWnd::ChartWndProc;
  wc.hInstance = ghInstance;
  wc.hbrBackground = CreateSolidBrush(0xFFFFFFu);
  wc.lpszClassName = L"CpuGraphClassChart";
  wc.hCursor = LoadCursorW(0, IDC_ARROW);
  RegisterClassExW(&wc);
  memset(&wc, 0, sizeof(WNDCLASSEXW));
  wc.cbSize = sizeof(WNDCLASSEXW);
  wc.lpfnWndProc = CGraphWnd::ChartWndProc;
  wc.hInstance = ghInstance;
  wc.hbrBackground = CreateSolidBrush(gConfig.ColorGraphBk);
  wc.lpszClassName = L"CpuGraphClassGraph";
  wc.hCursor = LoadCursorW(0, IDC_ARROW);
  RegisterClassExW(&wc);
  hMainWnd = CreateWindowExW(
               0,
               &gszMainClassName,
               L"Process Explorer - Sysinternals: www.sysinternals.com",
               0xCF0000u,
               0,
               0,
               780,
               550,
               0,
               0,
               hInstance,
               0);
  if ( !hMainWnd )
    return 0;
  if ( gConfig.WindowPlacement[0].length )
  {
    showCmd = gConfig.WindowPlacement[0].showCmd;
    if ( gConfig.WindowPlacement[0].showCmd == SW_MINIMIZE )
      showCmd = 1;
    if ( gbHide )
      showCmd = 0;
    gConfig.WindowPlacement[0].showCmd = showCmd;
    v9 = GetSystemMetrics(SM_CXVIRTUALSCREEN);
    if ( !v9 )
      v9 = GetSystemMetrics(SM_CXFULLSCREEN);
    v10 = GetSystemMetrics(SM_CYVIRTUALSCREEN);
    if ( !v10 )
      v10 = GetSystemMetrics(SM_CYFULLSCREEN);
    v11 = gConfig.WindowPlacement[0].rcNormalPosition.left;
    v12 = gConfig.WindowPlacement[0].rcNormalPosition.right;
    if ( gConfig.WindowPlacement[0].rcNormalPosition.left >= v9 - 10 )
      v11 = 100;
    gConfig.WindowPlacement[0].rcNormalPosition.left = v11;
    v13 = gConfig.WindowPlacement[0].rcNormalPosition.top;
    if ( gConfig.WindowPlacement[0].rcNormalPosition.right > v9 )
      v12 = v9;
    gConfig.WindowPlacement[0].rcNormalPosition.right = v12;
    if ( gConfig.WindowPlacement[0].rcNormalPosition.top >= v10 - 10 )
      v13 = 100;
    gConfig.WindowPlacement[0].rcNormalPosition.top = v13;
    if ( nCmdShow == SW_SHOWMINNOACTIVE )
    {
      v14 = gConfig.WindowPlacement[0].showCmd;
      if ( gConfig.bHideWhenMinimized )
        v14 = 0;
      gConfig.WindowPlacement[0].showCmd = v14;
    }
    SetWindowPlacement(hMainWnd, gConfig.WindowPlacement);
  }
  else
  {
    v15 = 5;
    if ( gbHide )
      v15 = 0;
    ShowWindow(hMainWnd, v15);
  }
  v16 = gbMainWndMinimized;
  if ( gbHide )
    v16 = 1;
  gbMainWndMinimized = v16;
  UpdateWindow(hMainWnd);
  return 1;
}
// 103CB88: using guessed type wchar_t aCpugraphclassc[19];
// 106A388: using guessed type char gbHide;
// 106A389: using guessed type char gbMainWndMinimized;

//----- (00FB4B90) --------------------------------------------------------
int wsprintf(wchar_t *Dst, wchar_t *Format, ...)
{
  va_list ArgList; // [esp+10h] [ebp+10h]

  va_start(ArgList, Format);
  return vswprintf_s(Dst, 0x100u, Format, ArgList);
}

//----- (00FB4BB0) --------------------------------------------------------
int MakeHandlePropSheetCaption(wchar_t *Dst, wchar_t *Format, ...)
{
  va_list ArgList; // [esp+10h] [ebp+10h]

  va_start(ArgList, Format);
  return vswprintf_s(Dst, 0x208u, Format, ArgList);
}

//----- (00FB4BD0) --------------------------------------------------------
CString *__thiscall ATL::CStringT<wchar_t,ATL::StrTraitATL<wchar_t,ATL::ChTraitsCRT<wchar_t>>>::CStringT<wchar_t,ATL::StrTraitATL<wchar_t,ATL::ChTraitsCRT<wchar_t>>>(CString *this, LPCSTR lpMultiByteStr)
{
  CString *v2; // esi
  IAtlStringMgr *v3; // ecx
  CHAR *v4; // eax

  v2 = this;
  v3 = ATL::StrTraitATL<wchar_t,ATL::ChTraitsCRT<wchar_t>>::GetDefaultManager();
  if ( !v3 )
    ATL::AtlThrowImpl(-2147467259);
  v2->pszData = ((v3->vtptr->GetNilData)() + 16);
  if ( !lpMultiByteStr || lpMultiByteStr & 0xFFFF0000 )
  {
    ATL::CStringT<wchar_t,ATL::StrTraitATL<wchar_t,ATL::ChTraitsCRT<wchar_t>>>::operator=(v2, lpMultiByteStr);
  }
  else
  {
    v4 = ATL::StrTraitATL<wchar_t,ATL::ChTraitsCRT<wchar_t>>::FindStringResourceInstance(lpMultiByteStr, 0);
    if ( v4 )
      ATL::CStringT<wchar_t,ATL::StrTraitATL<wchar_t,ATL::ChTraitsCRT<wchar_t>>>::LoadStringW(v2, v4, lpMultiByteStr);
  }
  return v2;
}

//----- (00FB4C70) --------------------------------------------------------
CString *__thiscall ATL::CStringT<wchar_t,ATL::StrTraitATL<wchar_t,ATL::ChTraitsCRT<wchar_t>>>::operator=(CString *this, LPCSTR lpMultiByteStr)
{
  CString *v2; // edi
  int v3; // esi
  CString *result; // eax

  v2 = this;
  if ( lpMultiByteStr && (v3 = MultiByteToWideChar(3u, 0, lpMultiByteStr, -1, 0, 0) - 1, v3 > 0) )
  {
    if ( ((*(v2->pszData - 2) - v3) | (1 - *(v2->pszData - 1))) < 0 )
      ATL::CSimpleStringT<wchar_t,0>::PrepareWrite2(v2, v3);
    MultiByteToWideChar(3u, 0, lpMultiByteStr, -1, v2->pszData, v3);
    if ( v3 > *(v2->pszData - 2) )
      ATL::AtlThrowImpl(E_INVALIDARG);
    *(v2->pszData - 3) = v3;
    *&v2->pszData[2 * v3] = 0;
    result = v2;
  }
  else
  {
    ATL::CSimpleStringT<wchar_t,0>::Empty(v2);
    result = v2;
  }
  return result;
}

//----- (00FB4D00) --------------------------------------------------------
int __stdcall sub_FB4D00(HDC hdc, wchar_t *Src, rsize_t SizeInWords, int a4)
{
  HANDLE v4; // eax
  wchar_t *v5; // eax
  unsigned __int16 *v6; // edi
  int v7; // esi
  HANDLE v8; // eax
  unsigned int v10; // ecx
  rsize_t v11; // esi
  HANDLE v12; // eax
  struct tagSIZE v13; // [esp+Ch] [ebp-20h]
  struct tagSIZE v14; // [esp+14h] [ebp-18h]
  struct tagSIZE v15; // [esp+1Ch] [ebp-10h]
  struct tagSIZE psizl; // [esp+24h] [ebp-8h]
  unsigned int v17; // [esp+40h] [ebp+14h]

  v17 = a4 - 4;
  v4 = GetProcessHeap();
  v5 = HeapAlloc(v4, 8u, 2 * SizeInWords);
  v6 = v5;
  if ( !v5 )
    return 0;
  wcscpy_s(v5, SizeInWords, Src);
  v7 = wcslen(v6);
  if ( !GetTextExtentPoint32W(hdc, v6, v7, &psizl) )
  {
LABEL_3:
    v8 = GetProcessHeap();
    HeapFree(v8, 0, v6);
    return 0;
  }
  if ( psizl.cx > v17 )
  {
    if ( !GetTextExtentPoint32W(hdc, L"...", wcslen(L"..."), &v15)
      || !GetTextExtentPoint32W(hdc, L"..", wcslen(L".."), &v14)
      || !GetTextExtentPoint32W(hdc, L".", wcslen(L"."), &v13) )
    {
      goto LABEL_3;
    }
    if ( v7 > 0 )
    {
      while ( 1 )
      {
        v6[--v7] = 0;
        if ( !GetTextExtentPoint32W(hdc, v6, v7, &psizl) )
          goto LABEL_3;
        v10 = v17;
        if ( psizl.cx + v15.cx <= v17 || v7 <= 0 )
          goto LABEL_15;
      }
    }
    v10 = v17;
LABEL_15:
    *v6 = *Src;
    if ( psizl.cx + v15.cx > v10 )
    {
      if ( psizl.cx + v14.cx > v10 )
      {
        if ( psizl.cx + v13.cx > v10 )
        {
          v11 = SizeInWords;
          *v6 = *Src;
        }
        else
        {
          v11 = SizeInWords;
          wcscat_s(v6, SizeInWords, L".");
        }
      }
      else
      {
        v11 = SizeInWords;
        wcscat_s(v6, SizeInWords, L"..");
      }
    }
    else
    {
      v11 = SizeInWords;
      wcscat_s(v6, SizeInWords, L"...");
    }
    wcscpy_s(Src, v11, v6);
  }
  v12 = GetProcessHeap();
  HeapFree(v12, 0, v6);
  return 1;
}

//----- (00FB4EF0) --------------------------------------------------------
signed int __cdecl sub_FB4EF0(unsigned int *a1, _DWORD *a2)
{
  unsigned int v2; // ecx
  unsigned int v3; // edx
  signed int result; // eax
  __int64 v5; // rdi
  bool v6; // zf
  bool v7; // sf
  unsigned __int8 v8; // of

  v2 = *a1;
  v3 = a1[1];
  if ( *a1 )
  {
    HIDWORD(v5) = *a2;
    LODWORD(v5) = a2[1];
    if ( !v5 )
      return 1;
    if ( HIDWORD(v5) == v2 )
    {
      v8 = __OFSUB__(v3, v5);
      v6 = v3 == v5;
      v7 = (v3 - v5) < 0;
      if ( v3 == v5 )
        return 0;
    }
    else
    {
      v8 = __OFSUB__(v3, v5);
      v6 = v3 == v5;
      v7 = (v3 - v5) < 0;
    }
    if ( !(v7 ^ v8) && (!((v7 ^ v8) | v6) || v2 > HIDWORD(v5)) )
      return 1;
    result = -1;
  }
  else if ( *a2 )
  {
    result = -1;
  }
  else
  {
    result = 0;
  }
  return result;
}

//----- (00FB4F50) --------------------------------------------------------
char __cdecl sub_FB4F50(CRegSettings *pConfig, DWORD *pdwValue, unsigned int a3)
{
  DWORD *pdwValue_1; // edx
  CRegSettings *v4; // ebx
  DWORD *v5; // esi
  CRegSettings *v6; // eoff
  volatile signed __int32 *v7; // eax
  const void *v8; // esi
  signed int v9; // ecx
  unsigned int v10; // esi
  const wchar_t **v11; // eax
  bool *v12; // edx
  const wchar_t **v13; // eax
  bool *v14; // edx
  DWORD *v15; // ecx

  pdwValue_1 = pdwValue;
  v4 = pConfig;
  v5 = pdwValue + 12;
  v6 = pConfig;
  _mm_storeu_si128(pConfig, _mm_loadu_si128((pdwValue + 1)));
  _mm_storeu_si128(&v4->WindowPlacement[0].ptMinPosition.y, _mm_loadu_si128((pdwValue_1 + 5)));
  _mm_storel_epi64(&v4->WindowPlacement[0].rcNormalPosition.top, _mm_loadl_epi64((pdwValue_1 + 9)));
  v7 = pdwValue_1[11];
  v4->WindowPlacement[0].rcNormalPosition.bottom = v7;
  qmemcpy(&v6->UnicodeFont, v5, sizeof(v6->UnicodeFont));
  v8 = pdwValue_1 + 97;
  v4->dbDivider = *(pdwValue_1 + 18);
  _mm_storeu_si128(v4->dwProcessColumns, _mm_loadu_si128((pdwValue_1 + 38)));
  _mm_storeu_si128(&v4->dwProcessColumns[8], _mm_loadu_si128((pdwValue_1 + 42)));
  _mm_storeu_si128(&v4->dwProcessColumns[16], _mm_loadu_si128((pdwValue_1 + 46)));
  _mm_storeu_si128(&v4->dwProcessColumns[24], _mm_loadu_si128((pdwValue_1 + 50)));
  _mm_storeu_si128(v4->dwHandleColumns, _mm_loadu_si128((pdwValue_1 + 54)));
  _mm_storeu_si128(&v4->dwHandleColumns[8], _mm_loadu_si128((pdwValue_1 + 58)));
  _mm_storeu_si128(&v4->dwHandleColumns[16], _mm_loadu_si128((pdwValue_1 + 62)));
  _mm_storeu_si128(&v4->dwHandleColumns[24], _mm_loadu_si128((pdwValue_1 + 66)));
  _mm_storeu_si128(v4->dwDllColumns, _mm_loadu_si128((pdwValue_1 + 70)));
  _mm_storeu_si128(&v4->dwDllColumns[8], _mm_loadu_si128((pdwValue_1 + 74)));
  _mm_storeu_si128(&v4->dwDllColumns[16], _mm_loadu_si128((pdwValue_1 + 78)));
  _mm_storeu_si128(&v4->dwDllColumns[24], _mm_loadu_si128((pdwValue_1 + 82)));
  if ( pdwValue_1[97] )
  {
    v9 = 32;
  }
  else
  {
    v8 = pdwValue_1 + 0x176;
    v9 = 64;
  }
  qmemcpy(v4->dwProcessColumnMap, v8, 4 * v9);
  qmemcpy(v4->dwDllColumnMap, pdwValue_1 + 130, sizeof(v4->dwDllColumnMap));
  qmemcpy(v4->dwIdsOfHandleColumnMap, pdwValue_1 + 163, sizeof(v4->dwIdsOfHandleColumnMap));
  v10 = a3;
  if ( a3 > 0x158 )
  {
    LOBYTE(v7) = *(pdwValue_1 + 344);
    v4->bShowUnnamedHandles = v7;
  }
  if ( v10 > 0x15C )
  {
    LOBYTE(v7) = *(pdwValue_1 + 348);
    v4->bShowDllView = v7;
  }
  if ( v10 > 0x160 )
  {
    v7 = pdwValue_1[88];
    v4->dwHandleSortColumn = v7;
  }
  if ( v10 > 0x164 )
  {
    LOBYTE(v7) = *(pdwValue_1 + 356);
    LOBYTE(v4->bHandleSortDirection) = v7;
  }
  if ( v10 > 0x168 )
  {
    v7 = pdwValue_1[90];
    v4->dwDllSortColumn = v7;
  }
  if ( v10 > 0x16C )
  {
    LOBYTE(v7) = *(pdwValue_1 + 364);
    LOBYTE(v4->bDllSortDirection) = v7;
  }
  if ( v10 > 0x170 )
  {
    v7 = pdwValue_1[92];
    v4->dwProcessSortColumn = v7;
  }
  if ( v10 > 0x174 )
  {
    LOBYTE(v7) = *(pdwValue_1 + 372);
    v4->bProcessSortDirection = v7;
  }
  if ( v10 > 0x175 )
  {
    LOBYTE(v7) = *(pdwValue_1 + 373);
    v4->bHighlightServices = v7;
  }
  if ( v10 > 0x176 )
  {
    LOBYTE(v7) = *(pdwValue_1 + 374);
    v4->bHighlightOwnProcesses = v7;
  }
  if ( v10 > 0x178 )
  {
    LOBYTE(v7) = *(pdwValue_1 + 376);
    v4->bHighlightRelocatedDlls = v7;
  }
  if ( v10 > 0x17C )
  {
    v7 = pdwValue_1[95];
    v4->dwRefreshRate = v7;
  }
  if ( v10 > 0x180 )
  {
    v7 = pdwValue_1[96];
    v4->dwProcessColumnCount = v7;
  }
  if ( v10 > 0x204 )
  {
    v7 = pdwValue_1[129];
    v4->dwDllColumnCount = v7;
  }
  if ( v10 > 0x288 )
  {
    v7 = pdwValue_1[162];
    v4->dwHandleColumnCount = v7;
  }
  if ( v10 > 0x30C )
  {
    LOBYTE(v7) = *(pdwValue_1 + 780);
    v4->bHighlightJobs = v7;
  }
  if ( v10 > 0x30D )
  {
    LOBYTE(v7) = *(pdwValue_1 + 781);
    v4->bShowCpuFractions = v7;
  }
  if ( v10 > 0x310 )
    v4->dbSavedDivider = *(pdwValue_1 + 98);
  if ( v10 > 0x318 )
  {
    LOBYTE(v7) = *(pdwValue_1 + 792);
    v4->bShowLowerPane = v7;
  }
  if ( v10 > 0x319 )
  {
    LOBYTE(v7) = *(pdwValue_1 + 793);
    v4->bShowAllUsers = v7;
  }
  if ( v10 > 0x41E )
  {
    LOBYTE(v7) = *(pdwValue_1 + 1054);
    LOBYTE(v4->bSymbolWarningShown) = v7;
  }
  if ( v10 > 0x523 )
  {
    LOBYTE(v7) = *(pdwValue_1 + 1315);
    v4->bHighliteNetProcess = v7;
  }
  if ( v10 > 0x524 )
  {
    LOBYTE(v7) = *(pdwValue_1 + 1316);
    v4->byReserved_00 = v7;
  }
  if ( v10 > 0x525 )
  {
    LOBYTE(v7) = *(pdwValue_1 + 1317);
    v4->bHideWhenMinimized = v7;
  }
  if ( v10 > 0x554 )
  {
    v7 = pdwValue_1[341];
    v4->ColorOwn = v7;
  }
  if ( v10 > 0x568 )
  {
    v7 = pdwValue_1[346];
    v4->ColorProtected = v7;
  }
  if ( v10 > 0x558 )
  {
    v7 = pdwValue_1[342];
    v4->ColorService = v7;
  }
  if ( v10 > 0x55C )
  {
    v7 = pdwValue_1[343];
    v4->ColorRelocatedDlls = v7;
  }
  if ( v10 > 0x560 )
  {
    v7 = pdwValue_1[344];
    v4->ColorJobs = v7;
  }
  if ( v10 > 0x564 )
  {
    v7 = pdwValue_1[345];
    v4->ColorNet = v7;
  }
  if ( v10 > 0x56C )
  {
    v7 = pdwValue_1[347];
    v4->dwHighlightDuration = v7;
  }
  if ( v10 > 0x570 )
  {
    LOBYTE(v7) = *(pdwValue_1 + 1392);
    v4->bAlwaysOntop = v7;
  }
  if ( v10 > 0x571 )
  {
    LOBYTE(v7) = *(pdwValue_1 + 1393);
    v4->bShowProcessTree = v7;
  }
  if ( v10 > 0x574 )
  {
    v7 = pdwValue_1[349];
    v4->dwStatusBarColumns = v7;
  }
  if ( v10 > 0x578 )
  {
    v7 = pdwValue_1[350];
    v4->dwOpacity = v7;
  }
  if ( v10 > 0x5D4 )
  {
    LOBYTE(v7) = *(pdwValue_1 + 1492);
    v4->bConfirmKill = v7;
  }
  if ( v10 > 0x6D8 )
  {
    v7 = pdwValue_1[438];
    v4->dwDefaultProcPropPage = v7;
  }
  if ( v10 > 0x6F4 )
  {
    LOBYTE(v7) = *(pdwValue_1 + 1780);
    v4->bVerifySignatures = v7;
  }
  if ( v10 > 0x6F5 )
  {
    LOBYTE(v7) = *(pdwValue_1 + 1781);
    v4->bShowAllCpus = v7;
  }
  if ( v10 > 0x31A )
  {
    v11 = ATL::CStringT<wchar_t,ATL::StrTraitATL<wchar_t,ATL::ChTraitsCRT<wchar_t>>>::CStringT<wchar_t,ATL::StrTraitATL<wchar_t,ATL::ChTraitsCRT<wchar_t>>>(
            &pConfig,
            pdwValue_1 + 794);
    wcscpy_s(v4->strDbgHelpModuleName, 0x104u, *v11);
    v12 = &pConfig[-1].ToolBandInfo[6].fBreak;
    v7 = &pConfig[-1].ToolBandInfo[7].fBreak;
    if ( _InterlockedDecrement(v7) <= 0 )
      LOBYTE(v7) = (*(**v12 + 4))(v12);
    pdwValue_1 = pdwValue;
  }
  if ( v10 > 0x41F )
  {
    v13 = ATL::CStringT<wchar_t,ATL::StrTraitATL<wchar_t,ATL::ChTraitsCRT<wchar_t>>>::CStringT<wchar_t,ATL::StrTraitATL<wchar_t,ATL::ChTraitsCRT<wchar_t>>>(
            &pConfig,
            pdwValue_1 + 0x41F);
    wcscpy_s(v4->strNtSymbolPath, 0x104u, *v13);
    v14 = &pConfig[-1].ToolBandInfo[6].fBreak;
    v7 = &pConfig[-1].ToolBandInfo[7].fBreak;
    if ( _InterlockedDecrement(v7) <= 0 )
      LOBYTE(v7) = (*(**v14 + 4))(v14);
  }
  v15 = pdwValue;
  if ( v10 > 0x528 )
  {
    _mm_storeu_si128(&v4->WindowPlacement[1], _mm_loadu_si128((pdwValue + 330)));
    _mm_storeu_si128(&v4->WindowPlacement[1].ptMinPosition.y, _mm_loadu_si128((v15 + 334)));
    _mm_storel_epi64(&v4->WindowPlacement[1].rcNormalPosition.top, _mm_loadl_epi64((v15 + 338)));
    v7 = v15[340];
    v4->WindowPlacement[1].rcNormalPosition.bottom = v7;
  }
  if ( v10 > 0x57C )
  {
    _mm_storeu_si128(&v4->WindowPlacement[2], _mm_loadu_si128((v15 + 351)));
    _mm_storeu_si128(&v4->WindowPlacement[2].ptMinPosition.y, _mm_loadu_si128((v15 + 355)));
    _mm_storel_epi64(&v4->WindowPlacement[2].rcNormalPosition.top, _mm_loadl_epi64((v15 + 359)));
    v7 = v15[361];
    v4->WindowPlacement[2].rcNormalPosition.bottom = v7;
  }
  if ( v10 > 0x5A8 )
  {
    _mm_storeu_si128(&v4->WindowPlacement[4], _mm_loadu_si128((v15 + 362)));
    _mm_storeu_si128(&v4->WindowPlacement[4].ptMinPosition.y, _mm_loadu_si128((v15 + 366)));
    _mm_storel_epi64(&v4->WindowPlacement[4].rcNormalPosition.top, _mm_loadl_epi64((v15 + 370)));
    v7 = v15[372];
    v4->WindowPlacement[4].rcNormalPosition.bottom = v7;
  }
  if ( v10 > 0x6DC )
  {
    _mm_storel_epi64(v4->ToolBandInfo, _mm_loadl_epi64((v15 + 439)));
    v7 = v15[441];
    *&v4->ToolBandInfo[0].fBreak = v7;
  }
  if ( v10 > 0x6E8 )
  {
    _mm_storel_epi64(&v4->ToolBandInfo[1], _mm_loadl_epi64((v15 + 442)));
    v7 = v15[444];
    *&v4->ToolBandInfo[1].fBreak = v7;
  }
  if ( v10 > 0x6F4 )
  {
    _mm_storel_epi64(&v4->ToolBandInfo[1], _mm_loadl_epi64((v15 + 445)));
    v7 = v15[447];
    *&v4->ToolBandInfo[1].fBreak = v7;
  }
  if ( v10 > 0x700 )
  {
    _mm_storel_epi64(&v4->ToolBandInfo[1], _mm_loadl_epi64(v15 + 112));
    v7 = v15[450];
    *&v4->ToolBandInfo[1].fBreak = v7;
  }
  if ( v10 > 0x70C )
  {
    _mm_storel_epi64(&v4->ToolBandInfo[1], _mm_loadl_epi64((v15 + 451)));
    v7 = v15[453];
    *&v4->ToolBandInfo[1].fBreak = v7;
  }
  return v7;
}

//----- (00FB55D0) --------------------------------------------------------
BOOL __stdcall sub_FB55D0(HDC hdc, wchar_t *Src, RECT *lprect, int a4)
{
  signed int v4; // ecx
  int v5; // esi
  int v6; // eax
  WCHAR String; // [esp+Ch] [ebp-4004h]

  if ( wcslen(Src) > 0x1FFF )
  {
    wcsncpy_s(&String, 0x2000u, Src, 0xFFFFFFFF);
    __report_rangecheckfailure();
    __debugbreak();
    JUMPOUT(*sub_FB56D0);
  }
  wcscpy_s(&String, 0x2000u, Src);
  v4 = 2;
  if ( a4 )
    v4 = 8;
  sub_FB4D00(hdc, &String, 0x2000u, lprect->right - v4 - lprect->left);
  if ( a4 )
  {
    SetTextAlign(hdc, 2u);
    v5 = lprect->right - 10;
  }
  else
  {
    SetTextAlign(hdc, 0);
    v5 = lprect->left + 2;
  }
  v6 = lstrlenW(&String);
  return ExtTextOutW(hdc, v5, lprect->top + 1, 6u, lprect, &String, v6, 0);
}
// 10067E8: using guessed type int __report_rangecheckfailure(void);

//----- (00FB56D0) --------------------------------------------------------
char __cdecl sub_FB56D0(char a1, tagTREEVIEWLISTITEMPARAM *pTreeItem, WORD uID, HDC hDC, RECT *lprc)
{
  int nID; // esi
  HBRUSH v6; // eax
  RECT *rc; // esi
  HDC hdc; // ebx
  HBRUSH v10; // eax
  RECT *v11; // esi
  HDC v12; // ebx
  HBRUSH v13; // eax
  RECT *v14; // ebx
  float v15; // xmm0_4
  HBRUSH v16; // eax
  RECT *v17; // esi
  HDC v18; // ebx
  float v19; // xmm0_4
  HDC v20; // edi
  double v21; // xmm0_8
  COLORREF v22; // eax
  WORD pwHue[4]; // [esp+1Ch] [ebp-Ch]
  WORD pwSaturation[2]; // [esp+24h] [ebp-4h]

  nID = uID;
  switch ( uID )
  {
    case IDS_CPU_HISTORY:
      v6 = GetSysColorBrush(5);
      rc = lprc;
      hdc = hDC;
      FrameRect(hDC, lprc, v6);
      ++rc->top;
      --rc->right;
      if ( !pTreeItem->pGraphData1 )
        TreeViewItemParam_InitGraph(pTreeItem);
      GraphData_DrawChart(pTreeItem->pGraphData1, hdc, rc, gConfig.ColorGraphBk, 1u, 0.0);
      return 1;
    case IDS_PROCESS_TIMELINE:
      v10 = GetSysColorBrush(5);
      v11 = lprc;
      v12 = hDC;
      FrameRect(hDC, lprc, v10);
      ++v11->top;
      --v11->right;
      if ( !pTreeItem->pGraphData1 )
        TreeViewItemParam_InitGraph(pTreeItem);
      sub_FB1FD0(&pTreeItem->CreateTime, v12, v11, gConfig.ColorGraphBk);
      return 1;
    case IDS_PRIVATE_BYTES_HISTORY:
      v13 = GetSysColorBrush(5);
      v14 = lprc;
      FrameRect(hDC, lprc, v13);
      ++v14->top;
      --v14->right;
      if ( !pTreeItem->pGraphData2 )
        TreeViewItemParam_InitGraph(pTreeItem);
      v15 = qword_107BA40;
      GraphData_DrawChart(
        pTreeItem->pGraphData2,
        hDC,
        v14,
        gConfig.ColorGraphBk,
        1u,
        ((v15 * 0.2 + qword_107BA40) * 0.0009765625));
      return 1;
  }
  if ( uID != 1330 )
  {
    v20 = hDC;
    if ( uID == IDS_VIRUSTOTAL && sub_1001820(pTreeItem->m_ItemDataForVirusTotal) )
    {
      if ( sub_1002910(pTreeItem->m_ItemDataForVirusTotal) )
        SetTextColor(v20, 0xFFu);
      else
        SetTextColor(v20, 0xFF0000u);
      SelectObject(v20, ghConfigUnderlineFont);
    }
    if ( a1 || !gConfig.bShowColumnHeatmaps )
      return 0;
    *&uID = 0;
    switch ( nID )
    {
      case IDS_CPU:
        ColorRGBToHLS(0x3C943Cu, &pwHue[2], &uID, pwSaturation);
        if ( pTreeItem->dwProcessId )
        {
          v21 = *&pTreeItem->m_CPU / 100.0;
          if ( v21 > 1.0 )
            v21 = db_one;
        }
        else
        {
          v21 = 0.0;
        }
        break;
      case IDS_PRIVATE_BYTES:
        ColorRGBToHLS(0x82A0u, &pwHue[2], &uID, pwSaturation);
        v21 = pTreeItem->PagefileUsage * 0.0009765625 / gpGraphInfoOfMemory->m_dbMemorySize;
        break;
      case IDS_WORKING_SET:
        ColorRGBToHLS(0x4080FFu, &pwHue[2], &uID, pwSaturation);
        v21 = pTreeItem->WorkingSetSize * 0.0009765625 / gpGraphInfoOfPhysicalMemory->m_dbMemorySize;
        break;
      case IDS_GPU2:
        ColorRGBToHLS(0x8080FFu, &pwHue[2], &uID, pwSaturation);
        v21 = *&pTreeItem->field_568 / 100.0;
        break;
      default:
        return 0;
    }
    if ( uID )
    {
      *&uID = sub_FB6210(v21, 130u, 230u);
      if ( uID >= 110u )
        SetTextColor(v20, 0);
      else
        SetTextColor(v20, 0xFFFFFFu);
      v22 = ColorHLSToRGB(pwHue[2], uID, pwSaturation[0]);
      SetBkColor(v20, v22);
    }
    return 0;
  }
  v16 = GetSysColorBrush(5);
  v17 = lprc;
  v18 = hDC;
  FrameRect(hDC, lprc, v16);
  ++v17->top;
  --v17->right;
  if ( !pTreeItem->pGraphDataPROCCPU )
    TreeViewItemParam_InitGraph(pTreeItem);
  v19 = gIOGraphInfo.dbMemorySize;
  GraphData_DrawChart(pTreeItem->pGraphDataPROCCPU, v18, v17, gConfig.ColorGraphBk, 1u, (v19 * 1.2));
  return 1;
}
// 103CDC0: using guessed type double db_onehundred;
// 107BA40: using guessed type __int64 qword_107BA40;

//----- (00FB5AD0) --------------------------------------------------------
errno_t __cdecl sub_FB5AD0(int a1, int a2, int a3, int a4, int a5, wchar_t *Dst, rsize_t SizeInWords)
{
  double v7; // xmm1_8
  errno_t result; // eax
  char v9; // fl
  bool v10; // cf
  bool v11; // zf
  char v12; // sf
  char v13; // of
  char v14; // pf

  v7 = *a1;
  if ( *a1 == 0.0 && !__PAIR__(a3, a2) && !__PAIR__(a5, a4) )
    return wcscpy_s(Dst, SizeInWords, &gszNullString);
  if ( gConfig.bShowCpuFractions )
  {
    if ( v7 >= 0.006 )
      return swprintf_s(Dst, SizeInWords, L"%02.2f", LODWORD(v7), HIDWORD(v7));
    result = swprintf_s(Dst, SizeInWords, L"< 0.01", LODWORD(v7), HIDWORD(v7));
  }
  else
  {
    if ( v7 >= 0.6 )
      return swprintf_s(Dst, SizeInWords, L"%0.0f", LODWORD(v7), HIDWORD(v7));
    result = swprintf_s(Dst, SizeInWords, L"< 1", LODWORD(v7), HIDWORD(v7));
  }
  v10 = *a1 < 0.0;
  v14 = 0;
  v11 = *a1 == 0.0;
  v12 = 0;
  v13 = 0;
  BYTE1(result) = v9;
  if ( *a1 == 0.0 )
    *a1 = db_zeropointzerozerofive;
  return result;
}
// 103E04C: using guessed type wchar_t a001[7];
// 103E9C8: using guessed type double db_zeropointzerozerofive;

//----- (00FB5BB0) --------------------------------------------------------
LPCWSTR __cdecl sub_FB5BB0(wchar_t *Dst, __int64 a2)
{
  if ( *&a2 == 0.0 )
    return wcscpy_s(Dst, 0x104u, &gszNullString);
  if ( gConfig.bFormatIoBytes )
    return sub_FB2200(0, Dst, 0x104u, a2, 0i64, 0i64 >> 63);
  swprintf(Dst, L"%f", a2);
  return sub_FC3290(Dst, 0x104u);
}

//----- (00FB5C30) --------------------------------------------------------
char __cdecl QueryListItemColor(HWND hWnd, int nItem, BOOL bFocused, COLORREF *pTextColor, COLORREF *pBackColor)
{
  bool v5; // cl
  int v6; // ebx
  DWORD (__stdcall *v7)(int); // esi
  char result; // al
  DWORD (__stdcall *v9)(int); // ecx
  COLORREF v10; // eax
  bool v11; // [esp+Ah] [ebp-2h]
  char v12; // [esp+Bh] [ebp-1h]

  v5 = GetFocus() == hWnd;
  v12 = 0;
  v11 = hWnd == ghWndTreeListView;
  if ( nItem <= 1000 )
  {
    v6 = bFocused;
  }
  else
  {
    v6 = *(nItem + 16);
    if ( *(nItem + 8) == gdwRefreshCount && v6 == 1 )
      v6 = *(nItem + 12);
  }
  if ( bFocused )
  {
    v7 = GetSysColor;
    if ( v5 )
    {
      *pTextColor = GetSysColor(14);
      *pBackColor = GetSysColor(13);
      return 0;
    }
    goto LABEL_9;
  }
  if ( nItem >= 1000 )
  {
    v9 = GetSysColor;
    switch ( v6 )
    {
      case 0:
        v10 = GetSysColor(5);
        v9 = GetSysColor;
        goto LABEL_18;
      case 1:
        v10 = gConfig.ColorDelProc;
        goto LABEL_17;
      case 2:
      case 3:
        v10 = gConfig.ColorNewProc;
LABEL_17:
        v12 = 1;
LABEL_18:
        *pBackColor = v10;
        break;
      default:
        break;
    }
    *pTextColor = v9(8);
    if ( !v6 )
    {
      if ( hWnd == ghWndDllsListCtrl && gConfig.bHighlightRelocatedDlls && *(nItem + 44) & 1 )
        *pBackColor = gConfig.ColorRelocatedDlls;
      if ( v11 )
      {
        if ( gConfig.bHighlightOwnProcesses && gConfig.bShowAllUsers && *(nItem + 40) & 0x40 )
          *pBackColor = gConfig.ColorOwn;
        if ( gConfig.bHighlightServices && *(nItem + 40) & 0x20 )
          *pBackColor = gConfig.ColorService;
        if ( *(nItem + 40) & 0x800 && gConfig.bHighlightJobs )
          *pBackColor = gConfig.ColorJobs;
        if ( (*(nItem + 1288) || *(nItem + 1284)) && gConfig.bHighliteNetProcess )
          *pBackColor = gConfig.ColorNet;
      }
      if ( gConfig.bHighlightPacked && (v11 && *(nItem + 40) & 0x100 || hWnd == ghWndDllsListCtrl && *(nItem + 44) & 4) )
        *pBackColor = gConfig.ColorPacked;
      if ( v11 )
      {
        if ( gConfig.bHighlightProtected && *(nItem + 40) & 0x400 )
          *pBackColor = gConfig.ColorProtected;
        if ( gConfig.bHighlightImmersive && *(nItem + 40) & 0x1000 )
          *pBackColor = gConfig.ColorImmersive;
        if ( gConfig.bHighlightSuspend )
        {
          if ( *(nItem + 40) < 0 )
            *pBackColor = gConfig.ColorSuspend;
        }
      }
    }
    result = v12;
  }
  else
  {
    v7 = GetSysColor;
    if ( !nItem )
    {
LABEL_9:
      *pTextColor = v7(8);
      *pBackColor = v7(10);
      return 0;
    }
    *pTextColor = GetSysColor(8);
    *pBackColor = GetSysColor(5);
    result = 0;
  }
  return result;
}
// 106A11C: using guessed type int gdwRefreshCount;

//----- (00FB5E60) --------------------------------------------------------
BOOL __cdecl CTreeList::SetHeaderItem(HWND hWndHeader, WPARAM wParam, int fImage)
{
  BOOL result; // eax
  MACRO_HDF Format; // ecx
  HDITEMW Item; // [esp+Ch] [ebp-2Ch]

  if ( fImage )
  {
    if ( gbBitmapOnRight )
    {
      Item.mask = HDI_FORMAT;
      SendMessageW(hWndHeader, HDM_GETITEMW, wParam, &Item);
      Format = HDF_SORTDOWN;
      if ( fImage >= 0 )
        Format = HDF_SORTUP;
      Item.fmt = Item.fmt & -0x2601u | Format;
    }
    else
    {
      Item.mask = HDI_IMAGE|HDI_FORMAT;
      SendMessageW(hWndHeader, HDM_GETITEMW, wParam, &Item);
      Item.fmt |= 0x1800u;
      Item.iImage = fImage < 0;
    }
    SendMessageW(hWndHeader, HDM_SETITEMW, wParam, &Item);
    result = UpdateWindow(hWndHeader);
  }
  else
  {
    Item.mask = 4;
    SendMessageW(hWndHeader, HDM_GETITEMW, wParam, &Item);
    if ( gbBitmapOnRight )
      Item.fmt &= -0x2601u;
    else
      Item.fmt &= -0x1801u;
    SendMessageW(hWndHeader, HDM_SETITEMW, wParam, &Item);
    result = UpdateWindow(hWndHeader);
  }
  return result;
}
// 106A8F8: using guessed type char gbBitmapOnRight;

//----- (00FB5F60) --------------------------------------------------------
BOOL __stdcall EnumFunc(HWND hWnd, LPARAM arg4)
{
  _bstr_t *v2; // ecx
  _bstr_t *v3; // ecx
  DWORD dwProcessId; // [esp+Ch] [ebp-220h]
  _bstr_t a2; // [esp+10h] [ebp-21Ch]
  WCHAR ClassName; // [esp+14h] [ebp-218h]
  int v8; // [esp+228h] [ebp-4h]

  GetWindowThreadProcessId(hWnd, &dwProcessId);
  if ( dwProcessId == *(*arg4 + 68)
    && GetClassNameW(hWnd, &ClassName, 260)
    && !_wcsicmp(&ClassName, L"TabThumbnailWindow")
    && GetWindowTextW(hWnd, &ClassName, 260) )
  {
    _bstr_t::_bstr_t(&a2, L"\n   ");
    v2 = *(arg4 + 4);
    v8 = 0;
    _bstr_t::operator+=(v2, &a2);
    v8 = -1;
    _bstr_t::_Free(&a2);
    _bstr_t::_bstr_t(&a2, &ClassName);
    v3 = *(arg4 + 4);
    v8 = 1;
    _bstr_t::operator+=(v3, &a2);
    _bstr_t::_Free(&a2);
  }
  return 1;
}

//----- (00FB6090) --------------------------------------------------------
char __cdecl IsStringID(signed int uID)
{
  bool v1; // zf

  if ( uID > 1111 )
  {
    if ( uID <= 1656 )
    {
      if ( uID < 1654 )
      {
        switch ( uID )
        {
          case 1180:
          case 1181:
          case 1187:
          case 1191:
          case 1193:
          case 1196:
          case 1199:
          case 1308:
          case 1330:
          case 1336:
          case 1337:
          case 1338:
          case 1340:
            return 0;
          default:
            return 1;
        }
        return 1;
      }
      return 0;
    }
    if ( uID > 1674 )
    {
      v1 = uID == IDS_CONTROL_FLOW_GUARD;
    }
    else
    {
      if ( uID >= 1673 || uID == 1667 )
        return 0;
      v1 = uID == 1670;
    }
  }
  else
  {
    if ( uID == 1111 )
      return 0;
    if ( uID <= 35 )
    {
      if ( uID != 35 )
      {
        switch ( uID )
        {
          case 3:
          case 19:
          case 21:
          case 22:
          case 25:
          case 26:
          case 30:
            return 0;
          default:
            return 1;
        }
        return 1;
      }
      return 0;
    }
    if ( uID > 1033 )
    {
      v1 = uID == 1061;
    }
    else
    {
      if ( uID >= 1032 || uID == 38 )
        return 0;
      v1 = uID == 42;
    }
  }
  if ( !v1 )
    return 1;
  return 0;
}

//----- (00FB6210) --------------------------------------------------------
unsigned __int16 __cdecl sub_FB6210(double a1, unsigned __int16 a2, unsigned __int16 a3)
{
  unsigned __int16 result; // ax

  if ( a1 == 0.0 )
    result = a3;
  else
    result = a3 - 5 * (((a3 - a2) * a1) / 5);
  return result;
}

//----- (00FB6270) --------------------------------------------------------
int __cdecl sub_FB6270(int a1, int a2)
{
  int v2; // edi
  _WORD *v3; // eax
  int v4; // eax
  _WORD *v5; // eax
  int v6; // eax
  _WORD *v7; // eax
  int v8; // eax
  Data_t_bstr_t *v9; // eax
  Data_t_bstr_t *v10; // ebx
  Data_t_bstr_t *v11; // edx
  int v12; // eax
  __int16 v13; // cx
  Data_t_bstr_t *v14; // edx
  OLECHAR *v15; // edx
  int *v16; // ebx
  Data_t_bstr_t *v17; // edi
  __int16 v18; // si
  Data_t_bstr_t *v19; // eax
  __int16 *v20; // ecx
  int v21; // esi
  __int16 v22; // ax
  _WORD *v23; // eax
  int v24; // eax
  _WORD *v25; // eax
  int v26; // eax
  _WORD *v27; // eax
  int v28; // eax
  int i; // esi
  signed int v30; // esi
  signed int v31; // ebx
  Data_t_bstr_t *v32; // eax
  Data_t_bstr_t *v33; // edx
  Data_t_bstr_t *v34; // ecx
  _bstr_t *v35; // esi
  _bstr_t *v36; // eax
  _bstr_t *v37; // eax
  _bstr_t *v38; // eax
  _bstr_t *v39; // eax
  const wchar_t *v40; // eax
  wchar_t *v41; // eax
  signed int v42; // esi
  Data_t_bstr_t *v43; // edi
  int v44; // eax
  OLECHAR *v45; // esi
  _bstr_t *v46; // eax
  _bstr_t *v47; // eax
  BSTR v48; // ecx
  int v49; // edx
  OLECHAR v50; // ax
  int v51; // ecx
  BSTR v52; // eax
  Data_t_bstr_t *v53; // esi
  LPARAM lParam; // [esp+14h] [ebp-40h]
  _bstr_t v56; // [esp+18h] [ebp-3Ch]
  _bstr_t v57; // [esp+1Ch] [ebp-38h]
  _bstr_t a1a; // [esp+20h] [ebp-34h]
  _bstr_t v59; // [esp+24h] [ebp-30h]
  _bstr_t v60; // [esp+28h] [ebp-2Ch]
  OLECHAR **v61; // [esp+2Ch] [ebp-28h]
  _bstr_t v62; // [esp+30h] [ebp-24h]
  _bstr_t v63; // [esp+34h] [ebp-20h]
  _bstr_t a2a; // [esp+38h] [ebp-1Ch]
  _bstr_t v65; // [esp+3Ch] [ebp-18h]
  _bstr_t v66; // [esp+40h] [ebp-14h]
  _bstr_t v67; // [esp+44h] [ebp-10h]
  int v68; // [esp+50h] [ebp-4h]

  if ( !(dword_1069E5C & 1) )
  {
    dword_1069E5C |= 1u;
    v68 = 0;
    _bstr_t::_bstr_t(&::a2, L"\r\n");
    atexit(sub_102A910);
  }
  v67.m_Data = 0;
  v2 = a2;
  v68 = 1;
  v3 = *(a2 + 784);
  if ( v3 && *v3 )
  {
    v4 = 0;
    if ( gConfig.dwProcessColumnCount <= 0 )
    {
LABEL_8:
      _bstr_t::operator+=(&v67, &::a2);
      _bstr_t::_bstr_t(&a2a, *(v2 + 784));
      LOBYTE(v68) = 2;
      _bstr_t::operator+=(&v67, &a2a);
      LOBYTE(v68) = 1;
      _bstr_t::_Free(&a2a);
    }
    else
    {
      while ( gConfig.dwProcessColumnMap[v4] != 38 )
      {
        if ( ++v4 >= gConfig.dwProcessColumnCount )
          goto LABEL_8;
      }
    }
  }
  v5 = *(v2 + 788);
  if ( v5 && *v5 )
  {
    v6 = 0;
    if ( gConfig.dwProcessColumnCount <= 0 )
    {
LABEL_14:
      _bstr_t::operator+=(&v67, &::a2);
      _bstr_t::_bstr_t(&a2a, *(v2 + 788));
      LOBYTE(v68) = 3;
      _bstr_t::operator+=(&v67, &a2a);
      LOBYTE(v68) = 1;
      _bstr_t::_Free(&a2a);
    }
    else
    {
      while ( gConfig.dwProcessColumnMap[v6] != 1033 )
      {
        if ( ++v6 >= gConfig.dwProcessColumnCount )
          goto LABEL_14;
      }
    }
  }
  v7 = *(v2 + 800);
  if ( v7 && *v7 )
  {
    v8 = 0;
    if ( gConfig.dwProcessColumnCount <= 0 )
    {
LABEL_20:
      _bstr_t::operator+=(&v67, &::a2);
      _bstr_t::_bstr_t(&a2a, L"Command Line:\n   ");
      LOBYTE(v68) = 4;
      _bstr_t::operator+=(&v67, &a2a);
      LOBYTE(v68) = 1;
      _bstr_t::_Free(&a2a);
      v9 = _wcsdup(*(v2 + 800));
      v10 = v9;
      v11 = v9;
      v66.m_Data = v9;
      v12 = &v9->m_wstr + 2;
      do
      {
        v13 = v11->m_wstr;
        v11 = (v11 + 2);
      }
      while ( v13 );
      if ( ((v11 - v12) >> 1) <= 0x64 )
      {
        _bstr_t::_bstr_t(&a2a, *(v2 + 800));
        LOBYTE(v68) = 8;
      }
      else
      {
        v14 = 0;
        if ( wcslen(v10) > 0x64 )
        {
          v15 = v10;
          v16 = &v10[16].m_RefCount;
          v17 = 0;
          do
          {
            v18 = *v16;
            *v16 = 0;
            _bstr_t::_bstr_t(&a2a, v15);
            LOBYTE(v68) = 5;
            _bstr_t::operator+=(&v67, &a2a);
            LOBYTE(v68) = 1;
            _bstr_t::_Free(&a2a);
            _bstr_t::_bstr_t(&v65, L"\n     ");
            LOBYTE(v68) = 6;
            _bstr_t::operator+=(&v67, &v65);
            LOBYTE(v68) = 1;
            _bstr_t::_Free(&v65);
            v19 = v66.m_Data;
            v16 += 50;
            v17 = (v17 + 100);
            *(v16 - 100) = v18;
            v15 = (v19 + 2 * v17);
            v20 = (v19 + 2 * v17);
            v21 = (v20 + 1);
            do
            {
              v22 = *v20;
              ++v20;
            }
            while ( v22 );
          }
          while ( ((v20 - v21) >> 1) > 0x64 );
          v10 = v66.m_Data;
          v62.m_Data = v17;
          v2 = a2;
          v14 = v62.m_Data;
        }
        _bstr_t::_bstr_t(&a2a, v10 + v14);
        LOBYTE(v68) = 7;
      }
      _bstr_t::operator+=(&v67, &a2a);
      LOBYTE(v68) = 1;
      _bstr_t::_Free(&a2a);
    }
    else
    {
      while ( gConfig.dwProcessColumnMap[v8] != 1032 )
      {
        if ( ++v8 >= gConfig.dwProcessColumnCount )
          goto LABEL_20;
      }
    }
  }
  v23 = *(v2 + 792);
  if ( v23 && *v23 )
  {
    v24 = 0;
    if ( gConfig.dwProcessColumnCount <= 0 )
    {
LABEL_37:
      _bstr_t::operator+=(&v67, &::a2);
      _bstr_t::_bstr_t(&a2a, L"Path:\n   ");
      LOBYTE(v68) = 9;
      _bstr_t::operator+=(&v67, &a2a);
      LOBYTE(v68) = 1;
      _bstr_t::_Free(&a2a);
      _bstr_t::_bstr_t(&a2a, *(v2 + 792));
      LOBYTE(v68) = 10;
      _bstr_t::operator+=(&v67, &a2a);
      LOBYTE(v68) = 1;
      _bstr_t::_Free(&a2a);
    }
    else
    {
      while ( gConfig.dwProcessColumnMap[v24] != 1061 )
      {
        if ( ++v24 >= gConfig.dwProcessColumnCount )
          goto LABEL_37;
      }
    }
  }
  v25 = *(v2 + 824);
  if ( v25 && *v25 )
  {
    v26 = 0;
    if ( gConfig.dwProcessColumnCount <= 0 )
    {
LABEL_43:
      _bstr_t::operator+=(&v67, &::a2);
      _bstr_t::_bstr_t(&a2a, "Package:\n   ");
      LOBYTE(v68) = 11;
      _bstr_t::operator+=(&v67, &a2a);
      LOBYTE(v68) = 1;
      _bstr_t::_Free(&a2a);
      _bstr_t::_bstr_t(&a2a, *(v2 + 824));
      LOBYTE(v68) = 12;
      _bstr_t::operator+=(&v67, &a2a);
      LOBYTE(v68) = 1;
      _bstr_t::_Free(&a2a);
    }
    else
    {
      while ( gConfig.dwProcessColumnMap[v26] != 1654 )
      {
        if ( ++v26 >= gConfig.dwProcessColumnCount )
          goto LABEL_43;
      }
    }
  }
  v27 = *(v2 + 796);
  if ( v27 && *v27 )
  {
    v28 = 0;
    if ( gConfig.dwProcessColumnCount <= 0 )
    {
LABEL_49:
      _bstr_t::operator+=(&v67, &::a2);
      _bstr_t::_bstr_t(&a2a, L"Comment:\n   ");
      LOBYTE(v68) = 13;
      _bstr_t::operator+=(&v67, &a2a);
      LOBYTE(v68) = 1;
      _bstr_t::_Free(&a2a);
      _bstr_t::_bstr_t(&a2a, *(v2 + 796));
      LOBYTE(v68) = 14;
      _bstr_t::operator+=(&v67, &a2a);
      LOBYTE(v68) = 1;
      _bstr_t::_Free(&a2a);
    }
    else
    {
      while ( gConfig.dwProcessColumnMap[v28] != 1181 )
      {
        if ( ++v28 >= gConfig.dwProcessColumnCount )
          goto LABEL_49;
      }
    }
  }
  if ( *(v2 + 860) )
  {
    _bstr_t::operator+=(&v67, &::a2);
    if ( _wcsicmp(*(v2 + 60), L"rundll32.exe") )
    {
      _bstr_t::_bstr_t(&a2, L"COM Class:\n   ");
      LOBYTE(v68) = 16;
      _bstr_t::operator+=(&v67, &a2);
      LOBYTE(v68) = 1;
      _bstr_t::_Free(&a2);
      if ( !*(v2 + 848) )
      {
LABEL_56:
        _bstr_t::_bstr_t(&a2, *(v2 + 860));
        LOBYTE(v68) = 19;
        _bstr_t::operator+=(&v67, &a2);
        LOBYTE(v68) = 1;
        _bstr_t::_Free(&a2);
        if ( *(v2 + 856) )
        {
          _bstr_t::_bstr_t(&a2, L"\n   ");
          LOBYTE(v68) = 20;
          _bstr_t::operator+=(&v67, &a2);
          LOBYTE(v68) = 1;
          _bstr_t::_Free(&a2);
          _bstr_t::_bstr_t(&a2, *(v2 + 856));
          LOBYTE(v68) = 21;
          _bstr_t::operator+=(&v67, &a2);
          LOBYTE(v68) = 1;
          _bstr_t::_Free(&a2);
        }
        if ( *(v2 + 852) )
        {
          _bstr_t::_bstr_t(&a2, L"\n   ");
          LOBYTE(v68) = 22;
          _bstr_t::operator+=(&v67, &a2);
          LOBYTE(v68) = 1;
          _bstr_t::_Free(&a2);
          _bstr_t::_bstr_t(&a2, *(v2 + 852));
          LOBYTE(v68) = 23;
          _bstr_t::operator+=(&v67, &a2);
          LOBYTE(v68) = 1;
          _bstr_t::_Free(&a2);
        }
        goto LABEL_93;
      }
      _bstr_t::_bstr_t(&a2, *(v2 + 848));
      LOBYTE(v68) = 17;
      _bstr_t::operator+=(&v67, &a2);
      LOBYTE(v68) = 1;
      _bstr_t::_Free(&a2);
      _bstr_t::_bstr_t(&a2, L"\n   ");
      LOBYTE(v68) = 18;
    }
    else
    {
      _bstr_t::_bstr_t(&a2, L"Rundll Target:\n   ");
      LOBYTE(v68) = 15;
    }
    _bstr_t::operator+=(&v67, &a2);
    LOBYTE(v68) = 1;
    _bstr_t::_Free(&a2);
    goto LABEL_56;
  }
  if ( _wcsicmp(*(v2 + 60), L"taskeng.exe")
    && _wcsicmp(*(v2 + 60), L"taskhost.exe")
    && _wcsicmp(*(v2 + 60), L"taskhostex.exe")
    && _wcsicmp(*(v2 + 60), L"taskhostw.exe") )
  {
    if ( _wcsicmp(*(v2 + 60), L"iexplore.exe") && _wcsicmp(*(v2 + 60), L"iexplore.exe") )
    {
      if ( *(v2 + 868) )
      {
        _bstr_t::operator+=(&v67, &::a2);
        _bstr_t::_bstr_t(&a2, L"WMI Providers:");
        LOBYTE(v68) = 27;
        _bstr_t::operator+=(&v67, &a2);
        LOBYTE(v68) = 1;
        _bstr_t::_Free(&a2);
        for ( i = *(v2 + 868); i; i = *(i + 12) )
        {
          _bstr_t::_bstr_t(&a2, L"\n   [");
          LOBYTE(v68) = 28;
          _bstr_t::operator+=(&v67, &a2);
          LOBYTE(v68) = 1;
          _bstr_t::_Free(&a2);
          _bstr_t::_bstr_t(&a2a, *i);
          LOBYTE(v68) = 29;
          _bstr_t::operator+=(&v67, &a2a);
          LOBYTE(v68) = 1;
          _bstr_t::_Free(&a2a);
          _bstr_t::_bstr_t(&v65, L"]\n       Namespace: ");
          LOBYTE(v68) = 30;
          _bstr_t::operator+=(&v67, &v65);
          LOBYTE(v68) = 1;
          _bstr_t::_Free(&v65);
          _bstr_t::_bstr_t(&v66, *(i + 4));
          LOBYTE(v68) = 31;
          _bstr_t::operator+=(&v67, &v66);
          LOBYTE(v68) = 1;
          _bstr_t::_Free(&v66);
          _bstr_t::_bstr_t(&v63, L"\n       DLL: ");
          LOBYTE(v68) = 32;
          _bstr_t::operator+=(&v67, &v63);
          LOBYTE(v68) = 1;
          _bstr_t::_Free(&v63);
          _bstr_t::_bstr_t(&v62, *(i + 8));
          LOBYTE(v68) = 33;
          _bstr_t::operator+=(&v67, &v62);
          LOBYTE(v68) = 1;
          _bstr_t::_Free(&v62);
        }
      }
      else if ( *(v2 + 40) & 0x20 )
      {
        if ( *(v2 + 864) )
        {
          _bstr_t::_bstr_t(&v62, L" (");
          LOBYTE(v68) = 34;
          _bstr_t::operator+=(&v67, &v62);
          LOBYTE(v68) = 1;
          _bstr_t::_Free(&v62);
          _bstr_t::_bstr_t(&v62, *(v2 + 864));
          LOBYTE(v68) = 35;
          _bstr_t::operator+=(&v67, &v62);
          LOBYTE(v68) = 1;
          _bstr_t::_Free(&v62);
          _bstr_t::_bstr_t(&v62, L")");
          LOBYTE(v68) = 36;
          _bstr_t::operator+=(&v67, &v62);
          LOBYTE(v68) = 1;
          _bstr_t::_Free(&v62);
        }
        _bstr_t::operator+=(&v67, &::a2);
        _bstr_t::_bstr_t(&v62, L"Services:");
        LOBYTE(v68) = 37;
        _bstr_t::operator+=(&v67, &v62);
        LOBYTE(v68) = 1;
        _bstr_t::_Free(&v62);
        EnterCriticalSection(&gServiceLock);
        v30 = gdwServiceReturned;
        v31 = 0;
        v32 = malloc(4 * gdwServiceReturned);
        v33 = 0;
        v66.m_Data = v32;
        v63.m_Data = 0;
        if ( v30 > 0 )
        {
          v34 = 0;
          a2a.m_Data = 0;
          do
          {
            v61 = (gpszServiceNames + v34);
            if ( *(gpszServiceNames + v34 + 36) == *(v2 + 68) )
            {
              v65.m_Data = 0;
              LOBYTE(v68) = 38;
              _bstr_t::_bstr_t(&v62, *v61);
              LOBYTE(v68) = 39;
              v35 = _bstr_t::_bstr_t(&v56, "]");
              LOBYTE(v68) = 40;
              v36 = _bstr_t::_bstr_t(&v57, " [");
              LOBYTE(v68) = 41;
              v37 = _bstr_t::operator+(&a1a, *(&a2a.m_Data->m_str + gpszServiceNames), v36);
              LOBYTE(v68) = 42;
              v38 = _bstr_t::operator+(&v37->m_Data, &v59, &v62);
              LOBYTE(v68) = 43;
              v39 = _bstr_t::operator+(&v38->m_Data, &v60, v35);
              sub_F73A50(&v65, v39);
              _bstr_t::_Free(&v60);
              _bstr_t::_Free(&v59);
              _bstr_t::_Free(&a1a);
              _bstr_t::_Free(&v57);
              _bstr_t::_Free(&v56);
              _bstr_t::_Free(&v62);
              if ( v65.m_Data )
                v40 = v65.m_Data->m_wstr;
              else
                v40 = 0;
              v41 = _wcsdup(v40);
              LOBYTE(v68) = 1;
              *(&v66.m_Data->m_wstr + v31++) = v41;
              _bstr_t::_Free(&v65);
              v30 = gdwServiceReturned;
              v34 = a2a.m_Data;
              v33 = v63.m_Data;
            }
            v33 = (v33 + 1);
            v34 = (v34 + 44);
            v63.m_Data = v33;
            a2a.m_Data = v34;
          }
          while ( v33 < v30 );
          v32 = v66.m_Data;
        }
        qsort(v32, v31, 4u, sub_FC5A60);
        v42 = 0;
        if ( v31 > 0 )
        {
          v43 = v66.m_Data;
          do
          {
            _bstr_t::_bstr_t(&v62, L"\n   ");
            LOBYTE(v68) = 44;
            _bstr_t::operator+=(&v67, &v62);
            LOBYTE(v68) = 1;
            _bstr_t::_Free(&v62);
            _bstr_t::_bstr_t(&v63, *(&v43->m_wstr + v42));
            LOBYTE(v68) = 45;
            _bstr_t::operator+=(&v67, &v63);
            LOBYTE(v68) = 1;
            _bstr_t::_Free(&v63);
            free(*(&v43->m_wstr + v42++));
          }
          while ( v42 < v31 );
          v2 = a2;
        }
        LeaveCriticalSection(&gServiceLock);
        free(v66.m_Data);
      }
    }
    else if ( *(v2 + 654) >= 0x37u )
    {
      v44 = *(v2 + 84);
      if ( v44 )
      {
        if ( !_wcsicmp(*(v44 + 60), L"iexplore.exe") )
        {
          _bstr_t::operator+=(&v67, &::a2);
          _bstr_t::_bstr_t(&a2, L"Tabs:");
          LOBYTE(v68) = 26;
          _bstr_t::operator+=(&v67, &a2);
          LOBYTE(v68) = 1;
          _bstr_t::_Free(&a2);
          lParam = v2;
          v56.m_Data = &v67;
          EnumWindows(EnumFunc, &lParam);
        }
      }
    }
  }
  else
  {
    v45 = sub_FC4990(*(v2 + 68));
    if ( v45 )
    {
      _bstr_t::operator+=(&v67, &::a2);
      v46 = _bstr_t::_bstr_t(&v56, v45);
      LOBYTE(v68) = 24;
      v47 = _bstr_t::operator+(&a2, L"Tasks:\n", v46);
      LOBYTE(v68) = 25;
      _bstr_t::operator+=(&v67, v47);
      _bstr_t::_Free(&a2);
      LOBYTE(v68) = 1;
      _bstr_t::_Free(&v56);
      free(v45);
    }
  }
LABEL_93:
  if ( !v67.m_Data || !v67.m_Data->m_wstr || !SysStringLen(v67.m_Data->m_wstr) )
  {
    _bstr_t::operator+=(&v67, &::a2);
    _bstr_t::_bstr_t(&a2, *(v2 + 60));
    LOBYTE(v68) = 46;
    _bstr_t::operator+=(&v67, &a2);
    LOBYTE(v68) = 1;
    _bstr_t::_Free(&a2);
  }
  if ( ::a2.m_Data )
    v48 = ::a2.m_Data->m_wstr;
  else
    v48 = 0;
  v49 = (v48 + 1);
  do
  {
    v50 = *v48;
    ++v48;
  }
  while ( v50 );
  v51 = (v48 - v49) >> 1;
  if ( v67.m_Data )
    v52 = v67.m_Data->m_wstr;
  else
    v52 = 0;
  _bstr_t::_bstr_t(a1, &v52[v51]);
  v53 = v67.m_Data;
  if ( v67.m_Data && !InterlockedDecrement(&v67.m_Data->m_RefCount) && v53 )
  {
    if ( v53->m_wstr )
    {
      SysFreeString(v53->m_wstr);
      v53->m_wstr = 0;
    }
    if ( v53->m_str )
    {
      j_j__free(v53->m_str);
      v53->m_str = 0;
    }
    j__free(v53);
  }
  return a1;
}
// 1069E5C: using guessed type int dword_1069E5C;

//----- (00FB6F30) --------------------------------------------------------
void __cdecl RegVar_ReadWrite(int fSave, int nCount, CRegVar *pVariable)
{
  wchar_t *pConfigItem; // [esp+0h] [ebp-3F4h]
  tagConfigItem ConfigItems[20]; // [esp+8h] [ebp-3ECh]
  WCHAR pszBuffer[260]; // [esp+1E8h] [ebp-20Ch]

  ConfigItems[1].dbValue = db_twohundred;
  ConfigItems[3].dbValue = db_six;
  ConfigItems[1].Address = &pVariable->ProcessImageColumnWidth;
  ConfigItems[4].llValue = 0i64;
  ConfigItems[2].Address = pVariable->ProcessColumns;
  ConfigItems[3].Address = &pVariable->PrcessColumnCount;
  *&ConfigItems[4].Address = pVariable->ProcessColumnMap;
  ConfigItems[5].Address = &pVariable->DllColumnCount;
  ConfigItems[6].Address = pVariable->DllColumns;
  ConfigItems[7].Address = pVariable->DllColumnMap;
  ConfigItems[5].dbValue = db_four;
  ConfigItems[8].Address = &pVariable->HandleColumnCount;
  ConfigItems[7].llValue = 0i64;
  ConfigItems[9].Address = pVariable->HandleColumnMap;
  ConfigItems[8].dbValue = db_two;
  ConfigItems[10].Address = pVariable->HandleColumns;
  ConfigItems[0].Name = L"ColumnSetName";
  ConfigItems[0].KeyType = KT_String;
  ConfigItems[0].StructSize = 520;
  ConfigItems[0].Address = pVariable;
  ConfigItems[0].llValue = 0i64;
  ConfigItems[1].Name = L"ProcessImageColumnWidth";
  ConfigItems[1].KeyType = 3;
  ConfigItems[1].StructSize = 2;
  ConfigItems[2].Name = L"ProcessColumns";
  ConfigItems[2].KeyType = 6;
  ConfigItems[2].StructSize = 192;
  ConfigItems[2].llValue = 0i64;
  ConfigItems[3].Name = L"PrcessColumnCount";
  ConfigItems[3].KeyType = 0;
  ConfigItems[3].StructSize = 0;
  ConfigItems[4].Name = L"ProcessColumnMap";
  ConfigItems[4].KeyType = 5;
  ConfigItems[4].StructSize = 384;
  ConfigItems[5].Name = L"DllColumnCount";
  ConfigItems[5].KeyType = 0;
  ConfigItems[5].StructSize = 0;
  ConfigItems[6].Name = L"DllColumns";
  ConfigItems[6].KeyType = 6;
  ConfigItems[6].StructSize = 64;
  ConfigItems[6].llValue = 0i64;
  ConfigItems[7].Name = L"DllColumnMap";
  ConfigItems[7].KeyType = 5;
  ConfigItems[7].StructSize = 128;
  ConfigItems[8].Name = L"HandleColumnCount";
  ConfigItems[8].KeyType = 0;
  ConfigItems[8].StructSize = 0;
  ConfigItems[9].Name = L"HandleColumnMap";
  ConfigItems[9].KeyType = 5;
  ConfigItems[9].StructSize = 128;
  ConfigItems[9].llValue = 0i64;
  ConfigItems[10].Name = L"HandleColumns";
  ConfigItems[10].KeyType = 6;
  ConfigItems[10].StructSize = 64;
  ConfigItems[10].llValue = 0i64;
  ConfigItems[11].Name = L"HandleSortColumn";
  ConfigItems[11].KeyType = 0;
  ConfigItems[11].StructSize = 0;
  ConfigItems[11].Address = &pVariable->HandleSortColumn;
  ConfigItems[11].llValue = 0i64;
  ConfigItems[12].Name = L"HandleSortDirection";
  ConfigItems[12].Address = &pVariable->HandleSortDirection;
  ConfigItems[13].Address = &pVariable->DllSortColumn;
  ConfigItems[14].Address = &pVariable->DllSortDirection;
  ConfigItems[15].Address = &pVariable->ProcessSortColumn;
  ConfigItems[16].Address = &pVariable->ProcessSortDirection;
  ConfigItems[17].Address = &pVariable->ShowProcessTree;
  ConfigItems[18].Address = &pVariable->StatusBarColumns;
  ConfigItems[15].llValue = qword_103EA40;
  ConfigItems[12].KeyType = KT_Bool;
  ConfigItems[12].StructSize = 0;
  ConfigItems[12].dbValue = db_one;
  ConfigItems[13].Name = L"DllSortColumn";
  ConfigItems[13].KeyType = 0;
  ConfigItems[13].StructSize = 0;
  ConfigItems[13].llValue = 0i64;
  ConfigItems[14].Name = L"DllSortDirection";
  ConfigItems[14].KeyType = 1;
  ConfigItems[14].StructSize = 0;
  ConfigItems[14].dbValue = db_one;
  ConfigItems[15].Name = L"ProcessSortColumn";
  ConfigItems[15].KeyType = 0;
  ConfigItems[15].StructSize = 0;
  ConfigItems[16].Name = L"ProcessSortDirection";
  ConfigItems[16].KeyType = 1;
  ConfigItems[16].StructSize = 0;
  ConfigItems[16].dbValue = db_one;
  ConfigItems[17].Name = L"ShowProcessTree";
  ConfigItems[17].KeyType = 1;
  ConfigItems[17].StructSize = 0;
  ConfigItems[17].dbValue = db_one;
  ConfigItems[18].Name = L"StatusBarColumns";
  ConfigItems[18].KeyType = 0;
  ConfigItems[18].StructSize = 0;
  ConfigItems[18].dbValue = db_twenty21;
  ConfigItems[19].Name = 0;
  ConfigItems[19].KeyType = 0;
  ConfigItems[19].StructSize = 0;
  ConfigItems[19].Address = 0;
  ConfigItems[19].llValue = 0i64;
  swprintf(pszBuffer, L"Software\\Sysinternals\\Process Explorer\\ColumnSet%d", nCount);
  pConfigItem = _wcsdup(pszBuffer);
  if ( fSave )
    SaveConfigItemToRegistry(&pConfigItem, ConfigItems);
  else
    LoadConfigItemFromRegistry(&pConfigItem, ConfigItems);
  free(pConfigItem);
}
// 103CB38: using guessed type double db_four;
// 103D414: using guessed type wchar_t aProcesscolumns[15];
// 103D434: using guessed type wchar_t aProcessimageco[24];
// 103D464: using guessed type wchar_t aHandlecolumns[14];
// 103D480: using guessed type wchar_t aDllcolumns[11];
// 103D4D8: using guessed type wchar_t aHandlesortcolu[17];
// 103D4FC: using guessed type wchar_t aHandlesortdire[20];
// 103D524: using guessed type wchar_t aDllsortcolumn[14];
// 103D540: using guessed type wchar_t aDllsortdirecti[17];
// 103D564: using guessed type wchar_t aProcesssortcol[18];
// 103D588: using guessed type wchar_t aProcesssortdir[21];
// 103D7D4: using guessed type wchar_t aShowprocesstre[16];
// 103D8BC: using guessed type wchar_t aPrcesscolumnco[18];
// 103D8E0: using guessed type wchar_t aProcesscolumnm[17];
// 103D904: using guessed type wchar_t aDllcolumncount[15];
// 103D924: using guessed type wchar_t aDllcolumnmap[13];
// 103D940: using guessed type wchar_t aHandlecolumnco[18];
// 103D964: using guessed type wchar_t aHandlecolumnma[16];
// 103DB90: using guessed type wchar_t aStatusbarcolum[17];
// 103DE18: using guessed type wchar_t aColumnsetname[14];
// 103E9E8: using guessed type double db_two;
// 103E9F0: using guessed type double db_six;
// 103E9F8: using guessed type double db_twenty21;
// 103EA00: using guessed type double db_twohundred;
// 103EA40: using guessed type __int64 qword_103EA40;

//----- (00FB73D0) --------------------------------------------------------
int __cdecl sub_FB73D0(HWND hWnd, char a2)
{
  int v2; // eax
  int result; // eax
  LPARAM lParam; // [esp+Ch] [ebp-464h]
  int v5; // [esp+10h] [ebp-460h]
  int v6; // [esp+14h] [ebp-45Ch]
  int v7; // [esp+18h] [ebp-458h]
  int v8; // [esp+1Ch] [ebp-454h]
  WCHAR *v9; // [esp+20h] [ebp-450h]
  int v10; // [esp+24h] [ebp-44Ch]
  int v11; // [esp+28h] [ebp-448h]
  int v12; // [esp+2Ch] [ebp-444h]
  char v13; // [esp+40h] [ebp-430h]
  wchar_t Src; // [esp+64h] [ebp-40Ch]
  WCHAR String; // [esp+26Ch] [ebp-204h]

  qmemcpy(&v13, &a2, 0x22Cu);
  memset(&v5, 0, 0x30u);
  wcscpy_s(&String, 0x100u, &Src);
  lParam = 13;
  v5 = 0x7FFFFFFF;
  v6 = 0;
  v7 = 0;
  v8 = 0;
  v9 = &String;
  v2 = lstrlenW(&String);
  v11 = 0;
  v10 = v2 + 1;
  result = malloc(0x22Cu);
  if ( result )
  {
    qmemcpy(result, &v13, 0x22Cu);
    v12 = result;
    result = SendMessageW(hWnd, 0x104Du, 0, &lParam) != -1;
  }
  return result;
}

//----- (00FB74F0) --------------------------------------------------------
char __cdecl TreeView_InsertVerifyColumn(HWND hWnd, UINT uID, int *pnIDs, int pnLength)
{
  int idx; // eax
  int i; // ecx
  bool v6; // zf
  char v7; // cl
  HWND hWnd_1; // edi
  WPARAM nItem; // ecx
  tagLVCOLUMNW ColumnInfo; // [esp+Ch] [ebp-A8h]
  HWND hWndIn; // [esp+2Ch] [ebp-88h]
  WCHAR Buffer[64]; // [esp+30h] [ebp-84h]

  hWndIn = hWnd;
  idx = 0;
  for ( i = *pnLength; idx < i; ++idx )
  {
    if ( pnIDs[idx] == uID )
      break;
  }
  if ( idx != i )
    return 0;
  ColumnInfo.iSubItem = *pnLength;
  ColumnInfo.cx = MulDiv(100, gLogPixelSize.x, 96);
  LoadStringW(ghInstance, uID, Buffer, 64);
  pnIDs[*pnLength] = uID;
  ColumnInfo.mask = 7;
  ColumnInfo.cchTextMax = 64;
  ColumnInfo.pszText = Buffer;
  if ( uID > IDS_PATH2 )
  {
    if ( uID <= IDS_AUTOSTART_LOCATION )
    {
      if ( uID < IDS_PACKAGE_NAME )
      {
        switch ( uID )
        {
          case IDS_DESKTOP_INTEGRITY_LEVEL:
          case IDS_COMMENT:
          case IDS_VERIFIED_SIGNER:
          case IDS_CPU_HISTORY:
          case IDS_PRIVATE_BYTES_HISTORY:
          case IDS_WINDOW_STATUS:
          case IDS_DEP:
          case IDS_DECODED_ACCESS:
          case IDS_IO_HISTORY:
          case IDC_SYSINFO_IOETW_STATIC_DISK:
          case IDC_PAGE_PROCTHREADS_STATIC_IO_PRIORITY:
          case IDC_PAGE_PROCTHREADS_STATIC_MEMORY_PRIORITY:
          case IDC_PAGE_PROCTHREADS_STATIC_IO_PRIORITY_VALUE:
            goto LABEL_25;
          default:
            goto LABEL_24;
        }
        goto LABEL_24;
      }
      goto LABEL_25;
    }
    if ( uID > IDS_UI_ACCESS )
    {
      v6 = uID == IDS_CONTROL_FLOW_GUARD;
    }
    else
    {
      if ( uID >= IDS_PROTECTION || uID == IDS_DPI_AWARENESS )
        goto LABEL_25;
      v6 = uID == IDS_VIRUSTOTAL;
    }
  }
  else
  {
    if ( uID == IDS_PATH2 )
      goto LABEL_25;
    if ( uID <= IDS_WINDOW_TITLE )
    {
      if ( uID != IDS_WINDOW_TITLE )
      {
        switch ( uID )
        {
          case IDS_PROCESS:
          case IDS_USER_NAME:
          case IDS_TYPE:
          case IDS_NAME1:
          case IDS_VERSION:
          case IDS_NAME2:
          case IDS_TIME:
            goto LABEL_25;
          default:
            goto LABEL_24;
        }
        goto LABEL_24;
      }
LABEL_25:
      v7 = 0;
      goto LABEL_26;
    }
    if ( uID > IDS_COMPANY_NAME )
    {
      v6 = uID == IDS_PATH;
    }
    else
    {
      if ( uID >= IDS_COMMAND_LINE || uID == IDS_DESCRIPTION )
        goto LABEL_25;
      v6 = uID == IDS_DESCRIPTION2;
    }
  }
  if ( v6 )
    goto LABEL_25;
LABEL_24:
  v7 = 1;
LABEL_26:
  hWnd_1 = hWndIn;
  v6 = v7 == 0;
  nItem = *pnLength;
  ColumnInfo.fmt = !v6;
  *pnLength = nItem + 1;
  SendMessageW(hWnd_1, LVM_INSERTCOLUMNW, nItem, &ColumnInfo);
  SetWindowLongW(hWnd_1, GWLP_USERDATA, *pnLength);
  if ( uID == IDS_VIRUSTOTAL && !gConfig.bCheckVirusTotal )
    MessageBoxW(
      hWnd_1,
      L"You can enable lookup of VirusTotal results for all files displayed in the process and DLL views by selecting the "
       "Check VirusTotal entry in the Options menu or check individual  files on-demand using the process and DLL properties dialogs.",
      L"VirusTotal",
      0x40u);
  return 1;
}

//----- (00FB7790) --------------------------------------------------------
int __cdecl sub_FB7790(HWND hWnd, char a2)
{
  DLLLISTITEMPARAM *pItemParam; // eax
  DLLLISTITEMPARAM *pItemParam_1; // ebx
  int v5; // eax
  tagLVITEMW ItemInfo; // [esp+4h] [ebp-34h]

  memset(&ItemInfo.iItem, 0, 0x30u);
  ItemInfo.mask = 13;
  ItemInfo.iItem = 0x7FFFFFFF;
  ItemInfo.iSubItem = 0;
  ItemInfo.state = 0;
  ItemInfo.stateMask = 0;
  ItemInfo.pszText = -1;
  ItemInfo.iImage = 0;
  pItemParam = malloc(sizeof(DLLLISTITEMPARAM));
  pItemParam_1 = pItemParam;
  if ( !pItemParam )
    return 0;
  qmemcpy(pItemParam, &a2, sizeof(DLLLISTITEMPARAM));
  pItemParam->m_nRefCount = 1;
  pItemParam->field_164 = 0;
  pItemParam->field_168 = 0;
  pItemParam->field_160 = 0;
  pItemParam->m_Type = 1;
  pItemParam->field_8 = gdwRefreshCount + 1;
  ItemInfo.lParam = pItemParam;
  if ( SendMessageW(hWnd, LVM_INSERTITEMW, 0, &ItemInfo) == -1 )
    return 0;
  pItemParam_1->m_Next = 0;
  pItemParam_1->m_Prev = gpDllListItemParamHeader;
  if ( gpDllListItemParamHeader )
    gpDllListItemParamHeader->m_Next = pItemParam_1;
  gpDllListItemParamHeader = pItemParam_1;
  if ( gConfig.bVerifySignatures )
  {
    InterlockedIncrement(&pItemParam_1->m_nRefCount);
    _beginthread(VerifyImageThreadProc, 0, pItemParam_1);
  }
  v5 = 2;
  if ( gConfig.bCheckVirusTotal )
    v5 = 0;
  sub_1001C30(pItemParam_1, ~(pItemParam_1->field_2C >> 1) & 1, v5);
  return 1;
}
// 106A11C: using guessed type int gdwRefreshCount;

//----- (00FB78D0) --------------------------------------------------------
wchar_t *__cdecl sub_FB78D0(HWND a1, wchar_t *a2)
{
  const WCHAR *v2; // eax
  int v3; // eax
  wchar_t *result; // eax
  HWND v5; // esi
  HWND v6; // eax
  LPARAM v7; // [esp+4h] [ebp-270h]
  int v8; // [esp+Ch] [ebp-268h]
  wchar_t *v9; // [esp+18h] [ebp-25Ch]
  LPARAM lParam; // [esp+38h] [ebp-23Ch]
  int v11; // [esp+3Ch] [ebp-238h]
  int v12; // [esp+40h] [ebp-234h]
  int v13; // [esp+44h] [ebp-230h]
  int v14; // [esp+48h] [ebp-22Ch]
  const WCHAR *v15; // [esp+4Ch] [ebp-228h]
  int v16; // [esp+50h] [ebp-224h]
  int v17; // [esp+54h] [ebp-220h]
  wchar_t *v18; // [esp+58h] [ebp-21Ch]
  HWND hWnd; // [esp+6Ch] [ebp-208h]
  wchar_t Dst; // [esp+70h] [ebp-204h]

  hWnd = a1;
  memset(&v11, 0, 0x30u);
  v2 = *(a2 + 9);
  lParam = 13;
  v11 = 0x7FFFFFFF;
  v12 = 0;
  v13 = 0;
  v14 = 0;
  v15 = v2;
  v3 = lstrlenW(v2);
  v17 = 0;
  v16 = v3 + 1;
  result = malloc(0xB8u);
  if ( result )
  {
    qmemcpy(result, a2, 0xB8u);
    v5 = hWnd;
    v18 = result;
    hWnd = SendMessageW(hWnd, 0x104Du, 0, &lParam);
    if ( hWnd == HWND_MESSAGE|0x2 )
    {
      result = 0;
    }
    else
    {
      wsprintf(&Dst, L"%d", *(a2 + 42));
      v8 = 1;
      v9 = &Dst;
      SendMessageW(v5, 0x1074u, hWnd, &v7);
      v8 = 2;
      v9 = a2 + 20;
      SendMessageW(v5, 0x1074u, hWnd, &v7);
      v9 = *(a2 + 45);
      v8 = 3;
      SendMessageW(v5, 0x1074u, hWnd, &v7);
      v6 = GetParent(v5);
      SendMessageW(v6, 0x465u, 0, 0);
      result = 1;
    }
  }
  return result;
}

//----- (00FB7A90) --------------------------------------------------------
int sub_FB7A90(HWND hWnd, ...)
{
  _DWORD *v1; // esi
  int result; // eax
  LPARAM lParam; // [esp+8h] [ebp-10F8h]
  int v4; // [esp+Ch] [ebp-10F4h]
  int v5; // [esp+10h] [ebp-10F0h]
  int v6; // [esp+14h] [ebp-10ECh]
  int v7; // [esp+18h] [ebp-10E8h]
  int v8; // [esp+1Ch] [ebp-10E4h]
  int v9; // [esp+24h] [ebp-10DCh]
  _DWORD *v10; // [esp+28h] [ebp-10D8h]
  char v11; // [esp+3Ch] [ebp-10C4h]
  va_list va; // [esp+110Ch] [ebp+Ch]

  va_start(va, hWnd);
  memmove_0(&v11, va, 0x10C0u);
  memset(&v4, 0, 0x30u);
  lParam = 13;
  v4 = 0x7FFFFFFF;
  v5 = 0;
  v6 = 0;
  v7 = 0;
  v8 = -1;
  v9 = 0;
  v1 = malloc(0x10C0u);
  if ( !v1 )
    return 0;
  memmove_0(v1, &v11, 0x10C0u);
  v1[1] = 2;
  v1[2] = gdwRefreshCount + 1;
  v10 = v1;
  if ( SendMessageW(hWnd, 0x104Du, 0, &lParam) == -1 )
    return 0;
  v1[1071] = 0;
  v1[1070] = dword_106539C;
  if ( dword_106539C )
    *(dword_106539C + 4284) = v1;
  result = 1;
  dword_106539C = v1;
  return result;
}
// 106A11C: using guessed type int gdwRefreshCount;

//----- (00FB7BC0) --------------------------------------------------------
tagTREEVIEWLISTITEMPARAM *__cdecl CTreeList::FindItem(HWND hWnd, LPARAM lParam)
{
  tagTREEVIEWLISTITEMPARAM *pItemParam; // eax
  tagTREEVIEWLISTITEMPARAM *pItemParam_1; // ebx
  WCHAR *v4; // eax
  tagTREEVIEWLISTITEMPARAM *pItemParam_2; // ecx
  CTreeList *pTreeList; // eax
  HICON v7; // ST0C_4
  struct _IMAGELIST *v8; // eax
  int nImage; // eax
  bool v10; // zf
  LRESULT (__stdcall *SendMessageW)(HWND, UINT, WPARAM, LPARAM); // esi
  tagTREEVIEWLISTITEMPARAM *v12; // eax
  LRESULT v13; // eax
  WPARAM v14; // eax
  LVFINDINFOW FindInfo; // [esp+4h] [ebp-18h]

  ::SendMessageW(hWnd, WM_SETREDRAW, 0, 0);
  pItemParam = malloc(sizeof(tagTREEVIEWLISTITEMPARAM));
  pItemParam_1 = pItemParam;
  if ( pItemParam )
  {
    qmemcpy(pItemParam, lParam, sizeof(tagTREEVIEWLISTITEMPARAM));
    pItemParam->nRefCount = 1;
    pItemParam->nListType = 0;
    pItemParam->field_8 = gdwRefreshCount + 1;
    v4 = pItemParam->szProcessName;
    if ( !v4 )
      v4 = pItemParam_1->szProcessName2;
    pItemParam_1->pszComments = ProcessComment_Find(v4);
    pItemParam_1->field_2C = -1;
    pItemParam_1->m_Next = 0;
    pItemParam_1->m_Prev = gpTreeViewListItemParam;
    if ( gpTreeViewListItemParam )
      gpTreeViewListItemParam->m_Next = pItemParam_1;
    gpTreeViewListItemParam = pItemParam_1;
    if ( pItemParam_1->dwProcessId )
    {
      pItemParam_2 = pItemParam_1;
      while ( pItemParam_1->InheritedFromUniqueProcessId != pItemParam_2->dwProcessId
           || *&pItemParam_2->CreateTime > *&pItemParam_1->CreateTime )
      {
        pItemParam_2 = pItemParam_2->m_Prev;
        if ( !pItemParam_2 )
          goto LABEL_17;
      }
      pItemParam_1->pItemParam = pItemParam_2;
      while ( pItemParam_2->dwStyle & TVIF_PARAM )
      {
        pItemParam_2 = pItemParam_2->pItemParam;
        if ( !pItemParam_2 )
          goto LABEL_17;
      }
      pItemParam_1->dwStyle &= -3u;
    }
LABEL_17:
    pTreeList = CTreeList::GetTreeList(hWnd);
    if ( pItemParam_1->hIcon )
    {
      v7 = pItemParam_1->hIcon;
      v8 = CTreeList::GetImageList(pTreeList);
      nImage = ImageList_ReplaceIcon(v8, -1, v7);
    }
    else
    {
      nImage = 0;
    }
    v10 = (pItemParam_1->dwStyle & TVIF_IMAGE) == 0;
    pItemParam_1->nImage = nImage;
    if ( v10
      || (!sub_FC50E0(pItemParam_1->szProcessName2) ? (pItemParam_1->dwStyle &= -2u) : (pItemParam_1->dwStyle |= 1u),
          pItemParam_1->dwStyle & 1 && gConfig.byte_14012ADFE) )
    {
      SendMessageW = ::SendMessageW;
    }
    else
    {
      sub_FB7F20(hWnd, pItemParam_1);
      SendMessageW = ::SendMessageW;
      ::SendMessageW(ghWndTreeListView, 0x2000u, pItemParam_1->field_5B8, pItemParam_1->field_30 != 0);
    }
    v12 = pItemParam_1->pItemParam;
    if ( v12 )
    {
      if ( ++v12->field_30 == 1 )
      {
        if ( pItemParam_1->pItemParam->dwStyle & TVIF_IMAGE )
        {
          FindInfo.flags = 1;
          FindInfo.lParam = pItemParam_1->pItemParam;
          v13 = SendMessageW(ghWndTreeListView, LVM_FINDITEMW, 0xFFFFFFFF, &FindInfo);
          SendMessageW(ghWndTreeListView, LVM_REDRAWITEMS, v13, v13);
          v14 = pItemParam_1->pItemParam->field_5B8;
          if ( v14 )
          {
            SendMessageW(ghWndTreeListView, TREELIST_MSG_2000, v14, 1);
            if ( pItemParam_1->dwStyle & TVIF_IMAGE )
              SendMessageW(ghWndTreeListView, TREELIST_MSG_2001, pItemParam_1->pItemParam->field_5B8, 1);
          }
        }
      }
    }
    pItemParam = pItemParam_1;
  }
  return pItemParam;
}
// 106A11C: using guessed type int gdwRefreshCount;

//----- (00FB7DD0) --------------------------------------------------------
char *__cdecl sub_FB7DD0(HWND hWnd, char a2)
{
  char *result; // eax
  char *v3; // ebx
  LPARAM lParam; // [esp+4h] [ebp-34h]
  int v5; // [esp+8h] [ebp-30h]
  int v6; // [esp+Ch] [ebp-2Ch]
  int v7; // [esp+10h] [ebp-28h]
  int v8; // [esp+14h] [ebp-24h]
  int v9; // [esp+18h] [ebp-20h]
  int v10; // [esp+20h] [ebp-18h]
  char *v11; // [esp+24h] [ebp-14h]

  memset(&v5, 0, 0x30u);
  lParam = 13;
  v5 = 0x7FFFFFFF;
  v6 = 0;
  v7 = 0;
  v8 = 0;
  v9 = -1;
  v10 = 0;
  v11 = 0;
  result = malloc(0x890u);
  v3 = result;
  if ( result )
  {
    qmemcpy(result, &a2, 0x890u);
    v11 = result;
    if ( SendMessageW(hWnd, 0x104Du, 0, &lParam) == -1 )
      v3 = 0;
    result = v3;
  }
  return result;
}

//----- (00FB7E70) --------------------------------------------------------
int __cdecl sub_FB7E70(HWND hWnd, char a2, int a3, int a4, int a5, int a6, int a7, int a8, int a9, int a10, int a11, int a12, int a13, int a14, int a15, int a16, int a17, int a18, int a19, int a20, int a21, int a22, int a23, int a24, int a25, int a26, int a27, int a28, int a29, int a30, int a31, int a32, int a33, int a34, int a35, int a36, int a37, int a38, int a39, int a40, int a41, int a42, int a43, int a44, int a45, int a46, int a47, int a48, int a49, int a50, int a51, int a52, int a53, int a54, int a55, int a56, int a57, int a58, int a59, int a60, int a61, int a62, int a63)
{
  int result; // eax
  _DWORD *v66; // ecx
  LPARAM lParam; // [esp+0h] [ebp-34h]
  int v68; // [esp+4h] [ebp-30h]
  int v69; // [esp+8h] [ebp-2Ch]
  int v70; // [esp+Ch] [ebp-28h]
  int v71; // [esp+10h] [ebp-24h]
  int v72; // [esp+14h] [ebp-20h]
  int v73; // [esp+1Ch] [ebp-18h]
  int v74; // [esp+20h] [ebp-14h]

  memset(&v68, 0, 0x30u);
  lParam = 13;
  v68 = 0x7FFFFFFF;
  v69 = 0;
  v70 = 0;
  v71 = 0;
  v72 = -1;
  v73 = 0;
  v74 = 0;
  result = malloc(0x290u);
  if ( result )
  {
    qmemcpy(result, &a2, 0x290u);
    v66 = a65;
    v74 = result;
    *(result + 652) = *a65;
    *v66 = result;
    result = SendMessageW(hWnd, 0x104Du, 0, &lParam) != -1;
  }
  return result;
}
// FB7E70: too many input arguments, some ignored

//----- (00FB7F20) --------------------------------------------------------
int __cdecl sub_FB7F20(HWND hWnd, tagTREEVIEWLISTITEMPARAM *pItemParam)
{
  int result; // eax
  tagTREEVIEWLISTITEMPARAM *v3; // ecx
  tagTREEVIEWLISTITEMPARAM *v4; // eax
  LRESULT v5; // eax
  int v6; // eax
  bool v7; // zf
  tagTREEVIEWLISTITEMPARAM *v8; // eax
  LPARAM lParam; // [esp+4h] [ebp-10h]
  tagTREEVIEWLISTITEMPARAM *v10; // [esp+8h] [ebp-Ch]
  int (__cdecl *v11)(_DWORD *, _DWORD *); // [esp+Ch] [ebp-8h]
  bool v12; // [esp+13h] [ebp-1h]

  v12 = gConfig.bShowProcessTree != 0;
  result = pItemParam->field_5B8;
  if ( !result )
  {
    if ( gConfig.bShowProcessTree && (v3 = pItemParam->pItemParam) != 0 && v3->dwStyle & 2 )
    {
      v4 = v3->field_5B8;
      if ( !v4 )
      {
        if ( pItemParam->dwStyle & TVIF_IMAGE )
          v4 = sub_FB7F20(hWnd, pItemParam->pItemParam);
        else
          v4 = pItemParam;
      }
    }
    else
    {
      v4 = 0;
    }
    lParam = v4;
    v10 = pItemParam;
    v11 = sub_FC1AF0;
    v5 = SendMessageW(hWnd, TREELIST_MSG_2004, 0, &lParam);
    pItemParam->field_5B8 = v5;
    v6 = SendMessageW(hWnd, TREELIST_MSG_2005, v5, 0);
    v7 = v12 == 0;
    pItemParam->field_2C = v6;
    if ( v7 )
    {
      if ( pItemParam->field_30 )
        SendMessageW(hWnd, TREELIST_MSG_2000, pItemParam->field_5B8, 1);
      SendMessageW(hWnd, TREELIST_MSG_2001, pItemParam->field_5B8, (pItemParam->dwStyle >> 2) & 1);
      v8 = pItemParam->pItemParam;
      if ( v8 && !v8->field_30 )
      {
        if ( !v8->field_5B8 )
          sub_FB7F20(hWnd, pItemParam->pItemParam);
        SendMessageW(hWnd, TREELIST_MSG_2000, pItemParam->pItemParam->field_5B8, 1);
        SendMessageW(
          hWnd,
          TREELIST_MSG_2001,
          pItemParam->pItemParam->field_5B8,
          (pItemParam->pItemParam->dwStyle >> TVIF_IMAGE) & 1);
      }
    }
    else
    {
      if ( pItemParam->field_30 )
        SendMessageW(hWnd, TREELIST_MSG_2000, pItemParam->field_5B8, 1);
      SendMessageW(hWnd, TREELIST_MSG_2001, pItemParam->field_5B8, (pItemParam->dwStyle >> 2) & 1);
    }
    result = pItemParam->field_5B8;
  }
  return result;
}

//----- (00FB8070) --------------------------------------------------------
void __cdecl TreeViewItemParam_InitGraph(tagTREEVIEWLISTITEMPARAM *pItem)
{
  CGraphData *v1; // eax
  CGraphData *v2; // eax
  int v3; // eax
  CGraphData *v4; // eax
  CGraphData *v5; // eax
  CGraphData *v6; // eax
  CGraphData *v7; // eax
  CGraphData *v8; // eax
  CGraphData *v9; // eax

  if ( !pItem->pGraphData1 )
  {
    v1 = InitGraphData(1, 2, 0);
    pItem->pGraphData1 = v1;
    v1->m_nItemID = 0;
    pItem->pGraphData1->m_Color = 0x3C943C;
    pItem->pGraphData1->m_dbMemorySize = db_onehundred;
    v2 = pItem->pGraphData1;
    if ( v2->m_nChildID == 2 )
    {
      v2->m_Item[0].Color = 255;
      pItem->pGraphData1->m_Item[0].dbMemorySize = db_onehundred;
    }
    v3 = pItem->dwProcessId;
    if ( v3 )
    {
      if ( v3 == -10 )
        pItem->pGraphData1->m_Color = 255;
    }
    else
    {
      pItem->pGraphData1->m_Item[0].Color = 0x3C943C;
    }
  }
  if ( !pItem->pGraphData2 )
  {
    v4 = InitGraphData(1, 1, 0);
    pItem->pGraphData2 = v4;
    v4->m_nItemID = 1;
    pItem->pGraphData2->m_Color = 0xAAAA;
    pItem->pGraphData2->m_dbMemorySize = db_onehundred;
  }
  if ( !pItem->pGraphDataPROCCPU )
  {
    v5 = InitGraphData(1, 2, 0);
    pItem->pGraphDataPROCCPU = v5;
    v5->m_nItemID = 2;
    pItem->pGraphDataPROCCPU->m_Color = 0xC83C1E;
    pItem->pGraphDataPROCCPU->m_dbMemorySize = db_one;
    pItem->pGraphDataPROCCPU->m_Item[0].Color = 0xC83CC8;
    pItem->pGraphDataPROCCPU->m_Item[0].dbMemorySize = db_one;
  }
  if ( gdwAdapterRuntingTime )
  {
    v6 = InitGraphData(1, 1, 0);
    pItem->pGraphData4 = v6;
    v6->m_nItemID = 4;
    pItem->pGraphData4->m_Color = 0x8080FF;
    pItem->pGraphData4->m_dbMemorySize = db_onehundred;
    v7 = InitGraphData(1, 1, 0);
    pItem->pGraphData5 = v7;
    v7->m_nItemID = 7;
    pItem->pGraphData5->m_Color = 0xFFC080;
    pItem->pGraphData5->m_dbMemorySize = db_one;
    v8 = InitGraphData(1, 1, 0);
    pItem->pGraphData6 = v8;
    v8->m_nItemID = 5;
    pItem->pGraphData6->m_Color = 0xAAAA;
    pItem->pGraphData6->m_dbMemorySize = db_one;
    v9 = InitGraphData(1, 1, 0);
    pItem->pGraphData7 = v9;
    v9->m_nItemID = 6;
    pItem->pGraphData7->m_Color = 0x4080FF;
    pItem->pGraphData7->m_dbMemorySize = db_one;
  }
}
// 103CDC0: using guessed type double db_onehundred;

//----- (00FB82A0) --------------------------------------------------------
struct _IMAGELIST *InitSortableImageList()
{
  struct _IMAGELIST *himl; // ST20_4
  HICON v1; // edi
  HICON v2; // ebx

  himl = ImageList_Create(16, 16, 1u, 256, 256);
  v1 = LoadIconW(ghInstance, 0xCB);
  v2 = LoadIconW(ghInstance, 0x71);
  ImageList_ReplaceIcon(himl, -1, v1);
  ImageList_ReplaceIcon(himl, -1, v2);
  return himl;
}

//----- (00FB8300) --------------------------------------------------------
HWND __cdecl CreateListCtrl(HWND hWnd, DWORD dwStyle, int a3, int a4, LONG dwNewLong, HMENU hMenu)
{
  HWND v6; // eax
  HWND v7; // esi
  HFONT v9; // ST28_4
  HWND v10; // eax
  HWND v11; // eax
  struct _IMAGELIST *v12; // esi
  LONG v13; // eax
  HWND v14; // [esp+8h] [ebp-18h]
  struct tagRECT Rect; // [esp+Ch] [ebp-14h]

  _mm_storeu_si128(&Rect, 0i64);
  InitCommonControls();
  GetClientRect(hWnd, &Rect);
  v6 = CreateWindowExW(
         0,
         L"SysListView32",
         &gszNullString,
         dwStyle,
         Rect.left,
         Rect.top,
         Rect.right,
         Rect.bottom,
         hWnd,
         hMenu,
         ghInstance,
         0);
  v7 = v6;
  v14 = v6;
  if ( !v6 )
    return 0;
  if ( !CTreeView::InitListHeader(v6, a3, a4, dwNewLong) )
  {
    DestroyWindow(v7);
    return 0;
  }
  SetClassLongW(v7, -12, 0);
  gOldListWndProc = SetWindowLongW(v7, -4, Proxy_ListCtrlWndProc);
  SendMessageW(v7, 0x1036u, 0x4030u, 16432);
  v9 = ghConfigFont;
  v10 = SendMessageW(v7, 0x101Fu, 0, 0);
  SendMessageW(v10, 0x30u, v9, 0);
  SendMessageW(v7, 0x30u, ghConfigFont, 0);
  v11 = SendMessageW(v7, 0x104Eu, 0, 0);
  CTreeList::InitToolTips(v11);
  v12 = InitSortableImageList();
  v13 = GetWindowLongW(v14, -16);
  SetWindowLongW(v14, -16, v13 | 0x40);
  SendMessageW(v14, 0x1003u, 1u, v12);
  return v14;
}

//----- (00FB8460) --------------------------------------------------------
void __cdecl sub_FB8460(tagTREEVIEWLISTITEMPARAM *a1)
{
  tagTREEVIEWLISTITEMPARAM *v1; // eax
  bool v2; // zf
  LRESULT nItem; // eax
  int v4; // eax
  tagTREEVIEWLISTITEMPARAM *v5; // ecx
  tagTREEVIEWLISTITEMPARAM *v6; // ecx
  tagTREEVIEWLISTITEMPARAM *i; // eax
  LVFINDINFOW FindInfo; // [esp+8h] [ebp-18h]

  SendMessageW(ghWndTreeListView, 0xBu, 0, 0);
  byte_10653B5 = 1;
  v1 = a1->pItemParam;
  if ( v1 )
  {
    v2 = v1->field_30-- == 1;
    if ( v2 )
    {
      if ( a1->pItemParam->dwStyle & 2 )
      {
        FindInfo.lParam = a1->pItemParam;
        FindInfo.flags = LVFI_PARAM;
        nItem = SendMessageW(ghWndTreeListView, LVM_FINDITEMW, 0xFFFFFFFF, &FindInfo);
        SendMessageW(ghWndTreeListView, LVM_REDRAWITEMS, nItem, nItem);
        v4 = a1->pItemParam->field_5B8;
        if ( v4 )
          SendMessageW(ghWndTreeListView, 0x2000u, v4, 0);
      }
    }
  }
  v5 = a1->m_Next;
  if ( v5 )
    v5->m_Prev = a1->m_Prev;
  else
    gpTreeViewListItemParam = a1->m_Prev;
  v6 = a1->m_Prev;
  if ( v6 )
    v6->m_Next = a1->m_Next;
  for ( i = gpTreeViewListItemParam; i; i = i->m_Prev )
  {
    if ( i->InheritedFromUniqueProcessId == a1->dwProcessId )
    {
      i->pItemParam = 0;
      if ( gConfig.bShowAllUsers || i->dwStyle & 0x40 )
        i->dwStyle |= 2u;
      if ( !(a1->dwStyle & 4) )
        i->dwStyle &= 0xFFFFFFFB;
    }
  }
  TreeViewListItemParam_Release(a1);
}
// 10653B5: using guessed type char byte_10653B5;

//----- (00FB8570) --------------------------------------------------------
LRESULT __cdecl sub_FB8570(HWND hWnd, int a2)
{
  LRESULT result; // eax
  LPARAM lParam; // [esp+Ch] [ebp-18h]
  int v4; // [esp+14h] [ebp-10h]

  lParam = 1;
  v4 = a2;
  result = SendMessageW(hWnd, 0x1053u, 0xFFFFFFFF, &lParam);
  if ( result >= 0 )
  {
    SendMessageW(hWnd, 0x1008u, result, 0);
    result = *(a2 + 84);
    if ( result )
    {
      if ( *(result + 48) )
      {
        result = *(result + 1464);
        if ( result )
        {
          result = SendMessageW(hWnd, 0x2002u, result, 0);
          if ( !result )
          {
            SendMessageW(hWnd, 0x2000u, *(*(a2 + 84) + 1464), 1);
            result = SendMessageW(hWnd, 0x2003u, *(*(a2 + 84) + 1464), 0);
          }
        }
      }
    }
  }
  return result;
}

//----- (00FB8600) --------------------------------------------------------
void __cdecl DLLLISTITEMPARAM_Release(tagTREEVIEWLISTITEMPARAM *lpAddend)
{
  if ( !InterlockedDecrement(&lpAddend->field_0) )
  {
    if ( *lpAddend->gap154 )
      free(*lpAddend->gap154);
    if ( lpAddend->field_150 )
      free(lpAddend->field_150);
    if ( *&lpAddend->gap154[4] )
      free(*&lpAddend->gap154[4]);
    if ( *&lpAddend->gap154[16] )
      free(*&lpAddend->gap154[16]);
    if ( *&lpAddend->gap154[20] )
      free(*&lpAddend->gap154[20]);
    if ( *&lpAddend->gap154[8] )
      free(*&lpAddend->gap154[8]);
    free(lpAddend);
  }
}

//----- (00FB8690) --------------------------------------------------------
void __cdecl TreeViewListItemParam_Release(tagTREEVIEWLISTITEMPARAM *a1)
{
  CGraphData *v1; // eax
  CGraphData *v2; // eax
  CGraphData *v3; // eax

  if ( !InterlockedDecrement(&a1->nRefCount) )
  {
    if ( a1->hIcon )
      DestroyIcon(a1->hIcon);
    if ( a1->hFileIcon )
      DestroyIcon(a1->hFileIcon);
    if ( a1->field_344 )
      free(a1->field_344);
    if ( a1->field_314 )
      free(a1->field_314);
    if ( a1->pszTitle )
      free(a1->pszTitle);
    if ( a1->pNetCclrInfo )
      free(a1->pNetCclrInfo);
    if ( a1->szProcessName )
      free(a1->szProcessName);
    if ( a1->szProcessName2 )
      free(a1->szProcessName2);
    if ( a1->pszName )
      free(a1->pszName);
    if ( a1->pszSystemName )
      free(a1->pszSystemName);
    if ( a1->pszComments )
      free(a1->pszComments);
    if ( a1->pszCommandLine )
      free(a1->pszCommandLine);
    if ( a1->pszEnvBlock )
      free(a1->pszEnvBlock);
    if ( a1->pszCurrentDirectory )
      free(a1->pszCurrentDirectory);
    if ( a1->field_350 )
      free(a1->field_350);
    if ( a1->field_354 )
      free(a1->field_354);
    if ( a1->field_358 )
      free(a1->field_358);
    if ( a1->m_ExtensionName )
      free(a1->m_ExtensionName);
    if ( a1->pszFullUserName )
      free(a1->pszFullUserName);
    if ( a1->field_334 )
      free(a1->field_334);
    if ( a1->pszPackageFullName )
      free(a1->pszPackageFullName);
    if ( a1->field_33C )
      free(a1->field_33C);
    if ( a1->bSupportWMIProviders )
      sub_10039A0(&a1->bSupportWMIProviders);
    if ( a1->field_3A0 )
      free(a1->field_3A0);
    v1 = a1->pGraphData1;
    if ( v1 )
      GraphData_Release(v1, 1);
    v2 = a1->pGraphData2;
    if ( v2 )
      GraphData_Release(v2, 1);
    v3 = a1->pGraphDataPROCCPU;
    if ( v3 )
      GraphData_Release(v3, 1);
    free(a1);
  }
}

//----- (00FB88B0) --------------------------------------------------------
char __cdecl CMainWnd::DrawList(LPDRAWITEMSTRUCT pDrawItemStruct)
{
  LONG nColumn; // eax
  int nItem; // ecx
  WPARAM v3; // edi
  char v4; // si
  unsigned int v6; // ecx
  __m128i v7; // xmm1
  char *v8; // edx
  unsigned int v9; // eax
  __m128i v10; // xmm0
  unsigned int v11; // esi
  unsigned int v12; // edi
  LONG v13; // ecx
  unsigned int v14; // edi
  __m128i v15; // xmm1
  char *v16; // ecx
  unsigned int v17; // eax
  __m128i v18; // xmm0
  DWORD v19; // edi
  WPARAM v20; // eax
  HWND v21; // edi
  COLORREF v22; // eax
  COLORREF v23; // eax
  LPARAM v24; // [esp+Ch] [ebp-43B0h]
  WPARAM v25; // [esp+14h] [ebp-43A8h]
  wchar_t *v26; // [esp+20h] [ebp-439Ch]
  int v27; // [esp+24h] [ebp-4398h]
  tagLVITEMW lvitem; // [esp+40h] [ebp-437Ch]
  LVCOLUMNW ColumnInfo; // [esp+74h] [ebp-4348h]
  unsigned int v30; // [esp+94h] [ebp-4328h]
  COLORREF TextColor; // [esp+98h] [ebp-4324h]
  DWORD bFocused; // [esp+9Ch] [ebp-4320h]
  COLORREF BackColor; // [esp+A0h] [ebp-431Ch]
  HWND hWnd; // [esp+A4h] [ebp-4318h]
  RECT rect; // [esp+A8h] [ebp-4314h]
  LPARAM lParam[4]; // [esp+B8h] [ebp-4304h]
  char v37; // [esp+C8h] [ebp-42F4h]
  WPARAM wParam[4]; // [esp+238h] [ebp-4184h]
  char v39; // [esp+248h] [ebp-4174h]
  wchar_t Src; // [esp+3B8h] [ebp-4004h]

  hWnd = pDrawItemStruct->hwndItem;
  nColumn = GetWindowLongW(hWnd, GWLP_USERDATA);
  nItem = pDrawItemStruct->itemID;
  v3 = nColumn;
  v30 = nColumn;
  lvitem.mask = 0xE;
  lvitem.iItem = nItem;
  lvitem.iSubItem = 0;
  SendMessageW(hWnd, LVM_GETITEMW, 0, &lvitem);
  LOBYTE(bFocused) = pDrawItemStruct->itemState & LVIS_FOCUSED;
  v4 = bFocused;
  QueryListItemColor(hWnd, pDrawItemStruct->itemData, bFocused, &TextColor, &BackColor);
  SetTextColor(pDrawItemStruct->hDC, TextColor);
  SetBkMode(pDrawItemStruct->hDC, 2);
  SetBkColor(pDrawItemStruct->hDC, BackColor);
  if ( hWnd == ghWndTreeListView )
    return sub_FB56D0(
             v4,
             pDrawItemStruct->itemData,
             gConfig.dwProcessColumnMap[pDrawItemStruct->itemAction],
             pDrawItemStruct->hDC,
             &pDrawItemStruct->rcItem);
  if ( !SendMessageW(hWnd, LVM_GETCOLUMNORDERARRAY, v3, wParam) )
  {
    v6 = 0;
    if ( v3 )
    {
      if ( v3 >= 8 )
      {
        v7 = _mm_load_si128(&gIntArray);
        v8 = &v39;
        do
        {
          v9 = v6 + 4;
          v8 += 32;
          v10 = _mm_add_epi32(_mm_shuffle_epi32(_mm_cvtsi32_si128(v6), 0), v7);
          v6 += 8;
          _mm_storeu_si128(v8 - 3, v10);
          _mm_storeu_si128(v8 - 2, _mm_add_epi32(_mm_shuffle_epi32(_mm_cvtsi32_si128(v9), 0), v7));
        }
        while ( v6 < v3 - (v3 & 7) );
      }
      for ( ; v6 < v3; ++v6 )
        wParam[v6] = v6;
    }
  }
  v11 = 0;
  BackColor = 0;
  if ( v3 )
  {
    do
    {
      ColumnInfo.mask = 3;
      v12 = v11;
      SendMessageW(hWnd, LVM_GETCOLUMNW, wParam[v11], &ColumnInfo);
      v13 = pDrawItemStruct->rcItem.left;
      bFocused = ColumnInfo.cx;
      rect.left = v13 + BackColor;
      rect.top = pDrawItemStruct->rcItem.top;
      rect.bottom = pDrawItemStruct->rcItem.bottom;
      rect.right = BackColor + v13 + ColumnInfo.cx;
      if ( hWnd == ghWndDllsListCtrl )
      {
        v14 = GetWindowLongW(hWnd, -21);
        if ( !SendMessageW(hWnd, LVM_GETCOLUMNORDERARRAY, v14, lParam) )
        {
          v11 = 0;
          if ( v14 )
          {
            if ( v14 >= 8 )
            {
              v15 = _mm_load_si128(&gIntArray);
              v16 = &v37;
              do
              {
                v17 = v11 + 4;
                v16 += 32;
                v18 = _mm_add_epi32(_mm_shuffle_epi32(_mm_cvtsi32_si128(v11), 0), v15);
                v11 += 8;
                _mm_storeu_si128(v16 - 3, v18);
                _mm_storeu_si128(v16 - 2, _mm_add_epi32(_mm_shuffle_epi32(_mm_cvtsi32_si128(v17), 0), v15));
              }
              while ( v11 < v14 - (v14 & 7) );
            }
            for ( ; v11 < v14; ++v11 )
              lParam[v11] = v11;
          }
        }
        if ( gConfig.dwDllColumnMap[lParam[v11]] == 1670 )
        {
          v19 = pDrawItemStruct->itemData;
          if ( sub_1001820(*(v19 + 364)) )
          {
            if ( sub_1002910(*(v19 + 364)) )
              SetTextColor(pDrawItemStruct->hDC, 0xFFu);
            else
              SetTextColor(pDrawItemStruct->hDC, 0xFF0000u);
            SelectObject(pDrawItemStruct->hDC, ghConfigUnderlineFont);
          }
        }
        else
        {
          SetTextColor(pDrawItemStruct->hDC, TextColor);
          SelectObject(pDrawItemStruct->hDC, ghConfigFont);
        }
        v12 = v11;
      }
      v27 = 0x1FFF;
      Src = 0;
      v20 = wParam[v12];
      v21 = hWnd;
      v25 = v20;
      v26 = &Src;
      SendMessageW(hWnd, LVM_GETITEMTEXTW, pDrawItemStruct->itemID, &v24);
      sub_FB55D0(pDrawItemStruct->hDC, &Src, &rect, ColumnInfo.fmt & 1);
      ++v11;
      BackColor += bFocused;
    }
    while ( v11 < v30 );
  }
  else
  {
    v21 = hWnd;
  }
  if ( pDrawItemStruct->itemState & 1 )
  {
    v22 = GetSysColor(8);
    SetTextColor(pDrawItemStruct->hDC, v22);
    v23 = GetSysColor(5);
    SetBkColor(pDrawItemStruct->hDC, v23);
  }
  if ( v21 == ghWndTreeListView )
  {
    rect.left = 0;
    SendMessageW(ghWndTreeListView, LVM_GETITEMRECT, 0, &rect);
    if ( rect.top != dword_106A338 )
    {
      dword_106A338 = rect.top;
      InvalidateRect(ghWndTreeListView, 0, 0);
    }
  }
  return 1;
}
// 103EA50: using guessed type RECT gIntArray;
// 106A338: using guessed type int dword_106A338;

//----- (00FB8D00) --------------------------------------------------------
int __cdecl UpdateMenuStatus(char bEnabled, int nPos)
{
  HMENU v2; // eax
  HMENU hSubMenu; // eax
  HMENU hSubMenu_1; // ebx
  int nCount; // eax
  UINT nIndex; // edi
  WPARAM uID; // esi
  int nCount_1; // [esp+8h] [ebp-4h]

  v2 = GetMenu(ghMainWnd);
  hSubMenu = GetSubMenu(v2, nPos);
  hSubMenu_1 = hSubMenu;
  nCount = GetMenuItemCount(hSubMenu);
  nIndex = 0;
  nCount_1 = nCount;
  if ( nCount > 0 )
  {
    while ( 1 )
    {
      nCount = GetMenuItemID(hSubMenu_1, nIndex);
      uID = nCount;
      if ( nCount == IDM_VIEW_SHOW_UNNAMED_HANDLES_AND_MAPPINGS || nCount == IDM_OPTIONS_HIGHLIGHT_RELOCATED_DLLS )
        goto LABEL_9;
      nCount = EnableMenuItem(hSubMenu_1, nIndex, (bEnabled == 0) | MF_BYPOSITION);
      if ( uID == IDM_PROCESS_PROPERTIES )
        break;
      if ( uID == IDM_PROCESS_KILL_PROCESS )
        goto LABEL_8;
LABEL_9:
      if ( ++nIndex >= nCount_1 )
        return nCount;
    }
    uID = IDM_VIEW_PROCESS_PROPERTIES;
LABEL_8:
    nCount = SendMessageW(ghWndToolbar, TB_ENABLEBUTTON, uID, bEnabled);
    goto LABEL_9;
  }
  return nCount;
}

//----- (00FB8DA0) --------------------------------------------------------
BOOL __cdecl sub_FB8DA0(tagTREEVIEWLISTITEMPARAM *pItemParam)
{
  tagTREEVIEWLISTITEMPARAM *i; // edx
  tagTREEVIEWLISTITEMPARAM *v2; // eax
  char v3; // bl

  SendMessageW(ghWndTreeListView, WM_SETREDRAW, 0, 0);
  for ( i = gpTreeViewListItemParam; i; i = i->m_Prev )
  {
    v2 = i->pItemParam;
    v3 = 1;
    if ( v2 )
    {
      while ( 1 )
      {
        v3 = (v2->dwStyle & 4) != 0 ? v3 : 0;
        if ( v2 == pItemParam )
          break;
        v2 = v2->pItemParam;
        if ( !v2 )
          goto LABEL_11;
      }
      if ( v3 && (gConfig.bShowAllUsers || i->dwStyle & 0x40) )
        i->dwStyle |= 2u;
      else
        i->dwStyle &= -3u;
    }
LABEL_11:
    ;
  }
  byte_10653B5 = 1;
  return SetEvent(ghTimerRefreshEvent);
}
// 10653B5: using guessed type char byte_10653B5;

//----- (00FB8E30) --------------------------------------------------------
char __cdecl ProcStrings_FindItem(HWND hDlg, HWND hWndList, tagFINDREPLACEW *pFindReplace, LPCWSTR lpszFindWhat, PBOOL pbFound, wchar_t *pszBuffer)
{
  tagFINDREPLACEW *FindrePlace; // ebx
  char fDownFind; // al
  LRESULT nCount; // esi
  int v9; // eax
  LRESULT nItemCount; // eax
  const wchar_t *lpstrFindWhat; // ST0C_4
  HWND hWndListCtrl; // edi
  int v14; // esi
  unsigned int v15; // kr00_4
  const wchar_t *v16; // edi
  LPWSTR v17; // edx
  int v18; // esi
  WCHAR v19; // ax
  int v20; // esi
  wchar_t *v21; // eax
  int v22; // eax
  LPWSTR v23; // edx
  WCHAR v24; // ax
  wchar_t *v25; // ebx
  tagFINDREPLACEW *v26; // esi
  const wchar_t *v27; // ecx
  int v28; // edx
  wchar_t v29; // ax
  int v30; // eax
  wchar_t v31; // ax
  unsigned int v32; // kr04_4
  LPWSTR v33; // edx
  int v34; // esi
  WCHAR v35; // ax
  signed int v36; // ecx
  HWND hWndListCtrl_1; // ebx
  HWND v38; // ST00_4
  LRESULT i; // eax
  WPARAM v40; // edi
  tagLVCOLUMNW ColumnInfo; // [esp+Ch] [ebp-427Ch]
  LVITEMW Item; // [esp+2Ch] [ebp-425Ch]
  LRESULT nNumberItem; // [esp+60h] [ebp-4228h]
  WPARAM nColumnIndex; // [esp+64h] [ebp-4224h]
  tagFINDREPLACEW *FindReplace; // [esp+68h] [ebp-4220h]
  unsigned int v46; // [esp+6Ch] [ebp-421Ch]
  HWND hWndDlg; // [esp+70h] [ebp-4218h]
  PBOOL pfbFound; // [esp+74h] [ebp-4214h]
  HWND hWndLC; // [esp+78h] [ebp-4210h]
  WPARAM nItem; // [esp+7Ch] [ebp-420Ch]
  char bDownFind; // [esp+83h] [ebp-4205h]
  wchar_t v52[8192]; // [esp+84h] [ebp-4204h]
  __int16 Text[256]; // [esp+4084h] [ebp-204h]

  FindrePlace = pFindReplace;
  hWndDlg = hDlg;
  pfbFound = pbFound;
  fDownFind = pFindReplace->Flags & FR_DOWN;
  hWndLC = hWndList;
  FindReplace = pFindReplace;
  bDownFind = fDownFind;
  nItem = SendMessageW(hWndList, LVM_GETNEXTITEM, 0xFFFFFFFF, 2);
  nCount = SendMessageW(hWndList, LVM_GETITEMCOUNT, 0, 0);
  if ( (nItem & 0x80000000) != 0 )
  {
    if ( bDownFind )
    {
      nItem = 0;
    }
    else
    {
      if ( *pfbFound )
      {
__FoundNothingAndQuit:
        wsprintf(Text, L"Cannot find string \"%s\"", FindrePlace->lpstrFindWhat);
        MessageBoxW(hWndDlg, Text, L"Process Explorer", 0x30u);
        return 0;
      }
      nItem = nCount;
    }
  }
  if ( *pfbFound )
  {
    v9 = wcscmp(lpszFindWhat, pszBuffer);
    if ( v9 )
      v9 = -(v9 < 0) | 1;
    if ( !v9 )
    {
      if ( bDownFind )
      {
        if ( ++nItem >= nCount )
          goto __FoundNothingAndQuit;
      }
      else if ( (--nItem & 0x80000000) != 0 )
      {
        goto __FoundNothingAndQuit;
      }
    }
  }
  nItemCount = SendMessageW(hWndLC, LVM_GETITEMCOUNT, 0, 0);
  lpstrFindWhat = pFindReplace->lpstrFindWhat;
  nNumberItem = nItemCount;
  wcscpy_s(pszBuffer, 0x2000u, lpstrFindWhat);
  hWndListCtrl = hWndLC;
  while ( 1 )
  {
    ColumnInfo.mask = 2;
    v14 = 0;
    nColumnIndex = 0;
    if ( SendMessageW(hWndListCtrl, LVM_GETCOLUMNW, 0, &ColumnInfo) )
      break;
LABEL_46:
    v36 = 2 * (bDownFind != 0) - 1 + nItem;
    nItem = v36;
    if ( v36 <= 0 || v36 == nNumberItem + 1 )
      goto __FoundNothingAndQuit;
  }
  while ( 1 )
  {
    Item.iSubItem = v14;
    v52[0] = 0;
    Item.pszText = v52;
    Item.cchTextMax = 0x2000;
    SendMessageW(hWndListCtrl, LVM_GETITEMTEXTW, nItem, &Item);
    v15 = wcslen(v52);
    v16 = FindrePlace->lpstrFindWhat;
    v17 = FindrePlace->lpstrFindWhat;
    v18 = (v17 + 1);
    do
    {
      v19 = *v17;
      ++v17;
    }
    while ( v19 );
    if ( v15 >= (v17 - v18) >> 1 )
    {
      if ( !(FindrePlace->Flags & 2) )
      {
        v23 = FindrePlace->lpstrFindWhat;
        v46 = 0;
        do
        {
          v24 = *v23;
          ++v23;
        }
        while ( v24 );
        if ( v15 - (v23 - (v16 + 1)) != -1 )
        {
          v25 = v52;
          do
          {
            v26 = FindReplace;
            v27 = v16;
            v28 = (v16 + 1);
            if ( FindReplace->Flags & 4 )
            {
              do
              {
                v29 = *v27;
                ++v27;
              }
              while ( v29 );
              v30 = wcsncmp(v25, v16, (v27 - v28) >> 1);
            }
            else
            {
              do
              {
                v31 = *v27;
                ++v27;
              }
              while ( v31 );
              v30 = _wcsnicmp(v25, v16, (v27 - v28) >> 1);
            }
            if ( v30 == 0 )
              goto LABEL_49;
            ++v46;
            ++v25;
            v32 = wcslen(v52);
            v16 = v26->lpstrFindWhat;
            v33 = v26->lpstrFindWhat;
            v34 = (v33 + 1);
            do
            {
              v35 = *v33;
              ++v33;
            }
            while ( v35 );
          }
          while ( v46 < v32 - ((v33 - v34) >> 1) + 1 );
          FindrePlace = FindReplace;
        }
        goto LABEL_45;
      }
      v20 = 0;
      if ( v52[0] )
        break;
    }
LABEL_45:
    hWndListCtrl = hWndLC;
    v14 = nColumnIndex++ + 1;
    if ( !SendMessageW(hWndLC, LVM_GETCOLUMNW, nColumnIndex, &ColumnInfo) )
      goto LABEL_46;
  }
  v21 = v52;
  if ( !v52[0] )
    goto LABEL_24;
  while ( 1 )
  {
    do
    {
      if ( *v21 == 32 )
        break;
      v21 = &v52[++v20];
    }
    while ( v52[v20] );
LABEL_24:
    if ( FindrePlace->Flags & 4 )
    {
      v22 = wcscmp(v52, FindrePlace->lpstrFindWhat);
      if ( v22 )
        v22 = -(v22 < 0) | 1;
    }
    else
    {
      v22 = _wcsicmp(v52, FindrePlace->lpstrFindWhat);
    }
    if ( v22 == 0 )
      break;
    v21 = &v52[++v20];
    if ( !v52[v20] )
      goto LABEL_45;
  }
LABEL_49:
  hWndListCtrl_1 = hWndLC;
  v38 = hWndLC;
  *pfbFound = 1;
  for ( i = SendMessageW(v38, LVM_GETNEXTITEM, 0xFFFFFFFF, 2);
        i != -1;
        i = SendMessageW(hWndListCtrl_1, LVM_GETNEXTITEM, 0xFFFFFFFF, 2) )
  {
    Item.stateMask = 3;
    Item.state = 0;
    SendMessageW(hWndListCtrl_1, LVM_SETITEMSTATE, i, &Item);
  }
  v40 = nItem;
  Item.stateMask = 3;
  Item.state = 3;
  SendMessageW(hWndListCtrl_1, LVM_SETITEMSTATE, nItem, &Item);
  SendMessageW(hWndListCtrl_1, LVM_ENSUREVISIBLE, v40, 0);
  SetFocus(hWndListCtrl_1);
  return 1;
}

//----- (00FB9300) --------------------------------------------------------
void InitDrawEngine()
{
  int index; // esi
  int v1; // eax
  int v2; // ST10_4
  signed int v3; // esi
  int v4; // ST10_4
  signed int v5; // esi
  int v6; // ST10_4
  HGDIOBJ v7; // eax
  int v8; // eax
  int v9; // eax
  unsigned __int16 v10; // cx
  signed int v11; // ecx
  int v12; // eax
  unsigned __int16 v13; // cx
  signed int v14; // ecx
  int nItem; // eax
  unsigned __int16 v16; // cx
  signed int uID_2; // ecx
  int v18; // eax
  unsigned __int16 v19; // cx
  signed int uID_1; // ecx
  DWORD dwOpacity; // eax
  COLORREF v22; // eax
  int index_1; // edi
  SHORT *pwProcessColumns; // ebx
  int *pdwProcessColumnMap; // esi
  int index_2; // esi
  signed int index_3; // edi
  int uID; // eax
  int dwIndex_2; // esi
  CRegVar *var; // edi
  tagRegKeyInfo KeyInfo; // [esp+Ch] [ebp-768h]
  HKEY hSubKey; // [esp+18h] [ebp-75Ch]
  DWORD dwValue[446]; // [esp+1Ch] [ebp-758h]
  tagLOGFONTW LogFont; // [esp+714h] [ebp-60h]

  RegDeleteKeyW(HKEY_CURRENT_USER, L"Software\\Systems Internals\\Process Explorer");
  memset(&gConfig, 0, 0x47E0u);
  gConfig.WindowPlacement[0].showCmd = SW_SHOWNORMAL;
  gConfig.WindowPlacement[0].rcNormalPosition.top = MulDiv(50, gLogPixelSize.y, 96);
  gConfig.WindowPlacement[0].rcNormalPosition.bottom = MulDiv(650, gLogPixelSize.y, 96);
  gConfig.WindowPlacement[0].rcNormalPosition.left = MulDiv(100, gLogPixelSize.x, 96);
  gConfig.WindowPlacement[0].rcNormalPosition.right = MulDiv(900, gLogPixelSize.x, 96);
  gConfig.WindowPlacement[0].length = sizeof(WINDOWPLACEMENT);
  gConfig.WindowPlacement[FindWindowplacement].rcNormalPosition.top = MulDiv(150, gLogPixelSize.y, 96);
  gConfig.WindowPlacement[FindWindowplacement].rcNormalPosition.left = MulDiv(150, gLogPixelSize.x, 96);
  gConfig.WindowPlacement[FindWindowplacement].length = sizeof(WINDOWPLACEMENT);
  gConfig.WindowPlacement[PropWindowplacement].rcNormalPosition.top = MulDiv(40, gLogPixelSize.y, 96);
  gConfig.WindowPlacement[PropWindowplacement].rcNormalPosition.left = MulDiv(40, gLogPixelSize.x, 96);
  gConfig.WindowPlacement[PropWindowplacement].length = sizeof(WINDOWPLACEMENT);
  gConfig.WindowPlacement[DllPropWindowplacement].rcNormalPosition.top = MulDiv(40, gLogPixelSize.y, 96);
  gConfig.WindowPlacement[DllPropWindowplacement].rcNormalPosition.left = MulDiv(40, gLogPixelSize.x, 96);
  gConfig.WindowPlacement[DllPropWindowplacement].length = sizeof(WINDOWPLACEMENT);
  gConfig.WindowPlacement[SysinfoWindowplacement].rcNormalPosition.top = MulDiv(40, gLogPixelSize.y, 96);
  gConfig.WindowPlacement[SysinfoWindowplacement].rcNormalPosition.left = MulDiv(40, gLogPixelSize.x, 96);
  gConfig.WindowPlacement[SysinfoWindowplacement].length = sizeof(WINDOWPLACEMENT);
  gConfig.ToolBandInfo[0].nWidth = -1;
  gConfig.ToolBandInfo[1].nWidth = -1;
  gConfig.ToolBandInfo[2].nWidth = -1;
  gConfig.ToolBandInfo[3].nWidth = -1;
  index = 0;
  gConfig.ToolBandInfo[4].nWidth = -1;
  gConfig.ToolBandInfo[5].nWidth = -1;
  gConfig.ToolBandInfo[6].nWidth = -1;
  gConfig.ToolBandInfo[7].nWidth = -1;
  gConfig.dwProcessColumnCount = 6;
  do
  {
    v1 = gProcessColumns[index].wID;
    v2 = gLogPixelSize.x;
    dwValue[index + 97] = v1;
    gConfig.dwProcessColumnMap[index] = v1;
    gConfig.dwProcessColumns[index] = MulDiv(word_105D1F2[2 * index], v2, 96);
    ++index;
  }
  while ( index < gConfig.dwProcessColumnCount );
  gConfig.dwHandleColumnCount = 2;
  v3 = 0;
  do
  {
    v4 = gLogPixelSize.x;
    gConfig.dwIdsOfHandleColumnMap[v3] = gHandleColumns[v3].wID;
    gConfig.dwHandleColumns[v3] = MulDiv(gHandleColumns[v3].nWidth, v4, 96);
    ++v3;
  }
  while ( v3 < gConfig.dwHandleColumnCount );
  gConfig.dwDllColumnCount = 4;
  v5 = 0;
  do
  {
    v6 = gLogPixelSize.x;
    gConfig.dwDllColumnMap[v5] = gDllColumns[v5].wID;
    gConfig.dwDllColumns[v5] = MulDiv(gDllColumns[v5].nWidth, v6, 96);
    ++v5;
  }
  while ( v5 < gConfig.dwDllColumnCount );
  v7 = GetStockObject(DEFAULT_GUI_FONT);
  GetObjectW(v7, sizeof(LOGFONTW), &LogFont);
  LogFont.lfWeight = 400;
  v8 = MulDiv(8, gLogPixelSize.y, 72);
  LogFont.lfWidth = 0;
  LogFont.lfHeight = -v8;
  qmemcpy(&gConfig.UnicodeFont, &LogFont, sizeof(gConfig.UnicodeFont));
  KeyInfo.szKeyName = _wcsdup(L"Software\\Sysinternals\\Process Explorer");
  LoadConfigItemFromRegistry(&KeyInfo, gConfigItems);
  if ( gConfig.UnicodeFont.lfHeight > 0 )
    gConfig.UnicodeFont.lfHeight = -MulDiv(gConfig.UnicodeFont.lfHeight, gLogPixelSize.y, 72);
  if ( !RegOpenKeyW(HKEY_CURRENT_USER, L"Software\\Sysinternals\\Process Explorer", &hSubKey) )
  {
    KeyInfo.nLength = 0x6F8;
    if ( !RegQueryValueExW(hSubKey, L"Settings", 0, 0, dwValue, &KeyInfo.nLength) && dwValue[0] - 501 <= 320 )
    {
      v9 = 0;
      if ( dwValue[96] <= 0 )
      {
__Loop:
        nItem = 0;
        if ( dwValue[129] <= 0 )
        {
LABEL_31:
          v18 = 0;
          if ( dwValue[162] <= 0 )
          {
LABEL_37:
            sub_FB4F50(&gConfig, dwValue, KeyInfo.nLength);
            RegDeleteValueW(hSubKey, L"Settings");
            CloseHandle(hSubKey);
            dwOpacity = gConfig.dwOpacity;
            if ( !gConfig.dwOpacity )
              dwOpacity = 100;
            gConfig.dwOpacity = dwOpacity;
            v22 = gConfig.ColorOwn;
            if ( !gConfig.ColorOwn )
              v22 = 0xFFD0D0;
            gConfig.ColorOwn = v22;
            if ( !gConfig.dwProcessColumnMap[0] )
              qmemcpy(gConfig.dwProcessColumnMap, &dwValue[97], 0x80u);
          }
          else
          {
            while ( 1 )
            {
              v19 = *(&dwValue[54] + v18);
              if ( !v19 )
                break;
              if ( v19 > 2000u )
                break;
              uID_1 = dwValue[v18 + 163];
              if ( uID_1 <= 0 || uID_1 > 41000 )
                break;
              if ( ++v18 >= dwValue[162] )
                goto LABEL_37;
            }
          }
        }
        else
        {
          while ( 1 )
          {
            v16 = *(&dwValue[70] + nItem);
            if ( !v16 )
              break;
            if ( v16 > 2000u )
              break;
            uID_2 = dwValue[nItem + 130];
            if ( uID_2 <= 0 || uID_2 > 41000 )
              break;
            if ( ++nItem >= dwValue[129] )
              goto LABEL_31;
          }
        }
      }
      else
      {
        while ( 1 )
        {
          v10 = *(&dwValue[38] + v9);
          if ( !v10 )
            break;
          if ( v10 > 2000u )
            break;
          v11 = dwValue[v9 + 374];
          if ( v11 <= 0 || v11 > 41000 )
            break;
          if ( ++v9 >= dwValue[96] )
            goto __Loop;
        }
        v12 = 0;
        while ( 1 )
        {
          v13 = *(&dwValue[38] + v12);
          if ( !v13 )
            break;
          if ( v13 > 2000u )
            break;
          v14 = dwValue[v12 + 97];
          if ( v14 <= 0 || v14 > 41000 )
            break;
          if ( ++v12 >= dwValue[96] )
            goto __Loop;
        }
      }
    }
  }
  index_1 = 0;
  if ( gConfig.dwProcessColumnCount > 0 )
  {
    pwProcessColumns = gConfig.dwProcessColumns;
    pdwProcessColumnMap = gConfig.dwProcessColumnMap;
    do
    {
      if ( *pdwProcessColumnMap == 3 )
      {
        memmove_0(pdwProcessColumnMap, pdwProcessColumnMap + 1, 4 * (--gConfig.dwProcessColumnCount - index_1));
        memmove_0(pwProcessColumns, pwProcessColumns + 1, 2 * (gConfig.dwProcessColumnCount - index_1));
      }
      ++index_1;
      ++pdwProcessColumnMap;
      ++pwProcessColumns;
    }
    while ( index_1 < gConfig.dwProcessColumnCount );
  }
  index_2 = 0;
  index_3 = -1;
  if ( gConfig.dwProcessColumnCount <= 0 )
    goto LABEL_68;
  do
  {
    if ( gConfig.dwProcessColumnMap[index_2] == IDS_PID )
    {
      index_3 = index_2;
      if ( gConfig.bETWStandardUserWarning )
        break;
    }
    else if ( !IsBuiltinAdministrative() && !gConfig.bETWStandardUserWarning )
    {
      uID = gConfig.dwProcessColumnMap[index_2];
      if ( uID >= IDS_NETWORK_RECEIVES && uID <= IDS_DISK_DELTA_TOTAL_BYTES )
      {
        gConfig.bETWStandardUserWarning = 1;
        MessageBoxW(
          0,
          L"Note that Disk and Networking information requires administrative rights",
          L"Process Explorer",
          MB_ICONEXCLAMATION);
        if ( index_3 != -1 )
          goto LABEL_60;
      }
    }
    ++index_2;
  }
  while ( index_2 < gConfig.dwProcessColumnCount );
  if ( index_3 == -1 )
  {
LABEL_68:
    gConfig.dwProcessColumnMap[index_2] = IDS_PID;
    gConfig.dwProcessColumns[index_2] = 200;
    ++gConfig.dwProcessColumnCount;
  }
LABEL_60:
  dwIndex_2 = 0;
  if ( gConfig.dwNumColumnsets > 0 )
  {
    var = gConfig.strMenuCulumnSet;
    do
    {
      RegVar_ReadWrite(0, dwIndex_2++, var);
      ++var;
    }
    while ( dwIndex_2 < gConfig.dwNumColumnsets );
  }
  if ( !gConfig.strNtSymbolPath[0] )
    GetEnvironmentVariableW(L"_NT_SYMBOL_PATH", gConfig.strNtSymbolPath, 0x104u);
  ghConfigFont = CreateFontIndirectW(&gConfig.UnicodeFont);
  qmemcpy(&LogFont, &gConfig.UnicodeFont, sizeof(LogFont));
  LogFont.lfUnderline = 1;
  ghConfigUnderlineFont = CreateFontIndirectW(&LogFont);
  free(KeyInfo.szKeyName);
}

//----- (00FB9980) --------------------------------------------------------
BOOL __cdecl sub_FB9980(HWND hWnd)
{
  HDC v1; // ebx
  struct tagCHOOSEFONTW v3; // [esp+Ch] [ebp-DCh]
  HWND v4; // [esp+48h] [ebp-A0h]
  LOGFONTW lf; // [esp+4Ch] [ebp-9Ch]
  WINDOWPLACEMENT wndpl; // [esp+A8h] [ebp-40h]
  struct tagRECT Rect; // [esp+D4h] [ebp-14h]

  v4 = hWnd;
  v1 = GetDC(hWnd);
  qmemcpy(&lf, &gConfig.UnicodeFont, sizeof(lf));
  v3.hDC = CreateCompatibleDC(v1);
  ReleaseDC(hWnd, v1);
  v3.lStructSize = 60;
  v3.lpLogFont = &lf;
  v3.hInstance = ghInstance;
  v3.nFontType = 0x2000;
  v3.hwndOwner = hWnd;
  v3.Flags = 8273;
  v3.rgbColors = 0;
  v3.lCustData = 0;
  v3.lpszStyle = 0;
  v3.nSizeMin = 0;
  v3.nSizeMax = 20;
  v3.lpfnHook = 0;
  v3.lpTemplateName = 1543;
  if ( ChooseFontW(&v3) )
  {
    qmemcpy(&gConfig.UnicodeFont, &lf, sizeof(gConfig.UnicodeFont));
    DeleteObject(ghConfigFont);
    ghConfigFont = CreateFontIndirectW(&gConfig.UnicodeFont);
    lf.lfUnderline = 1;
    ghConfigUnderlineFont = CreateFontIndirectW(&lf);
    InitTreeList(ghWndTreeListView, ghConfigFont);
    InitTreeList(ghWndDllsListCtrl, ghConfigFont);
    InitTreeList(ghWndHandlesListCtrl, ghConfigFont);
    GetWindowRect(ghMainWnd, &Rect);
    SetWindowPos(ghMainWnd, 0, Rect.left, Rect.top, Rect.right - Rect.left - 1, Rect.bottom - Rect.top, 4u);
    SetWindowPos(ghMainWnd, 0, Rect.left, Rect.top, Rect.right - Rect.left, Rect.bottom - Rect.top, 4u);
    if ( ghFindDlg )
    {
      EndDialog(ghFindDlg, 0);
      ghFindDlg = 0;
    }
    wndpl.flags = 0;
    wndpl.length = 44;
    GetWindowPlacement(hWnd, &wndpl);
    if ( wndpl.showCmd == 3 )
    {
      ShowWindow(hWnd, 9);
      ShowWindow(hWnd, 3);
    }
  }
  return DeleteDC(v3.hDC);
}

//----- (00FB9BB0) --------------------------------------------------------
LRESULT __cdecl sub_FB9BB0(HWND hWnd, LONG dwNewLong, UINT *pnIDs, WORD *pnWidths, char fSortable)
{
  LONG v5; // eax
  HWND v6; // eax
  LRESULT result; // eax
  struct _IMAGELIST *v8; // esi
  LONG v9; // eax

  v5 = GetWindowLongW(hWnd, -16);
  SetWindowLongW(hWnd, -16, v5 & 0xFFFFFFFD | 9);
  SetWindowLongW(hWnd, -21, dwNewLong);
  SendMessageW(hWnd, LVM_SETEXTENDEDLISTVIEWSTYLE, 0x4020u, 0x4020);
  v6 = SendMessageW(hWnd, LVM_GETTOOLTIPS, 0, 0);
  CTreeList::InitToolTips(v6);
  result = CTreeView::InitListHeader(hWnd, pnIDs, pnWidths, dwNewLong);
  if ( fSortable )
  {
    v8 = InitSortableImageList();
    v9 = GetWindowLongW(hWnd, -16);
    SetWindowLongW(hWnd, -16, v9 | LVS_SHAREIMAGELISTS);
    result = SendMessageW(hWnd, LVM_SETIMAGELIST, 1u, v8);
  }
  return result;
}

//----- (00FB9C50) --------------------------------------------------------
char __cdecl IsColumnIDValid(HWND hWnd, DWORD dwId)
{
  int nIndex; // eax

  nIndex = 0;
  if ( gConfig.dwProcessColumnCount <= 0 )
    return 0;
  while ( gConfig.dwProcessColumnMap[nIndex] != dwId )
  {
    if ( ++nIndex >= gConfig.dwProcessColumnCount )
      return 0;
  }
  return 1;
}

//----- (00FB9C80) --------------------------------------------------------
int __stdcall Proxy_ListCtrlWndProc(HWND hWnd, UINT Msg, WPARAM wParamIn, LPARAM lParamIn)
{
  HWND hWnd_1; // ebx
  LPARAM v5; // edi
  int result; // eax
  HCURSOR v7; // eax
  LRESULT nItemCount_1; // eax
  HBRUSH hBrush; // eax
  HBRUSH hBrush_1; // eax
  LRESULT nTopIndex; // eax
  HBRUSH hBrush_2; // eax
  int code; // eax
  signed int v14; // edi
  int v15; // ST18_4
  int v16; // ST14_4
  HWND v17; // eax
  int v18; // ST18_4
  int v19; // ST14_4
  HWND v20; // eax
  int nRet; // edi
  HDC v22; // esi
  int v23; // eax
  bool v24; // zf
  bool v25; // sf
  unsigned __int8 v26; // of
  LPARAM v27; // eax
  void *v28; // ST24_4
  LPARAM v29; // eax
  HWND hWndTooltips; // eax
  HANDLE v31; // eax
  HWND hWndTooltips_1; // eax
  HCURSOR hCursor; // eax
  unsigned int pUserData; // esi
  unsigned int nIndex; // ecx
  __m128i v36; // xmm1
  LPARAM *v37; // edx
  unsigned int v38; // eax
  __m128i v39; // xmm0
  HGLOBAL hGlobal; // edi
  int nLength; // ebx
  wchar_t *pBuffer; // esi
  LRESULT nItem_1; // ecx
  unsigned int nIdIndex; // eax
  HDC wParam_3; // ST20_4
  HWND hWndParent; // eax
  HWND hWndList; // edi
  int nItem; // eax
  int nID; // esi
  LRESULT nCount; // eax
  LRESULT v51; // eax
  LVITEMW Item; // [esp+Ch] [ebp-6254h]
  LVITEMW item; // [esp+40h] [ebp-6220h]
  unsigned int v54; // [esp+74h] [ebp-61ECh]
  HWND hWndNewOwner; // [esp+78h] [ebp-61E8h]
  unsigned __int32 nItemCount; // [esp+7Ch] [ebp-61E4h]
  LPARAM lParam_2; // [esp+80h] [ebp-61E0h]
  HDC wParam_2; // [esp+84h] [ebp-61DCh]
  struct tagPOINT Point; // [esp+88h] [ebp-61D8h]
  char v60; // [esp+90h] [ebp-61D0h]
  WPARAM uMsg; // [esp+94h] [ebp-61CCh]
  WPARAM wParam_1; // [esp+98h] [ebp-61C8h]
  RECT lParam_1; // [esp+9Ch] [ebp-61C4h]
  RECT rcItem; // [esp+ACh] [ebp-61B4h]
  struct tagRECT Rect; // [esp+BCh] [ebp-61A4h]
  RECT rc; // [esp+CCh] [ebp-6194h]
  LPARAM arrIDs[96]; // [esp+DCh] [ebp-6184h]
  WCHAR szText[8192]; // [esp+25Ch] [ebp-6004h]
  WCHAR chText[4096]; // [esp+425Ch] [ebp-2004h]

  hWnd_1 = hWnd;
  v5 = lParamIn;
  wParam_2 = wParamIn;
  hWndNewOwner = hWnd;
  lParam_2 = lParamIn;
  item.mask = 0;
  memset(&item.iItem, 0, 0x30u);
  if ( Msg > WM_NOTIFY )
  {
    if ( Msg == WM_KEYDOWN )
    {
      switch ( wParam_2 )
      {
        case VK_TAB:
          hWndList = ghWndTreeListView;
          if ( hWnd == ghWndTreeListView )
          {
            hWndList = ghWndHandlesListCtrl;
            if ( gConfig.bShowDllView )
              hWndList = ghWndDllsListCtrl;
          }
          item.iItem = 0;
          item.iSubItem = 0;
          item.stateMask = 2;
          item.mask = 12;
          nItem = SendMessageW(hWndList, LVM_GETNEXTITEM, 0xFFFFFFFF, 2);
          if ( nItem == -1 )
            nItem = 0;
          item.iItem = nItem;
          SetFocus(hWndList);
          Item.stateMask = 3;
          Item.state = 3;
          SendMessageW(hWndList, LVM_SETITEMSTATE, item.iItem, &Item);
          return 0;
        case VK_RETURN:
          if ( hWnd == ghWndTreeListView )
          {
            nID = IDC_TREEVIEW_LIST;
          }
          else
          {
            nItemCount = 2 * (hWnd == ghWndDllsListCtrl) + IDC_LISTCTRL_HANDLES;
            nID = 2 * (hWnd == ghWndDllsListCtrl) + IDC_LISTCTRL_HANDLES;
          }
          item.iItem = SendMessageW(hWnd, LVM_GETNEXTITEM, 0xFFFFFFFF, 2);
          if ( item.iItem != -1 )
            FillList(nID);
          return 0;
        case VK_END:
          Item.stateMask = 3;
          Item.state = 3;
          nCount = SendMessageW(hWnd, LVM_GETITEMCOUNT, 0, 0);
          SendMessageW(hWnd, LVM_SETITEMSTATE, nCount - 1, &Item);
          v51 = SendMessageW(hWnd, LVM_GETITEMCOUNT, 0, 0);
          SendMessageW(hWnd, LVM_ENSUREVISIBLE, v51 - 1, 0);
          return 0;
        case VK_HOME:
          Item.stateMask = 3;
          Item.state = 3;
          SendMessageW(hWnd, LVM_SETITEMSTATE, 0, &Item);
          SendMessageW(hWnd, LVM_ENSUREVISIBLE, 0, 0);
          return 0;
        case VK_CANCEL|0x40:
          if ( hWnd != ghWndTreeListView && GetKeyState(VK_LCONTROL) )
          {
            pUserData = GetWindowLongW(hWnd, GWLP_USERDATA);
            nItemCount = pUserData;
            if ( !SendMessageW(hWnd, LVM_GETCOLUMNORDERARRAY, pUserData, arrIDs) )
            {
              nIndex = 0;
              if ( pUserData )
              {
                if ( pUserData >= 8 )
                {
                  v36 = _mm_load_si128(&gIntArray);
                  v37 = &arrIDs[4];
                  do
                  {
                    v38 = nIndex + 4;
                    v37 += 8;
                    v39 = _mm_add_epi32(_mm_shuffle_epi32(_mm_cvtsi32_si128(nIndex), 0), v36);
                    nIndex += 8;
                    _mm_storeu_si128(v37 - 3, v39);
                    _mm_storeu_si128(v37 - 2, _mm_add_epi32(_mm_shuffle_epi32(_mm_cvtsi32_si128(v38), 0), v36));
                  }
                  while ( nIndex < pUserData - (pUserData & 7) );
                }
                for ( ; nIndex < pUserData; ++nIndex )
                  arrIDs[nIndex] = nIndex;
              }
            }
            hGlobal = 0;
            item.iItem = -1;
            nLength = 0;
            pBuffer = 0;
            nItem_1 = SendMessageW(hWndNewOwner, LVM_GETNEXTITEM, 0xFFFFFFFF, 2);
            for ( item.iItem = nItem_1; nItem_1 != -1; item.iItem = nItem_1 )
            {
              nIdIndex = 0;
              v54 = 0;
              if ( nItemCount )
              {
                while ( 1 )
                {
                  Item.iSubItem = arrIDs[nIdIndex];
                  Item.pszText = szText;
                  Item.cchTextMax = 8192;
                  SendMessageW(hWndNewOwner, LVM_GETITEMTEXTW, nItem_1, &Item);
                  nLength += wcslen(szText) + 2;
                  if ( pBuffer )
                  {
                    GlobalUnlock(hGlobal);
                    hGlobal = GlobalReAlloc(hGlobal, 2 * nLength + 2, 0);
                    pBuffer = GlobalLock(hGlobal);
                  }
                  else
                  {
                    hGlobal = GlobalAlloc(0x2002u, 2 * nLength + 2);
                    pBuffer = GlobalLock(hGlobal);
                    *pBuffer = 0;
                  }
                  wcscat_s(pBuffer, nLength + 1, szText);
                  if ( ++v54 >= nItemCount )
                    break;
                  wcscat_s(pBuffer, nLength + 1, L"\t");
                  nIdIndex = v54;
                  if ( v54 >= nItemCount )
                    break;
                  nItem_1 = item.iItem;
                }
              }
              wcscat_s(pBuffer, nLength + 1, L"\r\n");
              GlobalUnlock(hGlobal);
              nItem_1 = SendMessageW(hWndNewOwner, LVM_GETNEXTITEM, item.iItem, 2);
            }
            hWnd_1 = hWndNewOwner;
            SetFocus(hWndNewOwner);
            if ( hGlobal && OpenClipboard(hWnd_1) )
            {
              EmptyClipboard();
              SetClipboardData(CF_UNICODETEXT, hGlobal);
              CloseClipboard();
            }
            v5 = lParam_2;
          }
          goto LABEL_70;
        default:
LABEL_70:
          wParam_3 = wParam_2;
          hWndParent = GetParent(hWnd_1);
          SendMessageW(hWndParent, WM_KEYDOWN, wParam_3, v5);
          break;
      }
    }
    else if ( Msg == WM_MOUSEMOVE )
    {
      if ( gdwVersion < 1 )
      {
        hWndTooltips = SendMessageW(hWnd, LVM_GETTOOLTIPS, 0, 0);
        if ( !IsWindowVisible(hWndTooltips)
          || (Point.x = lParamIn, Point.y = SHIWORD(lParamIn), SendMessageW(hWnd, LVM_SUBITEMHITTEST, 0, &Point) >= 0)
          && (v31 = GetPropW(hWnd, L"hitrow"), wParam_1 != v31) )
        {
          hWndTooltips_1 = SendMessageW(hWnd, LVM_GETTOOLTIPS, 0, 0);
          SendMessageW(hWndTooltips_1, TTM_POP, 0, 0);
        }
      }
      if ( hWnd == ghWndDllsListCtrl )
      {
        GetCursorPos(&Point);
        ScreenToClient(hWnd, &Point);
        if ( SendMessageW(hWnd, LVM_SUBITEMHITTEST, 0, &Point) >= 0
          && gConfig.dwDllColumnMap[wParam_1] == IDS_VIRUSTOTAL )
        {
          item.iItem = uMsg;
          item.mask = LVIF_PARAM;
          SendMessageW(hWnd, LVM_GETITEMW, 0, &item);
          if ( sub_1001820(item.lParam[4].field_1C) )
          {
            hCursor = LoadCursorW(ghInstance, L"HAND");
            SetCursor(hCursor);
          }
        }
      }
    }
    return CallWindowProcW(gOldListWndProc, hWnd_1, Msg, wParam_2, v5);
  }
  if ( Msg != WM_NOTIFY )
  {
    switch ( Msg )
    {
      case WM_SETFOCUS:
      case WM_KILLFOCUS:
        if ( hWnd == ghWndTreeListView && wParam_2 != ghWndTreeListView )
          RefreshTreeView();
        return CallWindowProcW(gOldListWndProc, hWnd_1, Msg, wParam_2, v5);
      case WM_ERASEBKGND:
        if ( !SendMessageW(hWnd, LVM_GETITEMCOUNT, 0, 0) )
          return CallWindowProcW(gOldListWndProc, hWnd_1, Msg, wParam_2, v5);
        GetClientRect(hWnd, &Rect);
        rcItem.left = 0;
        nItemCount_1 = SendMessageW(hWnd, LVM_GETITEMCOUNT, 0, 0);
        SendMessageW(hWnd, LVM_GETITEMRECT, nItemCount_1 - 1, &rcItem);
        rc.left = rcItem.right;
        hBrush = GetSysColorBrush(COLOR_WINDOW);
        FillRect(wParam_2, &rc, hBrush);
        rc = Rect;
        rc.right = Rect.right;
        rc.top = rcItem.bottom;
        rc.bottom = Rect.bottom;
        hBrush_1 = GetSysColorBrush(COLOR_WINDOW);
        FillRect(wParam_2, &rc, hBrush_1);
        rcItem.left = 0;
        nTopIndex = SendMessageW(hWnd, LVM_GETTOPINDEX, 0, 0);
        SendMessageW(hWnd, LVM_GETITEMRECT, nTopIndex, &rcItem);
        rc.right = Rect.right;
        rc.left = 0;
        rc.top = 0;
        rc.bottom = rcItem.top;
        hBrush_2 = GetSysColorBrush(COLOR_WINDOW);
        FillRect(wParam_2, &rc, hBrush_2);
        return 1;
      case WM_SETCURSOR:
        if ( hWnd == ghWndHandlesListCtrl )
        {
          SetCursor(ghArrowCursor);
          result = 1;
        }
        else
        {
          if ( gnRefCount )
            v7 = LoadCursorW(0, IDC_APPSTARTING);
          else
            v7 = LoadCursorW(0, IDC_ARROW);
          SetCursor(v7);
          result = 1;
        }
        return result;
      default:
        return CallWindowProcW(gOldListWndProc, hWnd_1, Msg, wParam_2, v5);
    }
    return CallWindowProcW(gOldListWndProc, hWnd_1, Msg, wParam_2, v5);
  }
  // WM_NOTIFY
  if ( *lParamIn != SendMessageW(hWnd, LVM_GETTOOLTIPS, 0, 0) )
    return CallWindowProcW(gOldListWndProc, hWnd_1, Msg, wParam_2, v5);
  code = *(lParamIn + 8);
  if ( code != TTN_GETDISPINFOW )
  {
    if ( code == TTN_SHOW )
    {
      v14 = -1;
      if ( gdwVersion >= 1 )
        v14 = -4;
      GetCursorPos(&Point);
      ScreenToClient(hWnd, &Point);
      item.iItem = SendMessageW(hWnd, LVM_SUBITEMHITTEST, 0, &Point);
      if ( item.iItem != -1 && wParam_1 != -1 )
      {
        sub_FBA880(hWnd, uMsg, wParam_1, &lParam_1);
        Point.x = lParam_1.left;
        Point.y = lParam_1.top;
        ClientToScreen(hWnd, &Point);
        v15 = Point.y - 1;
        v16 = v14 + Point.x;
        v17 = SendMessageW(hWnd, LVM_GETTOOLTIPS, 0, 0);
        SetWindowPos(v17, 0, v16, v15, 0, 0, SWP_NOACTIVATE|SWP_NOSIZE);
        return 1;
      }
      v18 = Point.y - 1;
      v19 = v14 + Point.x;
      v20 = SendMessageW(hWnd, LVM_GETTOOLTIPS, 0, 0);
      SetWindowPos(v20, 0, v19, v18, 0, 0, SWP_NOACTIVATE);
      v5 = lParam_2;
    }
    return CallWindowProcW(gOldListWndProc, hWnd_1, Msg, wParam_2, v5);
  }
  if ( gdwVersion >= 1 )
    return CallWindowProcW(gOldListWndProc, hWnd_1, Msg, wParam_2, v5);
  nRet = CallWindowProcW(gOldListWndProc, hWnd, WM_NOTIFY, wParam_2, lParamIn);
  GetCursorPos(&Point);
  ScreenToClient(hWnd, &Point);
  if ( SendMessageW(hWnd, LVM_SUBITEMHITTEST, 0, &Point) < 0 || !(v60 & 0xE) || (wParam_1 & 0x80000000) != 0 )
    return nRet;
  item.iSubItem = wParam_1;
  item.iItem = uMsg;
  item.mask = 1;
  item.pszText = chText;
  item.cchTextMax = 4096;
  SendMessageW(hWnd, LVM_GETITEMW, 0, &item);
  if ( !chText[0] )
  {
    v29 = lParam_2;
    *(lParam_2 + 12) = 0;
    *(v29 + 16) = 0;
    return nRet;
  }
  Item.pszText = 2;
  SendMessageW(hWnd, LVM_GETCOLUMNW, wParam_1, &Item.pszText);
  _mm_storeu_si128(&lParam_1, 0i64);
  v22 = GetDC(hWnd);
  SelectObject(v22, ghConfigFont);
  DrawTextW(v22, chText, -1, &lParam_1, 0xD00u);
  v23 = lParam_1.right - lParam_1.left + 6;
  v26 = __OFSUB__(v23, Item.iImage);
  v24 = v23 == Item.iImage;
  v25 = v23 - Item.iImage < 0;
  v27 = lParam_2;
  if ( (v25 ^ v26) | v24 )
  {
    *(lParam_2 + 12) = 0;
    *(v27 + 16) = 0;
  }
  else
  {
    v28 = wParam_1;
    *(lParam_2 + 12) = chText;
    SetPropW(hWnd, L"hitrow", v28);
  }
  ReleaseDC(hWnd, v22);
  return nRet;
}
// 103EA50: using guessed type RECT gIntArray;
// 1064E54: using guessed type int gdwVersion;

//----- (00FBA880) --------------------------------------------------------
LRESULT __cdecl sub_FBA880(HWND hWnd, WPARAM uMsg, WPARAM wParam_1, RECT *lParam_1)
{
  HWND hwnd; // ebx
  void (__stdcall *SendMessageW)(HWND, UINT, WPARAM, LPARAM); // edi
  LRESULT bRet; // eax
  int dwProcessColumnCount_1; // edx
  signed int dwColumnCount; // ecx
  __m128i v9; // xmm1
  LPARAM *v10; // edi
  int dwProcessColumnCount; // ebx
  unsigned int v12; // eax
  __m128i v13; // xmm0
  CTreeList *v14; // eax
  LRESULT result; // eax
  RECT *rect; // eax
  unsigned int index; // eax
  RECT *v18; // eax
  RECT *v19; // eax
  HWND hWnd_1; // [esp+Ch] [ebp-188h]
  LPARAM arrIDs[96]; // [esp+10h] [ebp-184h]

  hwnd = hWnd;
  SendMessageW = ::SendMessageW;
  hWnd_1 = hWnd;
  bRet = ::SendMessageW(hWnd, LVM_GETCOLUMNORDERARRAY, gConfig.dwProcessColumnCount, arrIDs);
  dwProcessColumnCount_1 = gConfig.dwProcessColumnCount;
  if ( !bRet )
  {
    dwColumnCount = 0;
    if ( gConfig.dwProcessColumnCount > 0 )
    {
      if ( gConfig.dwProcessColumnCount >= 8u )
      {
        v9 = _mm_load_si128(&gIntArray);
        v10 = &arrIDs[4];
        dwProcessColumnCount = gConfig.dwProcessColumnCount - gConfig.dwProcessColumnCount % 8;
        do
        {
          v12 = dwColumnCount + 4;
          v10 += 8;
          v13 = _mm_add_epi32(_mm_shuffle_epi32(_mm_cvtsi32_si128(dwColumnCount), 0), v9);
          dwColumnCount += 8;
          _mm_storeu_si128(v10 - 3, v13);
          _mm_storeu_si128(v10 - 2, _mm_add_epi32(_mm_shuffle_epi32(_mm_cvtsi32_si128(v12), 0), v9));
        }
        while ( dwColumnCount < dwProcessColumnCount );
        hwnd = hWnd_1;
        SendMessageW = ::SendMessageW;
      }
      for ( ; dwColumnCount < dwProcessColumnCount_1; ++dwColumnCount )
        arrIDs[dwColumnCount] = dwColumnCount;
    }
  }
  if ( uMsg == -2 )
  {
    v14 = CTreeList::GetTreeList(hwnd);
    CTreeList::MapToHeader(v14, wParam_1, lParam_1);
    lParam_1->bottom -= lParam_1->top;
    result = lParam_1->left;
    lParam_1->right -= lParam_1->left;
  }
  else if ( wParam_1 )
  {
    if ( lParam_1 )
    {
      lParam_1->top = wParam_1;
      rect = lParam_1;
      lParam_1->left = 0;
    }
    else
    {
      rect = 0;
    }
    SendMessageW(hwnd, LVM_GETSUBITEMRECT, uMsg, rect);
    lParam_1->bottom -= lParam_1->top;
    result = lParam_1->left;
    lParam_1->right -= lParam_1->left;
  }
  else
  {
    index = 0;
    while ( arrIDs[index] )
    {
      if ( !arrIDs[index + 1] )
      {
        ++index;
        break;
      }
      if ( !arrIDs[index + 2] )
      {
        index += 2;
        break;
      }
      if ( !arrIDs[index + 3] )
      {
        index += 3;
        break;
      }
      if ( !arrIDs[index + 4] )
      {
        index += 4;
        break;
      }
      if ( !arrIDs[index + 5] )
      {
        index += 5;
        break;
      }
      index += 6;
      if ( index >= 96 )
        break;
    }
    if ( dwProcessColumnCount_1 == 1 )
    {
      if ( lParam_1 )
      {
        lParam_1->left = 0;
        result = (SendMessageW)(hwnd, LVM_GETITEMRECT, uMsg, lParam_1);
      }
      else
      {
        result = (SendMessageW)(hwnd, LVM_GETITEMRECT, uMsg, 0);
      }
    }
    else if ( index )
    {
      if ( lParam_1 )
      {
        lParam_1->top = *(&hWnd_1 + index);
        v18 = lParam_1;
        lParam_1->left = 0;
      }
      else
      {
        v18 = 0;
      }
      SendMessageW(hwnd, LVM_GETSUBITEMRECT, uMsg, v18);
      lParam_1->left = lParam_1->right;
      result = (SendMessageW)(hwnd, LVM_GETCOLUMNWIDTH, 0, 0);
      lParam_1->right = result;
    }
    else
    {
      if ( lParam_1 )
      {
        lParam_1->top = 1;
        v19 = lParam_1;
        lParam_1->left = 0;
      }
      else
      {
        v19 = 0;
      }
      SendMessageW(hwnd, LVM_GETSUBITEMRECT, uMsg, v19);
      lParam_1->bottom -= lParam_1->top;
      result = (SendMessageW)(hwnd, LVM_GETCOLUMNWIDTH, 0, 0);
      lParam_1->left = 0;
      lParam_1->right = result;
    }
  }
  return result;
}
// 103EA50: using guessed type RECT gIntArray;

//----- (00FBAB00) --------------------------------------------------------
BOOL __cdecl InitTreeList(HWND hWnd, WPARAM wParam)
{
  HWND v2; // eax
  struct tagRECT Rect; // [esp+Ch] [ebp-14h]

  v2 = SendMessageW(hWnd, 0x101Fu, 0, 0);
  SendMessageW(v2, 0x30u, wParam, 0);
  SendMessageW(hWnd, 0x30u, wParam, 0);
  GetClientRect(ghMainWnd, &Rect);
  CMainWnd::HandleSize(
    ghMainWnd,
    0,
    0,
    (LOWORD(Rect.right) - LOWORD(Rect.left)) | ((LOWORD(Rect.bottom) - LOWORD(Rect.top)) << 16));
  return InvalidateRgn(hWnd, 0, 1);
}

//----- (00FBABA0) --------------------------------------------------------
int __stdcall PropProcThreadsSortCallback(int a1, int a2, int *a3)
{
  _DWORD *v3; // esi
  signed int v4; // ebx
  int v5; // ecx
  _DWORD *v6; // edi
  _DWORD *v7; // edx
  unsigned int v8; // eax
  unsigned int v9; // ecx
  _DWORD *v10; // ebx
  bool v11; // cf
  int result; // eax
  int v13; // eax
  double v14; // xmm0_8
  double v15; // xmm1_8
  bool v16; // zf
  int v17; // ebx
  int v18; // edx
  unsigned int v19; // ecx
  unsigned int v20; // eax
  int v21; // ebx
  int v22; // edx
  unsigned int v23; // ecx
  unsigned int v24; // eax
  int v25; // eax
  _DWORD *v26; // ecx
  int v27; // ecx
  int v28; // ecx
  int v29; // ecx
  int v30; // ecx
  int v31; // ecx
  int v32; // ecx
  int v33; // ecx
  int v34; // ecx
  int v35; // ecx
  int v36; // ecx
  int v37; // ecx
  int v38; // ecx
  int v39; // ecx
  int v40; // ecx
  int v41; // ecx
  __int16 v42; // cx
  __int16 v43; // dx
  int v44; // ebx
  int v45; // eax
  const WCHAR *v46; // ecx
  int (__stdcall *v47)(LPCWSTR, LPCWSTR); // eax
  signed int v48; // eax
  int v49; // ebx
  int v50; // eax
  LPCWSTR v51; // eax
  LPCWSTR v52; // ebx
  int v53; // ecx
  int v54; // eax
  int v55; // ebx
  wchar_t **v56; // eax
  wchar_t *v57; // eax
  wchar_t **v58; // eax
  wchar_t *v59; // eax
  int v60; // eax
  signed int v61; // eax
  int v62; // eax
  int v63; // eax
  int v64; // eax
  unsigned int v65; // eax
  unsigned int v66; // ecx
  int v67; // eax
  int v68; // eax
  signed int v69; // eax
  unsigned int v70; // eax
  unsigned int v71; // ecx
  bool v72; // cf
  int v73; // eax
  const wchar_t *v74; // eax
  const wchar_t *v75; // eax
  int v76; // eax
  unsigned int v77; // ecx
  unsigned int v78; // eax
  unsigned int v79; // esi
  unsigned int v80; // edx
  unsigned __int64 v81; // kr18_8
  int v82; // eax
  int v83; // eax
  int v84; // eax
  int v85; // eax
  int v86; // eax
  int v87; // ebx
  unsigned int v88; // eax
  unsigned int v89; // ecx
  int v90; // eax
  int v91; // eax
  signed int v92; // eax
  int v93; // eax
  int v94; // eax
  int v95; // eax
  int v96; // eax
  int v97; // eax
  int v98; // ecx
  int v99; // eax
  int v100; // ebx
  wchar_t **v101; // eax
  wchar_t *v102; // eax
  wchar_t **v103; // eax
  wchar_t *v104; // eax
  int v105; // eax
  int v106; // eax
  int v107; // eax
  double v108; // xmm0_8
  int v109; // ebx
  int v110; // edx
  unsigned int v111; // ecx
  unsigned int v112; // eax
  unsigned int v113; // ecx
  signed int v114; // esi
  signed __int64 v115; // rax
  double v116; // xmm1_8
  int v117; // eax
  int v118; // eax
  int v119; // eax
  const wchar_t *v120; // ecx
  u_long v121; // esi
  u_long v122; // eax
  int v123; // esi
  u_short v124; // ax
  u_long v125; // esi
  u_long v126; // eax
  int v127; // esi
  u_short v128; // ax
  int v129; // eax
  int v130; // ebx
  int v131; // edi
  u_long v132; // edi
  int v133; // eax
  int v134; // ebx
  int v135; // edi
  u_long v136; // eax
  int v137; // [esp+10h] [ebp-424h]
  int v138; // [esp+14h] [ebp-420h]
  LPCWSTR lpString1; // [esp+18h] [ebp-41Ch]
  LPCWSTR v140; // [esp+1Ch] [ebp-418h]
  WCHAR String2; // [esp+20h] [ebp-414h]
  WCHAR String1; // [esp+228h] [ebp-20Ch]

  v3 = a1;
  v4 = 0;
  v5 = *a3;
  v140 = a1;
  v6 = a2;
  if ( v5 != 101 )
  {
    if ( v5 == 102 )
    {
      v61 = gConfig.dwIdsOfHandleColumnMap[a3[1]];
      if ( v61 > 39 )
      {
        v67 = v61 - 1185;
        if ( !v67 )
        {
          v4 = *(a1 + 40) - *(a2 + 40);
LABEL_274:
          v16 = LOBYTE(gConfig.bHandleSortDirection) == 0;
          goto LABEL_419;
        }
        v68 = v67 - 9;
        if ( !v68 )
        {
          v4 = *(a1 + 52) - *(a2 + 52);
          v16 = LOBYTE(gConfig.bHandleSortDirection) == 0;
          goto LABEL_419;
        }
        if ( v68 != 114 )
        {
LABEL_270:
          v4 = -1;
          v16 = LOBYTE(gConfig.bHandleSortDirection) == 0;
          goto LABEL_419;
        }
      }
      else if ( v61 != 39 )
      {
        v62 = v61 - 20;
        if ( v62 )
        {
          v63 = v62 - 1;
          if ( v63 )
          {
            if ( v63 == 1 )
            {
              v64 = lstrcmpiW((a1 + 2232), (a2 + 2232));
              v16 = LOBYTE(gConfig.bHandleSortDirection) == 0;
              v4 = v64;
              goto LABEL_419;
            }
            goto LABEL_270;
          }
          v4 = lstrcmpiW((a1 + 56), (a2 + 56));
          if ( !v4 )
          {
            v4 = *(a2 + 44) < *(a1 + 44) ? 1 : -1;
            v16 = LOBYTE(gConfig.bHandleSortDirection) == 0;
            goto LABEL_419;
          }
          goto LABEL_274;
        }
        v65 = *(a1 + 44);
        v66 = *(a2 + 44);
        if ( v65 <= v66 )
        {
          v4 = -(v65 < v66);
          v16 = LOBYTE(gConfig.bHandleSortDirection) == 0;
        }
        else
        {
          v16 = LOBYTE(gConfig.bHandleSortDirection) == 0;
          v4 = 1;
        }
        goto LABEL_419;
      }
      v4 = *(a1 + 48) - *(a2 + 48);
      v16 = LOBYTE(gConfig.bHandleSortDirection) == 0;
      goto LABEL_419;
    }
    if ( v5 == 104 )
    {
      v69 = gConfig.dwDllColumnMap[a3[1]];
      if ( v69 <= 30 )
      {
        if ( v69 != 30 )
        {
          switch ( v69 )
          {
            case 23:
              v70 = *(a1 + 36);
              v71 = *(a2 + 36);
              v72 = v70 < v71;
              if ( v70 <= v71 )
                goto LABEL_281;
              v16 = LOBYTE(gConfig.bDllSortDirection) == 0;
              v4 = 1;
              break;
            case 24:
              v4 = *(a1 + 56) - *(a2 + 56);
              v16 = LOBYTE(gConfig.bDllSortDirection) == 0;
              break;
            case 25:
              v73 = lstrcmpiW((a1 + 206), (a2 + 206));
              v16 = LOBYTE(gConfig.bDllSortDirection) == 0;
              v4 = v73;
              break;
            case 26:
              if ( wcsrchr(*(a1 + 344), 0x5Cu) )
                v74 = wcsrchr(*(a1 + 344), 0x5Cu) + 1;
              else
                v74 = *(a1 + 344);
              wcscpy_s(&String1, 0x104u, v74);
              if ( wcsrchr(*(a2 + 344), 0x5Cu) )
                v75 = wcsrchr(*(a2 + 344), 0x5Cu) + 1;
              else
                v75 = *(a2 + 344);
              wcscpy_s(&String2, 0x104u, v75);
              v76 = lstrcmpiW(&String1, &String2);
              v16 = LOBYTE(gConfig.bDllSortDirection) == 0;
              v4 = v76;
              break;
            default:
              goto LABEL_330;
          }
          goto LABEL_419;
        }
        v77 = *(a1 + 64);
        v78 = *(a1 + 68);
        v79 = *(a2 + 64);
        v80 = *(a2 + 68);
        if ( v77 == v79 && v78 == v80 )
        {
          v4 = 0;
          v16 = LOBYTE(gConfig.bDllSortDirection) == 0;
          goto LABEL_419;
        }
        v81 = __PAIR__(v78, v77) - __PAIR__(v80, v79);
        v137 = (__PAIR__(v78, v77) - __PAIR__(v80, v79)) >> 32;
        if ( v137 >= 0 && (__PAIR__(v78, v77) >= __PAIR__(v80, v79) && HIDWORD(v81) != 0 || v81) )
        {
          v16 = LOBYTE(gConfig.bDllSortDirection) == 0;
          v4 = 1;
          goto LABEL_419;
        }
        goto LABEL_330;
      }
      if ( v69 > 1118 )
      {
        if ( v69 > 1656 )
        {
          if ( v69 == 1670 )
          {
            v98 = *(a1 + 364);
            if ( v98 )
            {
              v99 = *(a2 + 364);
              if ( v99 )
              {
                v100 = *(v98 + 4);
                if ( v100 != 1 || *(v99 + 4) != 1 )
                {
                  v4 = v100 - *(v99 + 4);
                  v16 = LOBYTE(gConfig.bDllSortDirection) == 0;
                  goto LABEL_419;
                }
                v137 = *(v98 + 4);
                v138 = 1;
                lpString1 = -1;
                v140 = -1;
                v101 = *(v98 + 40);
                if ( v101 )
                  v102 = *v101;
                else
                  v102 = 0;
                scan_fn(v102, L"%d/%d", &v137);
                v103 = *(*(a2 + 364) + 40);
                if ( v103 )
                  v104 = *v103;
                else
                  v104 = 0;
                scan_fn(v104, L"%d/%d", &v138);
                v87 = v137;
                v86 = v138;
                if ( v137 == v138 )
                {
                  v4 = lpString1 - v140;
                  v16 = LOBYTE(gConfig.bDllSortDirection) == 0;
                  goto LABEL_419;
                }
                goto LABEL_308;
              }
            }
            v92 = sub_FC37B0(v98, *(a2 + 364));
            goto LABEL_350;
          }
          if ( v69 == 40757 )
          {
            v4 = (*(a1 + 54) & 0x4000) - (*(a2 + 54) & 0x4000);
            if ( (*(a1 + 54) & 0x4000) == (*(a2 + 54) & 0x4000) )
            {
              if ( *(a1 + 54) )
                v4 = *(a2 + 54) == 0;
              else
                v4 = -1;
              v16 = LOBYTE(gConfig.bDllSortDirection) == 0;
              goto LABEL_419;
            }
            goto LABEL_351;
          }
        }
        else
        {
          if ( v69 == 1656 )
          {
            v97 = lstrcmpiW(*(a1 + 348), *(a2 + 348));
            v16 = LOBYTE(gConfig.bDllSortDirection) == 0;
            v4 = v97;
            goto LABEL_419;
          }
          v94 = v69 - 1187;
          if ( !v94 )
          {
            v96 = lstrcmpiW(*(a1 + 356), *(a2 + 356));
            v16 = LOBYTE(gConfig.bDllSortDirection) == 0;
            v4 = v96;
            goto LABEL_419;
          }
          v95 = v94 - 130;
          if ( !v95 )
          {
            v92 = sub_FC37B0(*(a1 + 376), *(a2 + 376));
            goto LABEL_350;
          }
          if ( v95 == 21 )
          {
            v4 = (*(a1 + 54) & 0x40) - (*(a2 + 54) & 0x40);
            if ( (*(a1 + 54) & 0x40) == (*(a2 + 54) & 0x40) )
            {
              v4 = ((*(a2 + 44) >> 1) & 1) - ((*(a1 + 44) >> 1) & 1);
              v16 = LOBYTE(gConfig.bDllSortDirection) == 0;
              goto LABEL_419;
            }
            goto LABEL_351;
          }
        }
      }
      else
      {
        if ( v69 == 1118 )
        {
          v92 = sub_FC37B0(*(a1 + 380), *(a2 + 380));
          goto LABEL_350;
        }
        if ( v69 <= 1074 )
        {
          if ( v69 == 1074 )
          {
            v88 = *(a1 + 48);
            v89 = *(a2 + 48);
            v72 = v88 < v89;
            if ( v88 <= v89 )
            {
LABEL_281:
              v4 = -v72;
              v16 = LOBYTE(gConfig.bDllSortDirection) == 0;
            }
            else
            {
              v16 = LOBYTE(gConfig.bDllSortDirection) == 0;
              v4 = 1;
            }
            goto LABEL_419;
          }
          v82 = v69 - 40;
          if ( v82 )
          {
            v83 = v82 - 2;
            if ( !v83 )
            {
              v85 = lstrcmpiW(*(a1 + 336), *(a2 + 336));
              v16 = LOBYTE(gConfig.bDllSortDirection) == 0;
              v4 = v85;
              goto LABEL_419;
            }
            if ( v83 == 991 )
            {
              v84 = lstrcmpiW(*(a1 + 340), *(a2 + 340));
              v16 = LOBYTE(gConfig.bDllSortDirection) == 0;
              v4 = v84;
              goto LABEL_419;
            }
            goto LABEL_330;
          }
          v86 = (*(a2 + 44) >> 1) & 1;
          v87 = (*(a1 + 44) >> 1) & 1;
LABEL_308:
          v4 = v87 - v86;
          v16 = LOBYTE(gConfig.bDllSortDirection) == 0;
          goto LABEL_419;
        }
        v90 = v69 - 1111;
        if ( !v90 )
        {
          v93 = lstrcmpiW(*(a1 + 344), *(a2 + 344));
          v16 = LOBYTE(gConfig.bDllSortDirection) == 0;
          v4 = v93;
          goto LABEL_419;
        }
        v91 = v90 - 4;
        if ( !v91 )
        {
          v92 = sub_FC37B0(*(a1 + 368), *(a2 + 368));
          goto LABEL_350;
        }
        if ( v91 == 1 )
        {
          v92 = sub_FC37B0(*(a1 + 372), *(a2 + 372));
LABEL_350:
          v4 = v92;
LABEL_351:
          v16 = LOBYTE(gConfig.bDllSortDirection) == 0;
          goto LABEL_419;
        }
      }
LABEL_330:
      v4 = -1;
      v16 = LOBYTE(gConfig.bDllSortDirection) == 0;
      goto LABEL_419;
    }
    if ( v5 != 1040 )
    {
      if ( v5 == 1044 )
      {
        v107 = a3[1];
        switch ( v107 )
        {
          case 0:
            v4 = *(a1 + 44) - *(a2 + 44);
            v16 = byte_10653B4 == 0;
            goto LABEL_419;
          case 1:
            v108 = *(a1 + 576);
            if ( v108 != 0.0 || v108 != *(a2 + 576) )
            {
              v116 = *(a2 + 576);
              if ( v108 <= v116 )
              {
                v4 = (v116 <= v108) - 1;
                v16 = byte_10653B4 == 0;
              }
              else
              {
                v16 = byte_10653B4 == 0;
                v4 = 1;
              }
              goto LABEL_419;
            }
            v109 = *(a1 + 604);
            v110 = *(a2 + 604);
            v111 = *(a1 + 600);
            v112 = *(a2 + 600);
            if ( v109 < v110 )
              goto LABEL_377;
            if ( v109 > v110 )
              goto LABEL_375;
            if ( v111 > v112 )
            {
              v16 = byte_10653B4 == 0;
              v4 = 1;
              goto LABEL_419;
            }
            if ( v109 > v110 )
              goto LABEL_372;
            if ( v109 >= v110 )
            {
              if ( v111 < v112 )
              {
                v4 = -1;
                v16 = byte_10653B4 == 0;
                goto LABEL_419;
              }
LABEL_372:
              v113 = *(a1 + 584);
              v114 = *(a1 + 588);
              v115 = *(a2 + 584);
              if ( v114 >= SHIDWORD(v115) )
              {
                if ( v114 > SHIDWORD(v115) || v113 > v115 )
                {
LABEL_375:
                  v16 = byte_10653B4 == 0;
                  v4 = 1;
                  goto LABEL_419;
                }
                if ( __PAIR__(v114, v113) >= v115 )
                {
                  v4 = 0;
                  v16 = byte_10653B4 == 0;
                  goto LABEL_419;
                }
              }
            }
LABEL_377:
            v4 = -1;
            v16 = byte_10653B4 == 0;
            goto LABEL_419;
          case 2:
            if ( QueryThreadCycleTime && *(a1 + 40) )
            {
              v4 = sub_FC37B0(*(a1 + 600), *(a2 + 600));
              v16 = byte_10653B4 == 0;
            }
            else
            {
              v4 = *(a1 + 584) - *(a2 + 584);
              v16 = byte_10653B4 == 0;
            }
            goto LABEL_419;
          case 3:
          case 4:
            if ( *(a1 + 644) == -1 )
              goto LABEL_389;
            v117 = v107 - 3;
            if ( v117 )
            {
              if ( v117 != 1 )
                goto LABEL_391;
LABEL_389:
              v118 = _wcsicmp((a1 + 52), (a2 + 52));
            }
            else
            {
              v119 = *(a2 + 648);
              if ( !v119 || (v120 = *(a1 + 648)) == 0 )
              {
                v4 = (*(a1 + 648) - v119) >> 1;
                v16 = byte_10653B4 == 0;
                goto LABEL_419;
              }
              v118 = _wcsicmp(v120, *(a2 + 648));
            }
            v4 = v118;
            goto LABEL_391;
          default:
LABEL_391:
            v16 = byte_10653B4 == 0;
            goto LABEL_419;
        }
      }
      if ( v5 != 1192 )
        return v4;
      switch ( a3[1] )
      {
        case 0:
          v4 = *(a1 + 40) - *(a2 + 40);
          if ( *(a1 + 40) == *(a2 + 40) )
          {
            v121 = ntohl(*(a2 + 44));
            v122 = ntohl(*(v140 + 11));
            v4 = v122 - v121;
            if ( v122 == v121 )
            {
              v123 = ntohs(*(a2 + 584));
              v124 = ntohs(v140[292]);
              v4 = v124 - v123;
              if ( v124 == v123 )
              {
                v125 = ntohl(*(a2 + 1108));
                v126 = ntohl(v140[554]);
                v4 = v126 - v125;
                if ( v126 == v125 )
                {
                  v127 = ntohs(*(a2 + 1648));
                  v128 = ntohs(v140[824]);
                  v4 = v128 - v127;
                  if ( v128 == v127 )
                    v4 = *(v140 + 543) - *(a2 + 2172);
                }
              }
            }
          }
          break;
        case 1:
          v129 = *(a1 + 40);
          v130 = *(a2 + 40);
          if ( v129 == v130 )
          {
            if ( *(a2 + 44) == *(a1 + 44) )
            {
              v131 = ntohs(*(a2 + 584));
              v4 = ntohs(v140[292]) - v131;
            }
            else
            {
              v132 = ntohl(*(a2 + 44));
              v4 = ntohl(*(v140 + 11)) - v132;
            }
          }
          else
          {
            v4 = v130 - v129;
          }
          break;
        case 2:
          v133 = *(a1 + 40);
          v134 = *(a2 + 40);
          if ( v133 == v134 )
          {
            if ( *(a2 + 1108) != *(a1 + 1108) )
            {
              v136 = ntohl(*(a2 + 1108));
              goto LABEL_414;
            }
            v135 = ntohs(*(a2 + 1648));
            v4 = ntohs(v140[824]) - v135;
          }
          else
          {
            v4 = v134 - v133;
          }
          break;
        case 3:
          v4 = *(a1 + 2172) - *(a2 + 2172);
          if ( *(a1 + 2172) == *(a2 + 2172) )
          {
            v136 = ntohl(*(a2 + 1108));
LABEL_414:
            v4 = ntohl(*(v140 + 277)) - v136;
          }
          break;
        case 4:
          v4 = _wcsicmp(*(a1 + 2184), *(a2 + 2184));
          break;
        default:
          break;
      }
      v16 = byte_105D225 == 0;
LABEL_419:
      if ( v16 )
        v4 = -v4;
      return v4;
    }
    v105 = a3[1];
    if ( v105 )
    {
      if ( v105 != 1 )
      {
LABEL_358:
        v16 = byte_105D224 == 0;
        goto LABEL_419;
      }
      v106 = _wcsicmp(*(a1 + 48), *(a2 + 48));
    }
    else
    {
      v106 = _wcsicmp(*(a1 + 40), *(a2 + 40));
    }
    v4 = v106;
    goto LABEL_358;
  }
  if ( !gConfig.bShowProcessTree )
  {
    v13 = gConfig.dwProcessColumnMap[a3[1]];
    if ( v13 <= 1032 )
    {
      if ( v13 != 1032 )
      {
        switch ( v13 )
        {
          case 3:
            v4 = lstrcmpiW(*(a1 + 60), *(a2 + 60));
            goto LABEL_253;
          case 4:
            goto LABEL_189;
          case 5:
            v4 = *(a1 + 1368) - *(a2 + 1368);
            goto LABEL_253;
          case 7:
            v14 = *(a1 + 1304);
            v15 = *(a2 + 1304);
            if ( v14 <= v15 )
              goto LABEL_25;
            v16 = gConfig.bProcessSortDirection == 0;
            v4 = 1;
            goto LABEL_419;
          case 9:
            v4 = sub_FC37B0(*(a1 + 920), *(a2 + 920));
            goto LABEL_253;
          case 10:
            v4 = sub_FC37B0(*(a1 + 924), *(a2 + 924));
            goto LABEL_253;
          case 18:
            v4 = *(a1 + 92) - *(a2 + 92);
            goto LABEL_253;
          case 19:
            v4 = lstrcmpiW(*(a1 + 88), *(a2 + 88));
            goto LABEL_253;
          case 25:
            v4 = lstrcmpiW((a1 + 654), (a2 + 654));
            goto LABEL_253;
          case 35:
            v4 = lstrcmpiW((a1 + 104), (a2 + 104));
            goto LABEL_253;
          case 38:
            v4 = lstrcmpiW(*(a1 + 784), *(a2 + 784));
            goto LABEL_253;
          default:
            goto LABEL_26;
        }
        goto LABEL_26;
      }
      v4 = lstrcmpiW(*(a1 + 800), *(a2 + 800));
      goto LABEL_253;
    }
    if ( v13 > 1317 )
    {
      if ( v13 > 1609 )
      {
        if ( v13 > 40757 )
          goto LABEL_26;
        if ( v13 != 40757 )
        {
          switch ( v13 )
          {
            case 1610:
              v4 = *(a1 + 1088) - *(a2 + 1088);
              goto LABEL_253;
            case 1611:
              v4 = *(a1 + 1104) - *(a2 + 1104);
              goto LABEL_253;
            case 1612:
              v4 = *(a1 + 1120) - *(a2 + 1120);
              goto LABEL_253;
            case 1613:
              v4 = *(a1 + 1136) - *(a2 + 1136);
              goto LABEL_253;
            case 1614:
              v4 = *(a1 + 1152) - *(a2 + 1152);
              goto LABEL_253;
            case 1615:
              v4 = sub_FC37B0(*(a1 + 1096) + *(a1 + 1128), *(a2 + 1096) + *(a2 + 1128));
              goto LABEL_253;
            case 1616:
              v4 = sub_FC37B0(*(a1 + 1096), *(a2 + 1096));
              goto LABEL_253;
            case 1617:
              v4 = sub_FC37B0(*(a1 + 1080), *(a2 + 1080));
              goto LABEL_253;
            case 1618:
              v4 = sub_FC37B0(*(a1 + 1112), *(a2 + 1112));
              goto LABEL_253;
            case 1619:
              v4 = sub_FC37B0(*(a1 + 1128), *(a2 + 1128));
              goto LABEL_253;
            case 1620:
              v4 = sub_FC37B0(*(a1 + 1144), *(a2 + 1144));
              goto LABEL_253;
            case 1621:
              v4 = sub_FC37B0(*(a1 + 1160), *(a2 + 1160));
              goto LABEL_253;
            case 1622:
              v4 = sub_FC37B0(*(a1 + 1168), *(a2 + 1168));
              goto LABEL_253;
            case 1623:
              v4 = *(a1 + 1176) - *(a2 + 1176);
              goto LABEL_253;
            case 1624:
              v4 = *(a1 + 1192) - *(a2 + 1192);
              goto LABEL_253;
            case 1625:
              v4 = *(a1 + 1208) - *(a2 + 1208);
              goto LABEL_253;
            case 1626:
              v4 = *(a1 + 1224) - *(a2 + 1224);
              goto LABEL_253;
            case 1627:
              v4 = *(a1 + 1240) - *(a2 + 1240);
              goto LABEL_253;
            case 1628:
              v4 = *(a1 + 1256) - *(a2 + 1256);
              goto LABEL_253;
            case 1629:
              v4 = sub_FC37B0(*(a1 + 1200) + *(a1 + 1232), *(a2 + 1200) + *(a2 + 1232));
              goto LABEL_253;
            case 1630:
              v4 = sub_FC37B0(*(a1 + 1184), *(a2 + 1184));
              goto LABEL_253;
            case 1631:
              v4 = sub_FC37B0(*(a1 + 1200), *(a2 + 1200));
              goto LABEL_253;
            case 1632:
              v4 = sub_FC37B0(*(a1 + 1216), *(a2 + 1216));
              goto LABEL_253;
            case 1633:
              v4 = sub_FC37B0(*(a1 + 1232), *(a2 + 1232));
              goto LABEL_253;
            case 1634:
              v4 = sub_FC37B0(*(a1 + 1248), *(a2 + 1248));
              goto LABEL_253;
            case 1635:
              v4 = sub_FC37B0(*(a1 + 1264), *(a2 + 1264));
              goto LABEL_253;
            case 1636:
              v4 = sub_FC37B0(*(a1 + 1272), *(a2 + 1272));
              goto LABEL_253;
            case 1637:
              v14 = *(a1 + 1312);
              v15 = *(a2 + 1312);
              if ( v14 <= v15 )
                goto LABEL_25;
              v16 = gConfig.bProcessSortDirection == 0;
              v4 = 1;
              goto LABEL_419;
            case 1638:
LABEL_189:
              v49 = *(a1 + 68);
              v50 = *(a2 + 68);
              if ( v49 < 0 )
                v49 = 0;
              if ( v50 < 0 )
                v50 = 0;
              v51 = (v50 & 0xFFFFFFF);
              v52 = (v49 & 0xFFFFFFF);
              goto LABEL_194;
            case 1650:
              v14 = *(a1 + 1384);
              v15 = *(a2 + 1384);
              if ( v14 <= v15 )
                goto LABEL_25;
              v16 = gConfig.bProcessSortDirection == 0;
              v4 = 1;
              goto LABEL_419;
            case 1651:
              v4 = sub_FC37B0(*(a1 + 1408), *(a2 + 1408));
              goto LABEL_253;
            case 1652:
              v4 = sub_FC37B0(*(a1 + 1424), *(a2 + 1424));
              goto LABEL_253;
            case 1653:
              v4 = sub_FC37B0(*(a1 + 1440), *(a2 + 1440));
              goto LABEL_253;
            case 1654:
              v4 = lstrcmpiW(*(a1 + 824), *(a2 + 824));
              goto LABEL_253;
            case 1655:
LABEL_218:
              v4 = sub_FB4EF0((a1 + 624), (a2 + 624));
              goto LABEL_253;
            case 1656:
              v4 = lstrcmpiW(*(a1 + 828), *(a2 + 828));
              goto LABEL_253;
            case 1667:
              v4 = *(a2 + 644) - *(a1 + 644);
              goto LABEL_253;
            case 1670:
              v53 = *(a1 + 844);
              if ( v53 && (v54 = *(a2 + 844)) != 0 )
              {
                v55 = *(v53 + 4);
                if ( v55 != 1 || *(v54 + 4) != 1 )
                {
                  v4 = v55 - *(v54 + 4);
                }
                else
                {
                  lpString1 = *(v53 + 4);
                  v140 = 1;
                  v138 = -1;
                  v137 = -1;
                  v56 = *(v53 + 40);
                  if ( v56 )
                    v57 = *v56;
                  else
                    v57 = 0;
                  scan_fn(v57, L"%d/%d", &lpString1);
                  v58 = *(*(a2 + 844) + 40);
                  if ( v58 )
                    v59 = *v58;
                  else
                    v59 = 0;
                  scan_fn(v59, L"%d/%d", &v140);
                  v52 = lpString1;
                  v51 = v140;
                  if ( lpString1 == v140 )
                    v4 = v138 - v137;
                  else
LABEL_194:
                    v4 = v52 - v51;
                }
              }
              else
              {
                v4 = sub_FC37B0(v53, *(a2 + 844));
              }
              goto LABEL_253;
            case 1673:
              v4 = *(a1 + 649) - *(a2 + 649);
              goto LABEL_253;
            case 1674:
              v4 = ((*(a1 + 40) >> 13) & 1) - ((*(a2 + 40) >> 13) & 1);
              goto LABEL_253;
            default:
              goto LABEL_26;
          }
          goto LABEL_26;
        }
        v42 = *(a1 + 650);
        v43 = *(a2 + 650);
        v44 = *(a1 + 650) & 0x4000;
        v45 = *(a2 + 650) & 0x4000;
LABEL_250:
        v4 = v44 - v45;
        if ( v4 )
          goto LABEL_27;
        if ( !v42 )
          goto LABEL_26;
        LOBYTE(v4) = v43 == 0;
      }
      else
      {
        if ( v13 != 1609 )
        {
          switch ( v13 )
          {
            case 1326:
              v4 = *(a1 + 976) - *(a2 + 976);
              goto LABEL_253;
            case 1327:
              v4 = sub_FC37B0(*(a1 + 984), *(a2 + 984));
              goto LABEL_253;
            case 1328:
              v4 = *(a1 + 1008) - *(a2 + 1008);
              goto LABEL_253;
            case 1329:
              v4 = sub_FC37B0(*(a1 + 1016), *(a2 + 1016));
              goto LABEL_253;
            case 1330:
              v4 = sub_FC37B0(*(a1 + 984) + *(a1 + 1016), *(a2 + 984) + *(a2 + 1016));
              goto LABEL_253;
            case 1332:
              v4 = sub_FC37B0(*(a1 + 1048), *(a2 + 1048));
              goto LABEL_253;
            case 1333:
              v4 = sub_FC37B0(*(a1 + 1056), *(a2 + 1056));
              goto LABEL_253;
            case 1335:
              v4 = *(a1 + 1040) - *(a2 + 1040);
              goto LABEL_253;
            case 1336:
LABEL_151:
              v4 = -1;
              if ( gConfig.dwProcessColumnMap[a3[1]] == 1336 )
              {
                v46 = *(a1 + 816);
                v140 = *(a2 + 816);
              }
              else
              {
                v46 = *(a1 + 820);
                v140 = *(a2 + 820);
              }
              v47 = lstrcmpW;
              lpString1 = v46;
              if ( v46 )
              {
                if ( lstrcmpW(v46, L"Low") )
                {
                  if ( lstrcmpW(lpString1, L"Medium") )
                  {
                    if ( lstrcmpW(lpString1, L"High") )
                    {
                      if ( !lstrcmpW(lpString1, L"System") )
                        v4 = 3;
                    }
                    else
                    {
                      v4 = 2;
                    }
                  }
                  else
                  {
                    v4 = 1;
                  }
                }
                else
                {
                  v4 = 0;
                }
                v47 = lstrcmpW;
              }
              else
              {
                v4 = -2;
              }
              if ( v140 )
              {
                if ( v47(v140, L"Low") )
                {
                  if ( lstrcmpW(v140, L"Medium") )
                  {
                    if ( lstrcmpW(v140, L"High") )
                    {
                      v16 = lstrcmpW(v140, L"System") == 0;
                      v48 = -1;
                      if ( v16 )
                        v48 = 3;
                      v4 -= v48;
                    }
                    else
                    {
                      v4 -= 2;
                    }
                  }
                  else
                  {
                    --v4;
                  }
                }
              }
              else
              {
                v4 += 2;
              }
              goto LABEL_253;
            case 1337:
              v4 = ((*(a1 + 40) >> 9) & 1) - ((*(a2 + 40) >> 9) & 1);
              goto LABEL_253;
            case 1338:
              v42 = *(a1 + 650);
              v43 = *(a2 + 650);
              v44 = *(a1 + 650) & 0x40;
              v45 = *(a2 + 650) & 0x40;
              goto LABEL_250;
            case 1339:
              v4 = *(a1 + 872) - *(a2 + 872);
              goto LABEL_253;
            case 1340:
              v4 = *(a1 + 952) - *(a2 + 952);
              goto LABEL_253;
            case 1341:
              v4 = sub_FC37B0(*(a1 + 912), *(a2 + 912));
              goto LABEL_253;
            case 1342:
              v4 = sub_FC37B0(*(a1 + 916), *(a2 + 916));
              goto LABEL_253;
            default:
              goto LABEL_26;
          }
          goto LABEL_26;
        }
        v4 = *(a1 + 1072) - *(a2 + 1072);
      }
    }
    else
    {
      if ( v13 != 1317 )
      {
        switch ( v13 )
        {
          case 1033:
            v4 = lstrcmpiW(*(a1 + 788), *(a2 + 788));
            goto LABEL_253;
          case 1055:
          case 1191:
            v14 = *(a1 + 1296);
            if ( v14 != 0.0 || v14 != *(a2 + 1296) )
            {
              v15 = *(a2 + 1296);
              if ( v14 > v15 )
              {
                v16 = gConfig.bProcessSortDirection == 0;
                v4 = 1;
                goto LABEL_419;
              }
LABEL_25:
              if ( v15 <= v14 )
                goto LABEL_254;
            }
            else
            {
              v17 = *(a1 + 1356);
              v18 = *(a2 + 1356);
              v19 = *(a1 + 1352);
              v20 = *(a2 + 1352);
              if ( v17 < v18 )
                break;
              if ( v17 > v18 || v19 > v20 )
                goto LABEL_45;
              if ( v17 > v18 || v17 >= v18 && v19 >= v20 )
              {
                v21 = *(a1 + 1340);
                v22 = *(a2 + 1340);
                v23 = *(a1 + 1336);
                v24 = *(a2 + 1336);
                if ( v21 >= v22 )
                {
                  if ( v21 > v22 )
                  {
LABEL_45:
                    v16 = gConfig.bProcessSortDirection == 0;
                    v4 = 1;
                    goto LABEL_419;
                  }
                  if ( v23 > v24 )
                  {
                    v16 = gConfig.bProcessSortDirection == 0;
                    v4 = 1;
                    goto LABEL_419;
                  }
                  if ( v21 > v22 )
                    goto LABEL_254;
                  if ( v21 >= v22 )
                  {
                    if ( v23 < v24 )
                    {
                      v4 = -1;
                      v16 = gConfig.bProcessSortDirection == 0;
                      goto LABEL_419;
                    }
                    goto LABEL_254;
                  }
                }
              }
            }
            break;
          case 1056:
            v4 = *(a1 + 100) - *(a2 + 100);
            goto LABEL_253;
          case 1059:
            v4 = sub_FC37B0(*(a1 + 880), *(a2 + 880));
            goto LABEL_253;
          case 1060:
          case 1193:
            v4 = sub_FC37B0(*(a1 + 888), *(a2 + 888));
            goto LABEL_253;
          case 1061:
            v4 = lstrcmpiW(*(a1 + 792), *(a2 + 792));
            goto LABEL_253;
          case 1062:
            v4 = sub_FC37B0(*(a1 + 896), *(a2 + 896));
            goto LABEL_253;
          case 1063:
            v4 = sub_FC37B0(*(a1 + 900), *(a2 + 900));
            goto LABEL_253;
          case 1064:
            v4 = sub_FC37B0(*(a1 + 904), *(a2 + 904));
            goto LABEL_253;
          case 1065:
            v4 = *(a1 + 96) - *(a2 + 96);
            goto LABEL_253;
          case 1066:
            v4 = *(a1 + 1380) - *(a2 + 1380);
            goto LABEL_253;
          case 1067:
            v4 = *(a1 + 1376) - *(a2 + 1376);
            goto LABEL_253;
          case 1068:
            v4 = *(a1 + 960) - *(a2 + 960);
            goto LABEL_253;
          case 1069:
            v4 = sub_FC37B0(*(a1 + 968), *(a2 + 968));
            goto LABEL_253;
          case 1070:
            v4 = *(a1 + 992) - *(a2 + 992);
            goto LABEL_253;
          case 1071:
            v4 = sub_FC37B0(*(a1 + 1000), *(a2 + 1000));
            goto LABEL_253;
          case 1072:
            v4 = *(a1 + 1024) - *(a2 + 1024);
            goto LABEL_253;
          case 1073:
            v4 = sub_FC37B0(*(a1 + 1032), *(a2 + 1032));
            goto LABEL_253;
          case 1086:
            goto LABEL_218;
          case 1087:
            v4 = sub_FB4EF0((a1 + 1320), (a2 + 1320));
            goto LABEL_253;
          case 1091:
            v4 = sub_FC37B0(*(a1 + 1344), *(a2 + 1344));
            goto LABEL_253;
          case 1092:
            v4 = sub_FC37B0(*(a1 + 1336), *(a2 + 1336));
            goto LABEL_253;
          case 1094:
            v25 = *(a1 + 1284);
            if ( !v25 )
              goto LABEL_97;
            v26 = *(a2 + 1284);
            if ( !v26 )
              goto LABEL_95;
            v4 = *v25 - *v26;
            goto LABEL_253;
          case 1095:
            v25 = *(a1 + 1284);
            if ( !v25 )
              goto LABEL_97;
            v27 = *(a2 + 1284);
            if ( !v27 )
              goto LABEL_95;
            v4 = (*(v25 + 8) - *(v27 + 8));
            goto LABEL_253;
          case 1096:
            v25 = *(a1 + 1284);
            if ( !v25 )
              goto LABEL_97;
            v28 = *(a2 + 1284);
            if ( !v28 )
              goto LABEL_95;
            v4 = *(v25 + 16) - *(v28 + 16);
            goto LABEL_253;
          case 1097:
            v25 = *(a1 + 1284);
            if ( !v25 )
              goto LABEL_97;
            v29 = *(a2 + 1284);
            if ( !v29 )
              goto LABEL_95;
            v4 = *(v25 + 48) - *(v29 + 48);
            goto LABEL_253;
          case 1098:
            v25 = *(a1 + 1284);
            if ( !v25 )
              goto LABEL_97;
            v30 = *(a2 + 1284);
            if ( !v30 )
              goto LABEL_95;
            v4 = *(v25 + 32) - *(v30 + 32);
            goto LABEL_253;
          case 1099:
            v25 = *(a1 + 1284);
            if ( !v25 )
              goto LABEL_97;
            v31 = *(a2 + 1284);
            if ( !v31 )
              goto LABEL_95;
            v4 = *(v25 + 24) - *(v31 + 24);
            goto LABEL_253;
          case 1100:
            v25 = *(a1 + 1284);
            if ( !v25 )
              goto LABEL_97;
            v32 = *(a2 + 1284);
            if ( !v32 )
              goto LABEL_95;
            v4 = *(v25 + 56) - *(v32 + 56);
            goto LABEL_253;
          case 1101:
            v25 = *(a1 + 1284);
            if ( !v25 )
              goto LABEL_97;
            v33 = *(a2 + 1284);
            if ( !v33 )
              goto LABEL_95;
            v4 = *(v25 + 40) - *(v33 + 40);
            goto LABEL_253;
          case 1103:
            v25 = *(a1 + 1284);
            if ( !v25 )
              goto LABEL_97;
            v35 = *(a2 + 1284);
            if ( !v35 )
              goto LABEL_95;
            v4 = *(v25 + 112) - *(v35 + 112);
            goto LABEL_253;
          case 1104:
            v25 = *(a1 + 1284);
            if ( !v25 )
              goto LABEL_97;
            v36 = *(a2 + 1284);
            if ( !v36 )
              goto LABEL_95;
            v4 = *(v25 + 64) - *(v36 + 64);
            goto LABEL_253;
          case 1105:
            v25 = *(a1 + 1284);
            if ( !v25 )
              goto LABEL_97;
            v37 = *(a2 + 1284);
            if ( !v37 )
              goto LABEL_95;
            v4 = *(v25 + 72) - *(v37 + 72);
            goto LABEL_253;
          case 1106:
            v25 = *(a1 + 1284);
            if ( !v25 )
              goto LABEL_97;
            v38 = *(a2 + 1284);
            if ( !v38 )
              goto LABEL_95;
            v4 = *(v25 + 80) - *(v38 + 80);
            goto LABEL_253;
          case 1107:
            v25 = *(a1 + 1284);
            if ( !v25 )
              goto LABEL_97;
            v39 = *(a2 + 1284);
            if ( !v39 )
              goto LABEL_95;
            v4 = (*(v25 + 88) - *(v39 + 88));
            goto LABEL_253;
          case 1108:
            v25 = *(a1 + 1284);
            if ( !v25 )
              goto LABEL_97;
            v40 = *(a2 + 1284);
            if ( !v40 )
              goto LABEL_95;
            v4 = *(v25 + 104) - *(v40 + 104);
            goto LABEL_253;
          case 1109:
            v25 = *(a1 + 1284);
            if ( !v25 )
              goto LABEL_97;
            v41 = *(a2 + 1284);
            if ( !v41 )
              goto LABEL_95;
            v4 = *(v25 + 120) - *(v41 + 120);
            goto LABEL_253;
          case 1110:
            v25 = *(a1 + 1284);
            if ( !v25 )
              goto LABEL_97;
            v34 = *(a2 + 1284);
            if ( v34 )
            {
              v4 = *(v25 + 128) - *(v34 + 128);
            }
            else
            {
LABEL_95:
              if ( v25 )
              {
                v16 = gConfig.bProcessSortDirection == 0;
                v4 = 1;
                goto LABEL_419;
              }
LABEL_97:
              v4 = -(*(a2 + 1284) != 0);
            }
            goto LABEL_253;
          case 1114:
            v4 = sub_FC37B0(*(a1 + 876), *(a2 + 876));
            goto LABEL_253;
          case 1115:
            v4 = sub_FC37B0(*(a1 + 936), *(a2 + 936));
            goto LABEL_253;
          case 1116:
            v4 = sub_FC37B0(*(a1 + 940), *(a2 + 940));
            goto LABEL_253;
          case 1118:
            v4 = sub_FC37B0(*(a1 + 948), *(a2 + 948));
            goto LABEL_253;
          case 1179:
            v4 = sub_FC37B0(*(a1 + 884), *(a2 + 884));
            goto LABEL_253;
          case 1180:
            goto LABEL_151;
          case 1181:
            v4 = lstrcmpiW(*(a1 + 796), *(a2 + 796));
            goto LABEL_253;
          case 1187:
            v4 = lstrcmpiW(*(a1 + 836), *(a2 + 836));
            goto LABEL_253;
          case 1192:
            v4 = *(a1 + 892) - *(a2 + 892);
            goto LABEL_253;
          case 1195:
            v4 = sub_FC37B0(*(a1 + 1360), *(a2 + 1360));
            goto LABEL_253;
          case 1196:
            v4 = *(a1 + 620) - *(a2 + 620);
            if ( *(a1 + 620) != *(a2 + 620) )
              goto LABEL_27;
            v4 = (*(a1 + 616) - *(a2 + 616)) >> 2;
            goto LABEL_253;
          case 1199:
            v4 = *(a1 + 636) - *(a2 + 636);
            goto LABEL_253;
          case 1200:
            v4 = sub_FC37B0(*(a1 + 1352), *(a2 + 1352));
            goto LABEL_253;
          default:
            break;
        }
LABEL_26:
        v4 = -1;
LABEL_27:
        v16 = gConfig.bProcessSortDirection == 0;
        goto LABEL_419;
      }
      v4 = sub_FC37B0(*(a1 + 944), *(a2 + 944));
    }
LABEL_253:
    if ( v4 )
      goto LABEL_27;
LABEL_254:
    v60 = lstrcmpiW(*(a1 + 60), *(a2 + 60));
    v16 = gConfig.bProcessSortDirection == 0;
    v4 = v60;
    goto LABEL_419;
  }
  v7 = *(a2 + 84);
  v8 = *(a1 + 80);
  v9 = *(a2 + 80);
  v10 = *(a1 + 84);
  if ( v7 == a1 )
    return -1;
  while ( 1 )
  {
    if ( v10 == v6 )
      return 1;
    v11 = v8 < v9;
    if ( v8 == v9 )
      break;
LABEL_9:
    if ( v11 )
      goto LABEL_13;
    v3 = v10;
    if ( v8 <= v9 )
    {
      --v8;
LABEL_13:
      v6 = v7;
      --v9;
      goto LABEL_14;
    }
    --v8;
LABEL_14:
    v7 = v6[21];
    v10 = v3[21];
    if ( v7 == v3 )
      return -1;
  }
  if ( v8 && v10 != v7 )
  {
    v11 = v8 < v9;
    goto LABEL_9;
  }
  result = sub_FB4EF0(v3 + 156, v6 + 156);
  if ( !result )
    result = v3[17] - v6[17];
  return result;
}
// 1032BB0: using guessed type wchar_t aDD[6];
// 105D224: using guessed type char byte_105D224;
// 105D225: using guessed type char byte_105D225;
// 10653B4: using guessed type char byte_10653B4;

//----- (00FBCB80) --------------------------------------------------------
int __stdcall CTreeView::InitListHeader(HWND hWnd, UINT *pnIDs, WORD *pnWidths, DWORD dwColumnCount)
{
  HWND (__stdcall *GetParent)(HWND); // ecx
  WPARAM nColumn; // esi
  char v6; // al
  __m128i v7; // xmm1
  UINT *v8; // edx
  unsigned int Index; // ecx
  unsigned int v10; // eax
  __m128i v11; // xmm0
  tagLVCOLUMNW ColumnInfo; // [esp+0h] [ebp-22Ch]
  WORD *pnWidths_1; // [esp+20h] [ebp-20Ch]
  signed int *pnIDs_1; // [esp+24h] [ebp-208h]
  UINT arrIDS[96]; // [esp+28h] [ebp-204h]
  WCHAR szText[64]; // [esp+1A8h] [ebp-84h]

  pnIDs_1 = pnIDs;
  pnWidths_1 = pnWidths;
  ColumnInfo.mask = 0;
  _mm_storeu_si128(&ColumnInfo.fmt, 0i64);
  ColumnInfo.iOrder = 0;
  *&ColumnInfo.iSubItem = 0i64;
  while ( SendMessageW(hWnd, LVM_DELETECOLUMN, 0, 0) )
    ;
  GetParent = ::GetParent;
  nColumn = 0;
  // LVCF_FMT | LVCF_TEXT |  LVCF_WIDTH | LVCF_SUBITEM;
  ColumnInfo.mask = 0xF;
  ColumnInfo.pszText = szText;
  if ( dwColumnCount )
  {
    while ( 1 )
    {
      ColumnInfo.iSubItem = nColumn;
      ColumnInfo.cx = abs(pnWidths_1[nColumn]);
      if ( GetParent(hWnd) != ghMainWnd )
        break;
      if ( (pnWidths_1[nColumn] & 0x8000u) != 0 )
        goto LABEL_9;
      v6 = IsStringID(pnIDs_1[nColumn]);
      ColumnInfo.fmt = 0;
      if ( v6 )
        goto LABEL_9;
LABEL_10:
      LoadStringW(ghInstance, pnIDs_1[nColumn], szText, 64);
      if ( SendMessageW(hWnd, LVM_INSERTCOLUMNW, nColumn, &ColumnInfo) == -1 )
        return 0;
      GetParent = ::GetParent;
      if ( ++nColumn >= dwColumnCount )
        goto __Break;
    }
    if ( (pnWidths_1[nColumn] & 0x8000u) == 0 )
    {
      ColumnInfo.fmt = 0;
      goto LABEL_10;
    }
LABEL_9:
    ColumnInfo.fmt = LVCF_FMT;
    goto LABEL_10;
  }
__Break:
  if ( GetParent(hWnd) == ghMainWnd && IsStringID(*pnIDs_1) )
  {
    ColumnInfo.mask = 1;
    SendMessageW(hWnd, LVM_GETCOLUMNW, 0, &ColumnInfo);
    ColumnInfo.fmt |= 1u;
    ColumnInfo.mask = 1;
    SendMessageW(hWnd, LVM_SETCOLUMNW, 0, &ColumnInfo);
  }
  SetWindowLongW(hWnd, GWLP_USERDATA, dwColumnCount);
  v7 = _mm_load_si128(&gIntArray);
  v8 = &arrIDS[4];
  Index = 0;
  do
  {
    v10 = Index + 4;
    v8 += 8;
    v11 = _mm_add_epi32(_mm_shuffle_epi32(_mm_cvtsi32_si128(Index), 0), v7);
    Index += 8;
    _mm_storeu_si128(v8 - 3, v11);
    _mm_storeu_si128(v8 - 2, _mm_add_epi32(_mm_shuffle_epi32(_mm_cvtsi32_si128(v10), 0), v7));
  }
  while ( Index < 96 );
  SendMessageW(hWnd, LVM_SETCOLUMNORDERARRAY, dwColumnCount, arrIDS);
  InvalidateRect(hWnd, 0, 1);
  return 1;
}
// 103EA50: using guessed type RECT gIntArray;

//----- (00FBCDD0) --------------------------------------------------------
int __cdecl sub_FBCDD0(int a1, int a2)
{
  HWND v2; // edi
  tagTREEVIEWITEMPARAM *v3; // esi
  int v4; // eax
  int v5; // ecx
  int v6; // ecx
  int v7; // eax
  const WCHAR **v9; // eax
  const WCHAR *v10; // eax
  const WCHAR **v11; // eax
  const WCHAR *v12; // eax
  tagTREEVIEWLISTITEMPARAM *v13; // [esp-8h] [ebp-88h]
  LVITEMW item; // [esp+8h] [ebp-78h]
  struct tagPOINT Point; // [esp+3Ch] [ebp-44h]
  LVHITTESTINFO SubHitTestInfo; // [esp+44h] [ebp-3Ch]
  LVHITTESTINFO HitTestInfo; // [esp+58h] [ebp-28h]
  RECT lParam_1; // [esp+6Ch] [ebp-14h]

  HitTestInfo.pt.x = 0;
  _mm_storeu_si128(&HitTestInfo.pt.y, 0i64);
  item.mask = 0;
  memset(&item.iItem, 0, 0x30u);
  Point.x = 0;
  Point.y = 0;
  if ( a1 == 101 )
  {
    v2 = ghWndTreeListView;
  }
  else
  {
    if ( a1 != 104 )
      return 0;
    v2 = ghWndDllsListCtrl;
  }
  GetCursorPos(&Point);
  ScreenToClient(v2, &Point);
  HitTestInfo.pt = Point;
  item.iItem = SendMessageW(v2, LVM_HITTEST, 0, &HitTestInfo);
  item.iSubItem = 0;
  item.mask = 4;
  if ( SendMessageW(v2, LVM_GETITEMW, 0, &item) != 1 )
    return 0;
  sub_FBA880(v2, item.iItem, HitTestInfo.iSubItem, &lParam_1);
  v3 = item.lParam;
  if ( v2 != ghWndTreeListView )
  {
    SubHitTestInfo.pt.x = *(a2 + 32);
    SubHitTestInfo.pt.y = *(a2 + 36);
    SendMessageW(v2, LVM_SUBITEMHITTEST, 0, &SubHitTestInfo);
    if ( gConfig.dwDllColumnMap[SubHitTestInfo.iSubItem] == IDS_VIRUSTOTAL && sub_1001820(v3[4].field_1C) )
    {
      v11 = *(v3[4].field_1C + 36);
      if ( v11 )
        v12 = *v11;
      else
        v12 = 0;
      LaunchWebBrowser(v2, 0, v12);
    }
    return 0;
  }
  v4 = gConfig.dwProcessColumnMap[HitTestInfo.iSubItem];
  if ( v4 != 3 )
  {
    if ( v4 == 1670 && sub_1001820(item.lParam[10].field_4) )
    {
      v9 = *(v3[10].field_4 + 36);
      if ( v9 )
        v10 = *v9;
      else
        v10 = 0;
      LaunchWebBrowser(v2, 0, v10);
    }
    goto LABEL_24;
  }
  if ( !item.lParam->field_30
    || (!gConfig.bShowProcessTree ? (v5 = 0) : (v5 = item.lParam->field_50),
        (v6 = lParam_1.left + 16 * v5, HitTestInfo.pt.x <= v6 + 1) || HitTestInfo.pt.x >= v6 + 17) )
  {
LABEL_24:
    RefreshMenuWithTreeViewItemStatus(v3);
    RefreshVirusTotalMenuItem(v3);
    return 0;
  }
  v7 = item.lParam->field_28;
  if ( v7 & 4 )
  {
    v13 = item.lParam;
    item.lParam->field_28 = v7 & 0xFFFFFFFB;
  }
  else
  {
    v13 = item.lParam;
    item.lParam->field_28 = v7 | 4;
  }
  sub_FB8DA0(v13);
  RefreshMenuWithTreeViewItemStatus(v3);
  RefreshVirusTotalMenuItem(v3);
  return 0;
}

//----- (00FBD040) --------------------------------------------------------
int __cdecl sub_FBD040(WPARAM uTabID, int pThis)
{
  HWND *pThis_1; // ebx
  void (__stdcall *SendMessageW)(HWND, UINT, WPARAM, LPARAM); // esi
  int v4; // eax
  tagTREEVIEWITEMPARAM *v5; // edi
  bool v6; // al
  HMENU v7; // eax
  void *v8; // eax
  signed int v9; // edi
  signed int v10; // ebx
  DWORD v11; // ST04_4
  HMENU v12; // eax
  BOOL v13; // ST0C_4
  HMENU v14; // eax
  int v15; // edi
  HWND v16; // ST00_4
  int v17; // edi
  int v18; // esi
  int v19; // eax
  DWORD v20; // edx
  char v21; // al
  HWND v22; // ecx
  LRESULT v23; // eax
  HWND v24; // ST00_4
  HWND v25; // ST00_4
  LPARAM v27; // [esp+Ch] [ebp-94h]
  tagTREEVIEWITEMPARAM *v28; // [esp+14h] [ebp-8Ch]
  tagLVITEMW item; // [esp+24h] [ebp-7Ch]
  LPARAM v30; // [esp+58h] [ebp-48h]
  int v31; // [esp+5Ch] [ebp-44h]
  int v32; // [esp+60h] [ebp-40h]
  int v33; // [esp+64h] [ebp-3Ch]
  int v34; // [esp+68h] [ebp-38h]
  LPARAM lParam; // [esp+6Ch] [ebp-34h]
  int v36; // [esp+70h] [ebp-30h]
  int v37; // [esp+78h] [ebp-28h]
  WPARAM wParam; // [esp+8Ch] [ebp-14h]
  int v39; // [esp+90h] [ebp-10h]
  tagTREEVIEWITEMPARAM *v40; // [esp+94h] [ebp-Ch]
  void *i; // [esp+98h] [ebp-8h]
  LRESULT pThis_2; // [esp+9Ch] [ebp-4h]

  pThis_1 = pThis;
  SendMessageW = ::SendMessageW;
  v4 = *(pThis + 16);
  v5 = 0;
  pThis_2 = pThis;
  v40 = 0;
  wParam = uTabID;
  v39 = v4;
  if ( uTabID == IDC_TREEVIEW_LIST )
  {
    item.iItem = ::SendMessageW(ghWndTreeListView, LVM_GETNEXTITEM, 0xFFFFFFFF, 2);
    if ( item.iItem != -1 )
    {
      item.iSubItem = 0;
      item.mask = 4;
      ::SendMessageW(ghWndTreeListView, LVM_GETITEMW, 0, &item);
      v40 = item.lParam;
    }
    v6 = gConfig.bProcessSortDirection;
    if ( gConfig.bShowProcessTree || gConfig.dwProcessColumnMap[*(pThis + 16)] != 3 || gConfig.bProcessSortDirection )
    {
      gConfig.bShowProcessTree = 0;
      if ( gConfig.dwProcessSortColumn == *(pThis + 16) )
      {
        v6 = gConfig.bProcessSortDirection == 0;
        gConfig.bProcessSortDirection = gConfig.bProcessSortDirection == 0;
      }
      v11 = gConfig.dwProcessSortColumn;
      gConfig.dwProcessSortColumn = *(pThis + 16);
      CTreeList::InitHeaderColumn(*pThis, v11, gConfig.dwProcessSortColumn, v6);
      v12 = GetMenu(ghMainWnd);
      EnableMenuItem(v12, 0x9C6Cu, 1u);
      ::SendMessageW(ghWndToolbar, 0x401u, IDM_VIEW_SHOW_PROCESS_TREE, gConfig.bShowProcessTree == 0);
      v13 = gConfig.bShowProcessTree != 0;
      v14 = GetMenu(ghMainWnd);
      EnableMenuItem(v14, IDM_VIEW_SHOW_PROCESS_TREE, v13);
      SendMessageW = ::SendMessageW;
    }
    else
    {
      gConfig.dwProcessSortColumn = *(pThis + 16);
      ::SendMessageW(ghWndToolbar, 0x401u, 0x9C67u, 0);
      v7 = GetMenu(ghMainWnd);
      EnableMenuItem(v7, 0x9C67u, 1u);
      v8 = GetWindowLongW(ghWndTreeListView, -21);
      v9 = 0;
      i = v8;
      if ( v8 > 0 )
      {
        v10 = v8;
        do
        {
          lParam = 1;
          ::SendMessageW(ghWndTreeListView, 0x105Fu, v9, &lParam);
          v36 &= 0xFFFFE7FF;
          lParam = 1;
          ::SendMessageW(ghWndTreeListView, 0x1060u, v9++, &lParam);
        }
        while ( v9 < v10 );
        pThis_1 = pThis_2;
      }
      gConfig.bShowProcessTree = 1;
      sub_FF6020(gpTreeViewListItemParam);
    }
    SendMessageW(*pThis_1, 0xBu, 0, 0);
    pThis_2 = (SendMessageW)(*pThis_1, 0x1004u, 0, 0);
    v15 = 0;
    for ( i = operator new[](4 * pThis_2); v15 < pThis_2; ++v15 )
    {
      v31 = v15;
      v16 = *pThis_1;
      v32 = 0;
      v30 = 4;
      SendMessageW(v16, 0x104Bu, 0, &v30);
      *(i + v15) = v37;
    }
    SendMessageW(*pThis_1, 0x1009u, 0, 0);
    v17 = 0;
    if ( pThis_2 > 0 )
    {
      do
      {
        v18 = *(i + v17);
        v19 = sub_FB7F20(*pThis_1, *(i + v17++));
        *(v18 + 1464) = v19;
      }
      while ( v17 < pThis_2 );
      SendMessageW = ::SendMessageW;
    }
    j_j__free(i);
    v5 = v40;
  }
  else
  {
    switch ( uTabID )
    {
      case IDD_PROCEXPLORER_DIALOG:
        v20 = gConfig.dwHandleSortColumn;
        if ( gConfig.dwHandleSortColumn == v4 )
        {
          v21 = LOBYTE(gConfig.bHandleSortDirection) == 0;
          LOBYTE(gConfig.bHandleSortDirection) = LOBYTE(gConfig.bHandleSortDirection) == 0;
          v22 = *(pThis + 16);
        }
        else
        {
          v22 = *(pThis + 16);
          v21 = gConfig.bHandleSortDirection;
        }
        gConfig.dwHandleSortColumn = *(pThis + 16);
        break;
      case IDC_LISTCTRL_DLLS:
        v20 = gConfig.dwDllSortColumn;
        if ( gConfig.dwDllSortColumn == v4 )
        {
          v21 = LOBYTE(gConfig.bDllSortDirection) == 0;
          LOBYTE(gConfig.bDllSortDirection) = LOBYTE(gConfig.bDllSortDirection) == 0;
          v22 = *(pThis + 16);
        }
        else
        {
          v22 = *(pThis + 16);
          v21 = gConfig.bDllSortDirection;
        }
        gConfig.dwDllSortColumn = *(pThis + 16);
        break;
      case IDC_PAGE_PROCTHREADS_LISTCTRL:
        v20 = ::wParam;
        if ( ::wParam == v4 )
        {
          v21 = byte_10653B4 == 0;
          byte_10653B4 = byte_10653B4 == 0;
          v22 = *(pThis + 16);
        }
        else
        {
          v22 = *(pThis + 16);
          v21 = byte_10653B4;
        }
        ::wParam = *(pThis + 16);
        break;
      case IDC_DLG_HANDLE_INFO_STATIC_UNKNOWN1|IDS_REFRESH_PROCESS_LIST:
        v20 = nItem;
        if ( nItem == v4 )
        {
          v21 = byte_105D224 == 0;
          byte_105D224 = byte_105D224 == 0;
          v22 = *(pThis + 16);
        }
        else
        {
          v22 = *(pThis + 16);
          v21 = byte_105D224;
        }
        nItem = *(pThis + 16);
        break;
      case IDS_PRIVATE_DELTA_BYTES:
        v20 = dword_1069B98;
        if ( dword_1069B98 == v4 )
        {
          v21 = byte_105D225 == 0;
          byte_105D225 = byte_105D225 == 0;
        }
        else
        {
          v21 = byte_105D225;
        }
        v22 = *(pThis + 16);
        dword_1069B98 = *(pThis + 16);
        break;
      default:
        goto LABEL_47;
    }
    CTreeList::InitHeaderColumn(*pThis, v20, v22, v21);
  }
LABEL_47:
  SendMessageW(*pThis_1, 0x1030u, &wParam, PropProcThreadsSortCallback);
  v23 = (SendMessageW)(*pThis_1, 0x100Cu, 0xFFFFFFFF, 2);
  SendMessageW(*pThis_1, 0x1013u, v23, 0);
  if ( uTabID == 101 )
  {
    if ( v5 )
    {
      v27 = 1;
      v24 = *pThis_1;
      v28 = v5;
      item.iItem = (SendMessageW)(v24, 0x1053u, 0xFFFFFFFF, &v27);
      v25 = *pThis_1;
      v34 = 3;
      v33 = 3;
      SendMessageW(v25, 0x102Bu, item.iItem, &v30);
      SendMessageW(*pThis_1, 0x1013u, item.iItem, 0);
    }
    SendMessageW(*pThis_1, 0xBu, 1u, 0);
  }
  return 0;
}
// 105D224: using guessed type char byte_105D224;
// 105D225: using guessed type char byte_105D225;
// 10653B4: using guessed type char byte_10653B4;

//----- (00FBD4B0) --------------------------------------------------------
int __cdecl sub_FBD4B0(signed int a1, int a2)
{
  tagTREEVIEWITEMPARAM *v2; // ecx
  int v3; // edi
  tagTREEVIEWITEMPARAM *v4; // esi
  int *v5; // edx
  int v6; // edx
  tagTREEVIEWITEMPARAM *v8; // ecx
  int v9; // edx
  int v10; // edx
  tagTREEVIEWITEMPARAM *v11; // eax
  void *v12; // ecx
  tagTREEVIEWITEMPARAM *v13; // esi
  LVITEMW dllitem; // [esp+4h] [ebp-34h]

  dllitem.mask = 4;
  dllitem.iItem = *(a2 + 12);
  if ( a1 > 104 )
  {
    if ( a1 == 1040 )
    {
      SendMessageW(*a2, LVM_GETITEMW, 0, &dllitem);
      v11 = dllitem.lParam;
      v13 = dllitem.lParam;
      if ( dllitem.lParam->field_30 )
      {
        free(dllitem.lParam->field_30);
        v11 = dllitem.lParam;
      }
      v12 = v13->field_28;
    }
    else
    {
      if ( a1 != 1192 )
        return 0;
      SendMessageW(*a2, LVM_GETITEMW, 0, &dllitem);
      v11 = dllitem.lParam;
      if ( dllitem.lParam[25].field_4C )
      {
        free(dllitem.lParam[25].field_4C);
        v11 = dllitem.lParam;
      }
      v12 = v11[26].field_0;
    }
    if ( v12 )
    {
      free(v12);
      v11 = dllitem.lParam;
    }
    free(v11);
    return 0;
  }
  if ( a1 != 104 )
  {
    if ( a1 == 101 )
    {
      dword_105E0D8 = -1;
      *(*(a2 + 40) + 1464) = 0;
      return 0;
    }
    if ( a1 == 102 )
    {
      SendMessageW(ghWndHandlesListCtrl, LVM_GETITEMW, 0, &dllitem);
      v2 = dllitem.lParam;
      v3 = dllitem.lParam[51].field_0;
      v4 = dllitem.lParam + 51;
      v5 = &dllitem.lParam[50].field_50;
      if ( v3 )
      {
        *(v3 + 4280) = dllitem.lParam[50].field_50;
        v2 = dllitem.lParam;
      }
      else
      {
        dword_106539C = dllitem.lParam[50].field_50;
      }
      v6 = *v5;
      if ( v6 )
      {
        *(v6 + 4284) = v4->field_0;
        v2 = dllitem.lParam;
      }
      free(v2);
      return 0;
    }
    return 0;
  }
  SendMessageW(ghWndDllsListCtrl, LVM_GETITEMW, 0, &dllitem);
  v8 = dllitem.lParam;
  v9 = dllitem.lParam[4].field_34;
  if ( v9 )
    *(v9 + 384) = dllitem.lParam[4].field_30;
  else
    gpDllListItemParamHeader = dllitem.lParam[4].field_30;
  v10 = v8[4].field_30;
  if ( v10 )
    *(v10 + 388) = v8[4].field_34;
  DLLLISTITEMPARAM_Release(v8);
  return 0;
}
// 105E0D8: using guessed type int dword_105E0D8;

//----- (00FBD660) --------------------------------------------------------
int __cdecl FillList(int nID)
{
  HWND hWndList; // edi
  int nItem; // eax
  tagTREEVIEWITEMPARAM *v4; // esi
  tagLVITEMW lvitem; // [esp+8h] [ebp-34h]

  lvitem.mask = 0;
  memset(&lvitem.iItem, 0, 0x30u);
  switch ( nID )
  {
    case 101:
      hWndList = ghWndTreeListView;
      break;
    case 102:
      hWndList = ghWndHandlesListCtrl;
      break;
    case 104:
      hWndList = ghWndDllsListCtrl;
      break;
    default:
      return 0;
  }
  nItem = SendMessageW(hWndList, LVM_GETNEXTITEM, 0xFFFFFFFF, 2);
  if ( nItem != -1 )
  {
    lvitem.iItem = nItem;
    lvitem.iSubItem = 0;
    lvitem.mask = LVIF_PARAM;
    if ( SendMessageW(hWndList, LVM_GETITEMW, 0, &lvitem) == 1 )
    {
      switch ( nID )
      {
        case 101:
          CTreeList::FillTreeViewParam(lvitem.lParam);
          return 0;
        case 102:
          FillHandleListParam(hWndList, lvitem.lParam);
          return 0;
        case 104:
          v4 = lvitem.lParam;
          if ( lvitem.lParam->field_2C & 8 )
          {
            MessageBoxW(
              ghWndTreeListView,
              L"Properties not supported on pagefile-backed sections",
              L"Process Explorer Error",
              MB_ICONERROR);
            return 0;
          }
          if ( !lvitem.lParam->field_38 )
          {
            MessageBoxW(ghMainWnd, L"Not a valid DLL", L"Process Explorer", MB_ICONHAND);
            return 0;
          }
          InterlockedIncrement(&lvitem.lParam->field_0);
          v4->field_28 = gdwProcessIdSelected;
          _beginthread(PropertiesThreadProc, 0, v4);
          break;
      }
    }
  }
  return 0;
}

//----- (00FBD7A0) --------------------------------------------------------
int __cdecl sub_FBD7A0(int a1)
{
  return -(a1 != 101);
}

//----- (00FBD7B0) --------------------------------------------------------
int __cdecl sub_FBD7B0(signed int a1, int a2)
{
  int v2; // eax
  int result; // eax
  _DWORD *v4; // ecx
  signed int v5; // eax
  int v6; // eax
  int v7; // eax
  const wchar_t *v8; // eax
  int v9; // eax
  int v10; // eax
  bool v11; // zf
  int v12; // edx
  signed int v13; // ecx
  signed int v14; // eax
  signed int v15; // eax
  int v16; // eax
  int v17; // ebx
  int v18; // eax
  double v19; // xmm0_8
  int v20; // ebx
  unsigned int v21; // eax
  __int64 v22; // ST18_8
  const wchar_t *v23; // eax
  int v24; // eax
  int v25; // ecx
  int v26; // ecx
  int v27; // eax
  int v28; // eax
  const FILETIME *v29; // ebx
  unsigned int v30; // kr00_4
  unsigned int v31; // edx
  unsigned int v32; // ecx
  int *v33; // eax
  int v34; // edx
  int v35; // ecx
  int v36; // eax
  double v37; // xmm0_8
  int v38; // eax
  int v39; // edx
  int v40; // ecx
  int v41; // eax
  int v42; // edx
  int v43; // ecx
  int v44; // eax
  int v45; // edx
  int v46; // ecx
  int v47; // eax
  int v48; // edx
  int v49; // ecx
  int v50; // eax
  int v51; // edx
  int v52; // ecx
  int v53; // eax
  int v54; // edx
  int v55; // ecx
  int v56; // eax
  int v57; // edx
  int v58; // ecx
  int v59; // eax
  int v60; // edx
  int v61; // ecx
  int v62; // eax
  int v63; // edx
  int v64; // ecx
  int v65; // eax
  int v66; // edx
  int v67; // ecx
  int v68; // eax
  int v69; // edx
  int v70; // ecx
  int v71; // eax
  int v72; // eax
  int v73; // edx
  int v74; // ecx
  int v75; // eax
  int v76; // edx
  int v77; // ecx
  __int16 v78; // ax
  float v79; // xmm0_4
  double v80; // xmm0_8
  unsigned __int8 v81; // cl
  wchar_t *v82; // edx
  wchar_t *v83; // esi
  wchar_t v84; // ax
  unsigned int v85; // edx
  __int16 *v86; // edi
  __int16 v87; // ax
  __int16 *v88; // ecx
  __int16 v89; // ax
  const WCHAR **v90; // eax
  int v91; // esi
  signed int v92; // eax
  int v93; // eax
  int v94; // eax
  const WCHAR *v95; // eax
  int v96; // eax
  int v97; // eax
  int v98; // eax
  int v99; // eax
  const WCHAR **v100; // eax
  int v101; // eax
  int v102; // eax
  const WCHAR **v103; // eax
  int v104; // esi
  char v105; // al
  int v106; // ecx
  unsigned int v107; // kr04_4
  int v108; // ecx
  unsigned int v109; // kr08_4
  int v110; // eax
  int v111; // eax
  int v112; // esi
  int v113; // eax
  int v114; // eax
  void *v115; // ebx
  const wchar_t *v116; // eax
  const wchar_t *v117; // [esp+Ch] [ebp-268h]
  const wchar_t *v118; // [esp+Ch] [ebp-268h]
  const wchar_t *ArgList; // [esp+10h] [ebp-264h]
  int ArgLista; // [esp+10h] [ebp-264h]
  int ArgListb; // [esp+10h] [ebp-264h]
  signed int ArgList_4; // [esp+14h] [ebp-260h]
  int ArgList_4a; // [esp+14h] [ebp-260h]
  int ArgList_4b; // [esp+14h] [ebp-260h]
  int ArgList_4c; // [esp+14h] [ebp-260h]
  SIZE_T NumberOfBytesRead; // [esp+24h] [ebp-250h]
  struct _FILETIME LocalFileTime; // [esp+28h] [ebp-24Ch]
  int Buffer; // [esp+30h] [ebp-244h]
  int v129; // [esp+34h] [ebp-240h]
  struct _SYSTEMTIME SystemTime; // [esp+38h] [ebp-23Ch]
  wchar_t Dst; // [esp+48h] [ebp-22Ch]
  __int16 v132; // [esp+4Ah] [ebp-22Ah]
  __int16 v133; // [esp+66h] [ebp-20Eh]
  __int16 TimeStr[260]; // [esp+68h] [ebp-20Ch]

  v129 = a2;
  v2 = *(a2 + 12);
  if ( v2 & 2 )
  {
    *(a2 + 40) = *(*(a2 + 44) + 64);
    return 0;
  }
  if ( !*(a2 + 32) || !(v2 & 1) )
    return 0;
  wcscpy_s(TimeStr, 0x104u, &gszNullString);
  if ( a1 > 104 )
  {
    if ( a1 == 1044 )
    {
      v111 = *(a2 + 20);
      v112 = *(a2 + 44);
      switch ( v111 )
      {
        case 0:
          ArgList_4a = *(v112 + 44);
LABEL_49:
          swprintf(TimeStr, L"%d", ArgList_4a);
          goto LABEL_50;
        case 1:
          sub_FB5AD0(v112 + 576, *(v112 + 584), *(v112 + 584) >> 32, *(v112 + 600), *(v112 + 604), &Dst, 0x10u);
          goto LABEL_41;
        case 2:
          if ( QueryThreadCycleTime && *(v112 + 40) )
          {
            v8 = TimeStr;
            if ( !*(v112 + 600) )
              goto LABEL_51;
            swprintf(TimeStr, L"%I64u", *(v112 + 600), *(v112 + 604));
LABEL_90:
            sub_FC3290(TimeStr, 0x104u);
          }
          else
          {
            v8 = TimeStr;
            if ( !*(v112 + 584) )
              goto LABEL_51;
            swprintf(TimeStr, L"%d", *(v112 + 584), *(v112 + 588));
          }
          goto LABEL_50;
        case 3:
        case 4:
          if ( *(v112 + 644) == -1 )
            goto LABEL_363;
          v113 = v111 - 3;
          if ( v113 )
          {
            if ( v113 != 1 )
              goto LABEL_50;
LABEL_363:
            v8 = (v112 + 52);
          }
          else
          {
            Buffer = *(v112 + 644);
            ReadProcessMemory(*(v112 + 0x27C), (gdwTebAddressOffset + *(v112 + 0x280)), &Buffer, 4u, &NumberOfBytesRead);
            v114 = Buffer;
            if ( Buffer != *(v112 + 644) )
            {
              v115 = *(v112 + 648);
              if ( Buffer )
              {
                v116 = sub_FFEFB0(Buffer);
                *(v112 + 648) = _wcsdup(v116);
                v114 = Buffer;
              }
              else
              {
                *(v112 + 648) = 0;
              }
              if ( v115 )
              {
                free(v115);
                v114 = Buffer;
              }
              *(v112 + 644) = v114;
            }
            v8 = *(v112 + 648);
          }
          break;
        default:
          goto LABEL_50;
      }
      goto LABEL_364;
    }
    if ( a1 == 1192 )
    {
      v104 = *(a2 + 44);
      v105 = GetPropW(*a2, L"resolve");
      v106 = *(a2 + 20);
      LOBYTE(Buffer) = v105;
      switch ( v106 )
      {
        case 0:
          swprintf(&pszBuffer, L"%S", gszProtocolNames[*(v104 + 40)]);
          *(a2 + 32) = &pszBuffer;
          return 0;
        case 1:
          if ( v105 )
          {
            if ( *(v104 + 64) )
            {
              wcscpy_s(TimeStr, 0x104u, (v104 + 64));
            }
            else if ( sub_FC44B0(*(v104 + 40), Buffer, 1, *(v104 + 44), v104 + 48, TimeStr, 0x104u) )
            {
              wcscpy_s((v104 + 64), 0x104u, TimeStr);
            }
          }
          else
          {
            sub_FC44B0(*(v104 + 40), 0, 1, *(v104 + 44), v104 + 48, TimeStr, 0x104u);
          }
          v107 = wcslen(TimeStr);
          sub_FC4670(Buffer, *(v104 + 584), gszProtocolNames[*(v104 + 40)], &TimeStr[v107], 260 - v107);
          v20 = v129;
          v8 = TimeStr;
          goto LABEL_52;
        case 2:
          v108 = *(v104 + 40);
          if ( v108 && v108 != 2 )
          {
            *(a2 + 32) = L"*:*";
            return 0;
          }
          if ( v105 )
          {
            if ( *(v104 + 1128) )
            {
              wcscpy_s(TimeStr, 0x104u, (v104 + 1128));
            }
            else if ( sub_FC44B0(v108, Buffer, 0, *(v104 + 1108), v104 + 1112, TimeStr, 0x104u) )
            {
              wcscpy_s((v104 + 1128), 0x104u, TimeStr);
            }
          }
          else
          {
            sub_FC44B0(v108, 0, 0, *(v104 + 1108), v104 + 1112, TimeStr, 0x104u);
          }
          v109 = wcslen(TimeStr);
          sub_FC4670(Buffer, *(v104 + 1648), gszProtocolNames[*(v104 + 40)], &TimeStr[v109], 260 - v109);
          v20 = v129;
          v8 = TimeStr;
          break;
        case 3:
          v110 = *(v104 + 40);
          if ( v110 && v110 != 2 )
            goto LABEL_50;
          v8 = gszNetStatus[*(v104 + 2172)];
          goto LABEL_364;
        case 4:
          v8 = *(v104 + 2184);
          goto LABEL_364;
        default:
          goto LABEL_50;
      }
      goto LABEL_52;
    }
    goto LABEL_50;
  }
  if ( a1 != 104 )
  {
    if ( a1 != 101 )
    {
      if ( a1 == 102 )
      {
        v4 = *(a2 + 44);
        v5 = gConfig.dwIdsOfHandleColumnMap[*(a2 + 20)];
        if ( v5 > 39 )
        {
          v9 = v5 - 1185;
          if ( v9 )
          {
            v10 = v9 - 9;
            if ( v10 )
            {
              v11 = v10 == 114;
              v8 = TimeStr;
              if ( !v11 )
              {
LABEL_51:
                v20 = a2;
LABEL_52:
                wcsncpy_s(*(v20 + 32), *(v20 + 32) >> 32, v8, 0xFFFFFFFF);
                return 0;
              }
              sub_FA8CE0(v4[12], (v4 + 14), TimeStr);
            }
            else
            {
              v12 = v4[13];
              if ( v12 )
              {
                v13 = 45;
                v14 = 45;
                if ( v12 & 4 )
                  v14 = 68;
                ArgList_4 = v14;
                v15 = 45;
                if ( v12 & 2 )
                  v15 = 87;
                if ( v12 & 1 )
                  v13 = 82;
                swprintf(TimeStr, L"%C%C%C", v13, v15, ArgList_4);
              }
            }
          }
          else
          {
            swprintf(TimeStr, L"0x%08X", v4[10]);
          }
        }
        else if ( v5 == 39 )
        {
          swprintf(TimeStr, L"0x%08X", v4[12]);
        }
        else
        {
          v6 = v5 - 20;
          if ( v6 )
          {
            v7 = v6 - 1;
            if ( v7 )
            {
              if ( v7 == 1 )
              {
                v8 = (v4 + 558);
                goto LABEL_364;
              }
              goto LABEL_50;
            }
            v8 = (v4 + 14);
LABEL_364:
            if ( !v8 )
            {
LABEL_228:
              *(a2 + 32) = &gszNullString;
              return 0;
            }
            if ( v8 != TimeStr )
            {
              *(a2 + 32) = v8;
              return 0;
            }
            goto LABEL_51;
          }
          swprintf(TimeStr, L"0x%X", v4[11]);
        }
      }
      goto LABEL_50;
    }
    v16 = *(a2 + 20);
    v17 = *(a2 + 44);
    if ( v16 > gConfig.dwProcessColumnCount )
      return 0;
    v18 = gConfig.dwProcessColumnMap[v16];
    if ( v18 <= 1032 )
    {
      if ( v18 == 1032 )
      {
        v8 = *(v17 + 800);
        goto LABEL_364;
      }
      switch ( v18 )
      {
        case 3:
          v8 = *(v17 + 60);
          goto LABEL_364;
        case 4:
          goto LABEL_204;
        case 5:
          ArgList_4a = *(v17 + 1368);
          goto LABEL_49;
        case 6:
          goto LABEL_54;
        case 7:
          v19 = *(v17 + 1304);
          if ( v19 <= 0.005 )
          {
            wcscpy_s(&Dst, 0x10u, &gszNullString);
          }
          else if ( gConfig.bShowCpuFractions )
          {
            sub_FA13E0(&Dst, L"%02.2f", LODWORD(v19), HIDWORD(v19));
          }
          else
          {
            sub_FA13E0(&Dst, L"%0.0f", LODWORD(v19), HIDWORD(v19));
          }
          goto LABEL_41;
        case 9:
          v21 = *(v17 + 920);
          goto LABEL_62;
        case 10:
          swprintf(TimeStr, L"%I64u", *(v17 + 924) >> 10, 0);
          sub_FC3290(TimeStr, 0x104u);
          wcscat_s(TimeStr, 0x104u, L" K");
          goto LABEL_50;
        case 18:
          ArgList_4b = *(v17 + 92);
          goto LABEL_55;
        case 19:
          v8 = *(v17 + 88);
          goto LABEL_364;
        case 25:
          v8 = (v17 + 654);
          goto LABEL_364;
        case 35:
          v8 = (v17 + 104);
          goto LABEL_364;
        case 38:
          v8 = *(v17 + 784);
          goto LABEL_364;
        default:
          goto LABEL_50;
      }
      goto LABEL_50;
    }
    if ( v18 <= 1317 )
    {
      if ( v18 != 1317 )
      {
        switch ( v18 )
        {
          case 1033:
            v8 = *(v17 + 788);
            goto LABEL_364;
          case 1055:
            if ( *(v17 + 40) < 0 )
            {
              *(a2 + 32) = L"Suspended";
              return 0;
            }
            sub_FB5AD0(v17 + 1296, *(v17 + 1336), *(v17 + 1336) >> 32, *(v17 + 1352), *(v17 + 1356), &Dst, 0x10u);
            break;
          case 1056:
            v27 = *(v17 + 100);
            goto LABEL_113;
          case 1059:
            ArgList_4c = 0;
            ArgListb = *(v17 + 880);
            goto LABEL_88;
          case 1060:
            swprintf(TimeStr, L"%I64u", *(v17 + 888) >> 10, 0);
            sub_FC3290(TimeStr, 0x104u);
            wcscat_s(TimeStr, 0x104u, L" K");
            goto LABEL_50;
          case 1061:
            v8 = *(v17 + 792);
            goto LABEL_364;
          case 1062:
            swprintf(TimeStr, L"%I64u", *(v17 + 896) >> 10, 0);
            sub_FC3290(TimeStr, 0x104u);
            wcscat_s(TimeStr, 0x104u, L" K");
            goto LABEL_50;
          case 1063:
            swprintf(TimeStr, L"%I64u", *(v17 + 900) >> 10, 0);
            sub_FC3290(TimeStr, 0x104u);
            wcscat_s(TimeStr, 0x104u, L" K");
            goto LABEL_50;
          case 1064:
            swprintf(TimeStr, L"%I64u", *(v17 + 904) >> 10, 0);
            sub_FC3290(TimeStr, 0x104u);
            wcscat_s(TimeStr, 0x104u, L" K");
            goto LABEL_50;
          case 1065:
LABEL_54:
            ArgList_4b = *(v17 + 96);
            goto LABEL_55;
          case 1066:
            ArgList_4b = *(v17 + 1380);
            goto LABEL_55;
          case 1067:
            ArgList_4b = *(v17 + 1376);
            goto LABEL_55;
          case 1068:
            ArgList_4b = *(v17 + 960);
            ArgList = L"%u";
            goto LABEL_56;
          case 1069:
            v31 = *(v17 + 972);
            v32 = *(v17 + 968);
            goto LABEL_188;
          case 1070:
            ArgList_4b = *(v17 + 992);
            ArgList = L"%u";
            goto LABEL_56;
          case 1071:
            v31 = *(v17 + 1004);
            v32 = *(v17 + 1000);
            goto LABEL_188;
          case 1072:
            ArgList_4b = *(v17 + 1024);
            ArgList = L"%u";
            goto LABEL_56;
          case 1073:
            v31 = *(v17 + 1036);
            v32 = *(v17 + 1032);
            goto LABEL_188;
          case 1086:
            v28 = *(v17 + 624);
            v29 = (v17 + 624);
            if ( !(v29->dwHighDateTime | v28) )
              goto LABEL_184;
            FileTimeToLocalFileTime(v29, &LocalFileTime);
            FileTimeToSystemTime(&LocalFileTime, &SystemTime);
            GetTimeFormatW(0x400u, 0, &SystemTime, 0, TimeStr, 260);
            wcscat_s(TimeStr, 0x104u, L" ");
            v30 = wcslen(TimeStr);
            GetDateFormatW(0x400u, 0, &SystemTime, 0, &TimeStr[v30], 260 - v30);
            goto LABEL_50;
          case 1087:
            v22 = *(v17 + 1320);
            v20 = v129;
            swprintf(
              TimeStr,
              L"%I64d:%02I64d:%02I64d.%03I64d",
              *(*(v129 + 44) + 1320) / 0x861C46800ui64,
              *(*(v129 + 44) + 1320) / 0x23C34600ui64 % 0x3C,
              v22 / 10000000 % 60,
              v22 % 10000000 / 10000);
            v8 = TimeStr;
            goto LABEL_52;
          case 1091:
            ArgList_4c = *(v17 + 1348);
            ArgListb = *(v17 + 1344);
            goto LABEL_88;
          case 1092:
            v26 = *(v17 + 1340);
            if ( v26 < 0 || v26 <= 0 && !*(v17 + 1336) )
              goto LABEL_50;
            ArgList_4c = *(v17 + 1340);
            ArgListb = *(v17 + 1336);
LABEL_88:
            v118 = L"%I64d";
            goto LABEL_89;
          case 1094:
            v33 = *(v17 + 1284);
            if ( !v33 )
              goto LABEL_50;
            v34 = *v33;
            v35 = v33[1];
            v11 = *v33 == 0i64;
            v8 = TimeStr;
            if ( v11 )
              goto LABEL_51;
            swprintf(TimeStr, L"%I64d", v34, v35);
            goto LABEL_90;
          case 1095:
            v36 = *(v17 + 1284);
            if ( !v36 )
              goto LABEL_50;
            v37 = *(v36 + 8);
            goto LABEL_129;
          case 1096:
            v38 = *(v17 + 1284);
            if ( !v38 )
              goto LABEL_50;
            v39 = *(v38 + 16);
            v40 = *(v38 + 20);
            v11 = *(v38 + 16) == 0i64;
            v8 = TimeStr;
            if ( v11 )
              goto LABEL_51;
            swprintf(TimeStr, L"%I64d", v39, v40);
            goto LABEL_90;
          case 1097:
            v41 = *(v17 + 1284);
            if ( !v41 )
              goto LABEL_50;
            v42 = *(v41 + 48);
            v43 = *(v41 + 52);
            v11 = *(v41 + 48) == 0i64;
            v8 = TimeStr;
            if ( v11 )
              goto LABEL_51;
            swprintf(TimeStr, L"%I64d", v42, v43);
            goto LABEL_90;
          case 1098:
            v44 = *(v17 + 1284);
            if ( !v44 )
              goto LABEL_50;
            v45 = *(v44 + 32);
            v46 = *(v44 + 36);
            v11 = *(v44 + 32) == 0i64;
            v8 = TimeStr;
            if ( v11 )
              goto LABEL_51;
            swprintf(TimeStr, L"%I64d", v45, v46);
            goto LABEL_90;
          case 1099:
            v47 = *(v17 + 1284);
            if ( !v47 )
              goto LABEL_50;
            v48 = *(v47 + 24);
            v49 = *(v47 + 28);
            v11 = *(v47 + 24) == 0i64;
            v8 = TimeStr;
            if ( v11 )
              goto LABEL_51;
            swprintf(TimeStr, L"%I64d", v48, v49);
            goto LABEL_90;
          case 1100:
            v50 = *(v17 + 1284);
            if ( !v50 )
              goto LABEL_50;
            v51 = *(v50 + 56);
            v52 = *(v50 + 60);
            v11 = *(v50 + 56) == 0i64;
            v8 = TimeStr;
            if ( v11 )
              goto LABEL_51;
            swprintf(TimeStr, L"%I64d", v51, v52);
            goto LABEL_90;
          case 1101:
            v53 = *(v17 + 1284);
            if ( !v53 )
              goto LABEL_50;
            v54 = *(v53 + 40);
            v55 = *(v53 + 44);
            v11 = *(v53 + 40) == 0i64;
            v8 = TimeStr;
            if ( v11 )
              goto LABEL_51;
            swprintf(TimeStr, L"%I64d", v54, v55);
            goto LABEL_90;
          case 1103:
            v59 = *(v17 + 1284);
            if ( !v59 )
              goto LABEL_50;
            v60 = *(v59 + 112);
            v61 = *(v59 + 116);
            v11 = *(v59 + 112) == 0i64;
            v8 = TimeStr;
            if ( v11 )
              goto LABEL_51;
            swprintf(TimeStr, L"%I64d", v60, v61);
            goto LABEL_90;
          case 1104:
            v62 = *(v17 + 1284);
            if ( !v62 )
              goto LABEL_50;
            v63 = *(v62 + 64);
            v64 = *(v62 + 68);
            v11 = *(v62 + 64) == 0i64;
            v8 = TimeStr;
            if ( v11 )
              goto LABEL_51;
            swprintf(TimeStr, L"%I64d", v63, v64);
            goto LABEL_90;
          case 1105:
            v65 = *(v17 + 1284);
            if ( !v65 )
              goto LABEL_50;
            v66 = *(v65 + 72);
            v67 = *(v65 + 76);
            v11 = *(v65 + 72) == 0i64;
            v8 = TimeStr;
            if ( v11 )
              goto LABEL_51;
            swprintf(TimeStr, L"%I64d", v66, v67);
            goto LABEL_90;
          case 1106:
            v68 = *(v17 + 1284);
            if ( !v68 )
              goto LABEL_50;
            v69 = *(v68 + 80);
            v70 = *(v68 + 84);
            v11 = *(v68 + 80) == 0i64;
            v8 = TimeStr;
            if ( v11 )
              goto LABEL_51;
            swprintf(TimeStr, L"%I64d", v69, v70);
            goto LABEL_90;
          case 1107:
            v71 = *(v17 + 1284);
            if ( !v71 )
              goto LABEL_50;
            v37 = *(v71 + 88);
LABEL_129:
            v8 = TimeStr;
            if ( v37 == 0.0 )
              goto LABEL_51;
            swprintf(TimeStr, L"%02.02f", LODWORD(v37), HIDWORD(v37));
            goto LABEL_50;
          case 1108:
            v72 = *(v17 + 1284);
            if ( !v72 )
              goto LABEL_50;
            v73 = *(v72 + 104);
            v74 = *(v72 + 108);
            v11 = *(v72 + 104) == 0i64;
            v8 = TimeStr;
            if ( v11 )
              goto LABEL_51;
            swprintf(TimeStr, L"%I64d", v73, v74);
            goto LABEL_90;
          case 1109:
            v75 = *(v17 + 1284);
            if ( !v75 )
              goto LABEL_50;
            v76 = *(v75 + 120);
            v77 = *(v75 + 124);
            v11 = *(v75 + 120) == 0i64;
            v8 = TimeStr;
            if ( v11 )
              goto LABEL_51;
            swprintf(TimeStr, L"%I64d", v76, v77);
            goto LABEL_90;
          case 1110:
            v56 = *(v17 + 1284);
            if ( !v56 )
              goto LABEL_50;
            v57 = *(v56 + 128);
            v58 = *(v56 + 132);
            v11 = *(v56 + 128) == 0i64;
            v8 = TimeStr;
            if ( v11 )
              goto LABEL_51;
            swprintf(TimeStr, L"%I64d", v57, v58);
            goto LABEL_90;
          case 1114:
            swprintf(TimeStr, L"%I64u", *(v17 + 876) >> 10, 0);
            sub_FC3290(TimeStr, 0x104u);
            wcscat_s(TimeStr, 0x104u, L" K");
            goto LABEL_50;
          case 1115:
            ArgLista = *(v17 + 936) >> 10;
            v117 = L"%I64d";
            goto LABEL_63;
          case 1116:
            swprintf(TimeStr, L"%I64u", *(v17 + 940) >> 10, 0);
            sub_FC3290(TimeStr, 0x104u);
            wcscat_s(TimeStr, 0x104u, L" K");
            goto LABEL_50;
          case 1118:
            swprintf(TimeStr, L"%I64u", *(v17 + 948) >> 10, 0);
            sub_FC3290(TimeStr, 0x104u);
            wcscat_s(TimeStr, 0x104u, L" K");
            goto LABEL_50;
          case 1179:
            if ( !*(v17 + 884) )
              goto LABEL_50;
            ArgList_4b = *(v17 + 884);
            goto LABEL_55;
          case 1180:
            v8 = *(v17 + 820);
            goto LABEL_364;
          case 1181:
            v8 = *(v17 + 796);
            goto LABEL_364;
          case 1187:
            v8 = *(v17 + 836);
            goto LABEL_364;
          case 1190:
            goto LABEL_79;
          case 1192:
            v24 = *(v17 + 892);
            if ( v24 )
            {
              swprintf(TimeStr, L"%d", v24 / 1024);
              sub_FC3290(TimeStr, 0x104u);
              wcscat_s(TimeStr, 0x104u, L" K");
            }
            goto LABEL_50;
          case 1195:
            ArgList_4c = *(v17 + 1364);
            ArgListb = *(v17 + 1360);
            v118 = L"%I64u";
            goto LABEL_89;
          case 1196:
            if ( !*(v17 + 616) )
              goto LABEL_50;
            v23 = L"Not responding";
            if ( !*(v17 + 620) )
              v23 = L"Running";
            *(a2 + 32) = v23;
            return 0;
          case 1199:
            sub_FF7720(v17, TimeStr, 0x104u);
            goto LABEL_50;
          case 1200:
            v25 = *(v17 + 1356);
            if ( v25 < 0 || v25 <= 0 && !*(v17 + 1352) )
              goto LABEL_50;
            ArgList_4c = *(v17 + 1356);
            ArgListb = *(v17 + 1352);
            v118 = L"%I64u";
LABEL_89:
            swprintf(TimeStr, v118, ArgListb, ArgList_4c);
            goto LABEL_90;
          default:
            goto LABEL_50;
        }
LABEL_41:
        if ( Dst == 48 && (v132 == 48 || !v132) )
        {
          *(a2 + 32) = L"    ";
          return 0;
        }
        wcscpy_s(TimeStr, 0x104u, &Dst);
        goto LABEL_50;
      }
      v21 = *(v17 + 944);
      goto LABEL_62;
    }
    if ( v18 <= 1609 )
    {
      if ( v18 == 1609 )
      {
        if ( *(v17 + 1072) )
        {
          ArgList_4b = *(v17 + 1072);
          ArgList = L"%u";
LABEL_56:
          swprintf(TimeStr, ArgList, ArgList_4b);
LABEL_57:
          sub_FC3290(TimeStr, 0x104u);
        }
      }
      else
      {
        switch ( v18 )
        {
          case 1326:
            if ( !*(v17 + 976) )
              goto LABEL_50;
            ArgList_4b = *(v17 + 976);
            goto LABEL_55;
          case 1327:
            v31 = *(v17 + 988);
            v32 = *(v17 + 984);
            goto LABEL_188;
          case 1328:
            if ( !*(v17 + 1008) )
              goto LABEL_50;
            ArgList_4b = *(v17 + 1008);
            goto LABEL_55;
          case 1329:
            v31 = *(v17 + 1020);
            v32 = *(v17 + 1016);
            goto LABEL_188;
          case 1332:
            v31 = *(v17 + 1052);
            v32 = *(v17 + 1048);
            goto LABEL_188;
          case 1333:
            v31 = *(v17 + 1060);
            v32 = *(v17 + 1056);
            goto LABEL_188;
          case 1335:
            if ( !*(v17 + 1040) )
              goto LABEL_50;
            ArgList_4b = *(v17 + 1040);
            goto LABEL_55;
          case 1336:
            v8 = *(v17 + 816);
            goto LABEL_364;
          case 1337:
            if ( !(*(v17 + 40) & 0x200) )
              goto LABEL_50;
            *(a2 + 32) = L"Virtualized";
            return 0;
          case 1338:
            v78 = *(v17 + 650);
            if ( v78 & 0x40 )
              goto LABEL_182;
            goto LABEL_183;
          case 1339:
            v27 = *(v17 + 872);
LABEL_113:
            if ( v27 == -1 )
              goto LABEL_50;
            ArgList_4a = v27;
            goto LABEL_49;
          case 1340:
            sub_FF7790(*(v17 + 952), TimeStr, 0x104u);
            goto LABEL_50;
          case 1341:
            v21 = *(v17 + 912);
            goto LABEL_62;
          case 1342:
            v21 = *(v17 + 916);
            goto LABEL_62;
          default:
            goto LABEL_50;
        }
      }
      goto LABEL_50;
    }
    if ( v18 <= 40757 )
    {
      if ( v18 != 40757 )
      {
        switch ( v18 )
        {
          case 1610:
            if ( !*(v17 + 1088) )
              goto LABEL_50;
            ArgList_4b = *(v17 + 1088);
            goto LABEL_55;
          case 1611:
            if ( !*(v17 + 1104) )
              goto LABEL_50;
            ArgList_4b = *(v17 + 1104);
            ArgList = L"%u";
            goto LABEL_56;
          case 1612:
            if ( !*(v17 + 1120) )
              goto LABEL_50;
            ArgList_4b = *(v17 + 1120);
            goto LABEL_55;
          case 1613:
            if ( !*(v17 + 1136) )
              goto LABEL_50;
            ArgList_4b = *(v17 + 1136);
            ArgList = L"%u";
            goto LABEL_56;
          case 1614:
            if ( !*(v17 + 1152) )
              goto LABEL_50;
            ArgList_4b = *(v17 + 1152);
            goto LABEL_55;
          case 1616:
            v80 = *(v17 + 1096);
            goto LABEL_189;
          case 1617:
            v31 = *(v17 + 1084);
            v32 = *(v17 + 1080);
            goto LABEL_188;
          case 1618:
            v31 = *(v17 + 1116);
            v32 = *(v17 + 1112);
            goto LABEL_188;
          case 1619:
            v31 = *(v17 + 1132);
            v32 = *(v17 + 1128);
            goto LABEL_188;
          case 1620:
            v80 = *(v17 + 1144);
            goto LABEL_189;
          case 1621:
            if ( *(v17 + 1160) )
              sub_FB2200(0, TimeStr, 0x104u, COERCE__INT64(*(v17 + 1160)), 0i64, 0i64 >> 63);
            goto LABEL_50;
          case 1622:
            v80 = *(v17 + 1168);
            goto LABEL_189;
          case 1623:
            v8 = TimeStr;
            if ( !*(v17 + 1184) )
              goto LABEL_51;
            swprintf(TimeStr, L"%u", *(v17 + 1176));
            goto LABEL_57;
          case 1624:
            if ( !*(v17 + 1192) )
              goto LABEL_50;
            ArgList_4b = *(v17 + 1192);
            goto LABEL_55;
          case 1625:
            if ( !*(v17 + 1208) )
              goto LABEL_50;
            ArgList_4b = *(v17 + 1208);
            ArgList = L"%u";
            goto LABEL_56;
          case 1626:
            if ( !*(v17 + 1224) )
              goto LABEL_50;
            ArgList_4b = *(v17 + 1224);
            goto LABEL_55;
          case 1627:
            if ( !*(v17 + 1240) )
              goto LABEL_50;
            ArgList_4b = *(v17 + 1240);
            ArgList = L"%u";
            goto LABEL_56;
          case 1628:
            if ( !*(v17 + 1256) )
              goto LABEL_50;
            ArgList_4b = *(v17 + 1256);
LABEL_55:
            ArgList = L"%d";
            goto LABEL_56;
          case 1630:
            v31 = *(v17 + 1188);
            v32 = *(v17 + 1184);
            goto LABEL_188;
          case 1631:
            v31 = *(v17 + 1204);
            v32 = *(v17 + 1200);
            goto LABEL_188;
          case 1632:
            v31 = *(v17 + 1220);
            v32 = *(v17 + 1216);
            goto LABEL_188;
          case 1633:
            v31 = *(v17 + 1236);
            v32 = *(v17 + 1232);
            goto LABEL_188;
          case 1634:
            v31 = *(v17 + 1252);
            v32 = *(v17 + 1248);
            goto LABEL_188;
          case 1635:
            v31 = *(v17 + 1268);
            v32 = *(v17 + 1264);
            goto LABEL_188;
          case 1636:
            v31 = *(v17 + 1276);
            v32 = *(v17 + 1272);
LABEL_188:
            v79 = __PAIR__(v31, v32);
            v80 = v79;
LABEL_189:
            sub_FB5BB0(TimeStr, *&v80);
            goto LABEL_50;
          case 1637:
            sub_FB5AD0(v17 + 1312, 0, 0, 0, 0, &Dst, 0x10u);
            goto LABEL_41;
          case 1638:
LABEL_204:
            if ( *(v17 + 68) < 0 )
              goto LABEL_184;
            ArgList_4a = *(v17 + 68);
            goto LABEL_49;
          case 1650:
            sub_FB5AD0(v17 + 1384, 0, 0, 0, 0, &Dst, 0x10u);
            goto LABEL_41;
          case 1651:
            v8 = TimeStr;
            if ( !*(v17 + 1408) )
              goto LABEL_51;
            swprintf(TimeStr, L"%I64u", *(v17 + 1408), *(v17 + 1412));
            goto LABEL_64;
          case 1652:
            v8 = TimeStr;
            if ( !*(v17 + 1424) )
              goto LABEL_51;
            swprintf(TimeStr, L"%I64u", *(v17 + 1424), *(v17 + 1428));
            goto LABEL_64;
          case 1653:
            v8 = TimeStr;
            if ( !*(v17 + 1440) )
              goto LABEL_51;
            swprintf(TimeStr, L"%I64u", *(v17 + 1440), *(v17 + 1444));
            goto LABEL_64;
          case 1654:
            v8 = *(v17 + 824);
            goto LABEL_364;
          case 1656:
            v8 = *(v17 + 828);
            goto LABEL_364;
          case 1667:
            switch ( *(v17 + 644) )
            {
              case 0xFFFFFFFF:
                goto LABEL_228;
              case 0:
                *(a2 + 32) = L"Unaware";
                return 0;
              case 1:
                *(a2 + 32) = L"System Aware";
                return 0;
              case 2:
                *(a2 + 32) = L"Per-Monitor Aware";
                return 0;
              default:
                ArgList_4a = *(v17 + 644);
                break;
            }
            goto LABEL_49;
          case 1670:
            sub_1001A50(*(v17 + 844), TimeStr);
            goto LABEL_50;
          case 1673:
            v81 = *(v17 + 649);
            if ( !v81 )
              goto LABEL_50;
            if ( (v81 & 0xF0u) < 0x70 )
            {
              v82 = &aPsprotectedsig[64 * (v81 >> 4)];
              v83 = &aPsprotectedsig[64 * (v81 >> 4)];
              do
              {
                v84 = *v82;
                ++v82;
              }
              while ( v84 );
              v85 = v82 - v83;
              v86 = &v133;
              do
              {
                v87 = v86[1];
                ++v86;
              }
              while ( v87 );
              qmemcpy(v86, v83, v85);
            }
            if ( (*(v17 + 649) & 7) == 1 )
            {
              v88 = &v133;
              do
              {
                v89 = v88[1];
                ++v88;
              }
              while ( v89 );
              *v88 = *L"-Light";
              *(v88 + 1) = *L"ight";
              *(v88 + 2) = *L"ht";
              v88[6] = aLight[6];
            }
            v20 = v129;
            v8 = TimeStr;
            goto LABEL_52;
          case 1674:
            v90 = L"UI Access";
            if ( !(*(v17 + 40) & 0x2000) )
              v90 = &gszNullString;
            *(a2 + 32) = v90;
            return 0;
          default:
            goto LABEL_50;
        }
        goto LABEL_50;
      }
      v78 = *(v17 + 650);
      if ( !(*(v17 + 650) & 0x4000) )
      {
LABEL_183:
        if ( !v78 )
        {
LABEL_184:
          *(a2 + 32) = L"n/a";
          return 0;
        }
        goto LABEL_50;
      }
LABEL_276:
      *(a2 + 32) = L"CFG";
      return 0;
    }
LABEL_50:
    v8 = TimeStr;
    goto LABEL_51;
  }
  v91 = *(a2 + 44);
  v92 = gConfig.dwDllColumnMap[*(a2 + 20)];
  if ( v92 <= 30 )
  {
    if ( v92 == 30 )
    {
      v8 = (v91 + 76);
      goto LABEL_364;
    }
    switch ( v92 )
    {
      case 23:
        swprintf(TimeStr, L"0x%X", *(v91 + 36));
        goto LABEL_50;
      case 24:
        swprintf(TimeStr, L"0x%X", *(v91 + 56));
        goto LABEL_50;
      case 25:
        v8 = (v91 + 206);
        goto LABEL_364;
      case 26:
        if ( !wcsrchr(*(v91 + 344), 0x5Cu) )
          goto LABEL_304;
        v8 = wcsrchr(*(v91 + 344), 0x5Cu) + 1;
        goto LABEL_364;
      default:
        goto LABEL_50;
    }
    goto LABEL_50;
  }
  if ( v92 <= 1118 )
  {
    if ( v92 == 1118 )
    {
      v21 = *(v91 + 380);
    }
    else
    {
      if ( v92 <= 1074 )
      {
        if ( v92 == 1074 )
        {
          swprintf(TimeStr, L"0x%X", *(v91 + 48));
          goto LABEL_50;
        }
        v93 = v92 - 40;
        if ( v93 )
        {
          v94 = v93 - 2;
          if ( !v94 )
          {
            v8 = *(v91 + 336);
            goto LABEL_364;
          }
          if ( v94 == 991 )
          {
            v8 = *(v91 + 340);
            goto LABEL_364;
          }
          goto LABEL_50;
        }
        v95 = L"Data";
        if ( !(*(v91 + 44) & 2) )
          v95 = L"Image";
        *(a2 + 32) = v95;
        return 0;
      }
      v96 = v92 - 1111;
      if ( !v96 )
      {
LABEL_304:
        v8 = *(v91 + 344);
        goto LABEL_364;
      }
      v97 = v96 - 4;
      if ( v97 )
      {
        if ( v97 != 1 )
          goto LABEL_50;
        v21 = *(v91 + 372);
      }
      else
      {
        v21 = *(v91 + 368);
      }
    }
LABEL_62:
    ArgLista = v21 >> 10;
    v117 = L"%I64u";
LABEL_63:
    swprintf(TimeStr, v117, ArgLista, 0);
LABEL_64:
    sub_FC3290(TimeStr, 0x104u);
    wcscat_s(TimeStr, 0x104u, L" K");
    goto LABEL_50;
  }
  if ( v92 <= 1338 )
  {
    if ( v92 == 1338 )
    {
      if ( *(v91 + 54) & 0x40 )
      {
LABEL_182:
        *(a2 + 32) = L"ASLR";
        result = 0;
      }
      else
      {
        v100 = L"n/a";
        if ( !(*(v91 + 44) & 2) )
          v100 = &gszNullString;
        *(a2 + 32) = v100;
        result = 0;
      }
      return result;
    }
    v98 = v92 - 1187;
    if ( !v98 )
    {
      v8 = *(v91 + 356);
      goto LABEL_364;
    }
    v99 = v98 - 3;
    if ( !v99 )
    {
LABEL_79:
      *(a2 + 32) = L"32-bit";
      return 0;
    }
    if ( v99 != 127 )
      goto LABEL_50;
    v21 = *(v91 + 376);
    goto LABEL_62;
  }
  v101 = v92 - 1656;
  if ( !v101 )
  {
    v8 = *(v91 + 348);
    goto LABEL_364;
  }
  v102 = v101 - 14;
  if ( !v102 )
  {
    sub_1001A50(*(v91 + 364), TimeStr);
    goto LABEL_50;
  }
  if ( v102 != 39087 )
    goto LABEL_50;
  if ( *(v91 + 54) & 0x4000 )
    goto LABEL_276;
  v103 = L"n/a";
  if ( *(v91 + 54) )
    v103 = &gszNullString;
  *(a2 + 32) = v103;
  return 0;
}
// 103E080: using guessed type wchar_t aSuspended[10];
// 103E094: using guessed type wchar_t asc_103E094[5];
// 103E0A0: using guessed type wchar_t aVirtualized[12];
// 103E0C8: using guessed type wchar_t aUiAccess[10];
// 103E0DC: using guessed type wchar_t aUnaware[8];
// 103E0EC: using guessed type wchar_t aSystemAware[13];
// 103E108: using guessed type wchar_t aPerMonitorAwar[18];
// 103E12C: using guessed type wchar_t aAslr[5];
// 103E138: using guessed type wchar_t aCfg[4];
// 103E140: using guessed type wchar_t a32Bit[7];
// 103E18C: using guessed type wchar_t aNotResponding[15];
// 103E200: using guessed type wchar_t a0x08x[7];
// 103E220: using guessed type wchar_t aData_0[5];
// 103E250: using guessed type wchar_t asc_103E250[4];
// 103E9C8: using guessed type double db_zeropointzerozerofive;
// 105D238: using guessed type wchar_t *gszNetStatus[13];
// 106B1CC: using guessed type int gdwTebAddressOffset;
// FBD7B0: using guessed type WCHAR TimeStr[260];

//----- (00FBF490) --------------------------------------------------------
int __cdecl sub_FBF490(int a1, int a2)
{
  WPARAM v2; // eax
  int result; // eax

  if ( a1 != 101 || (v2 = *(a2 + 12), v2 != 9) && v2 != 36 && v2 != 35 && v2 != 13 )
    result = 0;
  else
    result = Proxy_ListCtrlWndProc(*a2, 256u, v2, 0);
  return result;
}

//----- (00FBF4D0) --------------------------------------------------------
int __cdecl sub_FBF4D0(HMENU hMnu)
{
  HWND v1; // edi
  LRESULT v2; // eax
  tagTREEVIEWLISTITEMPARAM *v3; // edi
  int v4; // eax
  HMENU v5; // eax
  int v6; // ecx
  HMENU v7; // esi
  const WCHAR *v8; // eax
  const WCHAR *v9; // eax
  BOOL v10; // ST10_4
  HMENU v11; // eax
  HMENU v12; // eax
  LPARAM v14; // [esp+8h] [ebp-68h]
  int v15; // [esp+14h] [ebp-5Ch]
  int v16; // [esp+18h] [ebp-58h]
  LPARAM lParam; // [esp+3Ch] [ebp-34h]
  LRESULT v18; // [esp+40h] [ebp-30h]
  int v19; // [esp+44h] [ebp-2Ch]
  char v20; // [esp+48h] [ebp-28h]
  int v21; // [esp+4Ch] [ebp-24h]
  tagTREEVIEWLISTITEMPARAM *pItem; // [esp+5Ch] [ebp-14h]
  HMENU hMnua; // [esp+78h] [ebp+8h]

  lParam = 0;
  memset(&v18, 0, 0x30u);
  if ( hMnu == 101 )
  {
    v1 = ghWndTreeListView;
  }
  else if ( hMnu == 102 )
  {
    v1 = ghWndHandlesListCtrl;
  }
  else
  {
    if ( hMnu != 104 )
      return 0;
    v1 = ghWndDllsListCtrl;
  }
  v18 = SendMessageW(v1, 0x100Cu, 0xFFFFFFFF, 2);
  v19 = 0;
  v21 = 2;
  lParam = 12;
  v2 = SendMessageW(v1, 0x104Bu, 0, &lParam);
  if ( hMnu == 101 )
  {
    if ( v2 == 1 && v20 & 2 )
    {
      v3 = pItem;
      v4 = pItem->dwProcessId;
      if ( gdwProcessIdSelected != v4 )
      {
        gdwProcessIdSelected = pItem->dwProcessId;
        UpdateMenuStatus(1, 3);
        v5 = GetMenu(ghMainWnd);
        v6 = v3->ProcessBasePriority;
        v7 = v5;
        hMnua = v5;
        if ( v6 == 4 && !v3->m_ProcessIoPriority )
          v6 = 0;
        sub_FFEF00(v5, v6);
        v16 = 2;
        v15 = 2;
        SendMessageW(ghWndDllsListCtrl, 0x102Bu, 0, &v14);
        v16 = 2;
        v15 = 2;
        SendMessageW(ghWndHandlesListCtrl, 0x102Bu, 0, &v14);
        v8 = L"R&esume";
        if ( SLOBYTE(v3->dwStyle) >= 0 )
          v8 = L"S&uspend";
        ModifyMenuW(v7, 0x9C6Au, 0, 0x9C6Au, v8);
        v9 = L"Un&hide";
        if ( !(v3->dwStyle & 1) )
          v9 = L"&Hide";
        ModifyMenuW(hMnua, 0x9C9Au, 0, 0x9C9Au, v9);
        RefreshMenuWithTreeViewItemStatus(v3);
        RefreshVirusTotalMenuItem(v3);
        if ( gConfig.bShowLowerPane )
          UpdateMenuStatus(0, 5);
        v10 = gConfig.bShowProcessTree == 0;
        v11 = GetMenu(ghMainWnd);
        EnableMenuItem(v11, 0x9C6Cu, v10);
LABEL_23:
        if ( gConfig.bShowLowerPane && !IsWindowVisible(ghFindDlg) && ghEvent2 )
        {
          SetEvent(ghEvent2);
          return 0;
        }
        return 0;
      }
    }
    else
    {
      gdwProcessIdSelected = -1;
      UpdateMenuStatus(0, 3);
      v12 = GetMenu(ghMainWnd);
      EnableMenuItem(v12, 0x9C6Cu, 1u);
      if ( gConfig.bShowLowerPane )
      {
        UpdateMenuStatus(0, 5);
        goto LABEL_23;
      }
    }
  }
  else if ( gConfig.bShowLowerPane )
  {
    if ( v2 == 1 && v20 & 2 )
    {
      UpdateMenuStatus(1, 5);
      return 0;
    }
    UpdateMenuStatus(0, 5);
  }
  return 0;
}
// 103E398: using guessed type wchar_t aREsume[8];
// 103E3BC: using guessed type wchar_t aUnHide[8];

//----- (00FBF750) --------------------------------------------------------
int __cdecl UpdateListViewContextMenu(UINT nID, HWND hWnd, POINT *pt)
{
  HWND hWndList; // edi
  int v4; // eax
  HMENU v5; // eax
  HMENU v6; // eax
  tagTREEVIEWLISTITEMPARAM *v7; // esi
  HMENU v8; // eax
  DLLINFOLISTITEMPARAM *v9; // esi
  char v10; // bl
  HMENU v11; // eax
  HMENU v12; // edx
  ListItemData1 *v13; // ecx
  const WCHAR *v14; // eax
  CHAR *v15; // eax
  int result; // eax
  HWND hWndParent; // eax
  UINT_PTR uID; // esi
  LVITEMW lParam; // [esp+8h] [ebp-34h]

  lParam.mask = 0;
  memset(&lParam.iItem, 0, 0x30u);
  switch ( nID )
  {
    case IDC_DLG_RUNDLG_BUTTON_BROWSE|IDS_REFERENCES|0x40:
      hWndList = ghWndTreeListView;
      goto LABEL_7;
    case IDC_DLG_RUNDLG_BUTTON_BROWSE|IDS_PARENT|0x40:
      hWndList = ghWndHandlesListCtrl;
      goto LABEL_7;
    case IDM_ABOUT:
      hWndList = ghWndDllsListCtrl;
LABEL_7:
      v4 = SendMessageW(hWndList, LVM_GETNEXTITEM, 0xFFFFFFFF, 2);
      if ( v4 != -1 )
      {
        lParam.iItem = v4;
        lParam.iSubItem = 0;
        lParam.mask = 4;
        if ( SendMessageW(hWndList, LVM_GETITEMW, 0, &lParam) == 1 )
        {
          ghSelectColumnPopupMenuHandle = CreatePopupMenu();
          if ( nID == IDC_TREEVIEW_LIST )
          {
            v5 = GetMenu(ghMainWnd);
            v6 = GetSubMenu(v5, 3);
            v7 = lParam.lParam;
            ghSelectColumnPopupMenuHandle = v6;
            RefreshMenuWithTreeViewItemStatus(lParam.lParam);
            RefreshVirusTotalMenuItem(v7);
          }
          else if ( nID == IDC_LISTCTRL_HANDLES )
          {
            v8 = GetMenu(ghMainWnd);
            ghSelectColumnPopupMenuHandle = GetSubMenu(v8, 5);
          }
          else
          {
            v9 = lParam.lParam;
            v10 = 0;
            v11 = GetMenu(ghMainWnd);
            v12 = GetSubMenu(v11, 5);
            ghSelectColumnPopupMenuHandle = v12;
            v13 = v9->m_ItemData1;
            if ( !v13 || (v14 = L"&Submit to VirusTotal", v13->field_4 != 6) )
              v14 = L"&Check VirusTotal";
            ModifyMenuW(v12, IDM_CHECK_VIRUSTOTALDOTCOM, 0, IDM_CHECK_VIRUSTOTALDOTCOM, v14);
            v15 = v9->m_strPath.pszData;
            if ( v15 && *v15 != '[' )
            {
              v10 = 0;
              if ( sub_1001C10(v9->m_ItemData1) )
                v10 = 1;
            }
            EnableMenuItem(ghSelectColumnPopupMenuHandle, IDM_CHECK_VIRUSTOTALDOTCOM, v10 == 0);
          }
          TrackPopupMenuEx(ghSelectColumnPopupMenuHandle, 0, pt->x, pt->y, ghMainWnd, 0);
          ghSelectColumnPopupMenuHandle = 0;
        }
      }
      return 0;
    case IDC_STATUSBAR:
      ghSelectColumnPopupMenuHandle = CreatePopupMenu();
      AppendMenuW(ghSelectColumnPopupMenuHandle, 0, IDM_SELECT_STATUSBAR_COLUMN, L"&Select Status Bar Columns...");
      TrackPopupMenuEx(ghSelectColumnPopupMenuHandle, 0, pt->x, pt->y, ghMainWnd, 0);
      ghSelectColumnPopupMenuHandle = 0;
      result = 0;
      break;
    default:
      hWndParent = GetParent(*hWnd);
      if ( hWndParent == ghWndTreeListView )
      {
        uID = IDM_SELECT_TREEVIEWLIST_COLUMN;
      }
      else if ( hWndParent == ghWndDllsListCtrl )
      {
        uID = IDM_SELECT_DLLSLIST_COLUMN;
      }
      else
      {
        uID = IDM_VIEW_SELECT_COLUMN;
        if ( hWndParent == ghWndHandlesListCtrl )
          uID = IDM_SELECT_HANDLESLIST_COLUMN;
      }
      ghSelectColumnPopupMenuHandle = CreatePopupMenu();
      AppendMenuW(ghSelectColumnPopupMenuHandle, 0, uID, L"&Select Columns...");
      TrackPopupMenuEx(ghSelectColumnPopupMenuHandle, 0, pt->x, pt->y, ghMainWnd, 0);
      ghSelectColumnPopupMenuHandle = 0;
      result = 0;
      break;
  }
  return result;
}
// 103E374: using guessed type wchar_t aCheckVirustota[18];

//----- (00FBF9E0) --------------------------------------------------------
bool __cdecl CTreeList::InitHeaderColumn(HWND hWnd, WPARAM wParam, HWND nItem, char flags)
{
  CTreeList *v4; // eax
  HWND v6; // ebx
  HWND hWndHeader; // eax
  _HD_ITEMW hditem; // [esp+4h] [ebp-2Ch]

  v4 = CTreeList::GetTreeList(hWnd);
  if ( v4 )
    return CTreeList::InitHeaderColumn(v4, nItem, flags != 0);
  v6 = SendMessageW(hWnd, LVM_GETHEADER, 0, 0);
  hditem.mask = 4;
  SendMessageW(v6, HDM_GETITEMW, wParam, &hditem);
  if ( gbBitmapOnRight )
    hditem.fmt &= -0x2601u;                     // -(HDF_BITMAP | HDF_SORTUP | HDF_SORTDOWN | HDF_RIGHT)
  else
    hditem.fmt &= -0x1801u;                     // -(HDF_BITMAP_ON_RIGHT | HDF_SORTDOWN | HDF_SORTDOWN | HDF_RIGHT)
  SendMessageW(v6, HDM_SETITEMW, wParam, &hditem);
  UpdateWindow(v6);
  hWndHeader = SendMessageW(hWnd, LVM_GETHEADER, 0, 0);
  return CTreeList::SetHeaderItem(hWndHeader, nItem, 2 * (flags != 0) - 1);
}
// 106A8F8: using guessed type char gbBitmapOnRight;

//----- (00FBFAA0) --------------------------------------------------------
LRESULT __cdecl sub_FBFAA0(HWND hWnd)
{
  DWORD v1; // ecx
  HWND v2; // ebx
  LRESULT v3; // eax
  BOOL v4; // eax
  UINT v5; // ST0C_4
  HMENU v6; // eax
  LPARAM lParam; // [esp+Ch] [ebp-3Ch]
  WPARAM v9; // [esp+10h] [ebp-38h]
  int v10; // [esp+14h] [ebp-34h]
  int v11; // [esp+2Ch] [ebp-1Ch]
  WPARAM wParam; // [esp+40h] [ebp-8h]
  DWORD v13; // [esp+44h] [ebp-4h]

  v1 = -1;
  wParam = hWnd;
  if ( hWnd == 101 )
  {
    v1 = gConfig.dwProcessSortColumn;
    v2 = ghWndTreeListView;
  }
  else if ( hWnd == 102 )
  {
    v1 = gConfig.dwHandleSortColumn;
    v2 = ghWndHandlesListCtrl;
  }
  else
  {
    if ( (hWnd - 102) != 2 )
    {
      v2 = hWnd;
      goto LABEL_9;
    }
    v1 = gConfig.dwDllSortColumn;
    v2 = ghWndDllsListCtrl;
  }
  if ( v1 != -1 )
  {
    if ( hWnd != 101 )
      goto LABEL_14;
    goto LABEL_13;
  }
LABEL_9:
  if ( hWnd != 101 || !gConfig.bShowProcessTree )
    return SendMessageW(v2, 0xBu, 1u, 0);
LABEL_13:
  byte_10653B5 = 1;
LABEL_14:
  v13 = v1;
  SendMessageW(v2, 0x1030u, &wParam, PropProcThreadsSortCallback);
  if ( hWnd == 101 )
  {
    if ( gConfig.bShowNewProcesses )
    {
      lParam = 4;
      v10 = 0;
      v9 = 0;
      if ( SendMessageW(ghWndTreeListView, 0x1004u, 0, 0) > 0 )
      {
        while ( 1 )
        {
          SendMessageW(ghWndTreeListView, 0x104Bu, 0, &lParam);
          if ( *(v11 + 16) == 2 && !*(v11 + 20) )
            break;
          ++v9;
          v3 = SendMessageW(ghWndTreeListView, 0x1004u, 0, 0);
          if ( v9 >= v3 )
            goto LABEL_22;
        }
        SendMessageW(ghWndTreeListView, 0x1013u, v9, 0);
      }
    }
LABEL_22:
    byte_10653B5 = 0;
    v4 = !gConfig.bShowProcessTree || SendMessageW(v2, 0x100Cu, 0xFFFFFFFF, 2) == -1;
    v5 = v4;
    v6 = GetMenu(ghMainWnd);
    EnableMenuItem(v6, 0x9C6Cu, v5);
  }
  return SendMessageW(v2, 0xBu, 1u, 0);
}
// 10653B5: using guessed type char byte_10653B5;

//----- (00FBFC20) --------------------------------------------------------
BOOL __stdcall DlgColumnSets(HWND hWndIn, UINT msg, WPARAM nID, NMLVDISPINFOW *lParam)
{
  HWND hWndList; // edi
  int nCurItem; // ebx
  tagTREEVIEWITEMPARAM *v6; // ecx
  BOOL result; // eax
  LRESULT v8; // esi
  signed int i; // esi
  int v10; // ST0C_4
  HMENU v11; // eax
  HMENU v12; // eax
  HMENU v13; // eax
  void (__stdcall *SendMessageW_1)(HWND, UINT, WPARAM, LPARAM); // esi
  int nColumn; // ebx
  int v16; // eax
  int v17; // ST08_4
  HMENU v18; // eax
  HMENU v19; // eax
  HMENU v20; // eax
  LRESULT v21; // ST10_4
  void (__stdcall *SendMessageW)(HWND, UINT, WPARAM, LPARAM); // ebx
  tagTREEVIEWITEMPARAM *Index; // esi
  CRegVar *regVar; // ebx
  int nLength; // eax
  UINT code; // eax
  LRESULT nCurItem2; // esi
  HWND v28; // eax
  HWND v29; // eax
  BOOL v30; // eax
  BOOL v31; // ST14_4
  HWND v32; // eax
  BOOL v33; // eax
  BOOL v34; // ST14_4
  HWND v35; // eax
  WCHAR *v36; // eax
  int v37; // ST10_4
  LVCOLUMNW ColumnInfo; // [esp+Ch] [ebp-44A4h]
  LVITEMW Item2; // [esp+2Ch] [ebp-4484h]
  LVITEMW ItemState; // [esp+60h] [ebp-4450h]
  LVITEMW ItemInfo; // [esp+94h] [ebp-441Ch]
  LVITEMW Item; // [esp+C8h] [ebp-43E8h]
  HWND hWndList_1; // [esp+FCh] [ebp-43B4h]
  HWND hWnd; // [esp+100h] [ebp-43B0h]
  CRegVar tempRegVar[10]; // [esp+104h] [ebp-43ACh]
  WCHAR szMenuName[520]; // [esp+3C8Ch] [ebp-824h]
  WCHAR szText[260]; // [esp+409Ch] [ebp-414h]
  WCHAR szName[260]; // [esp+42A4h] [ebp-20Ch]

  hWnd = hWndIn;
  ColumnInfo.mask = 0;
  _mm_storeu_si128(&ColumnInfo.fmt, 0i64);
  ColumnInfo.iOrder = 0;
  *&ColumnInfo.iSubItem = 0i64;
  ItemInfo.mask = 0;
  memset(&ItemInfo.iItem, 0, 0x30u);
  hWndList = GetDlgItem(hWndIn, IDC_DLG_COLUMN_SETS_LIST);
  hWndList_1 = hWndList;
  if ( msg == WM_NOTIFY )
  {
    code = lParam->hdr.code;
    if ( code != LVN_ENDLABELEDITW )
    {
      if ( code == LVN_BEGINLABELEDITW )
      {
        sbEditFlags = 1;
      }
      else if ( code == LVN_ITEMCHANGED && !sbEditFlags )
      {
        nCurItem2 = ::SendMessageW(hWndList, LVM_GETNEXTITEM, 0xFFFFFFFF, LVFI_STRING);
        v28 = GetDlgItem(hWnd, IDC_DLG_COLUMN_SETS_BUTTON_RENAME);
        EnableWindow(v28, nCurItem2 != -1);
        v29 = GetDlgItem(hWnd, IDC_DLG_COLUMN_SETS_BUTTON_DELETE);
        EnableWindow(v29, nCurItem2 != -1);
        v30 = nCurItem2 != -1 && nCurItem2;
        v31 = v30;
        v32 = GetDlgItem(hWnd, IDC_DLG_COLUMN_SETS_BUTTON_MOVEUP);
        EnableWindow(v32, v31);
        v33 = nCurItem2 != -1 && nCurItem2 != ::SendMessageW(hWndList, LVM_GETITEMCOUNT, 0, 0) - 1;
        v34 = v33;
        v35 = GetDlgItem(hWnd, IDC_DLG_COLUMN_SETS_BUTTON_MOVEDOWN);
        EnableWindow(v35, v34);
      }
      return 0;
    }
    v36 = lParam->item.pszText;
    sbEditFlags = 0;
    if ( !v36 )
      return 0;
    ItemState.pszText = v36;
    v37 = lParam->item.iItem;
    ItemState.iSubItem = 0;
    ::SendMessageW(hWndList, LVM_SETITEMTEXTW, v37, &ItemState);
    result = 1;
  }
  else
  {
    if ( msg != WM_INITDIALOG )
    {
      if ( msg == 273 )
      {
        if ( nID <= IDC_DLG_COLUMN_SETS_BUTTON_DELETE )
        {
          if ( nID == IDC_DLG_COLUMN_SETS_BUTTON_DELETE )
          {
            v8 = ::SendMessageW(hWndList, LVM_GETNEXTITEM, 0xFFFFFFFF, 2);
            ::SendMessageW(hWndList, LVM_DELETEITEM, v8, 0);
            if ( v8 )
              --v8;
            ItemState.stateMask = 3;
            ItemState.state = 3;
            ::SendMessageW(hWndList, LVM_SETITEMSTATE, v8, &ItemState);
            return 0;
          }
          if ( nID != 2 )
          {
            // if(nID<=IDC_DLG_COLUMN_SETS_BUTTON_MOVEDOWN)
            if ( nID - 1210 <= 1 )
            {
              nCurItem = ::SendMessageW(hWndList, LVM_GETNEXTITEM, 0xFFFFFFFF, 2);
              Item.mask = 5;
              if ( nID == IDC_DLG_COLUMN_SETS_BUTTON_MOVEUP )
                Item.iItem = nCurItem - 1;
              else
                Item.iItem = nCurItem + 1;
              Item.cchTextMax = 259;
              Item.pszText = szName;
              Item.iSubItem = 0;
              ::SendMessageW(hWndList, LVM_GETITEMW, 0, &Item);
              Item2.mask = 5;
              Item2.pszText = szText;
              Item2.iItem = nCurItem;
              Item2.cchTextMax = 259;
              Item2.iSubItem = 0;
              ::SendMessageW(hWndList, LVM_GETITEMW, 0, &Item2);
              v6 = Item.lParam;
              Item.pszText = szText;
              Item2.pszText = szName;
              Item.lParam = Item2.lParam;
              Item2.lParam = v6;
              ::SendMessageW(hWndList, LVM_SETITEMW, 0, &Item);
              ::SendMessageW(hWndList, LVM_SETITEMW, 0, &Item2);
              ItemState.stateMask = 3;
              ItemState.state = 3;
              ::SendMessageW(hWndList, LVM_SETITEMSTATE, Item.iItem, &ItemState);
            }
            return 0;
          }
          goto LABEL_28;
        }
        if ( nID == IDC_DLG_COLUMN_SETS_BUTTON_RENAME )
        {
          SetFocus(hWndList);
          v21 = ::SendMessageW(hWndList, LVM_GETNEXTITEM, 0xFFFFFFFF, 2);
          ::SendMessageW(hWndList, LVM_EDITLABELW, v21, 0);
          return 0;
        }
        if ( nID == IDC_DLG_COLUMN_SETS_BUTTON_OK )
        {
          for ( i = 0; i < gConfig.dwNumColumnsets; ++i )
          {
            v10 = gdwMenuItemPosLast;
            v11 = GetMenu(ghMainWnd);
            v12 = GetSubMenu(v11, 2);
            v13 = GetSubMenu(v12, v10);
            DeleteMenu(v13, 0, MF_BYPOSITION);
          }
          memmove_0(tempRegVar, gConfig.strMenuCulumnSet, 15240u);
          SendMessageW_1 = ::SendMessageW;
          nColumn = 0;
          gConfig.dwNumColumnsets = ::SendMessageW(hWndList, LVM_GETITEMCOUNT, 0, 0);
          if ( gConfig.dwNumColumnsets > 0 )
          {
            do
            {
              Item.mask = 5;
              Item.pszText = szName;
              Item.iItem = nColumn;
              Item.cchTextMax = 259;
              Item.iSubItem = 0;
              SendMessageW_1(hWndList, LVM_GETITEMW, 0, &Item);
              qmemcpy(
                &gConfig.strMenuCulumnSet[nColumn],
                &tempRegVar[Item.lParam],
                sizeof(gConfig.strMenuCulumnSet[nColumn]));
              wcscpy_s(gConfig.strMenuCulumnSet[nColumn].ColumnSetName, MAX_PATH, szName);
              if ( nColumn >= 10 )
              {
                wcscpy_s(szMenuName, 0x208u, szName);
              }
              else
              {
                if ( nColumn == 9 )
                  v16 = 0;
                else
                  v16 = nColumn + 1;
                MakeHandlePropSheetCaption(szMenuName, L"%s\tCtrl+%d", szName, v16);
              }
              v17 = gdwMenuItemPosLast;
              v18 = GetMenu(ghMainWnd);
              v19 = GetSubMenu(v18, 2);
              v20 = GetSubMenu(v19, v17);
              AppendMenuW(v20, 0, nColumn + IDM_PROCESS_PRIORITY_BASE, szMenuName);
              hWndList = hWndList_1;
              ++nColumn;
              SendMessageW_1 = ::SendMessageW;
            }
            while ( nColumn < gConfig.dwNumColumnsets );
          }
LABEL_28:
          EndDialog(hWnd, 0);
          return 0;
        }
      }
      return 0;
    }
    // WM_INITDIALOG
    SendMessageW = ::SendMessageW;
    sbEditFlags = 0;
    ::SendMessageW(hWndList, LVM_SETEXTENDEDLISTVIEWSTYLE, LVS_EX_FULLROWSELECT, LVS_EX_FULLROWSELECT);
    ::SendMessageW(hWndList, LVM_INSERTCOLUMNW, 0, &ColumnInfo);
    Index = 0;
    ItemInfo.mask = 0xD;                        // LVIF_TEXT|LVIF_IMAGE|LVIF_PARAM|LVIF_STATE
    ItemInfo.iItem = 0x7FFFFFFF;
    ItemInfo.iSubItem = 0;
    ItemInfo.state = 0;
    ItemInfo.stateMask = 0;
    if ( gConfig.dwNumColumnsets > 0 )
    {
      regVar = gConfig.strMenuCulumnSet;
      do
      {
        ItemInfo.pszText = regVar;
        nLength = lstrlenW(regVar->ColumnSetName);
        ItemInfo.iImage = 0;
        ItemInfo.cchTextMax = nLength + 1;
        ItemInfo.lParam = Index;
        ::SendMessageW(hWndList, LVM_INSERTITEMW, 0, &ItemInfo);
        Index = (Index + 1);
        ++regVar;
      }
      while ( Index < gConfig.dwNumColumnsets );
      SendMessageW = ::SendMessageW;
    }
    SendMessageW(hWndList, LVM_SETCOLUMNWIDTH, 0, 0xFFFE);// LVSCW_AUTOSIZE
    ItemState.stateMask = 3;                    // LVIS_SELECTED | LVIS_FOCUSED
    ItemState.state = 3;                        // LVIS_SELECTED | LVIS_FOCUSED
    SendMessageW(hWndList, LVM_SETITEMSTATE, 0, &ItemState);
    SetFocus(hWndList);
    result = 1;
  }
  return result;
}
// 1069E70: using guessed type char sbEditFlags;
// FBFF58: user specified stroff has not been processed: CRegVar offset 1524

//----- (00FC02A0) --------------------------------------------------------
BOOL __cdecl CMainWnd::Draw(int nColumn, HDC hdc, COLORREF *pColorReturned)
{
  WORD v3; // cx
  int v4; // eax
  __int32 v5; // eax
  double v6; // xmm0_8
  WORD v7; // cx
  COLORREF v8; // eax
  bool v9; // cf
  COLORREF v11; // [esp-10h] [ebp-2Ch]
  double v12; // [esp+0h] [ebp-1Ch]
  double pArg1; // [esp+8h] [ebp-14h]
  WORD pwHue[2]; // [esp+10h] [ebp-Ch]
  WORD pwSaturation[2]; // [esp+14h] [ebp-8h]
  WORD pwLuminance[2]; // [esp+18h] [ebp-4h]

  v3 = 0;
  *pwLuminance = 0;
  if ( !gConfig.bShowColumnHeatmaps )
    return v3 != 0;
  v4 = gConfig.dwProcessColumnMap[nColumn];
  if ( v4 > 1063 )
  {
    if ( v4 != 1650 )
      return v3 != 0;
    GraphData_QueryData(gpGraphInfoOfGPU, &pArg1, 0);
    v6 = pArg1 / gpGraphInfoOfGPU->m_dbMemorySize;
    v11 = 0x8080FF;
  }
  else if ( v4 == 1063 )
  {
    GraphData_QueryData(gpGraphInfoOfPhysicalMemory, &pArg1, 0);
    v6 = pArg1 / gpGraphInfoOfPhysicalMemory->m_dbMemorySize;
    v11 = 0x4080FF;
  }
  else
  {
    v5 = v4 - IDS_CPU;
    if ( !v5 )
    {
      GraphData_QueryData(gpGraphInfoOfCPU, &pArg1, 0);
      v12 = pArg1 / gpGraphInfoOfCPU->m_dbMemorySize;
      if ( pArg1 / gpGraphInfoOfCPU->m_dbMemorySize > 100.0 )
        v12 = db_onehundred;
      ColorRGBToHLS(0x3C943Cu, pwHue, pwLuminance, pwSaturation);
      goto LABEL_14;
    }
    if ( v5 != 5 )
      return v3 != 0;
    GraphData_QueryData(gpGraphInfoOfMemory, &pArg1, 0);
    v6 = pArg1 / gpGraphInfoOfMemory->m_dbMemorySize;
    v11 = 0x82A0;
  }
  v12 = v6;
  ColorRGBToHLS(v11, pwHue, pwLuminance, pwSaturation);
LABEL_14:
  v3 = pwLuminance[0];
  if ( pwLuminance[0] )
  {
    v7 = 5 * (46 - (v12 * 100.0) / 5);
    if ( v12 == 0.0 )
      v7 = 230;
    *pwLuminance = v7;
    v8 = ColorHLSToRGB(pwHue[0], v7, pwSaturation[0]);
    v9 = pwLuminance[0] < 110u;
    *pColorReturned = v8;
    if ( v9 )
      SetTextColor(hdc, 0xFFFFFFu);
    else
      SetTextColor(hdc, 0);
    SetBkColor(hdc, *pColorReturned);
    v3 = pwLuminance[0];
  }
  return v3 != 0;
}
// 103CDC0: using guessed type double db_onehundred;

//----- (00FC0490) --------------------------------------------------------
HCURSOR __cdecl CMainWnd::GetDynamicCursor(int a1, int nIndex)
{
  int v2; // eax
  HCURSOR result; // eax

  if ( gConfig.dwProcessColumnMap[nIndex] == IDS_VIRUSTOTAL
    && (CTreeList::GetTreeList(ghWndTreeListView), v2 = sub_F9E5D0(a1), sub_1001820(*(v2 + 0x34C))) )
  {
    result = LoadCursorW(ghInstance, L"HAND");
  }
  else
  {
    result = 0;
  }
  return result;
}

//----- (00FC04F0) --------------------------------------------------------
char __cdecl RedrawColumn(int fRedraw, HWND hWnd, int uID, WPARAM wParam)
{
  char bRet; // bl
  LPARAM dwIndex; // eax

  bRet = 0;
  if ( !fRedraw )
    return 0;
  if ( hWnd == ghWndTreeListView )
  {
    if ( gConfig.dwProcessSortColumn == -1
      || gConfig.bShowProcessTree
      || gConfig.dwProcessColumnMap[gConfig.dwProcessSortColumn] != uID )
    {
      if ( !gbMainWndMinimized )
      {
        dwIndex = 0;
        if ( gConfig.dwProcessColumnCount > 0 )
        {
          while ( gConfig.dwProcessColumnMap[dwIndex] != uID )
          {
            if ( ++dwIndex >= gConfig.dwProcessColumnCount )
              return 0;
          }
          // 尝试发送消息进行指定COLUMN的刷新
          PostMessageW(ghMainWnd, WM_MSG_7EB, wParam, dwIndex);
        }
      }
    }
    else
    {
      bRet = 1;
      if ( gConfig.dwProcessColumnCount < 16 && !gConfig.bShowLowerPane )
      {
        SendMessageW(hWnd, WM_SETREDRAW, 0, 0);
        return 1;
      }
    }
  }
  return bRet;
}
// 106A389: using guessed type char gbMainWndMinimized;

//----- (00FC05A0) --------------------------------------------------------
BOOL __stdcall DlgColumnSetSave(HWND hWnd, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
  double v4; // st6
  double v5; // st7
  HWND hWnd_1; // ecx
  HWND hWndCB_1; // eax
  signed int index_1; // ebx
  CRegVar *var_1; // esi
  int v11; // eax
  int v12; // ST08_4
  HMENU v13; // eax
  HMENU hViewMenu; // eax
  HMENU hSubMenu; // eax
  int index; // ebx
  DWORD dwNumColumnsets; // eax
  signed int dwColumnIndex; // esi
  CRegVar *var; // edi
  bool found; // zf
  void (__stdcall *SendMessageW)(HWND, UINT, WPARAM, LPARAM); // esi
  HWND hWndCB; // ebx
  signed int dwColumn; // edi
  CRegVar *pVar; // esi
  WCHAR szNewItem[520]; // [esp+10h] [ebp-61Ch]
  __int16 String[260]; // [esp+420h] [ebp-20Ch]

  hWnd_1 = hWnd;
  if ( uMsg == WM_INITDIALOG )
  {
    index = 0;
    do
    {
      swprintf(String, L"Column Set %d", index);
      dwNumColumnsets = gConfig.dwNumColumnsets;
      dwColumnIndex = 0;
      if ( gConfig.dwNumColumnsets > 0 )
      {
        var = gConfig.strMenuCulumnSet;
        while ( 1 )
        {
          found = _wcsicmp(String, var->ColumnSetName) == 0;
          dwNumColumnsets = gConfig.dwNumColumnsets;
          if ( found )
            break;
          ++dwColumnIndex;
          ++var;
          if ( dwColumnIndex >= gConfig.dwNumColumnsets )
            goto LABEL_31;
        }
        ++index;
      }
LABEL_31:
      ;
    }
    while ( dwColumnIndex != dwNumColumnsets );
    SendMessageW = ::SendMessageW;
    hWndCB = GetDlgItem(hWnd, IDC_DLG_COLUMN_SET_SAVE_COMBO);
    ::SendMessageW(hWndCB, CB_ADDSTRING, 0, String);
    dwColumn = 0;
    if ( gConfig.dwNumColumnsets > 0 )
    {
      pVar = gConfig.strMenuCulumnSet;
      do
      {
        ::SendMessageW(hWndCB, CB_ADDSTRING, 0, pVar);
        ++dwColumn;
        ++pVar;
      }
      while ( dwColumn < gConfig.dwNumColumnsets );
      SendMessageW = ::SendMessageW;
    }
    SendMessageW(hWndCB, CB_SETCURSEL, 0, 0);
    SendMessageW(hWndCB, CB_SETEDITSEL, 0, 0xFFFF0000);
  }
  else
  {
    if ( uMsg != WM_COMMAND )
      return 0;
    if ( wParam != 1 )
    {
      if ( wParam != 2 )
        return 0;
      goto LABEL_22;
    }
    hWndCB_1 = GetDlgItem(hWnd, IDC_DLG_COLUMN_SET_SAVE_COMBO);
    GetWindowTextW(hWndCB_1, String, 260);
    index_1 = 0;
    if ( gConfig.dwNumColumnsets <= 0 )
      goto LABEL_13;
    var_1 = gConfig.strMenuCulumnSet;
    do
    {
      if ( !_wcsicmp(String, var_1->ColumnSetName) )
        break;
      ++index_1;
      ++var_1;
    }
    while ( index_1 < gConfig.dwNumColumnsets );
    if ( index_1 != 10 )
    {
LABEL_13:
      UpdateWindowPlacement(ghMainWnd, 0);
      qmemcpy(&gConfig.strMenuCulumnSet[index_1], gConfig.szColumnSetName, sizeof(gConfig.strMenuCulumnSet[index_1]));
      wcscpy_s(gConfig.strMenuCulumnSet[index_1].ColumnSetName, MAX_PATH, String);
      if ( index_1 == gConfig.dwNumColumnsets )
      {
        if ( index_1 >= 10 )
        {
          wcscpy_s(szNewItem, 0x208u, String);
        }
        else
        {
          if ( index_1 == 9 )
            v11 = 0;
          else
            v11 = index_1 + 1;
          MakeHandlePropSheetCaption(szNewItem, L"%s\tCtrl+%d", String, v11);
        }
        v12 = gdwMenuItemPosLast;
        v13 = GetMenu(ghMainWnd);
        hViewMenu = GetSubMenu(v13, 2);
        hSubMenu = GetSubMenu(hViewMenu, v12);
        AppendMenuW(hSubMenu, 0, index_1 + IDM_PROCESS_PRIORITY_BASE, szNewItem);
        ++gConfig.dwNumColumnsets;
      }
      Command_SetColumn(v5, v4, 0, index_1 - 0x6127);
      hWnd_1 = hWnd;
LABEL_22:
      EndDialog(hWnd_1, 0);
      return 0;
    }
    while ( MessageBoxW(
              ghMainWnd,
              L"You must delete at least one column set before you can save a new column set.\n"
               "Do you want to open the Column Set Organizer dialog?",
              L"Process Explorer Warning",
              // MB_ICONEXCLAMATION | MB_YESNO
              0x34u) != IDNO )
    {
      DialogBoxParamW(ghInstance, L"COLUMNSETS", ghMainWnd, DlgColumnSets, 0);
      index_1 = gConfig.dwNumColumnsets;
      if ( gConfig.dwNumColumnsets != 10 )
        goto LABEL_13;
    }
  }
  return 1;
}

//----- (00FC08A0) --------------------------------------------------------
void __cdecl UpdateWindowPlacement(HWND hWnd, char bSave)
{
  WPARAM v2; // ebx
  unsigned int iBand; // esi
  HKEY v4; // ebx
  LRESULT v5; // eax
  int v6; // edx
  signed int v7; // ecx
  __m128i v8; // xmm1
  char *v9; // esi
  int v10; // ebx
  unsigned int v11; // eax
  __m128i v12; // xmm0
  int i; // ecx
  int v14; // esi
  int v15; // eax
  DWORD v16; // ecx
  int index; // esi
  HKEY v18; // ebx
  LRESULT v19; // eax
  signed int dwHandleColumnCount; // edx
  signed int v21; // ecx
  __m128i v22; // xmm1
  char *v23; // esi
  signed int v24; // ebx
  unsigned int v25; // eax
  __m128i v26; // xmm0
  signed int j; // ecx
  signed int dwIndex_1; // esi
  DWORD v29; // eax
  DWORD dwHandleSortColumn; // ecx
  signed int nColumn; // esi
  HKEY v32; // ebx
  LRESULT nOrderCount; // eax
  signed int dwDllColumnCount_1; // edx
  signed int dwIndex; // ecx
  __m128i v36; // xmm1
  char *v37; // esi
  signed int dwDllColumnCount; // ebx
  unsigned int v39; // eax
  __m128i v40; // xmm0
  signed int k; // ecx
  signed int v42; // esi
  DWORD v43; // eax
  DWORD v44; // ecx
  signed int v45; // esi
  int v46; // esi
  CRegVar *v47; // edi
  char v48[18400]; // [esp+8h] [ebp-4B3Ch]
  REBARBANDINFOW BandInfo; // [esp+47E8h] [ebp-35Ch]
  tagRegKeyInfo pThis; // [esp+4838h] [ebp-30Ch]
  int arrIDs[4]; // [esp+49C0h] [ebp-184h]
  char v52[368]; // [esp+49D0h] [ebp-174h]

  memmove_0(v48, &gConfig, sizeof(CRegSettings));
  gConfig.WindowPlacement[0].length = 44;
  GetWindowPlacement(hWnd, gConfig.WindowPlacement);
  if ( gConfig.bShowLowerPane )
    gConfig.dbSavedDivider = gConfig.dbDivider;
  if ( ghFindDlg )
  {
    gConfig.WindowPlacement[1].length = 44;
    GetWindowPlacement(ghFindDlg, &gConfig.WindowPlacement[1]);
  }                                             // ?gdwRefreshMenuIDLast@@3IA
  if ( !gConfig.dwRefreshRate )
  {
    switch ( gdwRefreshMenuIDLast )
    {
      case IDM_VIEW_UPDATESPEED_TWO_SECONDS:
        gConfig.dwRefreshRate = 2000;
        break;
      case IDM_VIEW_UPDATESPEED_FIVE_SECONDS:
        gConfig.dwRefreshRate = 5000;
        break;
      case IDM_VIEW_UPDATESPEED_TEN_SECONDS:
        gConfig.dwRefreshRate = 10000;
        break;
      case IDM_VIEW_UPDATESPEED_HALF_SECONDS:
        gConfig.dwRefreshRate = 500;
        break;
      default:
        gConfig.dwRefreshRate = 1000;
        break;
    }
  }
  v2 = 0;
  BandInfo.cbSize = sizeof(REBARBANDINFOW);
  BandInfo.fMask = 0x141;                       // RBBIM_ID|RBBIM_SIZE|RBBIM_STYLE
  iBand = 0;
  do
  {
    SendMessageW(ghWndReBar, RB_GETBANDINFOW, v2, &BandInfo);
    gConfig.ToolBandInfo[iBand].nWidth = MulDiv(BandInfo.cx, 96, gLogPixelSize.x);
    ++v2;
    gConfig.ToolBandInfo[iBand].nID = BandInfo.wID;
    gConfig.ToolBandInfo[iBand].fBreak = BandInfo.fStyle & RBBS_BREAK;
    ++iBand;
  }
  while ( iBand < 8 );
  gConfig.wProcessImageColumnWidth = SendMessageW(ghWndTreeListView, LVM_GETCOLUMNWIDTH, 0, 0);
  v4 = gConfig.dwProcessColumnMap[gConfig.dwProcessSortColumn];
  pThis.hKey = gConfig.dwProcessColumnMap[gConfig.dwProcessSortColumn];
  v5 = SendMessageW(ghWndTreeListView, 0x103Bu, gConfig.dwProcessColumnCount, arrIDs);
  v6 = gConfig.dwProcessColumnCount;
  if ( !v5 )
  {
    v7 = 0;
    if ( gConfig.dwProcessColumnCount > 0 )
    {
      if ( gConfig.dwProcessColumnCount >= 8u )
      {
        v8 = _mm_load_si128(&gIntArray);
        v9 = v52;
        v10 = gConfig.dwProcessColumnCount - gConfig.dwProcessColumnCount % 8;
        do
        {
          v11 = v7 + 4;
          v9 += 32;
          v12 = _mm_add_epi32(_mm_shuffle_epi32(_mm_cvtsi32_si128(v7), 0), v8);
          v7 += 8;
          _mm_storeu_si128(v9 - 3, v12);
          _mm_storeu_si128(v9 - 2, _mm_add_epi32(_mm_shuffle_epi32(_mm_cvtsi32_si128(v11), 0), v8));
        }
        while ( v7 < v10 );
        v4 = pThis.hKey;
      }
      for ( ; v7 < v6; ++v7 )
        arrIDs[v7] = v7;
    }
  }
  for ( i = 0; i < v6; ++i )
    *(&pThis.nLength + i) = gConfig.dwProcessColumnMap[arrIDs[i]];
  v14 = 0;
  if ( v6 > 0 )
  {
    do
    {
      v15 = *(&pThis.nLength + v14);
      gConfig.dwProcessColumnMap[v14] = v15;
      v16 = gConfig.dwProcessSortColumn;
      v6 = gConfig.dwProcessColumnCount;
      if ( v15 == v4 )
        v16 = v14;
      ++v14;
      gConfig.dwProcessSortColumn = v16;
    }
    while ( v14 < gConfig.dwProcessColumnCount );
  }
  index = 0;
  if ( v6 > 0 )
  {
    do
    {
      gConfig.dwProcessColumns[index] = SendMessageW(ghWndTreeListView, 0x101Du, arrIDs[index], 0);
      ++index;
    }
    while ( index < gConfig.dwProcessColumnCount );
  }
  v18 = gConfig.dwIdsOfHandleColumnMap[gConfig.dwHandleSortColumn];
  pThis.hKey = gConfig.dwIdsOfHandleColumnMap[gConfig.dwHandleSortColumn];
  v19 = SendMessageW(ghWndHandlesListCtrl, 0x103Bu, gConfig.dwHandleColumnCount, arrIDs);
  dwHandleColumnCount = gConfig.dwHandleColumnCount;
  if ( !v19 )
  {
    v21 = 0;
    if ( gConfig.dwHandleColumnCount > 0 )
    {
      if ( gConfig.dwHandleColumnCount >= 8 )
      {
        v22 = _mm_load_si128(&gIntArray);
        v23 = v52;
        v24 = gConfig.dwHandleColumnCount - gConfig.dwHandleColumnCount % 8;
        do
        {
          v25 = v21 + 4;
          v23 += 32;
          v26 = _mm_add_epi32(_mm_shuffle_epi32(_mm_cvtsi32_si128(v21), 0), v22);
          v21 += 8;
          _mm_storeu_si128(v23 - 3, v26);
          _mm_storeu_si128(v23 - 2, _mm_add_epi32(_mm_shuffle_epi32(_mm_cvtsi32_si128(v25), 0), v22));
        }
        while ( v21 < v24 );
        v18 = pThis.hKey;
      }
      for ( ; v21 < dwHandleColumnCount; ++v21 )
        arrIDs[v21] = v21;
    }
  }
  for ( j = 0; j < dwHandleColumnCount; ++j )
    *(&pThis.nLength + j) = gConfig.dwIdsOfHandleColumnMap[arrIDs[j]];
  dwIndex_1 = 0;
  if ( dwHandleColumnCount > 0 )
  {
    do
    {
      v29 = *(&pThis.nLength + dwIndex_1);
      gConfig.dwIdsOfHandleColumnMap[dwIndex_1] = v29;
      dwHandleSortColumn = gConfig.dwHandleSortColumn;
      dwHandleColumnCount = gConfig.dwHandleColumnCount;
      if ( v29 == v18 )
        dwHandleSortColumn = dwIndex_1;
      ++dwIndex_1;
      gConfig.dwHandleSortColumn = dwHandleSortColumn;
    }
    while ( dwIndex_1 < gConfig.dwHandleColumnCount );
  }
  nColumn = 0;
  if ( dwHandleColumnCount > 0 )
  {
    do
    {
      gConfig.dwHandleColumns[nColumn] = SendMessageW(ghWndHandlesListCtrl, LVM_GETCOLUMNWIDTH, arrIDs[nColumn], 0);
      ++nColumn;
    }
    while ( nColumn < gConfig.dwHandleColumnCount );
  }
  v32 = gConfig.dwDllColumnMap[gConfig.dwDllSortColumn];
  pThis.hKey = gConfig.dwDllColumnMap[gConfig.dwDllSortColumn];
  nOrderCount = SendMessageW(ghWndDllsListCtrl, LVM_GETCOLUMNORDERARRAY, gConfig.dwDllColumnCount, arrIDs);
  dwDllColumnCount_1 = gConfig.dwDllColumnCount;
  if ( !nOrderCount )
  {
    dwIndex = 0;
    if ( gConfig.dwDllColumnCount > 0 )
    {
      if ( gConfig.dwDllColumnCount >= 8 )
      {
        v36 = _mm_load_si128(&gIntArray);
        v37 = v52;
        dwDllColumnCount = gConfig.dwDllColumnCount - gConfig.dwDllColumnCount % 8;
        do
        {
          v39 = dwIndex + 4;
          v37 += 32;
          v40 = _mm_add_epi32(_mm_shuffle_epi32(_mm_cvtsi32_si128(dwIndex), 0), v36);
          dwIndex += 8;
          _mm_storeu_si128(v37 - 3, v40);
          _mm_storeu_si128(v37 - 2, _mm_add_epi32(_mm_shuffle_epi32(_mm_cvtsi32_si128(v39), 0), v36));
        }
        while ( dwIndex < dwDllColumnCount );
        v32 = pThis.hKey;
      }
      for ( ; dwIndex < dwDllColumnCount_1; ++dwIndex )
        arrIDs[dwIndex] = dwIndex;
    }
  }
  for ( k = 0; k < dwDllColumnCount_1; ++k )
    *(&pThis.nLength + k) = gConfig.dwDllColumnMap[arrIDs[k]];
  v42 = 0;
  if ( dwDllColumnCount_1 > 0 )
  {
    do
    {
      v43 = *(&pThis.nLength + v42);
      gConfig.dwDllColumnMap[v42] = v43;
      v44 = gConfig.dwDllSortColumn;
      dwDllColumnCount_1 = gConfig.dwDllColumnCount;
      if ( v43 == v32 )
        v44 = v42;
      ++v42;
      gConfig.dwDllSortColumn = v44;
    }
    while ( v42 < gConfig.dwDllColumnCount );
  }
  v45 = 0;
  if ( dwDllColumnCount_1 > 0 )
  {
    do
    {
      gConfig.dwDllColumns[v45] = SendMessageW(ghWndDllsListCtrl, 0x101Du, arrIDs[v45], 0);
      ++v45;
    }
    while ( v45 < gConfig.dwDllColumnCount );
  }
  if ( bSave )
  {
    pThis.szKeyName = _wcsdup(L"Software\\Sysinternals\\Process Explorer");
    gConfig.UnicodeFont.lfHeight = -MulDiv(gConfig.UnicodeFont.lfHeight, 72, gLogPixelSize.y);
    SaveConfigItemToRegistry(&pThis, gConfigItems);
    memmove_0(&gConfig, v48, 0x47E0u);
    v46 = 0;
    if ( gConfig.dwNumColumnsets > 0 )
    {
      v47 = gConfig.strMenuCulumnSet;
      do
      {
        RegVar_ReadWrite(1, v46++, v47);
        ++v47;
      }
      while ( v46 < gConfig.dwNumColumnsets );
    }
    free(pThis.szKeyName);
  }
}
// 103EA50: using guessed type RECT gIntArray;
// 105E10C: using guessed type int gdwRefreshMenuIDLast;
// FC08A0: using guessed type LPARAM arrIDs[4];

//----- (00FC0E90) --------------------------------------------------------
int __stdcall PropColumnSetsForDlls(HWND hWnd, UINT msg, WPARAM wParam, LPARAM lParam)
{
  HWND v4; // edi
  HWND v5; // eax
  BOOL v6; // ST0C_4
  HWND v7; // eax
  BOOL v8; // ST0C_4
  HWND v9; // eax
  BOOL v10; // ST0C_4
  HWND v11; // eax
  signed int v12; // esi
  UINT (__stdcall *v14)(HWND, int); // eax
  signed int i; // esi
  DWORD v16; // ecx
  unsigned int v17; // esi
  LPARAM lParama; // [esp+Ch] [ebp-ACh]
  char *v19; // [esp+18h] [ebp-A0h]
  int v20; // [esp+1Ch] [ebp-9Ch]
  LPARAM v21; // [esp+2Ch] [ebp-8Ch]
  HWND v22; // [esp+30h] [ebp-88h]
  char v23; // [esp+34h] [ebp-84h]

  v21 = lParam;
  v4 = hWnd;
  v22 = hWnd;
  if ( msg == 78 )
  {
    if ( *(lParam + 8) == -202 )
    {
      lParama = 7;
      v20 = 64;
      v19 = &v23;
      SendMessageW(ghWndDllsListCtrl, 0xBu, 0, 0);
      v14 = IsDlgButtonChecked;
      for ( i = 0; i < gConfig.dwDllColumnCount; ++i )
      {
        if ( v14(v4, gConfig.dwDllColumnMap[i]) != 1 )
        {
          v16 = gConfig.dwDllColumnCount;
          if ( i < (gConfig.dwDllColumnCount - 1) )
          {
            do
            {
              SendMessageW(ghWndDllsListCtrl, 0x105Fu, i + 1, &lParama);
              SendMessageW(ghWndDllsListCtrl, 0x1060u, i, &lParama);
              gConfig.dwDllColumnMap[i] = gConfig.dwDllColumnMap[i + 1];
              ++i;
              v16 = gConfig.dwDllColumnCount;
            }
            while ( i < (gConfig.dwDllColumnCount - 1) );
            v4 = v22;
          }
          gConfig.dwDllColumnCount = v16 - 1;
          SendMessageW(ghWndDllsListCtrl, 0x101Cu, v16 - 1, 0);
          SetWindowLongW(ghWndDllsListCtrl, -21, gConfig.dwDllColumnCount);
          i = -1;
          *dword_1069E60 = 1;
        }
        v14 = IsDlgButtonChecked;
      }
      v17 = 0;
      do
      {
        if ( v14(v4, dword_105D7F8[v17]) )
          TreeView_InsertVerifyColumn(
            ghWndDllsListCtrl,
            dword_105D7F8[v17],
            gConfig.dwDllColumnMap,
            &gConfig.dwDllColumnCount);
        v14 = IsDlgButtonChecked;
        ++v17;
      }
      while ( v17 < 21 );
      SendMessageW(ghWndDllsListCtrl, 0xBu, 1u, 0);
      InvalidateRect(ghWndDllsListCtrl, 0, 1);
      return 1;
    }
    return 0;
  }
  if ( msg != 272 )
    return 0;
  v5 = GetDlgItem(hWnd, 1190);
  EnableWindow(v5, 0);
  v6 = gdwVersion >= 1;
  v7 = GetDlgItem(v22, 1338);
  EnableWindow(v7, v6);
  v8 = gdwVersion >= 4;
  v9 = GetDlgItem(v22, 40757);
  EnableWindow(v9, v8);
  v10 = IsImmersiveProcess != 0;
  v11 = GetDlgItem(v22, 1654);
  EnableWindow(v11, v10);
  v12 = 0;
  for ( dword_1069E60 = *(v21 + 28); v12 < gConfig.dwDllColumnCount; ++v12 )
    CheckDlgButton(v22, gConfig.dwDllColumnMap[v12], 1u);
  return 1;
}
// 105D7F8: using guessed type int dword_105D7F8[];
// 1064E54: using guessed type int gdwVersion;
// 1069E60: using guessed type int dword_1069E60;
// 107BA4C: using guessed type int (__stdcall *IsImmersiveProcess)(_DWORD);

//----- (00FC1110) --------------------------------------------------------
int __stdcall PropColumnSetsForHandles(HWND hWnd, UINT msg, WPARAM wParam, LPARAM lParam)
{
  HWND v4; // edi
  signed int v5; // esi
  UINT (__stdcall *v7)(HWND, int); // eax
  signed int i; // esi
  DWORD v9; // ecx
  unsigned int v10; // esi
  signed int j; // eax
  signed int v12; // ST0C_4
  WPARAM v13; // ecx
  LPARAM lParama; // [esp+Ch] [ebp-A8h]
  BOOL v15; // [esp+10h] [ebp-A4h]
  int v16; // [esp+14h] [ebp-A0h]
  WCHAR *v17; // [esp+18h] [ebp-9Ch]
  int v18; // [esp+1Ch] [ebp-98h]
  DWORD v19; // [esp+20h] [ebp-94h]
  HWND v20; // [esp+2Ch] [ebp-88h]
  WCHAR Buffer; // [esp+30h] [ebp-84h]

  v4 = hWnd;
  v20 = hWnd;
  if ( msg == 78 )
  {
    if ( *(lParam + 8) == -202 )
    {
      lParama = 7;
      v15 = 0;
      v18 = 64;
      v17 = &Buffer;
      SendMessageW(ghWndHandlesListCtrl, 0xBu, 0, 0);
      v7 = IsDlgButtonChecked;
      for ( i = 0; i < gConfig.dwHandleColumnCount; ++i )
      {
        if ( v7(v4, gConfig.dwIdsOfHandleColumnMap[i]) != 1 )
        {
          v9 = gConfig.dwHandleColumnCount;
          if ( i < (gConfig.dwHandleColumnCount - 1) )
          {
            do
            {
              SendMessageW(ghWndHandlesListCtrl, 0x105Fu, i + 1, &lParama);
              SendMessageW(ghWndHandlesListCtrl, 0x1060u, i, &lParama);
              gConfig.dwIdsOfHandleColumnMap[i] = gConfig.dwIdsOfHandleColumnMap[i + 1];
              ++i;
              v9 = gConfig.dwHandleColumnCount;
            }
            while ( i < (gConfig.dwHandleColumnCount - 1) );
            v4 = v20;
          }
          gConfig.dwHandleColumnCount = v9 - 1;
          SendMessageW(ghWndHandlesListCtrl, 0x101Cu, v9 - 1, 0);
          SetWindowLongW(ghWndHandlesListCtrl, -21, gConfig.dwHandleColumnCount);
          i = -1;
          *dword_1069E64 = 1;
        }
        v7 = IsDlgButtonChecked;
      }
      v10 = 0;
      do
      {
        if ( v7(v4, dword_105D7DC[v10]) )
        {
          for ( j = 0; j < gConfig.dwHandleColumnCount; ++j )
          {
            if ( gConfig.dwIdsOfHandleColumnMap[j] == dword_105D7DC[v10] )
              break;
          }
          if ( j == gConfig.dwHandleColumnCount )
          {
            v19 = gConfig.dwHandleColumnCount;
            v16 = MulDiv(100, gLogPixelSize.x, 96);
            LoadStringW(ghInstance, dword_105D7DC[v10], &Buffer, 64);
            v12 = dword_105D7DC[v10];
            gConfig.dwIdsOfHandleColumnMap[gConfig.dwHandleColumnCount] = v12;
            v15 = IsStringID(v12) != 0;
            v13 = gConfig.dwHandleColumnCount++;
            SendMessageW(ghWndHandlesListCtrl, 0x1061u, v13, &lParama);
            SetWindowLongW(ghWndHandlesListCtrl, -21, gConfig.dwHandleColumnCount);
            *dword_1069E64 = 1;
          }
        }
        v7 = IsDlgButtonChecked;
        ++v10;
      }
      while ( v10 < 7 );
      SendMessageW(ghWndHandlesListCtrl, 0xBu, 1u, 0);
      InvalidateRect(ghWndHandlesListCtrl, 0, 1);
      return 1;
    }
    return 0;
  }
  if ( msg != 272 )
    return 0;
  v5 = 0;
  for ( dword_1069E64 = *(lParam + 28); v5 < gConfig.dwHandleColumnCount; ++v5 )
    CheckDlgButton(hWnd, gConfig.dwIdsOfHandleColumnMap[v5], 1u);
  return 1;
}
// 105D7DC: using guessed type int dword_105D7DC[];
// 1069E64: using guessed type int dword_1069E64;

//----- (00FC13D0) --------------------------------------------------------
int __stdcall PropColumnSetsForNet(HWND hWnd, UINT msg, WPARAM wParam, LPARAM lParam)
{
  HWND v4; // edi
  int v5; // esi
  int v7; // esi
  int v8; // ecx
  unsigned int v9; // esi
  int j; // eax
  signed int v11; // ST0C_4
  WPARAM v12; // ecx
  LPARAM lParama; // [esp+Ch] [ebp-A8h]
  BOOL v14; // [esp+10h] [ebp-A4h]
  int v15; // [esp+14h] [ebp-A0h]
  WCHAR *i; // [esp+18h] [ebp-9Ch]
  int v17; // [esp+1Ch] [ebp-98h]
  int v18; // [esp+20h] [ebp-94h]
  HWND v19; // [esp+2Ch] [ebp-88h]
  WCHAR Buffer; // [esp+30h] [ebp-84h]

  v4 = hWnd;
  v19 = hWnd;
  if ( msg == 78 )
  {
    if ( *(lParam + 8) == -202 )
    {
      v7 = 0;
      lParama = 7;
      v14 = 0;
      v17 = 64;
      for ( i = &Buffer; v7 < gConfig.dwProcessColumnCount; ++v7 )
      {
        if ( GetDlgItem(v4, gConfig.dwProcessColumnMap[v7])
          && IsDlgButtonChecked(v4, gConfig.dwProcessColumnMap[v7]) != 1 )
        {
          v8 = gConfig.dwProcessColumnCount;
          if ( v7 < gConfig.dwProcessColumnCount - 1 )
          {
            do
            {
              SendMessageW(ghWndTreeListView, 0x105Fu, v7 + 1, &lParama);
              SendMessageW(ghWndTreeListView, 0x1060u, v7, &lParama);
              gConfig.dwProcessColumnMap[v7] = gConfig.dwProcessColumnMap[v7 + 1];
              ++v7;
              v8 = gConfig.dwProcessColumnCount;
            }
            while ( v7 < gConfig.dwProcessColumnCount - 1 );
            v4 = v19;
          }
          gConfig.dwProcessColumnCount = v8 - 1;
          SendMessageW(ghWndTreeListView, 0x101Cu, v8 - 1, 0);
          SetWindowLongW(ghWndTreeListView, -21, gConfig.dwProcessColumnCount);
          v7 = -1;
          *dword_1069E6C = 1;
        }
      }
      v9 = 0;
      do
      {
        if ( IsDlgButtonChecked(v4, dword_105D798[v9]) )
        {
          for ( j = 0; j < gConfig.dwProcessColumnCount; ++j )
          {
            if ( gConfig.dwProcessColumnMap[j] == dword_105D798[v9] )
              break;
          }
          if ( j == gConfig.dwProcessColumnCount )
          {
            v18 = gConfig.dwProcessColumnCount;
            v15 = MulDiv(100, gLogPixelSize.x, 96);
            LoadStringW(ghInstance, dword_105D798[v9], &Buffer, 64);
            v11 = dword_105D798[v9];
            gConfig.dwProcessColumnMap[gConfig.dwProcessColumnCount] = v11;
            v14 = IsStringID(v11) != 0;
            v12 = gConfig.dwProcessColumnCount++;
            SendMessageW(ghWndTreeListView, 0x1061u, v12, &lParama);
            SetWindowLongW(ghWndTreeListView, -21, gConfig.dwProcessColumnCount);
            *dword_1069E6C = 1;
          }
        }
        ++v9;
      }
      while ( v9 < 17 );
      return 1;
    }
    return 0;
  }
  if ( msg != 272 )
    return 0;
  v5 = 0;
  for ( dword_1069E6C = *(lParam + 28); v5 < gConfig.dwProcessColumnCount; ++v5 )
    CheckDlgButton(hWnd, gConfig.dwProcessColumnMap[v5], 1u);
  return 1;
}
// 105D798: using guessed type int dword_105D798[];
// 1069E6C: using guessed type int dword_1069E6C;

//----- (00FC1680) --------------------------------------------------------
int __stdcall PropColumnSetsForProcess(HWND hWnd, UINT msg, WPARAM wParam, LPARAM lParam)
{
  HWND v4; // eax
  int v5; // ST0C_4
  HWND v6; // eax
  int v7; // ST0C_4
  HWND v8; // eax
  BOOL v9; // ST0C_4
  HWND v10; // eax
  BOOL v11; // ST0C_4
  HWND v12; // eax
  BOOL v13; // ST0C_4
  HWND v14; // eax
  BOOL v15; // ST0C_4
  HWND v16; // eax
  BOOL v17; // ST0C_4
  HWND v18; // eax
  BOOL v19; // ST0C_4
  HWND v20; // eax
  BOOL v21; // ST0C_4
  HWND v22; // eax
  BOOL v23; // ST0C_4
  HWND v24; // eax
  BOOL v25; // ST0C_4
  HWND v26; // eax
  BOOL v27; // ST0C_4
  HWND v28; // eax
  BOOL v29; // ST0C_4
  HWND v30; // eax
  BOOL v31; // ST0C_4
  HWND v32; // eax
  void (__stdcall *v33)(HWND, int, UINT); // eax
  int j; // esi
  HWND v35; // eax
  void (__stdcall *v36)(HWND, BOOL); // esi
  HWND v37; // eax
  HWND v38; // eax
  HWND v39; // eax
  HWND v40; // eax
  HWND v41; // eax
  HWND v42; // eax
  HWND v43; // eax
  HWND v44; // eax
  HWND v45; // eax
  void (__stdcall *v47)(HWND, UINT, WPARAM, LPARAM); // edi
  HWND (__stdcall *v48)(HWND, int); // eax
  int i; // esi
  int v50; // ecx
  unsigned int v51; // esi
  LPARAM lParama; // [esp+Ch] [ebp-A4h]
  int v53; // [esp+10h] [ebp-A0h]
  char *v54; // [esp+18h] [ebp-98h]
  int v55; // [esp+1Ch] [ebp-94h]
  char v56; // [esp+2Ch] [ebp-84h]

  if ( msg == WM_NOTIFY )
  {
    if ( *(lParam + 8) == -202 )
    {
      v47 = SendMessageW;
      lParama = 7;
      v53 = 0;
      v55 = 64;
      v54 = &v56;
      SendMessageW(ghWndTreeListView, 0xBu, 0, 0);
      v48 = GetDlgItem;
      for ( i = 0; i < gConfig.dwProcessColumnCount; ++i )
      {
        if ( v48(hWnd, gConfig.dwProcessColumnMap[i]) && IsDlgButtonChecked(hWnd, gConfig.dwProcessColumnMap[i]) != 1 )
        {
          v50 = gConfig.dwProcessColumnCount;
          if ( i < gConfig.dwProcessColumnCount - 1 )
          {
            do
            {
              SendMessageW(ghWndTreeListView, 0x105Fu, i + 1, &lParama);
              SendMessageW(ghWndTreeListView, 0x1060u, i, &lParama);
              gConfig.dwProcessColumnMap[i] = gConfig.dwProcessColumnMap[i + 1];
              ++i;
              v50 = gConfig.dwProcessColumnCount;
            }
            while ( i < gConfig.dwProcessColumnCount - 1 );
            v47 = SendMessageW;
          }
          gConfig.dwProcessColumnCount = v50 - 1;
          v47(ghWndTreeListView, 0x101Cu, v50 - 1, 0);
          SetWindowLongW(ghWndTreeListView, -21, gConfig.dwProcessColumnCount);
          i = -1;
          *dword_1069E68 = 1;
        }
        v48 = GetDlgItem;
      }
      v51 = 0;
      do
      {
        if ( v48(hWnd, dword_105D5F0[v51]) && IsDlgButtonChecked(hWnd, dword_105D5F0[v51]) )
          TreeView_InsertVerifyColumn(
            ghWndTreeListView,
            dword_105D5F0[v51],
            gConfig.dwProcessColumnMap,
            &gConfig.dwProcessColumnCount);
        v48 = GetDlgItem;
        ++v51;
      }
      while ( v51 < 105 );
      v47(ghWndTreeListView, 0xBu, 1u, 0);
      InvalidateRect(ghWndTreeListView, 0, 1);
      return 1;
    }
    return 0;
  }
  if ( msg != WM_INITDIALOG )
    return 0;
  dword_1069E68 = *(lParam + 28);
  v4 = GetDlgItem(hWnd, 1190);
  EnableWindow(v4, 0);
  v5 = gbWintrustInited;
  v6 = GetDlgItem(hWnd, 1187);
  EnableWindow(v6, v5);
  v7 = gbIsProcessDEPEnabled;
  v8 = GetDlgItem(hWnd, 1199);
  EnableWindow(v8, v7);
  v9 = gdwVersion >= 1;
  v10 = GetDlgItem(hWnd, 1337);
  EnableWindow(v10, v9);
  v11 = gdwVersion >= 1;
  v12 = GetDlgItem(hWnd, 1336);
  EnableWindow(v12, v11);
  v13 = gdwVersion >= 1;
  v14 = GetDlgItem(hWnd, 1180);
  EnableWindow(v14, v13);
  v15 = gdwVersion >= 1;
  v16 = GetDlgItem(hWnd, 1338);
  EnableWindow(v16, v15);
  v17 = gdwVersion >= 4;
  v18 = GetDlgItem(hWnd, 40757);
  EnableWindow(v18, v17);
  v19 = gdwVersion >= 1;
  v20 = GetDlgItem(hWnd, 1340);
  EnableWindow(v20, v19);
  v21 = gdwVersion >= 1;
  v22 = GetDlgItem(hWnd, 1339);
  EnableWindow(v22, v21);
  v23 = GetProcessDpiAwareness != 0;
  v24 = GetDlgItem(hWnd, 1667);
  EnableWindow(v24, v23);
  v25 = gdwVersion >= 1;
  v26 = GetDlgItem(hWnd, 1674);
  EnableWindow(v26, v25);
  v27 = gdwVersion >= 3;
  v28 = GetDlgItem(hWnd, 1673);
  EnableWindow(v28, v27);
  v29 = GetProcessorSystemCycleTime != 0;
  v30 = GetDlgItem(hWnd, 7);
  EnableWindow(v30, v29);
  v31 = IsImmersiveProcess != 0;
  v32 = GetDlgItem(hWnd, 1654);
  EnableWindow(v32, v31);
  v33 = CheckDlgButton;
  for ( j = 0; j < gConfig.dwProcessColumnCount; ++j )
  {
    v33(hWnd, gConfig.dwProcessColumnMap[j], 1u);
    v33 = CheckDlgButton;
  }
  v33(hWnd, 3, 1u);
  if ( gbProcessIdToSessionIdValid )
  {
    v36 = EnableWindow;
  }
  else
  {
    v35 = GetDlgItem(hWnd, 1056);
    v36 = EnableWindow;
    EnableWindow(v35, 0);
  }
  if ( !QueryProcessCycleTime )
  {
    v37 = GetDlgItem(hWnd, 1195);
    v36(v37, 0);
    v38 = GetDlgItem(hWnd, 1200);
    v36(v38, 0);
  }
  if ( !*GetGuiResources )
  {
    v39 = GetDlgItem(hWnd, 1067);
    v36(v39, 0);
    v40 = GetDlgItem(hWnd, 1066);
    v36(v40, 0);
  }
  if ( !gdwAdapterRuntingTime )
  {
    v41 = GetDlgItem(hWnd, 1650);
    v36(v41, 0);
  }
  if ( !*QueryWorkingSet )
  {
    v42 = GetDlgItem(hWnd, 1115);
    v36(v42, 0);
    v43 = GetDlgItem(hWnd, 1116);
    v36(v43, 0);
    v44 = GetDlgItem(hWnd, 1317);
    v36(v44, 0);
    v45 = GetDlgItem(hWnd, 1118);
    v36(v45, 0);
  }
  return 1;
}
// 105D5F0: using guessed type int dword_105D5F0[];
// 1064E54: using guessed type int gdwVersion;
// 1069E68: using guessed type int dword_1069E68;
// 106A38A: using guessed type char gbProcessIdToSessionIdValid;
// 106A390: using guessed type char gbIsProcessDEPEnabled;
// 106A391: using guessed type char gbWintrustInited;
// 106F2F4: using guessed type int GetProcessorSystemCycleTime;
// 106F36C: using guessed type int (__stdcall *GetProcessDpiAwareness)(_DWORD, _DWORD);
// 107BA4C: using guessed type int (__stdcall *IsImmersiveProcess)(_DWORD);

//----- (00FC1AF0) --------------------------------------------------------
int __cdecl sub_FC1AF0(_DWORD *a1, _DWORD *a2)
{
  int v2; // ebx
  unsigned int v3; // edi
  unsigned int v5; // edx
  int v6; // esi
  bool v7; // zf
  bool v8; // sf
  unsigned __int8 v9; // of

  v2 = a1[157];
  v3 = a1[156];
  if ( !*(a1 + 78) )
  {
    if ( *(a2 + 78) )
      return -1;
    return a1[17] - a2[17];
  }
  v5 = a2[156];
  v6 = a2[157];
  if ( !*(a2 + 78) )
    return 1;
  if ( v5 == v3 )
  {
    v9 = __OFSUB__(v2, v6);
    v7 = v2 == v6;
    v8 = v2 - v6 < 0;
    if ( v2 == v6 )
      return a1[17] - a2[17];
  }
  else
  {
    v9 = __OFSUB__(v2, v6);
    v7 = v2 == v6;
    v8 = v2 - v6 < 0;
  }
  if ( !(v8 ^ v9) && (!((v8 ^ v9) | v7) || v3 > v5) )
    return 1;
  return -1;
}

//----- (00FC1B70) --------------------------------------------------------
signed int __cdecl sub_FC1B70(int a1, HWND *a2)
{
  HWND *v2; // esi
  int v3; // eax
  _bstr_t *v4; // edi
  Data_t_bstr_t *v5; // eax

  v2 = a2;
  if ( !sub_FB2A70(*a2) )
    return 1;
  if ( *v2 == ghWndTreeListView && !v2[5] )
  {
    if ( !(dword_1069E54 & 1) )
    {
      stru_1069E50.m_Data = 0;
      dword_1069E54 |= 1u;
      atexit(sub_102A970);
    }
    CTreeList::GetTreeList(*v2);
    v3 = sub_F9E5D0(v2[4]);
    v4 = sub_FB6270(&a2, v3);
    if ( v4 != &stru_1069E50 )
    {
      _bstr_t::_Free(&stru_1069E50);
      v5 = v4->m_Data;
      stru_1069E50.m_Data = v5;
      if ( v5 )
        InterlockedIncrement(&v5->m_RefCount);
    }
    _bstr_t::_Free(&a2);
    if ( stru_1069E50.m_Data )
    {
      *v2[6] = stru_1069E50.m_Data->m_wstr;
      return 1;
    }
    *v2[6] = 0;
    return 1;
  }
  return 0;
}
// 1069E54: using guessed type int dword_1069E54;

//----- (00FC1C50) --------------------------------------------------------
signed int __cdecl sub_FC1C50(int a1, int a2)
{
  HMONITOR v2; // eax
  struct tagPOINT Point; // [esp+8h] [ebp-54h]
  struct tagMONITORINFO mi; // [esp+10h] [ebp-4Ch]
  __int128 pvParam; // [esp+38h] [ebp-24h]
  struct tagRECT Rect; // [esp+48h] [ebp-14h]

  GetCursorPos(&Point);
  if ( *MonitorFromPoint )
  {
    v2 = MonitorFromPoint(Point, 2u);
    if ( v2 )
    {
      mi.cbSize = 40;
      if ( GetMonitorInfoA(v2, &mi) )
        _mm_storeu_si128(&pvParam, _mm_loadu_si128(&mi.rcWork));
    }
  }
  else
  {
    SystemParametersInfoW(0x30u, 0, &pvParam, 0);
  }
  DWORD2(pvParam) -= 10;
  HIDWORD(pvParam) -= 10;
  GetWindowRect(*a2, &Rect);
  if ( !*(a2 + 20) )
    OffsetRect(&Rect, Point.x - Rect.left + 17, 34);
  if ( Rect.right > SDWORD2(pvParam) )
    OffsetRect(&Rect, DWORD2(pvParam) - Rect.right, 0);
  if ( Rect.bottom > SHIDWORD(pvParam) )
    OffsetRect(&Rect, 0, HIDWORD(pvParam) - Rect.bottom);
  SetWindowPos(*a2, 0, Rect.left, Rect.top, 0, 0, 0x15u);
  return 1;
}

//----- (00FC1D40) --------------------------------------------------------
BOOL RefreshTreeView()
{
  return InvalidateRect(ghWndTreeListView, 0, 0);
}

//----- (00FC1D60) --------------------------------------------------------
int sub_FC1D60(char *DstBuf, char *Format, ...)
{
  va_list ArgList; // [esp+10h] [ebp+10h]

  va_start(ArgList, Format);
  return vsprintf_s(DstBuf, 0x104u, Format, ArgList);
}

//----- (00FC1D80) --------------------------------------------------------
int sub_FC1D80(wchar_t *Dst, wchar_t *Format, ...)
{
  va_list ArgList; // [esp+10h] [ebp+10h]

  va_start(ArgList, Format);
  return vswprintf_s(Dst, 3u, Format, ArgList);
}

//----- (00FC1DA0) --------------------------------------------------------
int *__thiscall sub_FC1DA0(int *this, void *a2)
{
  int *v2; // esi

  v2 = this;
  this[5] = 7;
  this[4] = 0;
  *this = 0;
  if ( *a2 )
    sub_FA9760(this, a2, wcslen(a2));
  else
    sub_FA9760(this, a2, 0);
  return v2;
}

//----- (00FC1E00) --------------------------------------------------------
_DWORD *__thiscall sub_FC1E00(void *this, void *a2)
{
  _DWORD *result; // eax

  if ( *a2 )
    result = sub_FC31B0(this, a2, wcslen(a2));
  else
    result = sub_FC31B0(this, a2, 0);
  return result;
}

//----- (00FC1E50) --------------------------------------------------------
HRESULT __cdecl sub_FC1E50(char a1, OLECHAR *a2)
{
  HRESULT v2; // esi
  __m128i v3; // xmm0
  LPVOID v4; // ecx
  int v5; // edx
  BOOL **v6; // eax
  BOOL *v7; // edx
  int v8; // eax
  OLECHAR *v9; // eax
  BOOL **v10; // edx
  BOOL *v11; // edx
  int v12; // ecx
  int v13; // ecx
  int (__stdcall **v14)(int, void *, int *); // ecx
  BOOL **v15; // eax
  BOOL *v16; // edx
  HANDLE v17; // eax
  OLECHAR *v18; // eax
  BOOL **v19; // edx
  BOOL *v20; // edx
  int v21; // eax
  int v22; // ecx
  int (__stdcall **v23)(int, void *, int *); // ecx
  _DWORD *v24; // eax
  BOOL *v25; // edx
  int v26; // eax
  _DWORD *v27; // edx
  BOOL *v28; // edx
  BOOL *v29; // edx
  BSTR v30; // ecx
  VARIANTARG *v31; // esi
  signed int v32; // ebx
  __m128i v33; // xmm0
  __m128i v34; // xmm0
  BOOL *v35; // eax
  int *v36; // edi
  int v37; // edi
  __m128i v38; // xmm0
  int v39; // esi
  char v40; // al
  __m128i v41; // xmm0
  __m128i v42; // xmm0
  int v44; // [esp-40h] [ebp-548h]
  signed int v45; // [esp-3Ch] [ebp-544h]
  int v46; // [esp-38h] [ebp-540h]
  int v47; // [esp-34h] [ebp-53Ch]
  int v48; // [esp-30h] [ebp-538h]
  int v49; // [esp-2Ch] [ebp-534h]
  DWORD v50; // [esp-28h] [ebp-530h]
  int v51; // [esp-24h] [ebp-52Ch]
  wchar_t *v52; // [esp-20h] [ebp-528h]
  DWORD v53; // [esp-1Ch] [ebp-524h]
  WCHAR *v54; // [esp-18h] [ebp-520h]
  DWORD v55; // [esp-14h] [ebp-51Ch]
  WCHAR *v56; // [esp-10h] [ebp-518h]
  LPVOID v57; // [esp-Ch] [ebp-514h]
  BOOL *v58; // [esp-8h] [ebp-510h]
  BOOL *v59; // [esp-4h] [ebp-50Ch]
  __int128 v60; // [esp+10h] [ebp-4F8h]
  __int128 v61; // [esp+20h] [ebp-4E8h]
  __int128 v62; // [esp+30h] [ebp-4D8h]
  VARIANTARG v63; // [esp+40h] [ebp-4C8h]
  VARIANTARG v64; // [esp+50h] [ebp-4B8h]
  VARIANTARG v65; // [esp+60h] [ebp-4A8h]
  VARIANTARG pvarg; // [esp+70h] [ebp-498h]
  int *v67; // [esp+80h] [ebp-488h]
  int (__stdcall ***v68)(int, void *, int *); // [esp+84h] [ebp-484h]
  BOOL *v69; // [esp+88h] [ebp-480h]
  int (__stdcall ***v70)(int, void *, int *); // [esp+8Ch] [ebp-47Ch]
  int *v71; // [esp+90h] [ebp-478h]
  BOOL *v72; // [esp+94h] [ebp-474h]
  BOOL *v73; // [esp+98h] [ebp-470h]
  BOOL *v74; // [esp+9Ch] [ebp-46Ch]
  _bstr_t v75; // [esp+A0h] [ebp-468h]
  _bstr_t v76; // [esp+A4h] [ebp-464h]
  LPVOID ppv; // [esp+A8h] [ebp-460h]
  _bstr_t v78; // [esp+ACh] [ebp-45Ch]
  int *v79; // [esp+B0h] [ebp-458h]
  BOOL *v80; // [esp+B4h] [ebp-454h]
  OLECHAR *psz; // [esp+B8h] [ebp-450h]
  unsigned int v82; // [esp+CCh] [ebp-43Ch]
  OLECHAR *v83; // [esp+D0h] [ebp-438h]
  unsigned int v84; // [esp+E4h] [ebp-424h]
  WCHAR szDomainName[2]; // [esp+E8h] [ebp-420h]
  wchar_t Dst; // [esp+2F0h] [ebp-218h]
  int v87; // [esp+504h] [ebp-4h]

  v76.m_Data = a2;
  v78.m_Data = 0;
  sub_FC26B0(&psz);
  v87 = 0;
  ppv = 0;
  v2 = CoCreateInstance(&stru_10478CC, 0, 1u, &riid, &ppv);
  if ( v2 >= 0 )
  {
    VariantInit(&pvarg);
    _mm_storeu_si128(&v60, _mm_loadu_si128(&pvarg));
    VariantInit(&v65);
    _mm_storeu_si128(&v61, _mm_loadu_si128(&v65));
    VariantInit(&v64);
    _mm_storeu_si128(&v62, _mm_loadu_si128(&v64));
    VariantInit(&v63);
    v3 = _mm_loadu_si128(&v60);
    v4 = ppv;
    LOBYTE(v87) = 4;
    v5 = *ppv;
    _mm_storeu_si128(&v56, v3);
    _mm_storeu_si128(&v52, _mm_loadu_si128(&v61));
    _mm_storeu_si128(&v48, _mm_loadu_si128(&v62));
    _mm_storeu_si128(&v44, _mm_loadu_si128(&v63));
    v2 = (*(v5 + 40))(v4, v44, v45, v46, v47, v48, v49, v50, v51, v52, v53, v54, v55, v56, v57, v58, v59);
    VariantClear(&v63);
    VariantClear(&v64);
    VariantClear(&v65);
    LOBYTE(v87) = 0;
    VariantClear(&pvarg);
    if ( v2 < 0 )
    {
      v59 = ppv;
      (*(*ppv + 8))(ppv);
      goto LABEL_64;
    }
    v79 = 0;
    v6 = *_bstr_t::_bstr_t(&v75, L"\\");
    LOBYTE(v87) = 5;
    if ( v6 )
      v7 = *v6;
    else
      v7 = 0;
    v59 = &v79;
    v58 = v7;
    v57 = ppv;
    v8 = (*(*ppv + 28))(ppv, v7, &v79);
    LOBYTE(v87) = 0;
    v2 = v8;
    _bstr_t::_Free(&v75);
    if ( v2 < 0 )
    {
      v59 = ppv;
      (*(*ppv + 8))(ppv);
      goto LABEL_64;
    }
    v9 = &psz;
    if ( v82 >= 8 )
      v9 = psz;
    v10 = *_bstr_t::_bstr_t(&v75, v9);
    LOBYTE(v87) = 6;
    if ( v10 )
      v11 = *v10;
    else
      v11 = 0;
    v59 = 0;
    v58 = v11;
    v57 = v79;
    (*(*v79 + 60))(v79, v11, 0);
    LOBYTE(v87) = 0;
    _bstr_t::_Free(&v75);
    if ( a1 )
    {
      v59 = &v80;
      v80 = 0;
      v58 = 0;
      v12 = *ppv;
      v57 = ppv;
      v2 = (*(v12 + 36))(ppv, 0, &v80);
      v59 = ppv;
      (*(*ppv + 8))(ppv);
      if ( v2 < 0 )
      {
        v59 = v79;
        (*(*v79 + 8))(v79);
        goto LABEL_64;
      }
      v69 = 0;
      v59 = &v69;
      v58 = v80;
      v2 = (*(*v80 + 28))(v80, &v69);
      if ( v2 < 0 )
        goto LABEL_69;
      v59 = L"Process Explorer";
      v58 = v69;
      v2 = (*(*v69 + 40))(v69, L"Process Explorer");
      v59 = v69;
      (*(*v69 + 8))(v69);
      if ( v2 < 0 )
        goto LABEL_69;
      v73 = 0;
      v59 = &v73;
      v58 = v80;
      v2 = (*(*v80 + 44))(v80, &v73);
      if ( v2 < 0 )
        goto LABEL_69;
      v59 = -1;
      v58 = v73;
      v2 = (*(*v73 + 88))(v73, -1);
      v59 = v73;
      (*(*v73 + 8))(v73);
      if ( v2 < 0 )
        goto LABEL_69;
      v59 = 0;
      v58 = v73;
      (*(*v73 + 72))(v73, 0);
      v67 = 0;
      v59 = &v67;
      v58 = v80;
      v2 = (*(*v80 + 36))(v80, &v67);
      if ( v2 < 0 )
        goto LABEL_69;
      v59 = &v70;
      v70 = 0;
      v58 = 9;
      v13 = *v67;
      v57 = v67;
      v2 = (*(v13 + 40))(v67, 9, &v70);
      v59 = v67;
      (*(*v67 + 8))(v67);
      if ( v2 < 0 )
        goto LABEL_69;
      v59 = &v72;
      v72 = 0;
      v58 = &unk_104776C;
      v14 = *v70;
      v57 = v70;
      v2 = (*v14)(v70, &unk_104776C, &v72);
      v59 = v70;
      ((*v70)[2])(v70);
      if ( v2 < 0 )
      {
LABEL_69:
        v59 = v79;
        (*(*v79 + 8))(v79);
        v59 = v80;
        (*(*v80 + 8))(v80);
        goto LABEL_64;
      }
      v15 = *_bstr_t::_bstr_t(&v78, L"Logon Trigger");
      LOBYTE(v87) = 7;
      if ( v15 )
        v16 = *v15;
      else
        v16 = 0;
      v59 = v16;
      v58 = v72;
      (*(*v72 + 36))(v72, v16);
      LOBYTE(v87) = 0;
      _bstr_t::_Free(&v78);
      v59 = 0;
      v58 = 0;
      v57 = 0;
      v56 = 0;
      v55 = 260;
      v54 = szDomainName;
      v53 = 260;
      v52 = &Dst;
      v51 = 0;
      v50 = GetCurrentProcessId();
      v17 = GetCurrentProcess();
      QueryProcessUsers(v17, v50, v51, v52, v53, v54, v55, v56, v57, v58, v59);
      sub_FC1DA0(&v83, szDomainName);
      LOBYTE(v87) = 8;
      sub_FC1E00(&v83, L"\\");
      sub_FC1E00(&v83, &Dst);
      v18 = &v83;
      if ( v84 >= 8 )
        v18 = v83;
      v19 = *_bstr_t::_bstr_t(&v78, v18);
      LOBYTE(v87) = 9;
      if ( v19 )
        v20 = *v19;
      else
        v20 = 0;
      v59 = v20;
      v58 = v72;
      v21 = (*(*v72 + 92))(v72, v20);
      LOBYTE(v87) = 8;
      v2 = v21;
      _bstr_t::_Free(&v78);
      v59 = v72;
      (*(*v72 + 8))(v72);
      if ( v2 < 0 )
        goto LABEL_70;
      v71 = 0;
      v59 = &v71;
      v58 = v80;
      v2 = (*(*v80 + 68))(v80, &v71);
      if ( v2 < 0 )
        goto LABEL_70;
      v59 = &v68;
      v68 = 0;
      v58 = 0;
      v22 = *v71;
      v57 = v71;
      v2 = (*(v22 + 48))(v71, 0, &v68);
      v59 = v71;
      (*(*v71 + 8))(v71);
      if ( v2 < 0 )
        goto LABEL_70;
      v59 = &v74;
      v74 = 0;
      v58 = &unk_104781C;
      v23 = *v68;
      v57 = v68;
      v2 = (*v23)(v68, &unk_104781C, &v74);
      v59 = v68;
      ((*v68)[2])(v68);
      if ( v2 < 0 )
        goto LABEL_70;
      v24 = *_bstr_t::_bstr_t(&v76, v76.m_Data);
      LOBYTE(v87) = 10;
      v25 = (v24 ? *v24 : 0);
      v59 = v25;
      v58 = v74;
      v26 = (*(*v74 + 44))(v74, v25);
      LOBYTE(v87) = 8;
      v2 = v26;
      _bstr_t::_Free(&v76);
      v27 = *_bstr_t::_bstr_t(&v76, L"/t");
      LOBYTE(v87) = 11;
      v28 = (v27 ? *v27 : 0);
      v59 = v28;
      v58 = v74;
      (*(*v74 + 52))(v74, v28);
      LOBYTE(v87) = 8;
      _bstr_t::_Free(&v76);
      v59 = v74;
      (*(*v74 + 8))(v74);
      if ( v2 < 0 )
        goto LABEL_70;
      if ( IsBuiltinAdministrative() )
      {
        v78.m_Data = 0;
        v59 = &v78;
        v58 = v80;
        (*(*v80 + 60))(v80, &v78);
        v29 = &v83;
        if ( v84 >= 8 )
          v29 = v83;
        v30 = v78.m_Data->m_wstr;
        v59 = v29;
        v58 = v78.m_Data;
        (*(v30 + 12))(v78.m_Data, v29);
        v59 = 1;
        v58 = v78.m_Data;
        (*(v78.m_Data->m_wstr + 18))(v78.m_Data, 1);
        v59 = v78.m_Data;
        (*(v78.m_Data->m_wstr + 2))(v78.m_Data);
      }
      v75.m_Data = 0;
      if ( IsBuiltinAdministrative() )
      {
        v31 = sub_F993D0(&v63, L"Builtin\\Administrators");
        LOBYTE(v87) = 12;
        v32 = 1;
      }
      else
      {
        VariantInit(&v65);
        v31 = &v65;
        v87 = 13;
        v32 = 2;
      }
      v78.m_Data = v32;
      v33 = _mm_loadu_si128(sub_F993D0(&v64, &gszNullString));
      v87 = 14;
      v59 = &pvarg;
      _mm_storeu_si128(&v62, v33);
      VariantInit(v59);
      v34 = _mm_loadu_si128(&pvarg);
      v35 = &psz;
      LOBYTE(v87) = 15;
      if ( v82 >= 8 )
        v35 = psz;
      _mm_storeu_si128(&v61, v34);
      v59 = v35;
      _mm_storeu_si128(&v60, _mm_loadu_si128(v31));
      v36 = *_bstr_t::_bstr_t(&v76, v59);
      LOBYTE(v87) = 16;
      if ( v36 )
        v37 = *v36;
      else
        v37 = 0;
      v38 = _mm_loadu_si128(&v62);
      v39 = *v79;
      v59 = &v75;
      _mm_storeu_si128(&v55, v38);
      v40 = IsBuiltinAdministrative();
      v41 = _mm_loadu_si128(&v61);
      v54 = ((v40 != 0) + 3);
      _mm_storeu_si128(&v50, v41);
      v42 = _mm_loadu_si128(&v60);
      v45 = 6;
      v44 = v80;
      _mm_storeu_si128(&v46, v42);
      v2 = (*(v39 + 68))(v79, v37, v44, v45, v46, v47, v48, v49, v50, v51, v52, v53, v54, v55, v56, v57, v58, v59);
      _bstr_t::_Free(&v76);
      VariantClear(&pvarg);
      VariantClear(&v64);
      if ( v32 & 2 )
      {
        LOBYTE(v32) = v32 & 0xFD;
        VariantClear(&v65);
      }
      v87 = 8;
      if ( v32 & 1 )
        VariantClear(&v63);
      if ( v2 < 0 )
      {
LABEL_70:
        v59 = v79;
        (*(*v79 + 8))(v79);
        v59 = v80;
        (*(*v80 + 8))(v80);
        sub_F73820(&v83);
        goto LABEL_64;
      }
      v59 = v80;
      (*(*v80 + 8))(v80);
      v59 = v75.m_Data;
      (*(v75.m_Data->m_wstr + 2))(v75.m_Data);
      LOBYTE(v87) = 0;
      sub_F73820(&v83);
    }
    v59 = v79;
    (*(*v79 + 8))(v79);
    v2 = 0;
  }
LABEL_64:
  if ( v82 >= 8 )
    j__free(psz);
  return v2;
}

//----- (00FC26B0) --------------------------------------------------------
void *__cdecl sub_FC26B0(void *a1)
{
  DWORD v1; // ST04_4
  HANDLE v2; // eax
  int v3; // ecx
  int v4; // ecx
  void *v6; // [esp+10h] [ebp-438h]
  int v7; // [esp+20h] [ebp-428h]
  unsigned int v8; // [esp+24h] [ebp-424h]
  WCHAR szDomainName[2]; // [esp+28h] [ebp-420h]
  wchar_t Dst; // [esp+230h] [ebp-218h]
  int v11; // [esp+444h] [ebp-4h]

  v11 = 0;
  v1 = GetCurrentProcessId();
  v2 = GetCurrentProcess();
  QueryProcessUsers(v2, v1, 0, &Dst, 0x104u, szDomainName, 0x104u, 0, 0, 0, 0);
  v8 = 7;
  v7 = 0;
  LOWORD(v6) = 0;
  if ( szDomainName[0] )
    v3 = wcslen(szDomainName);
  else
    v3 = 0;
  sub_FA9760(&v6, szDomainName, v3);
  v11 = 1;
  sub_FC31B0(&v6, L"-", 1);
  if ( Dst )
    v4 = wcslen(&Dst);
  else
    v4 = 0;
  sub_FC31B0(&v6, &Dst, v4);
  *(a1 + 5) = 7;
  *(a1 + 4) = 0;
  *a1 = 0;
  sub_FA9760(a1, L"Process Explorer-", 17);
  sub_FC30E0(a1, &v6, 0, -1);
  if ( v8 >= 8 )
    j__free(v6);
  return a1;
}
// 103F134: using guessed type wchar_t asc_103F134[2];
// 103F138: using guessed type wchar_t aProcessExplore_3[18];

//----- (00FC2850) --------------------------------------------------------
errno_t __cdecl sub_FC2850(wchar_t *Dst, rsize_t SizeInWords)
{
  DWORD nLength; // [esp+Ch] [ebp-420h]
  WCHAR RemoteName; // [esp+10h] [ebp-41Ch]
  WCHAR LocalName; // [esp+420h] [ebp-Ch]

  GetModuleFileNameW(0, Dst + 1, SizeInWords - 2);
  sub_FC1D80(&LocalName, L"%c:", Dst[1]);
  nLength = 520;
  if ( !WNetGetConnectionW(&LocalName, &RemoteName, &nLength) )
  {
    wcscat_s(&RemoteName, 0x208u, Dst + 2);
    wcscpy_s(Dst + 1, SizeInWords - 1, &RemoteName);
  }
  *Dst = 34;
  wcscat_s(Dst, SizeInWords, L"\"");
  return _wcsupr_s(Dst, SizeInWords);
}

//----- (00FC2910) --------------------------------------------------------
char __cdecl sub_FC2910(int a1, int a2, int a3, wchar_t *Dst, rsize_t SizeInWords)
{
  int v5; // edi
  _DWORD *v6; // eax
  _DWORD *v7; // edx
  unsigned int v8; // esi
  bool v9; // cf
  const wchar_t **v10; // eax
  int v11; // edx
  int v13; // [esp+Ch] [ebp-4h]

  v5 = dword_1069E78;
  if ( !dword_1069E78 )
    return 0;
  while ( 1 )
  {
    if ( a1 && a1 != 1 || *v5 && *v5 != 1 )
    {
      if ( (a1 == 2 || a1 == 3) && (*v5 == 2 || *v5 == 3) )
      {
        v6 = a3;
        v7 = (v5 + 272);
        v8 = 12;
        while ( *v7 == *v6 )
        {
          ++v7;
          ++v6;
          v9 = v8 < 4;
          v8 -= 4;
          if ( v9 )
            goto LABEL_13;
        }
      }
      goto LABEL_17;
    }
    if ( *(v5 + 268) == a2 )
      break;
LABEL_17:
    v5 = *(v5 + 288);
    if ( !v5 )
      return 0;
  }
LABEL_13:
  v10 = ATL::CStringT<wchar_t,ATL::StrTraitATL<wchar_t,ATL::ChTraitsCRT<wchar_t>>>::CStringT<wchar_t,ATL::StrTraitATL<wchar_t,ATL::ChTraitsCRT<wchar_t>>>(
          &v13,
          (v5 + 4));
  wcscpy_s(Dst, SizeInWords, *v10);
  v11 = v13 - 16;
  if ( _InterlockedDecrement((v13 - 16 + 12)) <= 0 )
    (*(**v11 + 4))(v11);
  return 1;
}
// 1069E78: using guessed type int dword_1069E78;

//----- (00FC29E0) --------------------------------------------------------
WCHAR *__cdecl sub_FC29E0(HKEY hKey, LPCWSTR lpValueName)
{
  WCHAR *v2; // esi
  WCHAR *v3; // ebx
  DWORD v4; // edi
  DWORD cbData; // [esp+8h] [ebp-4h]

  v2 = 0;
  cbData = 0;
  if ( !RegQueryValueExW(hKey, lpValueName, 0, 0, 0, &cbData) )
  {
    v3 = malloc(cbData);
    if ( !RegQueryValueExW(hKey, lpValueName, 0, 0, v3, &cbData) )
    {
      v4 = ExpandEnvironmentStringsW(v3, 0, 0);
      cbData = v4;
      if ( v4 )
      {
        v2 = malloc(2 * v4);
        ExpandEnvironmentStringsW(v3, v2, v4);
      }
    }
    free(v3);
  }
  return v2;
}

//----- (00FC2A70) --------------------------------------------------------
void __cdecl sub_FC2A70(const __m128i *a1)
{
  struct hostent *v1; // eax
  void (__stdcall *v2)(LPCRITICAL_SECTION); // edi
  const __m128i *v3; // ebx
  int v4; // ST24_4
  int v5; // ST20_4
  int v6; // ST1C_4
  int v7; // ST18_4
  int v8; // ST14_4
  int v9; // ST10_4
  int v10; // ST0C_4
  u_short v11; // ax
  struct hostent *v12; // eax
  __m128i *v13; // esi
  _DWORD *v14; // eax
  char Dst; // [esp+10h] [ebp-108h]

  EnterCriticalSection(&gLock3);
  if ( a1->m128i_i32[0] && a1->m128i_i32[0] != 1 )
  {
    v1 = gethostbyaddr(a1[17].m128i_i8, 16, 23);
    if ( v1 )
    {
      strcpy_s(&Dst, 0x104u, v1->h_name);
      v2 = LeaveCriticalSection;
      LeaveCriticalSection(&gLock3);
    }
    else
    {
      v2 = LeaveCriticalSection;
      LeaveCriticalSection(&gLock3);
      v4 = htons(a1[17].m128i_u16[7]);
      v5 = htons(a1[17].m128i_u16[6]);
      v6 = htons(a1[17].m128i_u16[5]);
      v7 = htons(a1[17].m128i_u16[4]);
      v8 = htons(a1[17].m128i_u16[3]);
      v9 = htons(a1[17].m128i_u16[2]);
      v10 = htons(a1[17].m128i_u16[1]);
      v11 = htons(a1[17].m128i_u16[0]);
      sub_FC1D60(&Dst, "[%x:%x:%x:%x:%x:%x:%x:%x]", v11, v10, v9, v8, v7, v6, v5, v4);
    }
    v3 = a1;
  }
  else
  {
    v3 = htonl(a1[16].m128i_u32[2]);
    v12 = gethostbyaddr(&a1[16].m128i_i8[8], 4, 2);
    if ( v12 )
    {
      strcpy_s(&Dst, 0x104u, v12->h_name);
      v2 = LeaveCriticalSection;
      LeaveCriticalSection(&gLock3);
    }
    else
    {
      v2 = LeaveCriticalSection;
      LeaveCriticalSection(&gLock3);
      sub_FC1D60(&Dst, "%d.%d.%d.%d", v3 >> 24, (v3 >> 16) & 0xFF, v3 >> 8, v3);
    }
  }
  _strlwr_s(&Dst, 0x104u);
  EnterCriticalSection(&gLock2);
  v13 = malloc(0x124u);
  strcpy_s(&v13->m128i_i32[1], 0x104u, &Dst);
  v13[16].m128i_i32[3] = v3;
  _mm_storeu_si128(v13 + 17, _mm_loadu_si128(a1 + 17));
  v13->m128i_i32[0] = a1->m128i_i32[0];
  v13[18].m128i_i32[0] = dword_1069E78;
  v14 = dword_1069E7C;
  dword_1069E78 = v13;
  if ( dword_1069E7C )
  {
    while ( v14[67] != v3 )
    {
      v14 = v14[72];
      if ( !v14 )
        goto LABEL_15;
    }
    dword_1069E7C = v14[72];
    free(v14);
  }
LABEL_15:
  SetEvent(ghEvent6);
  v2(&gLock2);
}
// 1069E78: using guessed type int dword_1069E78;

//----- (00FC2CD0) --------------------------------------------------------
char __cdecl WriteMemoryStringToList(HWND hWnd, DWORD dwMinLength, LPVOID pBuffer, DWORD dwLength)
{
  _BYTE *pBuf; // ebx
  BOOL bPrintable; // eax
  DWORD dwBufLen; // ecx
  DWORD dwMinLen; // edx
  unsigned int offset; // esi
  DWORD index; // edi
  unsigned int chStr; // ebx
  signed int dwMinLength_; // edx
  int nMemCharIndex; // ecx
  unsigned int nWideCharIndex; // ebx
  CStringData *var14; // eax
  int fWideChar; // eax
  WCHAR v16; // ax
  unsigned int nWideCharIndex_; // ebx
  unsigned int nOffset; // esi
  unsigned int nIndex; // edi
  int nMemCharIndex1; // ecx
  unsigned int nWideCharIndex1; // ebx
  DWORD v22; // edx
  int bAlphable; // eax
  CStringData *v24; // edx
  LVITEMW Item; // [esp+4h] [ebp-30050h]
  DWORD v26; // [esp+38h] [ebp-3001Ch]
  char *pszText; // [esp+3Ch] [ebp-30018h]
  HWND hWnda; // [esp+40h] [ebp-30014h]
  CStringData *pwszText; // [esp+44h] [ebp-30010h]
  int nCount; // [esp+48h] [ebp-3000Ch]
  char *pszBuf; // [esp+4Ch] [ebp-30008h]
  char szText[65536]; // [esp+50h] [ebp-30004h]
  WCHAR wszText[65536]; // [esp+10050h] [ebp-20004h]

  pBuf = pBuffer;
  hWnda = hWnd;
  pszBuf = pBuffer;
  Item.mask = 0;
  LOBYTE(bPrintable) = memset(&Item.iItem, 0, 0x30u);
  dwBufLen = dwLength;
  dwMinLen = dwMinLength;
  if ( dwLength >= dwMinLength )
  {
    offset = -1;
    index = 0;
    if ( dwLength )
    {
      while ( 1 )
      {
        chStr = *&pBuf[index];
        bPrintable = _ismbcprint(chStr);
        if ( !bPrintable && chStr != '~' )
        {
          if ( offset != -1 )
          {
            dwMinLength_ = dwMinLength;
            LOBYTE(bPrintable) = 2 * dwMinLength;
            if ( index - offset >= 2 * dwMinLength )
            {
              nMemCharIndex = 0;
              nWideCharIndex = 0;
              nCount = 0;
              if ( offset < index )
              {
                var14 = (dwLength - dwMinLength + 1);
                pwszText = (dwLength - dwMinLength + 1);
                do
                {
                  if ( offset >= var14 )
                    break;
                  fWideChar = iswalpha(pszBuf[offset]);
                  nMemCharIndex = nCount;
                  if ( fWideChar )
                    nMemCharIndex = nCount++ + 1;
                  v16 = pszBuf[offset];
                  offset += 2;
                  wszText[nWideCharIndex++] = v16;
                  var14 = pwszText;
                }
                while ( offset < index );
                dwMinLength_ = dwMinLength;
              }
              nWideCharIndex_ = nWideCharIndex;
              if ( nWideCharIndex_ >= 65536 )
              {
__ErrorExit:
                __report_rangecheckfailure();
                JUMPOUT(*algn_FC2FF0);
              }
              LOBYTE(bPrintable) = 0;
              wszText[nWideCharIndex_] = 0;
              if ( nMemCharIndex >= dwMinLength_ )
              {
                szText[1024] = 0;
                Item.pszText = wszText;
                Item.mask = 5;
                Item.iItem = 0x7FFFFFFF;
                Item.lParam = 1;
                LOBYTE(bPrintable) = SendMessageW(hWnda, LVM_INSERTITEMW, 0, &Item);
              }
            }
            offset = -1;
          }
          goto __NEXT;
        }
        if ( chStr == ' ' )
        {
          if ( offset == -1 )
            goto __NEXT;
        }
        else if ( offset == -1 )
        {
          offset = index;
        }
        ++index;
__NEXT:
        dwBufLen = dwLength;
        ++index;
        pBuf = pszBuf;
        if ( index >= dwLength )
        {
          dwMinLen = dwMinLength;
          break;
        }
      }
    }
    nOffset = -1;
    nIndex = 0;
    if ( dwBufLen )
    {
      do
      {
        LOBYTE(bPrintable) = pBuf[nIndex];
        if ( (bPrintable < ' ' || bPrintable >= '~') && bPrintable != '~' )
        {
          if ( nOffset != -1 )
          {
            LOBYTE(bPrintable) = nIndex - nOffset;
            if ( nIndex - nOffset >= dwMinLen )
            {
              nMemCharIndex1 = 0;
              nWideCharIndex1 = 0;
              nCount = 0;
              if ( nOffset < nIndex )
              {
                v22 = dwLength - dwMinLen + 1;
                v26 = v22;
                bPrintable = &szText[-nOffset];
                pszText = &szText[-nOffset];
                do
                {
                  if ( nOffset >= v22 )
                    break;
                  bAlphable = isalpha(pszBuf[nOffset]);
                  nMemCharIndex1 = nCount;
                  if ( bAlphable )
                    nMemCharIndex1 = nCount++ + 1;
                  ++nWideCharIndex1;
                  LOBYTE(bPrintable) = pszBuf[nOffset];
                  pszText[nOffset++] = bPrintable;
                  v22 = v26;
                }
                while ( nOffset < nIndex );
                if ( nWideCharIndex1 >= 0x10000 )
                  goto __ErrorExit;
                dwMinLen = dwMinLength;
              }
              szText[nWideCharIndex1] = 0;
              if ( nMemCharIndex1 >= dwMinLen )
              {
                ATL::CStringT<wchar_t,ATL::StrTraitATL<wchar_t,ATL::ChTraitsCRT<wchar_t>>>::CStringT<wchar_t,ATL::StrTraitATL<wchar_t,ATL::ChTraitsCRT<wchar_t>>>(
                  &pwszText,
                  szText);
                Item.pszText = pwszText;
                Item.mask = 5;
                Item.iItem = 0x7FFFFFFF;
                szText[1024] = 0;
                Item.lParam = 1;
                SendMessageW(hWnda, LVM_INSERTITEMW, 0, &Item);
                v24 = pwszText - 1;
                bPrintable = &pwszText[-1].nRefs;
                if ( _InterlockedDecrement(bPrintable) <= 0 )
                  LOBYTE(bPrintable) = (v24->pStringMgr->vtptr->Free)(v24);
                dwMinLen = dwMinLength;
              }
              pBuf = pszBuf;
              dwBufLen = dwLength;
            }
            nOffset = -1;
          }
        }
        else if ( bPrintable != ' ' && nOffset == -1 )
        {
          nOffset = nIndex;
        }
        ++nIndex;
      }
      while ( nIndex < dwBufLen );
    }
  }
  return bPrintable;
}
// 10067E8: using guessed type int __report_rangecheckfailure(void);

//----- (00FC3000) --------------------------------------------------------
BOOL __cdecl IsServer(LPCWSTR lpszServerName)
{
  BOOL ret; // ebx
  WCHAR *pszSuiteName; // eax
  WCHAR *pszName; // edi
  WCHAR *lpszName; // esi
  DWORD dwType; // [esp+4h] [ebp-Ch]
  DWORD cbData; // [esp+8h] [ebp-8h]
  HKEY hKey; // [esp+Ch] [ebp-4h]

  ret = 0;
  hKey = 0;
  dwType = 0;
  cbData = 0;
  if ( !RegOpenKeyW(HKEY_LOCAL_MACHINE, L"System\\CurrentControlSet\\Control\\ProductOptions", &hKey)
    && !RegQueryValueExW(hKey, L"ProductSuite", 0u, &dwType, 0u, &cbData) )
  {
    if ( cbData )
    {
      pszSuiteName = LocalAlloc(LMEM_ZEROINIT, cbData);
      pszName = pszSuiteName;
      if ( pszSuiteName )
      {
        if ( !RegQueryValueExW(hKey, L"ProductSuite", 0u, &dwType, pszSuiteName, &cbData) && dwType == REG_MULTI_SZ )
        {
          lpszName = pszName;
          if ( *pszName )
          {
            while ( lstrcmpW(lpszName, lpszServerName) )
            {
              lpszName += lstrlenW(lpszName) + 1;
              if ( !*lpszName )
                goto __free;
            }
            ret = 1;
          }
        }
__free:
        LocalFree(pszName);
      }
    }
  }
  if ( hKey )
    RegCloseKey(hKey);
  return ret;
}

//----- (00FC30E0) --------------------------------------------------------
_DWORD *__thiscall sub_FC30E0(void *this, int a2, int a3, int a4)
{
  _DWORD *v4; // edi
  _DWORD *v5; // esi
  unsigned int v6; // eax
  unsigned int v7; // ebx
  unsigned int v8; // eax
  int v9; // ecx
  _DWORD *v10; // ecx
  int v11; // ecx
  bool v12; // cf
  int v14; // [esp+14h] [ebp+8h]

  v4 = a2;
  v5 = this;
  v6 = *(a2 + 16);
  if ( v6 < a3 )
    std::_Xout_of_range("invalid string position");
  v7 = a4;
  v8 = v6 - a3;
  v9 = *(this + 4);
  v14 = v5[4];
  if ( v8 < a4 )
    v7 = v8;
  if ( -1 - v9 <= v7 )
    std::_Xlength_error("string too long");
  if ( v7 && sub_F7FC40(v5, v9 + v7, 0) )
  {
    if ( v4[5] >= 8u )
      v4 = *v4;
    if ( v5[5] < 8u )
      v10 = v5;
    else
      v10 = *v5;
    if ( v7 )
      memmove_0(v10 + 2 * v5[4], v4 + 2 * a3, 2 * v7);
    v11 = v7 + v14;
    v12 = v5[5] < 8u;
    v5[4] = v7 + v14;
    if ( !v12 )
    {
      *(*v5 + 2 * v11) = 0;
      return v5;
    }
    *(v5 + v11) = 0;
  }
  return v5;
}

//----- (00FC31B0) --------------------------------------------------------
_DWORD *__thiscall sub_FC31B0(void *this, void *a2, int a3)
{
  void *v3; // edi
  _DWORD *v4; // esi
  unsigned int v5; // ecx
  unsigned int v6; // eax
  _DWORD *v7; // edx
  _DWORD *v8; // eax
  _DWORD *result; // eax
  char *v10; // ecx
  _DWORD *v11; // ecx
  int v12; // ecx
  bool v13; // cf
  char *v14; // [esp+10h] [ebp+8h]

  v3 = a2;
  v4 = this;
  if ( a2
    && ((v5 = *(this + 5), v5 < 8) ? (v6 = v4) : (v6 = *v4),
        a2 >= v6 && (v5 < 8 ? (v7 = v4) : (v7 = *v4), v7 + 2 * v4[4] > a2)) )
  {
    if ( v5 < 8 )
      v8 = v4;
    else
      v8 = *v4;
    result = sub_FC30E0(v4, v4, (a2 - v8) >> 1, a3);
  }
  else
  {
    v10 = v4[4];
    v14 = v10;
    if ( -1 - v10 <= a3 )
      std::_Xlength_error("string too long");
    if ( a3 && sub_F7FC40(v4, &v10[a3], 0) )
    {
      if ( v4[5] < 8u )
        v11 = v4;
      else
        v11 = *v4;
      if ( a3 )
        memmove_0(v11 + 2 * v4[4], v3, 2 * a3);
      v12 = &v14[a3];
      v13 = v4[5] < 8u;
      v4[4] = &v14[a3];
      if ( !v13 )
      {
        *(*v4 + 2 * v12) = 0;
        return v4;
      }
      *(v4 + v12) = 0;
    }
    result = v4;
  }
  return result;
}

//----- (00FC3290) --------------------------------------------------------
LPCWSTR __cdecl sub_FC3290(LPCWSTR lpValue, rsize_t SizeInWords)
{
  wchar_t *v2; // eax
  WCHAR NumberStr; // [esp+4h] [ebp-804h]

  GetNumberFormatW(0x400u, 0, lpValue, 0, &NumberStr, 1024);
  wcscpy_s(lpValue, SizeInWords, &NumberStr);
  v2 = wcsstr(lpValue, &gszLocaleInfo);
  if ( v2 )
    *v2 = 0;
  return lpValue;
}

//----- (00FC3300) --------------------------------------------------------
void __cdecl sub_FC3300(wchar_t *a1)
{
  int v1; // edi
  int v2; // esi
  int v3; // edx
  WCHAR v4; // ax
  WCHAR v5; // cx
  wchar_t *v6; // esi
  wchar_t v7; // ax
  size_t v8; // esi
  wchar_t *v9; // edi
  wchar_t *v10; // ecx
  wchar_t v11; // ax
  DWORD cbData; // [esp+8h] [ebp-618h]
  WCHAR ValueName[2]; // [esp+Ch] [ebp-614h]
  HKEY phkResult; // [esp+10h] [ebp-610h]
  wchar_t v15[260]; // [esp+14h] [ebp-60Ch]
  BYTE v16[2]; // [esp+21Ch] [ebp-404h]
  wchar_t Dst; // [esp+21Eh] [ebp-402h]
  __int16 v18; // [esp+250h] [ebp-3D0h]
  BYTE Data[2]; // [esp+41Ch] [ebp-204h]
  char v20; // [esp+41Eh] [ebp-202h]
  WCHAR v21; // [esp+44Eh] [ebp-1D2h]

  *Data = 0;
  memset(&v20, 0, 0x1FEu);
  *v16 = 0;
  memset(&Dst, 0, 0x1FEu);
  *ValueName = 65;
  v1 = 0;
  if ( !RegOpenKeyW(HKEY_CURRENT_USER, L"Software\\Microsoft\\Windows\\CurrentVersion\\Explorer\\RunMRU", &phkResult) )
  {
    cbData = 512;
    RegQueryValueExW(phkResult, L"MRUList", 0, 0, Data, &cbData);
    _wcslwr_s(Data, 0x100u);
    v2 = 0;
    if ( wcslen(Data) <= 0 )
    {
LABEL_8:
      wcscpy_s(&Dst, 0xFFu, Data);
      v18 = 0;
      v3 = 0;
      while ( (1 << v3) & v1 )
      {
        if ( ++v3 >= 26 )
        {
          v4 = *v16;
          goto LABEL_14;
        }
      }
      v4 = v3 + 97;
LABEL_14:
      v5 = v4;
      v6 = a1;
      if ( v3 == 26 )
        v5 = v21;
      *v16 = v5;
      ValueName[0] = v5;
      do
      {
        v7 = *v6;
        ++v6;
      }
      while ( v7 );
      v8 = v6 - (a1 + 1) + 3;
      v9 = malloc(2 * v8);
      swprintf_s(v9, v8, L"%s\\1", a1);
      v10 = v9;
      do
      {
        v11 = *v10;
        ++v10;
      }
      while ( v11 );
      RegSetValueExW(phkResult, ValueName, 0, 1u, v9, 2 * (v10 - (v9 + 1)) + 2);
      RegSetValueExW(phkResult, L"MRUList", 0, 1u, v16, 2 * wcslen(v16) + 2);
      RegCloseKey(phkResult);
      free(v9);
    }
    else
    {
      while ( 1 )
      {
        ValueName[0] = *&Data[2 * v2];
        cbData = 520;
        v1 |= 122 - ValueName[0] > 1;
        if ( !RegQueryValueExW(phkResult, ValueName, 0, 0, v15, &cbData) )
        {
          if ( wcsrchr(v15, 0x5Cu) )
            *wcsrchr(v15, 0x5Cu) = 0;
          if ( !_wcsicmp(a1, v15) )
            break;
        }
        if ( ++v2 >= wcslen(Data) )
          goto LABEL_8;
      }
      RegCloseKey(phkResult);
    }
  }
}

//----- (00FC35F0) --------------------------------------------------------
BOOL __cdecl ReplaceMenuIconFromStockIcon(HMENU hmenu, UINT item)
{
  DWORD v2; // esi
  MENUITEMINFOW mii; // [esp+8h] [ebp-24Ch]
  int v5; // [esp+38h] [ebp-21Ch]
  DWORD v6; // [esp+3Ch] [ebp-218h]

  v2 = dword_1069E80;
  if ( !dword_1069E80 )
  {
    memset(&v6, dword_1069E80, 0x214u);
    v5 = 536;
    SHGetStockIconInfo(77, 257, &v5);
    v2 = v6;
    dword_1069E80 = v6;
  }
  memset(&mii.fMask, 0, 0x2Cu);
  mii.cbSize = 48;
  mii.fMask = 160;
  mii.hbmpItem = -1;
  mii.dwItemData = v2;
  return SetMenuItemInfoW(hmenu, item, 0, &mii);
}
// 107BA50: using guessed type int (__stdcall *SHGetStockIconInfo)(_DWORD, _DWORD, _DWORD);

//----- (00FC36B0) --------------------------------------------------------
bool __cdecl sub_FC36B0(int a1, unsigned int a2, char a3, char a4)
{
  unsigned int v4; // esi
  _DWORD *v5; // edx

  v4 = 0;
  if ( !a2 )
    return 0;
  v5 = (a1 + 4);
  while ( *v5 != 1 && *v5 || !((1 << a3) & *(v5 - 1)) )
  {
    ++v4;
    v5 += 6;
    if ( v4 >= a2 )
      return 0;
  }
  return ((1 << a4) & *(a1 + 24 * v4)) != 0;
}

//----- (00FC3710) --------------------------------------------------------
HWND __cdecl PropSheet_UpdateTab(HWND hWnd)
{
  HWND hWndParent; // eax
  HWND hWndTab; // eax
  HWND v3; // edi
  struct tagRECT Rect; // [esp+8h] [ebp-14h]

  hWndParent = GetParent(hWnd);
  hWndTab = GetDlgItem(hWndParent, IDS_PROCPROPSHEET_TABCTRL);
  v3 = hWndTab;
  if ( hWndTab )
  {
    GetWindowRect(hWndTab, &Rect);
    SendMessageW(v3, TCM_ADJUSTRECT, 0, &Rect);
    MapWindowPoints(0, hWnd, &Rect, 2u);
    SetWindowPos(hWnd, 0, Rect.left, Rect.top, Rect.right - Rect.left, Rect.bottom - Rect.top, SWP_NOACTIVATE);
    hWndTab = gpfnEnableThemeDialogTexture;
    if ( gpfnEnableThemeDialogTexture )
      hWndTab = gpfnEnableThemeDialogTexture(hWnd, 6);
  }
  return hWndTab;
}
// 1069E88: using guessed type int (__stdcall *gpfnEnableThemeDialogTexture)(_DWORD, _DWORD);

//----- (00FC37B0) --------------------------------------------------------
signed int __cdecl sub_FC37B0(unsigned __int64 a1, unsigned __int64 a2)
{
  signed int result; // eax

  if ( HIDWORD(a1) < HIDWORD(a2) )
    goto LABEL_10;
  if ( HIDWORD(a1) > HIDWORD(a2) || a1 > a2 )
    return 1;
  if ( a1 >= a2 )
    result = 0;
  else
LABEL_10:
    result = -1;
  return result;
}

//----- (00FC37F0) --------------------------------------------------------
BOOL __cdecl sub_FC37F0(char a1)
{
  DWORD v1; // esi
  HKEY phkResult; // [esp+4h] [ebp-418h]
  BYTE Data[2]; // [esp+8h] [ebp-414h]
  char v5; // [esp+Ah] [ebp-412h]

  *Data = 0;
  memset(&v5, 0, 0x40Eu);
  sub_FC2850(Data, 0x208u);
  if ( gdwVersion < 1 )
  {
    v1 = RegOpenKeyExW(HKEY_CURRENT_USER, L"Software\\Microsoft\\Windows\\CurrentVersion\\Run", 0, 2u, &phkResult);
    if ( v1 )
    {
LABEL_10:
      SetLastError(v1);
      ReportMsg(L"Error configuring auto start", ghMainWnd);
      return v1 == 0;
    }
    if ( a1 )
    {
      wcscat_s(Data, 0x208u, L" /t");
      v1 = RegSetValueExW(phkResult, L"Process Explorer", 0, 1u, Data, 2 * wcslen(Data) + 2);
    }
    else
    {
      v1 = RegDeleteValueW(phkResult, L"Process Explorer");
      if ( v1 == 2 )
        v1 = 0;
    }
    RegCloseKey(phkResult);
  }
  else
  {
    v1 = sub_FC1E50(a1, Data);
  }
  if ( v1 )
    goto LABEL_10;
  return v1 == 0;
}
// 103F218: using guessed type wchar_t aErrorConfiguri[29];
// 1064E54: using guessed type int gdwVersion;

//----- (00FC3940) --------------------------------------------------------
LRESULT __cdecl CTreeList::InitToolTips(HWND hWnd)
{
  SendMessageW(hWnd, TTM_SETDELAYTIME, 3u, 0);
  SendMessageW(hWnd, TTM_SETMAXTIPWIDTH, 0, 4000);
  return SendMessageW(hWnd, TTM_SETDELAYTIME, 2u, 1000000);
}

//----- (00FC3980) --------------------------------------------------------
BOOL __cdecl DrawLine(HWND hWnd, int y)
{
  HPEN hPen; // eax
  HPEN v3; // esi
  HPEN ho; // ST1C_4
  HDC hDC; // eax
  HDC v6; // ebx
  HDC hdc; // ST24_4
  HGDIOBJ hOldpen; // edi
  struct tagRECT rcClient; // [esp+18h] [ebp-14h]

  hPen = CreatePen(PS_COSMETIC, 5, 0);
  v3 = hPen;
  ho = hPen;
  GetClientRect(hWnd, &rcClient);
  hDC = GetDC(hWnd);
  v6 = hDC;
  hdc = hDC;
  hOldpen = SelectObject(hDC, v3);
  SetROP2(v6, R2_NOT);
  MoveToEx(hdc, 0, y + 6, 0);
  LineTo(hdc, rcClient.right, y + 6);
  SelectObject(hdc, hOldpen);
  SetROP2(hdc, R2_NOP);
  ReleaseDC(hWnd, hdc);
  return DeleteObject(ho);
}

//----- (00FC3A30) --------------------------------------------------------
char __cdecl MakeApplicationName(LPCWSTR lpFileName, wchar_t *Src, int a3, wchar_t *Dst)
{
  char result; // al
  rsize_t v5; // ebx
  wchar_t *v6; // edi
  wchar_t *v7; // esi
  wchar_t *v8; // eax
  wchar_t *v9; // eax

  if ( GetFileAttributesW(lpFileName) == -1 )
  {
    v5 = wcslen(lpFileName) + a3 + 2;
    v6 = Src;
    v7 = malloc(2 * v5);
    if ( Src )
    {
      while ( *v6 )
      {
        wcscpy_s(v7, v5, v6);
        v8 = wcschr(v7, 0x3Bu);
        if ( v8 )
          *v8 = 0;
        wcscat_s(v7, v5, L"\\");
        wcscat_s(v7, v5, lpFileName);
        if ( GetFileAttributesW(v7) != -1 )
        {
          wcscpy_s(Dst, 0x104u, v7);
          j__free(v7);
          return 1;
        }
        v9 = wcschr(v6, 0x3Bu);
        if ( v9 )
        {
          v6 = v9 + 1;
          if ( v9 != -2 )
            continue;
        }
        break;
      }
    }
    j__free(v7);
    result = 0;
  }
  else
  {
    wcscpy_s(Dst, 0x104u, lpFileName);
    result = 1;
  }
  return result;
}

//----- (00FC3B30) --------------------------------------------------------
HWND __cdecl QueryTopMostWindowByProcessID(int dwProcessId_1)
{
  HWND ret; // edi
  HWND hWndFound; // esi
  HWND v3; // eax
  HWND v4; // eax
  DWORD dwPid; // [esp+8h] [ebp-1004h]
  WINDOWPLACEMENT wp; // [esp+Ch] [ebp-1000h]
  WCHAR szText[2024]; // [esp+38h] [ebp-FD4h]

  ret = 0;
  hWndFound = FindWindowExW(0, 0, 0, 0);
  if ( !hWndFound )
    return 0;
  do
  {
    GetWindowThreadProcessId(hWndFound, &dwPid);
    if ( dwPid == dwProcessId_1 && (IsWindowVisible(hWndFound) || IsIconic(hWndFound)) )
    {
      if ( !IsIconic(hWndFound)
        || (GetWindowPlacement(hWndFound, &wp), wp.rcNormalPosition.right - wp.rcNormalPosition.left > 1) )
      {
        if ( GetWindowTextW(hWndFound, szText, 2024) )
        {
          ret = hWndFound;
          if ( !GetParent(hWndFound) )
            break;
          v3 = GetParent(hWndFound);
          if ( !GetParent(v3) )
          {
            v4 = GetParent(hWndFound);
            if ( !IsWindowVisible(v4) )
              break;
          }
        }
      }
    }
    hWndFound = FindWindowExW(0, hWndFound, 0, 0);
  }
  while ( hWndFound );
  return ret;
}

//----- (00FC3C40) --------------------------------------------------------
int __cdecl sub_FC3C40(wchar_t *a1, size_t SizeInWords, __int64 a3)
{
  double v3; // xmm0_8
  const wchar_t *v5; // [esp+8h] [ebp-4Ch]
  wchar_t Dst; // [esp+10h] [ebp-44h]
  char v7; // [esp+12h] [ebp-42h]

  Dst = 0;
  memset(&v7, 0, 0x3Eu);
  v3 = *&a3;
  if ( *&a3 < 1073741824.0 )
  {
    if ( *&a3 < 1048576.0 )
    {
      if ( *&a3 < 1024.0 )
        goto LABEL_8;
      v3 = *&a3 * 0.0009765625;
      v5 = L" KB";
    }
    else
    {
      v3 = *&a3 * 0.00000095367431640625;
      v5 = L" MB";
    }
  }
  else
  {
    v3 = *&a3 * 9.313225746154785e-10;
    v5 = L" GB";
  }
  wcscpy_s(&Dst, 0x20u, v5);
LABEL_8:
  if ( Dst )
    return swprintf_s(a1, SizeInWords, L"%0.1f %s", LODWORD(v3), HIDWORD(v3), &Dst);
  if ( v3 == 0.0 )
    return swprintf_s(a1, SizeInWords, L"0");
  return swprintf_s(a1, SizeInWords, L"%0.0f B", LODWORD(v3), HIDWORD(v3));
}
// 103CBE0: using guessed type wchar_t aGb[4];

//----- (00FC3D60) --------------------------------------------------------
char __cdecl UserInfoWithSIDList_Find(PSID pSID, LPWSTR pszName, DWORD cbName, LPWSTR pszDomainName, DWORD cbDomainName)
{
  tagUserInfoWithSID *v5; // esi
  tagUserInfoWithSID *v6; // edi
  DWORD v7; // eax
  void *v8; // eax
  void *v9; // ST14_4
  DWORD v10; // eax
  char result; // al
  enum _SID_NAME_USE nUse; // [esp+Ch] [ebp-4h]

  v5 = gpUserInfoWithSIDList;
  if ( gpUserInfoWithSIDList )
  {
    while ( !EqualSid(v5->pSID, pSID) )
    {
      v5 = v5->pNext;
      if ( !v5 )
        goto LABEL_4;
    }
    wcscpy_s(pszName, cbName, v5->szName);
    wcscpy_s(pszDomainName, cbDomainName, v5->szDomainName);
    result = 1;
  }
  else
  {
LABEL_4:
    if ( LookupAccountSidW(&gszNullString, pSID, pszName, &cbName, pszDomainName, &cbDomainName, &nUse) )
    {
      v6 = malloc(sizeof(tagUserInfoWithSID));
      v7 = GetLengthSid(pSID);
      v8 = malloc(v7);
      v6->pSID = v8;
      v9 = v8;
      v10 = GetLengthSid(pSID);
      CopySid(v10, v9, pSID);
      wcscpy_s(v6->szName, 0x104u, pszName);
      wcscpy_s(v6->szDomainName, 0x104u, pszDomainName);
      v6->pNext = gpUserInfoWithSIDList;
      result = 1;
      gpUserInfoWithSIDList = v6;
    }
    else
    {
      result = 0;
    }
  }
  return result;
}

//----- (00FC3E70) --------------------------------------------------------
int *__cdecl sub_FC3E70(PSYSTEM_LOGICAL_PROCESSOR_INFORMATION pSystemLogicalProcessorInfo, int dwCount, signed int dwProcessorID, signed int *pnValue1, int *pnValue2)
{
  int dwCount_1; // edi
  signed int v6; // ecx
  signed int dwProcessorCoreCount_1; // ebx
  unsigned int dwNumaNodeCount; // esi
  signed int dwProcessorCoreCount; // edx
  PUCHAR pRelationShip; // ecx
  int RelationShip; // eax
  int *result; // eax
  signed int NodeNumber; // [esp+Ch] [ebp-4h]

  dwCount_1 = dwCount;
  v6 = -1;
  dwProcessorCoreCount_1 = -1;
  NodeNumber = -1;
  dwNumaNodeCount = -1;
  dwProcessorCoreCount = 0;
  if ( !dwCount )
    goto __quit;
  pRelationShip = &pSystemLogicalProcessorInfo->Relationship;
  do
  {
    if ( (1 << dwProcessorID) & *(pRelationShip - 1) )
    {
      RelationShip = *pRelationShip;
      if ( *pRelationShip == RelationNumaNode )
      {
        NodeNumber = *(pRelationShip + 1);
      }
      else
      {
        if ( RelationShip )
          goto LABEL_10;
        // RelationProcessorCore
        dwProcessorCoreCount_1 = dwProcessorCoreCount;
      }
    }
    RelationShip = *pRelationShip;
    if ( !*pRelationShip )
    {
      // RelationProcessorCore
      ++dwProcessorCoreCount;
      goto __Next;
    }
LABEL_10:
    if ( RelationShip == RelationNumaNode )
      ++dwNumaNodeCount;
__Next:
    pRelationShip += sizeof(SYSTEM_LOGICAL_PROCESSOR_INFORMATION);
    --dwCount_1;
  }
  while ( dwCount_1 );
  if ( dwNumaNodeCount > 1 )
  {
    v6 = NodeNumber;
__quit:
    *pnValue1 = v6;
    result = pnValue2;
    *pnValue2 = 1;
    return result;
  }
  if ( dwProcessorCoreCount_1 == -1 )
  {
    *pnValue1 = dwProcessorID;
    result = pnValue2;
    *pnValue2 = -1;
  }
  else
  {
    *pnValue1 = dwProcessorCoreCount_1;
    result = pnValue2;
    *pnValue2 = 0;
  }
  return result;
}
// FC3ECC: CONTAINING_RECORD: no field 'PUCHAR' in struct 'SYSTEM_LOGICAL_PROCESSOR_INFORMATION' at 24

//----- (00FC3F20) --------------------------------------------------------
int __cdecl sub_FC3F20(_DWORD *a1, unsigned int a2, int a3)
{
  int v3; // edx
  _DWORD *v4; // esi
  unsigned int v5; // ecx
  int v7; // [esp+Ch] [ebp-4h]

  v3 = 0;
  v7 = 0;
  if ( a2 )
  {
    v4 = a1;
    while ( 2 )
    {
      v5 = 0;
      do
      {
        if ( !v4[1] )
        {
          if ( (1 << v5) & *v4 && a3 == v3 )
            return v5;
          ++v3;
        }
        ++v5;
      }
      while ( v5 < 0x20 );
      v4 += 6;
      if ( ++v7 < a2 )
        continue;
      break;
    }
  }
  return a3;
}

//----- (00FC3F80) --------------------------------------------------------
void __cdecl sub_FC3F80(wchar_t *Str, int a2, int a3, int a4, int a5)
{
  wchar_t *v5; // ecx
  wchar_t v6; // ax
  Data_t_bstr_t *v7; // esi
  const wchar_t *v8; // eax
  const wchar_t *v9; // eax
  wchar_t *v10; // eax
  EventItem *v11; // edi
  Data_t_bstr_t *v12; // eax
  const WCHAR *v13; // eax
  bool v14; // bl
  OLECHAR *v15; // eax
  HKEY v16; // ST20_4
  _bstr_t *v17; // eax
  Data_t_bstr_t *v18; // eax
  const WCHAR *v19; // eax
  bool v20; // bl
  WCHAR *v21; // eax
  wchar_t *v22; // edi
  WCHAR *v23; // ecx
  int v24; // edx
  WCHAR v25; // ax
  wchar_t *v26; // eax
  DWORD v27; // ST10_4
  DWORD cbData; // [esp+Ch] [ebp-2A8h]
  DWORD dwLen; // [esp+10h] [ebp-2A4h]
  _bstr_t v30; // [esp+14h] [ebp-2A0h]
  _bstr_t v31; // [esp+18h] [ebp-29Ch]
  HKEY phkResult; // [esp+1Ch] [ebp-298h]
  _bstr_t a1; // [esp+20h] [ebp-294h]
  EventItem v34; // [esp+24h] [ebp-290h]
  wchar_t Dst; // [esp+230h] [ebp-84h]

  v31.m_Data = a2;
  v5 = Str;
  dwLen = a4;
  v34.strEventTrace.m_Data = 0;
  do
  {
    v6 = *v5;
    ++v5;
  }
  while ( v6 );
  _wcsupr_s(Str, v5 - (Str + 1) + 1);
  _bstr_t::operator=(&v34, Str);
  v7 = v34.strEventTrace.m_Data;
  if ( v34.strEventTrace.m_Data )
    v8 = v34.strEventTrace.m_Data->m_wstr;
  else
    v8 = 0;
  if ( wcsstr(v8, L"/PROCESSID:") )
  {
    if ( v7 )
      v9 = v7->m_wstr;
    else
      v9 = 0;
    v10 = wcsstr(v9, L"/PROCESSID:");
    v11 = _bstr_t::_bstr_t(&a1, v10 + 11);
    if ( &v34 != v11 )
    {
      _bstr_t::_Free(&v34.strEventTrace);
      v7 = v11->strEventTrace.m_Data;
      v34.strEventTrace.m_Data = v7;
      if ( v7 )
        InterlockedIncrement(&v7->m_RefCount);
    }
    _bstr_t::_Free(&a1);
    v12 = _bstr_t::operator+(&a1, L"CLSID\\", &v34.strEventTrace)->m_Data;
    if ( v12 )
      v13 = v12->m_wstr;
    else
      v13 = 0;
    v14 = RegOpenKeyExW(HKEY_CLASSES_ROOT, v13, 0, 0x20019u, &phkResult) == 0;
    _bstr_t::_Free(&a1);
    if ( v14 )
    {
      cbData = 520;
      if ( !RegQueryValueExW(phkResult, 0, 0, 0, &v34.field_4, &cbData) )
      {
        v15 = _wcsdup(&v34.field_4);
        v16 = phkResult;
        v31.m_Data->m_wstr = v15;
        RegCloseKey(v16);
      }
      _bstr_t::_bstr_t(&a1, L"\\InProcServer32");
      v17 = _bstr_t::operator+(&v30, L"CLSID\\", &v34.strEventTrace);
      v18 = _bstr_t::operator+(&v17->m_Data, &v31, &a1)->m_Data;
      if ( v18 )
        v19 = v18->m_wstr;
      else
        v19 = 0;
      v20 = RegOpenKeyExW(HKEY_CLASSES_ROOT, v19, 0, 0x20019u, &phkResult) == 0;
      _bstr_t::_Free(&v31);
      _bstr_t::_Free(&v30);
      _bstr_t::_Free(&a1);
      if ( v20 )
      {
        v21 = sub_FC29E0(phkResult, 0);
        v22 = v21;
        if ( v21 )
        {
          v23 = v21;
          v24 = (v21 + 1);
          do
          {
            v25 = *v23;
            ++v23;
          }
          while ( v25 );
          _wcslwr_s(v22, ((v23 - v24) >> 1) + 1);
          v26 = _wcsdup(v22);
          v27 = dwLen;
          *a3 = v26;
          sub_FC43C0(v22, &Dst, 0x40u, v27, a5);
          free(v22);
        }
        RegCloseKey(phkResult);
      }
    }
  }
  if ( v7 && !InterlockedDecrement(&v7->m_RefCount) )
  {
    if ( v7->m_wstr )
    {
      SysFreeString(v7->m_wstr);
      v7->m_wstr = 0;
    }
    if ( v7->m_str )
    {
      j_j__free(v7->m_str);
      v7->m_str = 0;
    }
    j__free(v7);
  }
}

//----- (00FC4280) --------------------------------------------------------
wchar_t *__cdecl sub_FC4280(wchar_t *a1)
{
  rsize_t v1; // ebx
  wchar_t *v2; // esi
  wchar_t *v3; // eax
  wchar_t *result; // eax
  WCHAR Buffer; // [esp+Ch] [ebp-20Ch]
  wchar_t v6; // [esp+12h] [ebp-206h]

  GetSystemDirectoryW(&Buffer, 0x104u);
  v1 = wcslen(&Buffer) + wcslen(a1) + 19;
  v2 = malloc(2 * v1);
  *wcschr(&v6, 0x5Cu) = 0;
  if ( _wcsnicmp(a1, L"\\SystemRoot\\", 0xCu) )
  {
    if ( !wcsncmp(a1, L"\\??\\", 4u) )
    {
      wcscpy_s(v2, v1, a1 + 4);
      result = v2;
    }
    else
    {
      if ( *a1 == 92 )
        swprintf_s(v2, v1, L"%c:%s", Buffer, a1);
      else
        swprintf_s(v2, v1, L"%s\\System32\\Drivers\\%s", &Buffer, a1);
      result = v2;
    }
  }
  else
  {
    v3 = wcschr(a1 + 1, 0x5Cu);
    swprintf_s(v2, v1, L"%s%s", &Buffer, v3);
    result = v2;
  }
  return result;
}
// 103EF74: using guessed type wchar_t aCS[6];

//----- (00FC43C0) --------------------------------------------------------
DWORD __cdecl sub_FC43C0(LPCWSTR lptstrFilename, wchar_t *Dst, rsize_t SizeInWords, DWORD dwLen, int a5)
{
  _DWORD *v5; // edi
  DWORD v6; // eax
  int *v8; // esi
  const wchar_t *v9; // eax
  const wchar_t *v10; // eax
  DWORD dwHandle; // [esp+8h] [ebp-4h]
  DWORD dwLena; // [esp+20h] [ebp+14h]

  wcscpy_s(Dst, SizeInWords, &gszNullString);
  v5 = dwLen;
  *dwLen = 0;
  *a5 = 0;
  v6 = GetFileVersionInfoSizeW(lptstrFilename, &dwHandle);
  dwLena = v6;
  if ( !v6 )
    return GetLastError();
  v8 = malloc(v6);
  if ( GetFileVersionInfoW(lptstrFilename, 0, dwLena, v8) )
  {
    sub_FDBEC0(v8[13], v8[12], Dst, SizeInWords);
    v9 = sub_FDEAA0(v8, L"FileDescription");
    if ( v9 || (v9 = sub_FDEAA0(v8, L"ProductDescription")) != 0 )
      *v5 = _wcsdup(v9);
    v10 = sub_FDEAA0(v8, L"CompanyName");
    if ( v10 || (v10 = sub_FDEAA0(v8, L"Copyright")) != 0 )
      *a5 = _wcsdup(v10);
  }
  free(v8);
  return 0;
}
// 102D200: using guessed type wchar_t aFiledescriptio[16];
// 102D220: using guessed type wchar_t aCompanyname[12];
// 103EBB8: using guessed type wchar_t aProductdescrip[19];
// 103EBE0: using guessed type wchar_t aCopyright[10];

//----- (00FC44B0) --------------------------------------------------------
char __cdecl sub_FC44B0(int a1, char a2, int a3, u_long hostlong, int a5, wchar_t *Dst, size_t SizeInWords)
{
  unsigned int v7; // eax
  unsigned int v8; // ebx
  int v9; // ST28_4
  int v10; // ST24_4
  int v11; // ST20_4
  int v12; // ST1C_4
  int v13; // ST18_4
  int v14; // ST14_4
  int v15; // ST10_4
  u_short v16; // ax
  char result; // al
  _DWORD *v18; // eax
  __m128i *v19; // ecx

  v7 = htonl(hostlong);
  v8 = v7;
  if ( a2 )
  {
    if ( sub_FC2910(a1, v7, a5, Dst, SizeInWords) )
    {
      result = 1;
    }
    else
    {
      swprintf_s(Dst, SizeInWords, L"%d.%d.%d.%d", v8 >> 24, (v8 >> 16) & 0xFF, v8 >> 8, v8);
      EnterCriticalSection(&gLock2);
      v18 = dword_1069E7C;
      if ( dword_1069E7C )
      {
        while ( v18[67] != v8 )
        {
          v18 = v18[72];
          if ( !v18 )
            goto LABEL_11;
        }
      }
      else
      {
LABEL_11:
        v19 = malloc(0x124u);
        v19->m128i_i32[0] = a1;
        v19[16].m128i_i32[2] = hostlong;
        v19[16].m128i_i32[3] = v8;
        if ( a5 )
          _mm_storeu_si128(v19 + 17, _mm_loadu_si128(a5));
        v19[18].m128i_i32[0] = dword_1069E7C;
        dword_1069E7C = v19;
        _beginthread(sub_FC2A70, 0, v19);
      }
      LeaveCriticalSection(&gLock2);
      result = 0;
    }
  }
  else if ( a1 && a1 != 1 )
  {
    v9 = htons(*(a5 + 14));
    v10 = htons(*(a5 + 12));
    v11 = htons(*(a5 + 10));
    v12 = htons(*(a5 + 8));
    v13 = htons(*(a5 + 6));
    v14 = htons(*(a5 + 4));
    v15 = htons(*(a5 + 2));
    v16 = htons(*a5);
    swprintf_s(Dst, SizeInWords, L"[%x:%x:%x:%x:%x:%x:%x:%x]", v16, v15, v14, v13, v12, v11, v10, v9);
    result = 0;
  }
  else
  {
    swprintf_s(Dst, SizeInWords, L"%d.%d.%d.%d", v7 >> 24, (v7 >> 16) & 0xFF, v7 >> 8, v7);
    result = 0;
  }
  return result;
}

//----- (00FC4670) --------------------------------------------------------
wchar_t *__cdecl sub_FC4670(char a1, int port, char *proto, wchar_t *Dst, size_t SizeInWords)
{
  u_short v5; // ax
  struct servent *v6; // eax

  if ( a1 )
  {
    v6 = getservbyport(port, proto);
    if ( v6 )
    {
      swprintf_s(Dst, SizeInWords, L":%S", v6->s_name);
      return Dst;
    }
    v5 = htons(port);
  }
  else
  {
    v5 = htons(port);
  }
  swprintf_s(Dst, SizeInWords, L":%d", v5);
  return Dst;
}

//----- (00FC46D0) --------------------------------------------------------
wchar_t *__cdecl ProcessComment_Find(wchar_t *ProcessName)
{
  int index; // esi
  tagProcessComment *pHiddenProcesses; // eax
  int v3; // ecx
  bool found; // zf

  index = 0;
  if ( !ProcessName )
    return 0;
  pHiddenProcesses = gpProcessComments;
  if ( !gpProcessComments || !gpProcessComments->pszName )
    return 0;
  v3 = 0;
  while ( 1 )
  {
    found = _wcsicmp(ProcessName, pHiddenProcesses[v3].pszName) == 0;
    pHiddenProcesses = gpProcessComments;
    if ( found )
      break;
    v3 = ++index;
    if ( !gpProcessComments[index].pszName )
      return 0;
  }
  return _wcsdup(gpProcessComments[index].pszComment);
}

//----- (00FC4730) --------------------------------------------------------
wchar_t *__cdecl sub_FC4730(wchar_t *a1, int a2)
{
  wchar_t *result; // eax

  *a2 = 0;
  result = wcsstr(a1, L"-k");
  if ( result )
  {
    result = wcsstr(a1, L"-k") + 3;
    if ( result )
    {
      result = _wcsdup(result);
      *a2 = result;
    }
  }
  return result;
}

//----- (00FC4780) --------------------------------------------------------
WCHAR *__cdecl sub_FC4780(wchar_t *a1, LPCWSTR lpServiceName)
{
  WCHAR *v2; // ebx
  wchar_t *v3; // esi
  wchar_t *v4; // ecx
  wchar_t v5; // ax
  LPCWSTR v6; // ecx
  WCHAR v7; // ax
  wchar_t *v8; // esi
  WCHAR *result; // eax
  DWORD v10; // esi
  DWORD v11; // ST10_4
  SC_HANDLE v12; // esi
  DWORD v13; // eax
  DWORD v14; // edi
  DWORD v15; // eax
  DWORD v16; // edi
  WCHAR *v17; // esi
  LPWSTR FilePart; // [esp+Ch] [ebp-14h]
  struct _QUERY_SERVICE_CONFIGW *v19; // [esp+10h] [ebp-10h]
  DWORD pcbBytesNeeded; // [esp+14h] [ebp-Ch]
  SC_HANDLE hService; // [esp+18h] [ebp-8h]
  HKEY phkResult; // [esp+1Ch] [ebp-4h]

  v2 = 0;
  v3 = _wcsdup(a1);
  v4 = v3;
  do
  {
    v5 = *v4;
    ++v4;
  }
  while ( v5 );
  _wcsupr_s(v3, v4 - (v3 + 1) + 1);
  if ( wcsstr(v3, L"SVCHOST.EXE") )
  {
    v6 = lpServiceName;
    do
    {
      v7 = *v6;
      ++v6;
    }
    while ( v7 );
    hService = (v6 - (lpServiceName + 1) + 46);
    v8 = malloc(2 * hService);
    swprintf_s(v8, hService, L"System\\CurrentControlSet\\Services\\%s", lpServiceName);
    if ( !RegOpenKeyExW(HKEY_LOCAL_MACHINE, v8, 0, 0x20019u, &phkResult) )
    {
      v2 = sub_FC29E0(phkResult, L"ServiceDll");
      if ( !v2 )
      {
        RegCloseKey(phkResult);
        swprintf_s(v8, hService, L"System\\CurrentControlSet\\Services\\%s\\Parameters", lpServiceName);
        if ( !RegOpenKeyExW(HKEY_LOCAL_MACHINE, v8, 0, 0x20019u, &phkResult) )
        {
          v2 = sub_FC29E0(phkResult, L"ServiceDll");
          RegCloseKey(phkResult);
        }
      }
    }
  }
  else
  {
    result = OpenServiceW(ghSCManagerHandle, lpServiceName, 5u);
    hService = result;
    if ( !result )
      return result;
    QueryServiceConfigW(result, 0, 0, &pcbBytesNeeded);
    v10 = pcbBytesNeeded;
    v19 = malloc(pcbBytesNeeded);
    v11 = v10;
    v12 = hService;
    QueryServiceConfigW(hService, v19, v11, &pcbBytesNeeded);
    CloseServiceHandle(v12);
    v8 = v19;
    v13 = ExpandEnvironmentStringsW(v19->lpBinaryPathName, 0, 0);
    v14 = v13;
    if ( v13 )
    {
      v2 = malloc(2 * v13);
      ExpandEnvironmentStringsW(v19->lpBinaryPathName, v2, v14);
    }
  }
  free(v8);
  if ( GetFileAttributesW(v2) == -1 )
  {
    v15 = SearchPathW(0, v2, 0, 0, 0, 0);
    v16 = v15;
    if ( v15 )
    {
      v17 = malloc(2 * v15);
      SearchPathW(0, v2, 0, v16, v17, &FilePart);
      _wcslwr_s(v17, v16);
      free(v2);
      v2 = v17;
    }
  }
  return v2;
}

//----- (00FC4990) --------------------------------------------------------
wchar_t *__cdecl sub_FC4990(int a1)
{
  wchar_t *v1; // ebx
  Data_t_bstr_t *v2; // esi
  LPVOID v3; // ecx
  int v4; // edx
  int v5; // edi
  int v6; // ecx
  LONG i; // ebx
  __m128i v8; // xmm0
  _bstr_t v9; // edx
  int v10; // edi
  _bstr_t *v11; // eax
  _bstr_t *v12; // eax
  _bstr_t *v13; // eax
  _bstr_t *v14; // eax
  _bstr_t *v15; // eax
  _bstr_t *v16; // eax
  _bstr_t *v17; // eax
  int v19; // [esp-40h] [ebp-FCh]
  int v20; // [esp-3Ch] [ebp-F8h]
  int v21; // [esp-38h] [ebp-F4h]
  int v22; // [esp-34h] [ebp-F0h]
  int v23; // [esp-30h] [ebp-ECh]
  int v24; // [esp-2Ch] [ebp-E8h]
  int v25; // [esp-28h] [ebp-E4h]
  int v26; // [esp-24h] [ebp-E0h]
  int v27; // [esp-20h] [ebp-DCh]
  int v28; // [esp-1Ch] [ebp-D8h]
  int v29; // [esp-18h] [ebp-D4h]
  int v30; // [esp-14h] [ebp-D0h]
  int v31; // [esp-10h] [ebp-CCh]
  LPVOID v32; // [esp-Ch] [ebp-C8h]
  _bstr_t *v33; // [esp-8h] [ebp-C4h]
  int *v34; // [esp-4h] [ebp-C0h]
  __int128 v35; // [esp+Ch] [ebp-B0h]
  __int128 v36; // [esp+1Ch] [ebp-A0h]
  __int128 v37; // [esp+2Ch] [ebp-90h]
  VARIANTARG v38; // [esp+3Ch] [ebp-80h]
  VARIANTARG v39; // [esp+4Ch] [ebp-70h]
  VARIANTARG pvarg; // [esp+5Ch] [ebp-60h]
  VARIANTARG v41; // [esp+6Ch] [ebp-50h]
  OLECHAR *psz; // [esp+7Ch] [ebp-40h]
  _bstr_t a1a; // [esp+80h] [ebp-3Ch]
  _bstr_t v44; // [esp+84h] [ebp-38h]
  int v45; // [esp+88h] [ebp-34h]
  _bstr_t v46; // [esp+8Ch] [ebp-30h]
  OLECHAR *v47; // [esp+90h] [ebp-2Ch]
  _bstr_t v48; // [esp+94h] [ebp-28h]
  _bstr_t v49; // [esp+98h] [ebp-24h]
  _bstr_t v50; // [esp+9Ch] [ebp-20h]
  _bstr_t v51; // [esp+A0h] [ebp-1Ch]
  int v52; // [esp+A4h] [ebp-18h]
  _bstr_t v53; // [esp+A8h] [ebp-14h]
  _bstr_t *v54; // [esp+ACh] [ebp-10h]
  LPVOID ppv; // [esp+B0h] [ebp-Ch]
  _bstr_t *v56; // [esp+B4h] [ebp-8h]
  _bstr_t v57; // [esp+B8h] [ebp-4h]

  v1 = 0;
  v2 = 0;
  ppv = 0;
  v57.m_Data = 0;
  if ( CoCreateInstance(&stru_103F100, 0, 1u, &CLSID_ITaskService, &ppv) >= 0 )
  {
    VariantInit(&pvarg);
    _mm_storeu_si128(&v37, _mm_loadu_si128(&pvarg));
    VariantInit(&v39);
    _mm_storeu_si128(&v36, _mm_loadu_si128(&v39));
    VariantInit(&v38);
    _mm_storeu_si128(&v35, _mm_loadu_si128(&v38));
    VariantInit(&v41);
    v3 = ppv;
    v4 = *ppv;
    _mm_storeu_si128(&v31, _mm_loadu_si128(&v37));
    _mm_storeu_si128(&v27, _mm_loadu_si128(&v36));
    _mm_storeu_si128(&v23, _mm_loadu_si128(&v35));
    _mm_storeu_si128(&v19, _mm_loadu_si128(&v41));
    v5 = (*(v4 + 40))(v3, v19, v20, v21, v22, v23, v24, v25, v26, v27, v28, v29, v30, v31, v32, v33, v34);
    VariantClear(&v41);
    VariantClear(&v38);
    VariantClear(&v39);
    VariantClear(&pvarg);
    if ( v5 >= 0 )
    {
      v34 = &v56;
      v56 = 0;
      v33 = 1;
      v6 = *ppv;
      v32 = ppv;
      if ( (*(v6 + 32))(ppv, 1, &v56) >= 0 )
      {
        v34 = &v52;
        v33 = v56;
        (v56->m_Data[2].m_str)(v56, &v52);
        for ( i = 1; i < v52 + 1; ++i )
        {
          v41.vt = 3;
          v34 = &v54;
          v41.lVal = i;
          v8 = _mm_loadu_si128(&v41);
          v9.m_Data = v56->m_Data;
          v29 = v56;
          _mm_storeu_si128(&v30, v8);
          v10 = (v9.m_Data[2].m_RefCount)(v29, v30, v31, v32, v33, v34);
          VariantClear(&v41);
          if ( v10 >= 0 )
          {
            v34 = &v45;
            v33 = v54;
            if ( (v54->m_Data[4].m_RefCount)(v54, &v45) >= 0 && v45 == a1 )
            {
              v34 = &psz;
              v33 = v54;
              if ( (v54->m_Data[3].m_RefCount)(v54, &psz) >= 0 )
              {
                if ( v2 )
                {
                  if ( v2->m_wstr )
                  {
                    v34 = v2->m_wstr;
                    if ( SysStringLen(v34) )
                    {
                      v11 = _bstr_t::_bstr_t(&v48, L"\n");
                      v12 = _bstr_t::operator+(&v57.m_Data, &v44, v11);
                      sub_F73A50(&v57, v12);
                      _bstr_t::_Free(&v44);
                      _bstr_t::_Free(&v48);
                    }
                  }
                }
                v13 = _bstr_t::_bstr_t(&v51, psz);
                v14 = _bstr_t::operator+(&a1a, L"   ", v13);
                _bstr_t::operator+=(&v57, v14);
                _bstr_t::_Free(&a1a);
                _bstr_t::_Free(&v51);
                v34 = &v47;
                v33 = v54;
                if ( (v54->m_Data[3].m_wstr)(v54, &v47) >= 0 )
                {
                  _bstr_t::_bstr_t(&v53, L"]");
                  v34 = &v53;
                  v33 = &v46;
                  v15 = _bstr_t::_bstr_t(&v49, v47);
                  v16 = _bstr_t::operator+(&v50, L" [", v15);
                  v17 = _bstr_t::operator+(&v16->m_Data, v33, v34);
                  _bstr_t::operator+=(&v57, v17);
                  _bstr_t::_Free(&v46);
                  _bstr_t::_Free(&v50);
                  _bstr_t::_Free(&v49);
                  _bstr_t::_Free(&v53);
                }
                v2 = v57.m_Data;
              }
            }
            v34 = v54;
            (v54->m_Data->m_RefCount)(v54);
          }
        }
        v34 = v56;
        (v56->m_Data->m_RefCount)(v56);
        v1 = 0;
      }
    }
    v34 = ppv;
    (*(*ppv + 8))(ppv);
    if ( v2 )
    {
      if ( v2->m_wstr )
      {
        v34 = v2->m_wstr;
        if ( SysStringLen(v34) )
        {
          v34 = v2->m_wstr;
          v1 = _wcsdup(v34);
        }
      }
      if ( !InterlockedDecrement(&v2->m_RefCount) )
      {
        if ( v2->m_wstr )
        {
          SysFreeString(v2->m_wstr);
          v2->m_wstr = 0;
        }
        if ( v2->m_str )
        {
          j_j__free(v2->m_str);
          v2->m_str = 0;
        }
        j__free(v2);
      }
    }
  }
  return v1;
}

//----- (00FC4CC0) --------------------------------------------------------
BOOL __cdecl DrawHungWindow(HWND hWnd)
{
  int nWidth; // esi
  HDC hDCWindow; // eax
  HDC hDCWindow_1; // edi
  HDC hDCWindow_2; // ST24_4
  int hDC; // ebx
  HPEN hPen; // edi
  HGDIOBJ hBrush; // eax
  struct tagRECT rcWindow; // [esp+14h] [ebp-14h]

  nWidth = 3 * GetSystemMetrics(SM_CXBORDER);
  hDCWindow = GetWindowDC(hWnd);
  hDCWindow_1 = hDCWindow;
  hDCWindow_2 = hDCWindow;
  GetWindowRect(hWnd, &rcWindow);
  hDC = SaveDC(hDCWindow_1);
  SetROP2(hDCWindow_1, R2_NOT);
  hPen = CreatePen(PS_INSIDEFRAME, nWidth, 0);
  SelectObject(hDCWindow_2, hPen);
  hBrush = GetStockObject(NULL_BRUSH);
  SelectObject(hDCWindow_2, hBrush);
  Rectangle(hDCWindow_2, 0, 0, rcWindow.right - rcWindow.left, rcWindow.bottom - rcWindow.top);
  RestoreDC(hDCWindow_2, hDC);
  ReleaseDC(hWnd, hDCWindow_2);
  return DeleteObject(hPen);
}

//----- (00FC4D80) --------------------------------------------------------
bool __usercall IsProcessExplorerRunAtStartup@<al>(int a1@<ebp>, _DWORD *a2@<edi>)
{
  _DWORD *v2; // ecx
  int v3; // edx
  int v4; // edi
  _DWORD *v5; // eax
  OLECHAR *v6; // edx
  int v7; // esi
  OLECHAR *v8; // eax
  BSTR **v9; // eax
  BSTR v10; // edx
  LSTATUS v11; // esi
  int v13; // [esp-310h] [ebp-31Ch]
  int v14; // [esp-30Ch] [ebp-318h]
  int v15; // [esp-308h] [ebp-314h]
  int v16; // [esp-304h] [ebp-310h]
  int v17; // [esp-300h] [ebp-30Ch]
  int v18; // [esp-2FCh] [ebp-308h]
  int v19; // [esp-2F8h] [ebp-304h]
  int v20; // [esp-2F4h] [ebp-300h]
  int v21; // [esp-2F0h] [ebp-2FCh]
  int v22; // [esp-2ECh] [ebp-2F8h]
  int v23; // [esp-2E8h] [ebp-2F4h]
  int v24; // [esp-2E4h] [ebp-2F0h]
  int v25; // [esp-2E0h] [ebp-2ECh]
  int v26; // [esp-2DCh] [ebp-2E8h]
  _DWORD *v27; // [esp-2D8h] [ebp-2E4h]
  BSTR v28; // [esp-2D4h] [ebp-2E0h]
  _DWORD *v29; // [esp-2D0h] [ebp-2DCh]
  int v30; // [esp-2C0h] [ebp-2CCh]
  int v31; // [esp-2B0h] [ebp-2BCh]
  int v32; // [esp-2A0h] [ebp-2ACh]
  int v33; // [esp-290h] [ebp-29Ch]
  int v34; // [esp-280h] [ebp-28Ch]
  int v35; // [esp-270h] [ebp-27Ch]
  int v36; // [esp-260h] [ebp-26Ch]
  int v37; // [esp-244h] [ebp-250h]
  signed int v38; // [esp-240h] [ebp-24Ch]
  _DWORD *v39; // [esp-23Ch] [ebp-248h]
  _DWORD *v40; // [esp-238h] [ebp-244h]
  HKEY v41; // [esp-234h] [ebp-240h]
  int v42; // [esp-230h] [ebp-23Ch]
  _DWORD *v43; // [esp-22Ch] [ebp-238h]
  OLECHAR *v44; // [esp-228h] [ebp-234h]
  unsigned int v45; // [esp-214h] [ebp-220h]
  int v46; // [esp-210h] [ebp-21Ch]
  unsigned int v47; // [esp-4h] [ebp-10h]
  int v48; // [esp+0h] [ebp-Ch]
  int v49; // [esp+4h] [ebp-8h]
  int retaddr; // [esp+Ch] [ebp+0h]

  v48 = a1;
  v49 = retaddr;
  v47 = &v48 ^ __security_cookie;
  v29 = a2;
  if ( gdwVersion < 1 )
  {
    v11 = RegOpenKeyExW(HKEY_CURRENT_USER, L"Software\\Microsoft\\Windows\\CurrentVersion\\Run", 0, 1u, &v41);
    if ( !v11 )
    {
      v38 = 520;
      v11 = RegQueryValueExW(v41, L"Process Explorer", 0, &v37, &v46, &v38);
      RegCloseKey(v41);
    }
    return v11 == 0;
  }
  sub_FC26B0(&v44);
  v43 = 0;
  if ( CoCreateInstance(&stru_10478CC, 0, 1u, &riid, &v43) >= 0 )
  {
    VariantInit(&v35);
    _mm_store_si128(&v31, _mm_load_si128(&v35));
    VariantInit(&v34);
    _mm_store_si128(&v32, _mm_load_si128(&v34));
    VariantInit(&v33);
    _mm_store_si128(&v30, _mm_load_si128(&v33));
    VariantInit(&v36);
    v2 = v43;
    v3 = *v43;
    _mm_storeu_si128(&v25, _mm_load_si128(&v31));
    _mm_storeu_si128(&v21, _mm_load_si128(&v32));
    _mm_storeu_si128(&v17, _mm_load_si128(&v30));
    _mm_storeu_si128(&v13, _mm_loadu_si128(&v36));
    v4 = (*(v3 + 40))(v2, v13, v14, v15, v16, v17, v18, v19, v20, v21, v22, v23, v24, v25, v26, v27, v28, v29);
    VariantClear(&v36);
    VariantClear(&v33);
    VariantClear(&v34);
    VariantClear(&v35);
    if ( v4 >= 0 )
    {
      v40 = 0;
      v5 = *_bstr_t::_bstr_t(&v42, L"\\");
      v6 = (v5 ? *v5 : 0);
      v29 = &v40;
      v28 = v6;
      v27 = v43;
      v7 = (*(*v43 + 28))(v43, v6, &v40);
      _bstr_t::_Free(&v42);
      if ( v7 >= 0 )
      {
        v8 = &v44;
        if ( v45 >= 8 )
          v8 = v44;
        v9 = _bstr_t::_bstr_t(&v42, v8);
        if ( *v9 )
          v10 = **v9;
        else
          v10 = 0;
        v29 = &v39;
        v28 = v10;
        v27 = v40;
        v11 = (*(*v40 + 52))(v40, v10, &v39);
        _bstr_t::_Free(&v42);
        if ( !v11 )
        {
          v29 = v39;
          (*(*v39 + 8))(v39);
        }
        v29 = v43;
        (*(*v43 + 8))(v43);
        sub_F73820(&v44);
        return v11 == 0;
      }
    }
    v29 = v43;
    (*(*v43 + 8))(v43);
  }
  if ( v45 >= 8 )
    j__free(v44);
  return 0;
}
// FC4D80: could not find valid save-restore pair for ebp
// FC4D80: could not find valid save-restore pair for edi
// 1064E54: using guessed type int gdwVersion;

//----- (00FC5050) --------------------------------------------------------
bool IsXPDll()
{
  HMODULE v0; // eax
  FARPROC DllGetVersion; // eax
  DLLVERSIONINFO VersionInfo; // [esp+0h] [ebp-18h]

  v0 = LoadLibraryW(L"comctl32.dll");
  DllGetVersion = GetProcAddress(v0, "DllGetVersion");
  if ( !DllGetVersion )
    return 0;
  VersionInfo.cbSize = sizeof(DLLVERSIONINFO);
  VersionInfo.dwMajorVersion = 0;
  *&VersionInfo.dwMinorVersion = 0i64;
  VersionInfo.dwPlatformID = 0;
  return (DllGetVersion)(&VersionInfo) >= 0 && VersionInfo.dwMajorVersion >= 6;// Windows XP
}

//----- (00FC50E0) --------------------------------------------------------
char __cdecl sub_FC50E0(wchar_t *a1)
{
  WCHAR **v1; // eax
  int v2; // esi
  int v3; // eax

  v1 = gpHiddenProcesses;
  if ( !*gpHiddenProcesses )
    return 0;
  v2 = 0;
  while ( 1 )
  {
    v3 = _wcsicmp(v1[v2], a1);
    ++v2;
    if ( !v3 )
      break;
    v1 = gpHiddenProcesses;
    if ( !gpHiddenProcesses[v2] )
      return 0;
  }
  return 1;
}

//----- (00FC5120) --------------------------------------------------------
char IsPAEEnabled()
{
  HMODULE v0; // eax
  int (__stdcall *IsProcessorFeaturePresent)(); // eax
  char result; // al

  v0 = GetModuleHandleW(L"Kernel32.dll");
  IsProcessorFeaturePresent = GetProcAddress(v0, "IsProcessorFeaturePresent");
  if ( IsProcessorFeaturePresent )
    result = IsProcessorFeaturePresent();
  else
    result = 0;
  return result;
}

//----- (00FC5150) --------------------------------------------------------
char CanReplaceTaskManager()
{
  wchar_t *v0; // esi
  wchar_t *v1; // eax
  int v2; // eax
  DWORD cbData; // [esp+4h] [ebp-41Ch]
  HKEY phkResult; // [esp+8h] [ebp-418h]
  wchar_t Data[260]; // [esp+Ch] [ebp-414h]
  wchar_t Dst; // [esp+214h] [ebp-20Ch]
  WCHAR Filename; // [esp+216h] [ebp-20Ah]

  if ( !RegOpenKeyW(
          HKEY_LOCAL_MACHINE,
          L"Software\\Microsoft\\Windows NT\\CurrentVersion\\Image File Execution Options\\taskmgr.exe",
          &phkResult) )
  {
    cbData = 520;
    if ( !RegQueryValueExW(phkResult, L"Debugger", 0, 0, Data, &cbData) )
    {
      _wcsupr_s(Data, 0x104u);
      GetModuleFileNameW(0, &Filename, 0x102u);
      Dst = 34;
      wcscat_s(&Dst, 0x104u, L"\"");
      _wcsupr_s(&Dst, 0x104u);
      v0 = wcsrchr(Data, 0x5Cu);
      v1 = wcsrchr(&Dst, 0x5Cu);
      if ( v1 )
      {
        if ( v0 )
        {
          v2 = wcscmp(v0, v1);
          if ( v2 )
            v2 = -(v2 < 0) | 1;
          if ( !v2 )
          {
            RegCloseKey(phkResult);
            return 1;
          }
        }
      }
    }
    RegCloseKey(phkResult);
  }
  return 0;
}

//----- (00FC52B0) --------------------------------------------------------
int __usercall IsWinServer@<eax>(int a1@<ebx>, int a2@<esi>)
{
  DWORD dwVersion; // eax
  HMODULE v4; // eax
  ULONGLONG *VerSetConditionMask; // eax
  HMODULE v6; // eax
  BOOL VerifyVersionInfoA; // esi
  _OSVERSIONINFOEXA VerInfo; // [esp+4h] [ebp-A0h]

  dwVersion = GetVersion();
  if ( (dwVersion & 0x80000000) != 0 )
    return 0;
  if ( dwVersion <= 4u )
    return IsServer(L"Terminal Server");
  if ( dwVersion >= 5u && dwVersion >> 16 > 0x893 )
    return 1;
  v4 = GetModuleHandleW(L"ntdll.dll");
  if ( !v4 )
    return 0;
  VerSetConditionMask = GetProcAddress(v4, "VerSetConditionMask");
  if ( !VerSetConditionMask )
    return 0;
  // NTSYSAPI ULONGLONG VerSetConditionMask(
  //   ULONGLONG ConditionMask,
  //   DWORD     TypeMask,
  //   BYTE      Condition
  // );
  (VerSetConditionMask)(0, 0, VER_SUITENAME, VER_AND, a1, a2);
  v6 = GetModuleHandleW(L"KERNEL32.DLL");
  if ( !v6 )
    return 0;
  VerifyVersionInfoA = GetProcAddress(v6, "VerifyVersionInfoA");
  if ( !VerifyVersionInfoA )
    return 0;
  memset(&VerInfo, 0, sizeof(_OSVERSIONINFOEXA));
  VerInfo.dwOSVersionInfoSize = sizeof(_OSVERSIONINFOEXA);
  VerInfo.wReserved[0] = VER_SERVICEPACKMINOR;
  // BOOL VerifyVersionInfoA(
  //   LPOSVERSIONINFOEXA lpVersionInformation,
  //   DWORD              dwTypeMask,
  //   DWORDLONG          dwlConditionMask
  // );
  return (VerifyVersionInfoA)(&VerInfo, VER_SUITENAME);
}
// FC52B0: could not find valid save-restore pair for esi

//----- (00FC53F0) --------------------------------------------------------
BOOL __cdecl CMainWnd::Hide(HWND hWnd)
{
  BOOL result; // eax

  result = ShowWindow(hWnd, 0);
  gbMainWndMinimized = 1;
  return result;
}
// 106A389: using guessed type char gbMainWndMinimized;

//----- (00FC5420) --------------------------------------------------------
char *__cdecl Fake_GetLogicalProcessorInformation(PDWORD pdwCount)
{
  PDWORD v1; // esi
  DWORD_PTR (__stdcall *SetThreadAffinityMask)(HANDLE, DWORD_PTR); // ebx
  DWORD_PTR dwMask; // edi
  HANDLE v4; // eax
  int meax; // eax
  char v15; // cl
  unsigned int v16; // esi
  unsigned int i; // eax
  DWORD v18; // eax
  int v19; // edx
  DWORD v20; // ecx
  int v21; // ebx
  bool v22; // sf
  unsigned __int8 v23; // of
  HANDLE v24; // eax
  ULONG_PTR v25; // ST08_4
  HANDLE v26; // eax
  DWORD v27; // esi
  char *v28; // eax
  DWORD v29; // edx
  char *v30; // edi
  int v31; // ecx
  int v32; // eax
  int dwIndex; // [esp+20h] [ebp-118h]
  ULONG_PTR ProcessAffinityMask; // [esp+24h] [ebp-114h]
  int dwMaskBuf[64]; // [esp+28h] [ebp-110h]
  int mebx; // [esp+128h] [ebp-10h]
  int medx; // [esp+12Ch] [ebp-Ch]
  int mecx; // [esp+130h] [ebp-8h]

  // https://blog.csdn.net/linyanhou/article/details/14109095
  v1 = pdwCount;
  *pdwCount = 0;
  dwMaskBuf[0] = 0;
  memset(&dwMaskBuf[1], 0, 0xFCu);
  SetThreadAffinityMask = ::SetThreadAffinityMask;
  dwIndex = 0;
  dwMask = 1;
  do
  {
    v4 = GetCurrentThread();
    if ( !SetThreadAffinityMask(v4, dwMask) )
      break;
    Sleep(0);
    meax = 0;
    __asm { cpuid }
    mebx = _EBX;
    medx = _EDX;
    mecx = _ECX;
    _EAX = 1;
    __asm { cpuid }
    if ( ((_EAX & 0xF00) == 0xF00 || _EAX & 0xF00000)
      && mebx == 'uneG'
      && medx == 'Ieni'
      && mecx == 'letn'
      && (_EDX >> 28) & 1 )
    {
      v15 = 0;
      v16 = (_EBX >> 16) & 0xFF;
      for ( i = 1; i < v16; ++v15 )
        i *= 2;
      v1 = pdwCount;
      v18 = 0;
      v19 = _EBX >> 24 >> v15;
      v20 = *pdwCount;
      if ( *pdwCount )
      {
        do
        {
          if ( v19 == dwMaskBuf[2 * v18] )
            break;
          ++v18;
        }
        while ( v18 < v20 );
      }
      if ( v18 >= v20 )
        *pdwCount = v20 + 1;
      dwMaskBuf[2 * v18 + 1] |= dwMask;
      dwMaskBuf[2 * v18] = v19;
    }
    v21 = dwIndex + 1;
    dwMask = __ROL4__(dwMask, 1);
    dwIndex = v21;
    v23 = __OFSUB__(v21, 32);
    v22 = v21 - 32 < 0;
    SetThreadAffinityMask = ::SetThreadAffinityMask;
  }
  while ( v22 ^ v23 );
  ProcessAffinityMask = -1;
  v24 = GetCurrentProcess();
  GetProcessAffinityMask(v24, &ProcessAffinityMask, &ProcessAffinityMask);
  v25 = ProcessAffinityMask;
  v26 = GetCurrentThread();
  SetThreadAffinityMask(v26, v25);
  v27 = *v1;
  if ( !v27 )
    return 0;
  v28 = malloc(24 * v27);
  v29 = 0;
  v30 = v28;
  if ( v27 )
  {
    v31 = (v28 + 8);
    do
    {
      v32 = dwMaskBuf[2 * v29 + 1];
      v31 += 24;
      ++v29;
      *(v31 - 28) = 0;
      *(v31 - 24) = 1;
      *(v31 - 32) = v32;
    }
    while ( v29 < v27 );
  }
  return v30;
}

//----- (00FC5670) --------------------------------------------------------
BOOL __cdecl PE_SetWindowPlacement(HWND hWnd, POINT pt)
{
  LONG left; // esi
  int top; // edi
  int v4; // eax
  LONG bottom; // ecx
  int v6; // eax
  int v7; // eax
  WINDOWPLACEMENT wp; // [esp+10h] [ebp-40h]
  struct tagRECT rcClient; // [esp+3Ch] [ebp-14h]

  left = pt.x;
  top = pt.y;
  if ( pt.x < 0 )
    left = 10;
  if ( pt.y < 0 )
    top = 10;
  GetClientRect(hWnd, &rcClient);
  if ( GetSystemMetrics(SM_CXVIRTUALSCREEN) )
  {
    if ( GetSystemMetrics(SM_CXVIRTUALSCREEN) - rcClient.right < left )
      left = GetSystemMetrics(SM_CXVIRTUALSCREEN) - rcClient.right;
    v4 = GetSystemMetrics(SM_CYVIRTUALSCREEN);
    bottom = rcClient.bottom;
    if ( v4 - rcClient.bottom < top )
    {
      v6 = GetSystemMetrics(SM_CYVIRTUALSCREEN);
LABEL_14:
      bottom = rcClient.bottom;
      top = v6 - rcClient.bottom;
      goto LABEL_15;
    }
  }
  else
  {
    if ( GetSystemMetrics(SM_CXSCREEN) - rcClient.right < left )
      left = GetSystemMetrics(SM_CXSCREEN) - rcClient.right;
    v7 = GetSystemMetrics(SM_CYSCREEN);
    bottom = rcClient.bottom;
    if ( v7 - rcClient.bottom < top )
    {
      v6 = GetSystemMetrics(SM_CYSCREEN);
      goto LABEL_14;
    }
  }
LABEL_15:
  wp.flags = WPF_SETMINPOSITION;
  wp.rcNormalPosition.right = left + rcClient.right;
  wp.rcNormalPosition.bottom = bottom + top;
  wp.rcNormalPosition.left = left;
  wp.rcNormalPosition.top = top;
  return SetWindowPlacement(hWnd, &wp);
}

//----- (00FC5750) --------------------------------------------------------
char __cdecl LaunchWebBrowser(HWND hWnd, bool flags, LPCWSTR lpszURL)
{
  LPCWSTR v3; // edi
  LSTATUS v4; // esi
  wchar_t *pszParameters; // esi
  wchar_t *v6; // eax
  const wchar_t *v7; // ebx
  wchar_t *v8; // eax
  int v9; // esi
  WCHAR v10; // ax
  char result; // al
  OLECHAR *pszFile; // [esp+Ch] [ebp-224h]
  wchar_t *Dst; // [esp+10h] [ebp-220h]
  HWND hWnda; // [esp+14h] [ebp-21Ch]
  unsigned int SizeInWords; // [esp+18h] [ebp-218h]
  DWORD cbData; // [esp+1Ch] [ebp-214h]
  HKEY phkResult; // [esp+20h] [ebp-210h]
  BYTE Data[2]; // [esp+24h] [ebp-20Ch]
  wchar_t v19; // [esp+26h] [ebp-20Ah]

  v3 = lpszURL;
  v4 = RegOpenKeyExW(
         HKEY_CURRENT_USER,
         L"Software\\Microsoft\\Windows\\Shell\\Associations\\UrlAssociations\\http\\UserChoice",
         0,
         0x20019u,
         &phkResult);
  if ( !v4 )
  {
    cbData = 260;
    v4 = RegQueryValueExW(phkResult, L"ProgId", 0, 0, Data, &cbData);
    RegCloseKey(phkResult);
    if ( !v4 )
    {
      wcscat_s(Data, 0x104u, L"\\shell\\open\\command");
      if ( RegOpenKeyExW(HKEY_CLASSES_ROOT, Data, 0, 0x20019u, &phkResult) )
        goto LABEL_22;
      cbData = 260;
      v4 = RegQueryValueExW(phkResult, 0, 0, 0, Data, &cbData);
      RegCloseKey(phkResult);
      if ( !v4 )
        goto LABEL_22;
    }
  }
  if ( !RegOpenKeyExW(HKEY_CLASSES_ROOT, L"http\\shell\\open\\command", 0, 0x20019u, &phkResult) )
  {
    cbData = 260;
    v4 = RegQueryValueExW(phkResult, 0, 0, 0, Data, &cbData);
    RegCloseKey(phkResult);
  }
  if ( v4 )
  {
    MessageBoxW(hWnd, L"No web browser is configured.", L"Process Explorer Error", 0x10u);
    result = 0;
  }
  else
  {
LABEL_22:
    SizeInWords = wcslen(Data) + wcslen(lpszURL) + 6;
    pszParameters = malloc(2 * SizeInWords);
    Dst = pszParameters;
    pszFile = Data;
    if ( *Data == 34 )
    {
      strcpy(Data, "\"");
      pszFile = &v19;
      v6 = wcschr(&v19, '"');
    }
    else
    {
      v6 = wcschr(Data, ' ');
    }
    v7 = v6;
    if ( v6 )
    {
      *v6 = 0;
      v7 = v6 + 1;
    }
    if ( flags )
    {
      v8 = wcsstr(Data, L"\"%1\"");
      hWnda = v8;
      if ( v8 )
      {
        v9 = v8 - v7;
        wcsncpy_s(Dst, SizeInWords, v7, v9 + 1);
        wcscpy_s(&Dst[v9 + 1], SizeInWords - v9 - 1, L"? ");
        pszParameters = Dst;
        wcscat_s(Dst, SizeInWords, lpszURL);
        wcscat_s(Dst, SizeInWords, hWnda + 3);
      }
      else
      {
        swprintf_s(pszParameters, SizeInWords, L"\"? %s\"", lpszURL);
      }
    }
    else
    {
      do
      {
        v10 = *v3;
        ++v3;
        *(v3 + pszParameters - lpszURL - 2) = v10;
      }
      while ( v10 );
    }
    PE_ShellExecute(pszFile, pszParameters, 0);
    free(pszParameters);
    result = 1;
  }
  return result;
}

//----- (00FC5A60) --------------------------------------------------------
int __cdecl sub_FC5A60(const void *a1, const void *a2)
{
  return _stricmp(*a1, *a2);
}

//----- (00FC5A80) --------------------------------------------------------
LSTATUS LoadHiddenProcessesFromRegistry()
{
  WCHAR **v0; // eax
  LSTATUS result; // eax
  BYTE *v2; // ebx
  const wchar_t *v3; // esi
  int v4; // edi
  WCHAR *v5; // eax
  WCHAR v6; // cx
  int v7; // [esp+0h] [ebp-10h]
  DWORD Type; // [esp+4h] [ebp-Ch]
  HKEY hKey; // [esp+8h] [ebp-8h]
  DWORD cbData; // [esp+Ch] [ebp-4h]

  cbData = 0;
  v0 = malloc(4u);
  gpHiddenProcesses = v0;
  *v0 = 0;
  result = RegOpenKeyExW(HKEY_CURRENT_USER, L"Software\\Sysinternals\\Process Explorer", 0, KEY_READ, &hKey);
  if ( !result )
  {
    if ( !RegQueryValueExW(hKey, L"HiddenProcs", 0, &Type, 0, &cbData) )
    {
      v2 = malloc(cbData);
      RegQueryValueExW(hKey, L"HiddenProcs", 0, &Type, v2, &cbData);
      v3 = v2;
      if ( v2 < &v2[2 * cbData] )
      {
        v4 = 0;
        do
        {
          if ( !*v3 )
            break;
          gpHiddenProcesses = realloc(gpHiddenProcesses, v4 * 4 + 8);
          gpHiddenProcesses[v4] = _wcsdup(v3);
          v5 = gpHiddenProcesses[v4];
          v7 = (v5 + 1);
          do
          {
            v6 = *v5;
            ++v5;
          }
          while ( v6 );
          gpHiddenProcesses[v4 + 1] = 0;
          ++v4;
          v3 += ((v5 - v7) >> 1) + 1;
        }
        while ( v3 < &v2[2 * cbData] );
      }
    }
    result = RegCloseKey(hKey);
  }
  return result;
}

//----- (00FC5BA0) --------------------------------------------------------
LSTATUS LoadProcessCommentsFromRegistry()
{
  DWORD v0; // esi
  LSTATUS result; // eax
  DWORD Type; // [esp+4h] [ebp-814h]
  DWORD cbData; // [esp+8h] [ebp-810h]
  HKEY phkResult; // [esp+Ch] [ebp-80Ch]
  DWORD cchValueName; // [esp+10h] [ebp-808h]
  WCHAR ValueName; // [esp+14h] [ebp-804h]

  v0 = 0;
  result = RegOpenKeyExW(
             HKEY_CURRENT_USER,
             L"Software\\Sysinternals\\Process Explorer\\ProcessComments",
             0,
             0x20019u,
             &phkResult);
  if ( !result )
  {
    cchValueName = 1024;
    if ( !RegEnumValueW(phkResult, 0, &ValueName, &cchValueName, 0, &Type, 0, &cbData) )
    {
      do
      {
        gpProcessComments = realloc(gpProcessComments, 8 * v0 + 16);
        gpProcessComments[v0].pszName = _wcsdup(&ValueName);
        gpProcessComments[v0].pszComment = malloc(cbData);
        cchValueName += 2;
        RegEnumValueW(phkResult, v0, &ValueName, &cchValueName, 0, &Type, gpProcessComments[v0].pszComment, &cbData);
        gpProcessComments[v0 + 1].pszName = 0;
        cchValueName = 1024;
        ++v0;
      }
      while ( !RegEnumValueW(phkResult, v0, &ValueName, &cchValueName, 0, &Type, 0, &cbData) );
    }
    result = RegCloseKey(phkResult);
  }
  return result;
}

//----- (00FC5D10) --------------------------------------------------------
char __cdecl ReplaceTaskManager(HWND a1, char a2)
{
  DWORD v2; // eax
  DWORD v3; // esi
  char result; // al
  HKEY phkResult; // [esp+0h] [ebp-418h]
  BYTE Data[2]; // [esp+4h] [ebp-414h]
  char v7; // [esp+6h] [ebp-412h]

  *Data = 0;
  memset(&v7, 0, 0x40Eu);
  sub_FC2850(Data, 0x208u);
  v2 = RegCreateKeyW(
         HKEY_LOCAL_MACHINE,
         L"Software\\Microsoft\\Windows NT\\CurrentVersion\\Image File Execution Options\\taskmgr.exe",
         &phkResult);
  if ( v2 )
  {
    if ( a2 )
    {
      SetLastError(v2);
      ReportMsg(L"Error replacing Task Manager", ghMainWnd);
    }
    result = 0;
  }
  else
  {
    v3 = RegSetValueExW(phkResult, L"Debugger", 0, 1u, Data, 2 * wcslen(Data) + 2);
    RegCloseKey(phkResult);
    if ( v3 )
    {
      if ( a2 )
      {
        SetLastError(v3);
        ReportMsg(L"Error replacing Task Manager", ghMainWnd);
      }
      result = 0;
    }
    else
    {
      result = 1;
    }
  }
  return result;
}
// 103EE00: using guessed type wchar_t aErrorReplacing[29];

//----- (00FC5E40) --------------------------------------------------------
char __thiscall sub_FC5E40(HKEY this)
{
  DWORD v1; // eax
  HKEY phkResult; // [esp+0h] [ebp-4h]

  phkResult = this;
  if ( !CanReplaceTaskManager() )
    return 1;
  v1 = RegOpenKeyW(
         HKEY_LOCAL_MACHINE,
         L"Software\\Microsoft\\Windows NT\\CurrentVersion\\Image File Execution Options\\taskmgr.exe",
         &phkResult);
  if ( !v1 )
  {
    RegDeleteValueW(phkResult, L"Debugger");
    RegCloseKey(phkResult);
    return 1;
  }
  SetLastError(v1);
  ReportMsg(L"Error restoring Task Manager", ghMainWnd);
  return 0;
}
// 103EDC4: using guessed type wchar_t aErrorRestoring[29];

//----- (00FC5EB0) --------------------------------------------------------
DWORD __cdecl LaunchProcExplorer64(int a1, WORD a2)
{
  DWORD result; // eax
  unsigned __int16 v3; // si
  wchar_t *v4; // eax
  WCHAR *v5; // eax
  struct _STARTUPINFOW StartupInfo; // [esp+0h] [ebp-46Ch]
  struct _PROCESS_INFORMATION ProcessInformation; // [esp+44h] [ebp-428h]
  HKEY hSubKey; // [esp+54h] [ebp-418h]
  WCHAR szPathName; // [esp+58h] [ebp-414h]
  WCHAR szFileName; // [esp+260h] [ebp-20Ch]

  StartupInfo.cb = 68;
  StartupInfo.lpReserved = 0;
  memset(&StartupInfo.lpDesktop, 0, 0x3Cu);
  _mm_storeu_si128(&ProcessInformation, 0i64);
  result = GetModuleFileNameW(0, &szFileName, 0x103u);
  if ( result )
  {
    if ( !RegCreateKeyW(HKEY_CURRENT_USER, L"Software\\Sysinternals\\Process Explorer", &hSubKey) )
    {
      RegSetValueExW(hSubKey, L"OriginalPath", 0, 1u, &szFileName, 2 * wcslen(&szFileName));
      RegCloseKey(hSubKey);
    }
    *wcsrchr(&szFileName, 0x2Eu) = 0;
    wcscat_s(&szFileName, 0x104u, L"64.exe");
    if ( gSystemInfo.wProcessorArchitecture == PROCESSOR_ARCHITECTURE_IA64 )
    {
      v3 = IDS_DRIVER_64;
    }
    else
    {
      if ( gSystemInfo.wProcessorArchitecture != PROCESSOR_ARCHITECTURE_AMD64 )
      {
        swprintf(&szFileName, L"Unsupported processor type: %d\n", gSystemInfo.wProcessorArchitecture);
        MessageBoxW(0, &szFileName, L"Process Explorer", 0x10u);
        return 0;
      }
      v3 = IDS_DRIVER_32;
    }
    ExpandEnvironmentStringsW(L"%TEMP%", &szPathName, 0x104u);
    v4 = wcsrchr(&szFileName, '\\');
    wcscat_s(&szPathName, 0x104u, v4);
    wcscpy_s(&szFileName, 0x104u, &szPathName);
    if ( !CDriver::SaveDriverFromResource(v3, &szFileName) && GetFileAttributesW(&szFileName) == -1 )
      return 0;
    if ( !RegOpenKeyW(HKEY_CURRENT_USER, L"Software\\Sysinternals\\Process Explorer", &hSubKey) )
    {
      RegSetValueExW(hSubKey, L"Path", 0, 1u, &szFileName, 2 * wcslen(&szFileName));
      RegCloseKey(hSubKey);
    }
    StartupInfo.wShowWindow = a2;
    StartupInfo.dwFlags = 1;
    v5 = GetCommandLineW();
    if ( !CreateProcessW(&szFileName, v5, 0, 0, 0, 0, 0, 0, &StartupInfo, &ProcessInformation) )
      return 0;
    if ( a1 )
    {
      WaitForSingleObject(ProcessInformation.hProcess, 0xFFFFFFFF);
      DeleteFileW(&szFileName);
    }
    CloseHandle(ProcessInformation.hProcess);
    CloseHandle(ProcessInformation.hThread);
    result = 1;
  }
  return result;
}

//----- (00FC6180) --------------------------------------------------------
DWORD __cdecl sub_FC6180(const WCHAR *a1, int a2, char a3)
{
  SHELLEXECUTEINFOW pExecInfo; // [esp+4h] [ebp-450h]
  wchar_t Dst; // [esp+40h] [ebp-414h]

  sub_FC2850(&Dst, 0x208u);
  memset(&pExecInfo, 0, 0x3Cu);
  pExecInfo.nShow = a2;
  pExecInfo.lpFile = &Dst;
  pExecInfo.cbSize = 60;
  pExecInfo.fMask = 64;
  pExecInfo.hwnd = 0;
  pExecInfo.lpVerb = L"Runas";
  pExecInfo.lpParameters = a1;
  if ( !ShellExecuteExW(&pExecInfo) )
    return GetLastError();
  if ( a3 )
    WaitForSingleObject(pExecInfo.hProcess, 0xFFFFFFFF);
  CloseHandle(pExecInfo.hProcess);
  return 0;
}

//----- (00FC6260) --------------------------------------------------------
int Fake_IsWow64Process()
{
  HMODULE v0; // eax
  FARPROC v1; // esi
  HANDLE v2; // eax
  int v4; // [esp+4h] [ebp-4h]

  v4 = 0;
  v0 = GetModuleHandleW(L"kernel32.dll");
  v1 = GetProcAddress(v0, "IsWow64Process");
  if ( v1 )
  {
    v2 = GetCurrentProcess();
    (v1)(v2, &v4);
  }
  return v4;
}

//----- (00FC62A0) --------------------------------------------------------
LSTATUS __cdecl sub_FC62A0(int a1, wchar_t *a2)
{
  int v2; // eax
  const wchar_t *v3; // ebx
  int v4; // edi
  tagTREEVIEWLISTITEMPARAM *v5; // esi
  const wchar_t *v6; // eax
  const wchar_t *v7; // eax
  LRESULT v8; // eax
  tagProcessComment *v9; // ecx
  int v10; // eax
  int v11; // esi
  LSTATUS result; // eax
  tagProcessComment *v13; // edx
  const BYTE *v14; // esi
  LPARAM lParam; // [esp+Ch] [ebp-1Ch]
  tagTREEVIEWLISTITEMPARAM *v16; // [esp+14h] [ebp-14h]
  HKEY phkResult; // [esp+24h] [ebp-4h]

  v2 = a1;
  v3 = *(a1 + 792);
  v4 = 0;
  if ( !v3 )
    v3 = *(a1 + 60);
  v5 = gpTreeViewListItemParam;
  if ( gpTreeViewListItemParam )
  {
    do
    {
      if ( *(v2 + 792) && (v6 = v5->szProcessName) != 0 && !_wcsicmp(v6, v3)
        || (v7 = v5->szProcessName2) != 0 && !_wcsicmp(v7, v3) )
      {
        free(v5->pszComments);
        v5->pszComments = (*a2 ? _wcsdup(a2) : 0);
        lParam = 1;
        v16 = v5;
        v8 = SendMessageW(ghWndTreeListView, 0x1053u, 0xFFFFFFFF, &lParam);
        if ( v8 != -1 )
          PostMessageW(ghMainWnd, 0x7EBu, v8, -1);
      }
      v5 = v5->m_Prev;
      v2 = a1;
    }
    while ( v5 );
    v4 = 0;
  }
  v9 = gpProcessComments;
  if ( !gpProcessComments )
    goto LABEL_33;
  if ( gpProcessComments->pszName )
  {
    v10 = 0;
    while ( _wcsicmp(v9[v10].pszName, v3) )
    {
      v9 = gpProcessComments;
      v10 = ++v4;
      if ( !gpProcessComments[v4].pszName )
        goto LABEL_23;
    }
    free(gpProcessComments[v4].pszComment);
    gpProcessComments[v4].pszComment = _wcsdup(a2);
    v9 = gpProcessComments;
  }
LABEL_23:
  if ( !v9 )
    goto LABEL_33;
  v11 = v4;
  if ( !v9[v4].pszName )
  {
LABEL_33:
    gpProcessComments = realloc(v9, 8 * v4 + 16);
    v11 = v4;
    gpProcessComments[v11].pszName = _wcsdup(v3);
    gpProcessComments[v11].pszComment = _wcsdup(a2);
    gpProcessComments[v11 + 1].pszName = 0;
  }
  result = RegCreateKeyW(HKEY_CURRENT_USER, L"Software\\Sysinternals\\Process Explorer\\ProcessComments", &phkResult);
  if ( !result )
  {
    v13 = &gpProcessComments[v11];
    v14 = gpProcessComments[v11].pszComment;
    if ( *v14 )
      RegSetValueExW(phkResult, v13->pszName, 0, 1u, v14, 2 * wcslen(v14) + 2);
    else
      RegDeleteValueW(phkResult, v13->pszName);
    result = RegCloseKey(phkResult);
  }
  return result;
}

//----- (00FC64C0) --------------------------------------------------------
char __cdecl ImportStringsToListFromFile(HWND hWnd, LPCWSTR lpFileName)
{
  HANDLE hFile; // esi
  char bRet; // al
  HCURSOR v4; // eax
  LVITEMW lParam; // [esp+8h] [ebp-10048h]
  HCURSOR hCursor; // [esp+3Ch] [ebp-10014h]
  DWORD dwRet; // [esp+40h] [ebp-10010h]
  char Buffer[65544]; // [esp+44h] [ebp-1000Ch]

  hFile = CreateFileW(lpFileName, GENERIC_READ, 3u, 0, 3u, 0, 0);
  if ( hFile == INVALID_HANDLE_VALUE )
  {
    lParam.mask = 5;
    lParam.iItem = 0x7FFFFFFF;
    lParam.pszText = L"<Error opening file>";
    lParam.lParam = 1;
    SendMessageW(hWnd, LVM_INSERTITEMW, 0, &lParam);
    bRet = 0;
  }
  else
  {
    v4 = ghWaitCursor;
    if ( !ghWaitCursor )
    {
      v4 = LoadCursorW(ghWaitCursor, IDC_WAIT);
      ghWaitCursor = v4;
    }
    hCursor = SetCursor(v4);
    while ( ReadFile(hFile, Buffer, 65544u, &dwRet, 0) )
    {
      if ( !dwRet )
        break;
      WriteMemoryStringToList(hWnd, 3u, Buffer, dwRet);
      if ( dwRet == 65544 )
        SetFilePointer(hFile, -2, 0, 1u);
    }
    CloseHandle(hFile);
    SetCursor(hCursor);
    bRet = 1;
  }
  return bRet;
}
// 103EBF4: using guessed type wchar_t aErrorOpeningFi[21];

//----- (00FC6620) --------------------------------------------------------
HCURSOR __cdecl LoadProcessStringsToList(HWND hWnd, HANDLE ProcessHandle, LPCVOID lpBaseAddress, DWORD dwSize)
{
  HCURSOR v4; // eax
  char *pAddress; // edi
  DWORD v6; // esi
  SIZE_T dwLength; // ecx
  HCURSOR hCursor; // [esp+Ch] [ebp-10010h]
  SIZE_T dwRet; // [esp+14h] [ebp-10008h]
  char Buffer[65536]; // [esp+18h] [ebp-10004h]

  v4 = ghWaitCursor;
  pAddress = lpBaseAddress;
  if ( !ghWaitCursor )
  {
    v4 = LoadCursorW(ghWaitCursor, IDC_WAIT);
    ghWaitCursor = v4;
  }
  v6 = dwSize;
  hCursor = SetCursor(v4);
  do
  {
    dwLength = v6;
    if ( v6 > 65536 )
      dwLength = 0x10000;
    dwRet = dwLength;
    if ( !ReadProcessMemory(ProcessHandle, pAddress, Buffer, dwLength, &dwRet) )
      break;
    WriteMemoryStringToList(hWnd, 3u, Buffer, dwRet);
    v6 -= dwRet;
    pAddress += dwRet;
    if ( dwRet == 0x10000 )
    {
      v6 += 2;
      pAddress -= 2;
    }
  }
  while ( v6 );
  return SetCursor(hCursor);
}

//----- (00FC6710) --------------------------------------------------------
int __cdecl PE_FillControl(int a1, HDC hdc)
{
  if ( !ghWhiteBrush )
    ghWhiteBrush = CreateSolidBrush(0xFFFFFFu);
  SetBkColor(hdc, 0xFFFFFFu);
  return ghWhiteBrush;
}
// 1069E8C: using guessed type int ghWhiteBrush;

//----- (00FC6750) --------------------------------------------------------
int __cdecl QueryTagInformationEx(PVOID *ppv, PDWORD pdwValue2, PDWORD pdwValue3, PDWORD pdwValue4)
{
  int result; // eax
  DWORD *v5; // edx
  TAG_INFO_NAME_TAG_MAPPING *QueryIn; // [esp+Ch] [ebp-8h]
  DWORD *pValue; // [esp+10h] [ebp-4h]

  if ( *ppv )
  {
    LocalFree(*ppv);
    *pdwValue4 = 0;
    *pdwValue3 = 0;
  }
  QueryIn = pdwValue2;
  pValue = 0;
  result = I_QueryTagInformation(0, ServiceNameTagMappingInformation, &QueryIn);
  if ( !result )
  {
    v5 = pValue;
    *pdwValue3 = *pValue;
    *pdwValue4 = v5[1];
    *ppv = v5;
  }
  return result;
}

//----- (00FC67B0) --------------------------------------------------------
BOOL __cdecl TrayIcon_Add(HWND hWnd, UINT nID, CGraphData *pGraphData, LPCWSTR lpszTipText)
{
  HICON v4; // edi
  BOOL v5; // esi
  struct _NOTIFYICONDATAW Data; // [esp+14h] [ebp-3CCh]
  RECT rc; // [esp+3CCh] [ebp-14h]

  _mm_storeu_si128(&rc, _mm_load_si128(&stru_103F270));
  memset(&Data, 0, 0x3B8u);
  Data.uID = nID;
  Data.cbSize = 952;
  Data.hWnd = hWnd;
  Data.uFlags = 7;
  Data.uCallbackMessage = WM_NOTIFY_TRAYICON;
  v4 = GraphData_DrawChart(pGraphData, 0, &rc, gConfig.ColorGraphBk, 0, 0.0);
  Data.hIcon = v4;
  if ( lpszTipText )
    wcsncpy_s(Data.szTip, 0x80u, lpszTipText, 0xFFFFFFFF);
  else
    Data.szTip[0] = 0;
  v5 = Shell_NotifyIconW(NIM_ADD, &Data);
  DestroyIcon(v4);
  return v5;
}
// 103F270: using guessed type RECT stru_103F270;

//----- (00FC68A0) --------------------------------------------------------
BOOL __cdecl TrayIcon_Delete(HWND hWnd, UINT nID)
{
  struct _NOTIFYICONDATAW Data; // [esp+4h] [ebp-3BCh]

  memset(&Data, 0, 952u);
  Data.uID = nID;
  Data.cbSize = 952;
  Data.hWnd = hWnd;
  return Shell_NotifyIconW(NIM_DELETE, &Data);
}

//----- (00FC6910) --------------------------------------------------------
BOOL __cdecl sub_FC6910(int a1, int a2, int a3, wchar_t *Src)
{
  struct _NOTIFYICONDATAW Data; // [esp+Ch] [ebp-3BCh]

  wcscpy_s(&Dst, 0x100u, Src);
  memset(&Data, 0, 0x3B8u);
  Data.cbSize = 952;
  Data.hWnd = a1;
  Data.uID = a2;
  Data.uFlags = 6;
  Data.hIcon = a3;
  if ( Src )
    wcsncpy_s(Data.szTip, 0x80u, Src, 0xFFFFFFFF);
  else
    Data.szTip[0] = 0;
  return Shell_NotifyIconW(1u, &Data);
}

//----- (00FC69D0) --------------------------------------------------------
BOOL __cdecl RefreshVirusTotalMenuItem(tagTREEVIEWLISTITEMPARAM *pItemParam)
{
  char v1; // bl
  ListItemData1 *v2; // eax
  bool v3; // zf
  const WCHAR *v4; // eax
  const WCHAR *v5; // ST10_4
  HMENU v6; // eax
  WCHAR *v7; // eax
  HMENU v8; // eax

  v1 = 0;
  v2 = pItemParam->m_ItemDataForVirusTotal;
  if ( !v2 || (v3 = v2->field_4 == 6, v4 = L"&Submit to VirusTotal", !v3) )
    v4 = L"&Check VirusTotal";
  v5 = v4;
  v6 = GetMenu(ghMainWnd);
  ModifyMenuW(v6, IDM_PROCESS_CHECK_VIRUSTOTALDOTCOM, MF_BYCOMMAND, IDM_PROCESS_CHECK_VIRUSTOTALDOTCOM, v5);
  v7 = pItemParam->szProcessName;
  if ( v7 )
  {
    if ( *v7 != '[' )
    {
      v1 = 0;
      if ( sub_1001C10(pItemParam->m_ItemDataForVirusTotal) )
        v1 = 1;
    }
  }
  v8 = GetMenu(ghMainWnd);
  return EnableMenuItem(v8, IDM_PROCESS_CHECK_VIRUSTOTALDOTCOM, v1 == 0);
}
// 103E374: using guessed type wchar_t aCheckVirustota[18];

//----- (00FC6A70) --------------------------------------------------------
BOOL __cdecl RefreshMenuWithTreeViewItemStatus(tagTREEVIEWLISTITEMPARAM *pItem)
{
  HMENU hMainMenu; // edi
  HWND hWnd; // eax
  HMENU v3; // eax
  BOOL result; // eax
  HMENU v5; // eax
  BOOL v6; // eax
  BOOL v7; // eax
  BOOL v8; // eax

  hMainMenu = GetMenu(ghMainWnd);
  hWnd = QueryTopMostWindowByProcessID(pItem->dwProcessId);
  pItem->hMainWndBackup = hWnd;
  if ( hWnd )
  {
    v5 = GetSubMenu(hMainMenu, 3);
    EnableMenuItem(v5, 0, MF_BYPOSITION);
    EnableMenuItem(hMainMenu, IDM_PROCESS_WINDOW_BRING_TO_FRONT, 0);
    EnableMenuItem(hMainMenu, IDM_PROCESS_WINDOW_CLOSE, 0);
    v6 = !IsIconic(pItem->hMainWndBackup) && !IsZoomed(pItem->hMainWndBackup);
    EnableMenuItem(hMainMenu, IDM_PROCESS_WINDOW_RESTORE, v6);
    v7 = IsIconic(pItem->hMainWndBackup);
    EnableMenuItem(hMainMenu, IDM_PROCESS_WINDOW_MINIMIZE, v7 != 0);
    v8 = IsZoomed(pItem->hMainWndBackup);
    result = EnableMenuItem(hMainMenu, IDM_PROCESS_WINDOW_MAXIMIZE, v8 != 0);
  }
  else
  {
    v3 = GetSubMenu(hMainMenu, 3);
    EnableMenuItem(v3, 0, 0x401u);
    EnableMenuItem(hMainMenu, IDM_PROCESS_WINDOW_BRING_TO_FRONT, MF_GRAYED);
    EnableMenuItem(hMainMenu, IDM_PROCESS_WINDOW_CLOSE, MF_GRAYED);
    EnableMenuItem(hMainMenu, IDM_PROCESS_WINDOW_RESTORE, MF_GRAYED);
    EnableMenuItem(hMainMenu, IDM_PROCESS_WINDOW_MINIMIZE, MF_GRAYED);
    result = EnableMenuItem(hMainMenu, IDM_PROCESS_WINDOW_MAXIMIZE, MF_GRAYED);
  }
  return result;
}

//----- (00FC6B90) --------------------------------------------------------
bool __cdecl sub_FC6B90(HWND hWnd, int a2, int a3)
{
  HWND v3; // esi
  HMODULE v5; // eax
  FARPROC v6; // eax
  HWND v7; // ecx

  v3 = QueryTopMostWindowByProcessID(a3);
  if ( !v3 )
  {
    v7 = ghMainWnd;
    if ( hWnd )
      v7 = hWnd;
    MessageBoxW(v7, L"No visible windows found for this process", L"Process Explorer Warning", 0x30u);
    return v3 != 0;
  }
  if ( a2 <= 40638 )
  {
    if ( a2 == 40638 )
    {
      ShowWindowAsync(v3, 6);
      return v3 != 0;
    }
    if ( a2 == 40084 )
    {
      if ( IsIconic(v3) )
        ShowWindowAsync(v3, 9);
      SetForegroundWindow(v3);
      return v3 != 0;
    }
    return v3 != 0;
  }
  if ( a2 == 40639 )
  {
    ShowWindowAsync(v3, 3);
    return v3 != 0;
  }
  if ( a2 != 40640 )
  {
    if ( a2 == 40641 )
    {
      ShowWindowAsync(v3, 9);
      return v3 != 0;
    }
    return v3 != 0;
  }
  v5 = GetModuleHandleW(L"user32.dll");
  v6 = GetProcAddress(v5, "EndTask");
  if ( v6 )
    (v6)(v3, 0, 0);
  else
    PostMessageW(v3, 0x10u, 0, 0);
  return v3 != 0;
}

//----- (00FC6C90) --------------------------------------------------------
LSTATUS SaveHiddenProcessesToRegistry()
{
  int v0; // ebx
  int nIndex; // esi
  LSTATUS result; // eax
  WCHAR **ppHiddenProcesses; // edi
  WCHAR **ppHiddenProcesses_1; // eax
  WCHAR *pHiddenProcesses; // eax
  WCHAR *v6; // edx
  WCHAR chText; // cx
  rsize_t nLength; // ebx
  wchar_t *v9; // eax
  int item; // esi
  int nIndex_1; // edx
  WCHAR *pHiddenProcesses_1; // ecx
  int v13; // esi
  WCHAR v14; // ax
  int nLength_1; // ecx
  BYTE *lpData; // [esp+8h] [ebp-14h]
  wchar_t *v17; // [esp+10h] [ebp-Ch]
  int nIndex_2; // [esp+14h] [ebp-8h]
  HKEY hSubKey; // [esp+18h] [ebp-4h]

  v0 = 0;
  nIndex = 0;
  result = RegCreateKeyW(HKEY_CURRENT_USER, L"Software\\Sysinternals\\Process Explorer", &hSubKey);
  if ( !result )
  {
    ppHiddenProcesses = gpHiddenProcesses;
    if ( *gpHiddenProcesses )
    {
      ppHiddenProcesses_1 = gpHiddenProcesses;
      do
      {
        pHiddenProcesses = *ppHiddenProcesses_1;
        ++nIndex;
        v6 = pHiddenProcesses + 1;
        do
        {
          chText = *pHiddenProcesses;
          ++pHiddenProcesses;
        }
        while ( chText );
        v0 += pHiddenProcesses - v6 + 1;
        ppHiddenProcesses_1 = &gpHiddenProcesses[nIndex];
      }
      while ( gpHiddenProcesses[nIndex] );
    }
    nLength = v0 + 1;
    if ( nIndex )
    {
      v9 = malloc(2 * nLength);
      lpData = v9;
      nIndex_2 = 0;
      v17 = v9;
      if ( *ppHiddenProcesses )
      {
        item = 0;
        do
        {
          wcscpy_s(v9, nLength, *ppHiddenProcesses);
          nIndex_1 = nIndex_2++ + 1;
          pHiddenProcesses_1 = gpHiddenProcesses[item];
          v13 = (pHiddenProcesses_1 + 1);
          do
          {
            v14 = *pHiddenProcesses_1;
            ++pHiddenProcesses_1;
          }
          while ( v14 );
          nLength_1 = (pHiddenProcesses_1 - v13) >> 1;
          item = nIndex_1;
          ppHiddenProcesses = &gpHiddenProcesses[nIndex_1];
          v9 = &v17[nLength_1 + 1];
          v17 += nLength_1 + 1;
        }
        while ( *ppHiddenProcesses );
      }
      *v9 = 0;
      RegSetValueExW(hSubKey, L"HiddenProcs", 0, REG_MULTI_SZ, lpData, 2 * nLength);
      result = RegCloseKey(hSubKey);
    }
    else
    {
      RegDeleteValueW(hSubKey, L"HiddenProcs");
      result = RegCloseKey(hSubKey);
    }
  }
  return result;
}

//----- (00FC6DB0) --------------------------------------------------------
HANDLE __cdecl sub_FC6DB0(HANDLE TokenHandle)
{
  DWORD v1; // esi
  unsigned int *v2; // ebx
  int v3; // edi
  unsigned int v4; // esi
  unsigned int *v5; // ecx
  unsigned int v6; // eax
  const __m128i *v7; // esi
  unsigned int v8; // edi
  unsigned int v9; // edx
  _DWORD *v10; // eax
  char *v11; // edx
  void *v12; // ebx
  HMODULE v13; // eax
  FARPROC v14; // eax
  DWORD v15; // eax
  DWORD v16; // esi
  DWORD v17; // eax
  DWORD v18; // esi
  ACL *v19; // edi
  ACL *v20; // ecx
  DWORD v21; // esi
  void *v22; // esi
  struct _SID_AND_ATTRIBUTES v24; // [esp+4h] [ebp-6Ch]
  LPVOID pAce; // [esp+Ch] [ebp-64h]
  PSECURITY_DESCRIPTOR ppSecurityDescriptor; // [esp+10h] [ebp-60h]
  ACL *v27; // [esp+14h] [ebp-5Ch]
  void *v28; // [esp+18h] [ebp-58h]
  PSID TokenInformation; // [esp+1Ch] [ebp-54h]
  int v30; // [esp+20h] [ebp-50h]
  DWORD TokenInformationLength; // [esp+24h] [ebp-4Ch]
  PSID hMem; // [esp+28h] [ebp-48h]
  PSID AccountSid; // [esp+2Ch] [ebp-44h]
  PSID pSid; // [esp+30h] [ebp-40h]
  void *v35; // [esp+34h] [ebp-3Ch]
  PACL ppDacl; // [esp+38h] [ebp-38h]
  unsigned int v37; // [esp+3Ch] [ebp-34h]
  DWORD ReturnLength; // [esp+40h] [ebp-30h]
  void *v39; // [esp+44h] [ebp-2Ch]
  HANDLE handle; // [esp+48h] [ebp-28h]
  struct _SID_IDENTIFIER_AUTHORITY pIdentifierAuthority; // [esp+4Ch] [ebp-24h]
  __int128 v42; // [esp+54h] [ebp-1Ch]
  __int64 v43; // [esp+64h] [ebp-Ch]

  _mm_storeu_si128(&v42, _mm_loadu_si128(L"S-1-16-4096"));
  v28 = TokenHandle;
  *pIdentifierAuthority.Value = 0;
  *&pIdentifierAuthority.Value[4] = 1280;
  pSid = 0;
  AccountSid = 0;
  handle = 0;
  v43 = *L"096";
  hMem = 0;
  TokenInformation = 0;
  v30 = 0;
  AllocateAndInitializeSid(&pIdentifierAuthority, 2u, 0x20u, 0x220u, 0, 0, 0, 0, 0, 0, &pSid);
  v24.Sid = pSid;
  v24.Attributes = 0;
  GetTokenInformation(TokenHandle, TokenPrivileges, 0, 0, &ReturnLength);
  v1 = ReturnLength;
  v35 = malloc(ReturnLength);
  GetTokenInformation(TokenHandle, TokenPrivileges, v35, v1, &ReturnLength);
  v39 = malloc(ReturnLength);
  *v39 = 0;
  AllocateAndInitializeSid(&pIdentifierAuthority, 2u, 0x20u, 0x221u, 0, 0, 0, 0, 0, 0, &AccountSid);
  v2 = sub_FC7450(AccountSid);
  if ( !v2 )
  {
    v2 = malloc(0x4Cu);
    v3 = 0;
    v4 = 0;
    *v2 = 0;
    do
    {
      if ( LookupPrivilegeValueW(0, off_105E0BC[v4], &v2[v3 + 1]) )
        ++*v2;
      ++v4;
      v3 += 3;
    }
    while ( v4 < 5 );
  }
  v5 = v35;
  v6 = 0;
  v37 = 0;
  if ( *v35 )
  {
    v7 = (v35 + 4);
    do
    {
      v8 = *v2;
      v9 = 0;
      if ( *v2 )
      {
        v10 = v2 + 1;
        do
        {
          if ( v7->m128i_i32[0] == *v10 && v7->m128i_i32[1] == v10[1] )
            break;
          ++v9;
          v10 += 3;
        }
        while ( v9 < v8 );
        v6 = v37;
        v5 = v35;
      }
      if ( v9 == v8 )
      {
        v11 = v39 + 12 * *v39;
        v5 = v35;
        ++*v39;
        _mm_storel_epi64((v11 + 4), _mm_loadl_epi64(v7));
        *(v11 + 3) = v7->m128i_i32[2];
        v6 = v37;
      }
      ++v6;
      v7 = (v7 + 12);
      v37 = v6;
    }
    while ( v6 < *v5 );
  }
  free(v5);
  free(v2);
  v12 = v39;
  if ( gpfnCreateRestrictedToken(v28, 0, 1u, &v24, *v39, (v39 + 4), 0, 0, &handle) )
  {
    v13 = LoadLibraryW(L"Advapi32.dll");
    v14 = GetProcAddress(v13, "ConvertStringSidToSidA");
    dword_106A090 = v14;
    if ( v14 && (v14)(&v42, &hMem) )
    {
      v30 = 32;
      TokenInformation = hMem;
      v15 = GetLengthSid(hMem);
      SetTokenInformation(handle, TokenIntegrityLevel, &TokenInformation, v15 + 8);
      LocalFree(hMem);
    }
  }
  else
  {
    handle = 0;
  }
  GetTokenInformation(handle, TokenUser, 0, 0, &TokenInformationLength);
  v16 = TokenInformationLength;
  v39 = malloc(TokenInformationLength);
  GetTokenInformation(handle, TokenUser, v39, v16, &TokenInformationLength);
  GetSecurityInfo(handle, SE_KERNEL_OBJECT, 4u, 0, 0, &ppDacl, 0, &ppSecurityDescriptor);
  v17 = GetLengthSid(*v39);
  v18 = v17 + ppDacl->AclSize + 8;
  v19 = malloc(v17 + ppDacl->AclSize + 8);
  InitializeAcl(v19, v18, 2u);
  v20 = ppDacl;
  v21 = 0;
  if ( ppDacl->AceCount > 0u )
  {
    do
    {
      GetAce(v20, v21, &pAce);
      AddAce(v19, 2u, v21, pAce, *(pAce + 1));
      v20 = ppDacl;
      ++v21;
    }
    while ( v21 < ppDacl->AceCount );
  }
  v22 = v39;
  AddAccessAllowedAce(v19, 2u, 0x10000000u, *v39);
  SetSecurityInfo(handle, SE_KERNEL_OBJECT, 4u, 0, 0, v19, 0);
  v27 = v19;
  SetTokenInformation(handle, TokenDefaultDacl, &v27, v19->AclSize);
  free(v19);
  free(v22);
  LocalFree(ppSecurityDescriptor);
  FreeSid(pSid);
  FreeSid(AccountSid);
  free(v12);
  return handle;
}
// 103F37C: using guessed type wchar_t aS1164096[12];
// 105E0BC: using guessed type wchar_t *off_105E0BC[5];
// 106A090: using guessed type int dword_106A090;
// 106A118: using guessed type int (__stdcall *gpfnCreateRestrictedToken)(void *, unsigned int, unsigned int, struct _SID_AND_ATTRIBUTES *, unsigned int, struct _LUID_AND_ATTRIBUTES *, unsigned int, struct _SID_AND_ATTRIBUTES *, void **);

//----- (00FC7140) --------------------------------------------------------
BOOL __cdecl QueryCurrentAuthorityInfo(wchar_t **a1)
{
  HANDLE v1; // eax
  wchar_t *v2; // eax
  HANDLE TokenHandle; // [esp+4h] [ebp-80Ch]
  DWORD ReturnLength; // [esp+8h] [ebp-808h]
  void *TokenInformation; // [esp+Ch] [ebp-804h]

  v1 = GetCurrentProcess();
  OpenProcessToken(v1, 8u, &TokenHandle);
  ReturnLength = 2048;
  GetTokenInformation(TokenHandle, TokenUser, &TokenInformation, 0x800u, &ReturnLength);
  ReturnLength = 0;
  QueryAuthorityInfoFromSID(TokenInformation, *a1, &ReturnLength);
  v2 = malloc(2 * ReturnLength);
  *a1 = v2;
  QueryAuthorityInfoFromSID(TokenInformation, v2, &ReturnLength);
  return CloseHandle(TokenHandle);
}

//----- (00FC7200) --------------------------------------------------------
BOOL __cdecl QueryAuthorityInfoFromSID(PSID pSid, wchar_t *Dst, int a3)
{
  BOOL result; // eax
  PSID_IDENTIFIER_AUTHORITY v4; // edi
  unsigned int v5; // ecx
  int v6; // eax
  int v7; // esi
  int v8; // eax
  DWORD v9; // edi
  int v10; // esi
  PDWORD v11; // eax
  DWORD v12; // [esp+4h] [ebp-4h]

  result = IsValidSid(pSid);
  if ( result )
  {
    v4 = GetSidIdentifierAuthority(pSid);
    v12 = *GetSidSubAuthorityCount(pSid);
    v5 = 12 * v12 + 28;
    if ( *a3 >= v5 )
    {
      v6 = swprintf_s(Dst, *a3, L"S-%lu-", 1);
      v7 = v6;
      if ( v4->Value[0] || v4->Value[1] )
        v8 = swprintf_s(
               &Dst[v6],
               *a3 - v6,
               L"0x%02hx%02hx%02hx%02hx%02hx%02hx",
               v4->Value[0],
               v4->Value[1],
               v4->Value[2],
               v4->Value[3],
               v4->Value[4],
               v4->Value[5]);
      else
        v8 = swprintf_s(
               &Dst[v6],
               *a3 - v6,
               L"%lu",
               v4->Value[5] + ((v4->Value[4] + ((v4->Value[3] + (v4->Value[2] << 8)) << 8)) << 8));
      v9 = 0;
      v10 = v8 + v7;
      if ( v12 )
      {
        do
        {
          v11 = GetSidSubAuthority(pSid, v9++);
          v10 += swprintf_s(&Dst[v10], *a3 - v10, L"-%lu", *v11);
        }
        while ( v9 < v12 );
      }
      result = 1;
    }
    else
    {
      *a3 = v5;
      SetLastError(0x7Au);
      result = 0;
    }
  }
  return result;
}

//----- (00FC7330) --------------------------------------------------------
char IsBuiltinAdministrative()
{
  HANDLE v0; // eax
  DWORD v1; // esi
  unsigned int *v2; // ebx
  unsigned int v3; // edi
  bool v4; // zf
  _DWORD *v5; // esi
  DWORD ReturnLength; // [esp+0h] [ebp-18h]
  PSID pSid; // [esp+4h] [ebp-14h]
  HANDLE TokenHandle; // [esp+8h] [ebp-10h]
  struct _SID_IDENTIFIER_AUTHORITY pIdentifierAuthority; // [esp+Ch] [ebp-Ch]

  *pIdentifierAuthority.Value = 0;
  *&pIdentifierAuthority.Value[4] = 1280;
  pSid = 0;
  if ( !byte_106A094 )
  {
    v0 = GetCurrentProcess();
    OpenProcessToken(v0, 8u, &TokenHandle);
    AllocateAndInitializeSid(&pIdentifierAuthority, 2u, 0x20u, 0x220u, 0, 0, 0, 0, 0, 0, &pSid);
    GetTokenInformation(TokenHandle, TokenGroups, 0, 0, &ReturnLength);
    v1 = ReturnLength;
    v2 = malloc(ReturnLength);
    if ( GetTokenInformation(TokenHandle, TokenGroups, v2, v1, &ReturnLength) )
    {
      v3 = 0;
      v4 = *v2 == 0;
      if ( *v2 > 0 )
      {
        v5 = v2 + 2;
        do
        {
          if ( EqualSid(pSid, *(v5 - 1)) && *v5 & 4 && *v5 & 0xFFFFFFEF )
            break;
          ++v3;
          v5 += 2;
        }
        while ( v3 < *v2 );
        v4 = v3 == *v2;
      }
      byte_106A095 = !v4;
    }
    free(v2);
    FreeSid(pSid);
    CloseHandle(TokenHandle);
    byte_106A094 = 1;
  }
  return byte_106A095;
}
// 106A094: using guessed type char byte_106A094;
// 106A095: using guessed type char byte_106A095;

//----- (00FC7450) --------------------------------------------------------
_DWORD *__cdecl sub_FC7450(PSID AccountSid)
{
  _DWORD *v1; // ebx
  ULONG v2; // esi
  _DWORD *v3; // eax
  ULONG v4; // esi
  struct _LUID *v5; // edi
  struct _LSA_OBJECT_ATTRIBUTES ObjectAttributes; // [esp+4h] [ebp-24h]
  PVOID PolicyHandle; // [esp+1Ch] [ebp-Ch]
  PLSA_UNICODE_STRING UserRights; // [esp+20h] [ebp-8h]
  ULONG CountOfRights; // [esp+24h] [ebp-4h]

  *&ObjectAttributes.SecurityDescriptor = 0i64;
  v1 = 0;
  _mm_storeu_si128(&ObjectAttributes, 0i64);
  if ( !LsaOpenPolicy(0, &ObjectAttributes, 0x800u, &PolicyHandle) )
  {
    if ( !LsaEnumerateAccountRights(PolicyHandle, AccountSid, &UserRights, &CountOfRights) )
    {
      v2 = CountOfRights;
      if ( CountOfRights )
      {
        v3 = malloc(12 * CountOfRights + 16);
        v1 = v3;
        *v3 = v2;
        v4 = 0;
        if ( CountOfRights )
        {
          v5 = (v3 + 1);
          do
          {
            LookupPrivilegeValueW(0, UserRights[v4++].Buffer, v5);
            v5 = (v5 + 12);
          }
          while ( v4 < CountOfRights );
        }
        LsaFreeMemory(UserRights);
      }
    }
    LsaClose(PolicyHandle);
  }
  return v1;
}

//----- (00FC7500) --------------------------------------------------------
int sub_FC7500(wchar_t *Dst, wchar_t *Format, ...)
{
  va_list ArgList; // [esp+10h] [ebp+10h]

  va_start(ArgList, Format);
  return vswprintf_s(Dst, 0x80u, Format, ArgList);
}

//----- (00FC7520) --------------------------------------------------------
_DWORD *__thiscall sub_FC7520(_DWORD *this, int (__stdcall ***a2)(_DWORD, GUID *, _DWORD *))
{
  _DWORD *v2; // esi
  bool v3; // sf
  _DWORD *result; // eax

  v2 = this;
  *this = 0;
  if ( !a2 )
    return this;
  v3 = (**a2)(a2, &stru_103FC40, this) < 0;
  result = v2;
  if ( v3 )
    *v2 = 0;
  return result;
}
// 103FC40: using guessed type GUID stru_103FC40;

//----- (00FC7560) --------------------------------------------------------
_DWORD *__thiscall sub_FC7560(_DWORD *this, int (__stdcall ***a2)(_DWORD, GUID *, _DWORD *))
{
  _DWORD *v2; // esi
  bool v3; // sf
  _DWORD *result; // eax

  v2 = this;
  *this = 0;
  if ( !a2 )
    return this;
  v3 = (**a2)(a2, &stru_103FD30, this) < 0;
  result = v2;
  if ( v3 )
    *v2 = 0;
  return result;
}
// 103FD30: using guessed type GUID stru_103FD30;

//----- (00FC75A0) --------------------------------------------------------
_DWORD *__thiscall sub_FC75A0(_DWORD *this)
{
  _DWORD *result; // eax

  *this = &MixedModeStackWalker::`vftable';
  result = this;
  this[1] = 1;
  this[6] = 0;
  this[7] = 0;
  this[8] = 0;
  this[9] = 0;
  this[3] = 0;
  this[4] = 0;
  return result;
}
// 103F470: using guessed type void *MixedModeStackWalker::`vftable';

//----- (00FC7600) --------------------------------------------------------
int __thiscall sub_FC7600(_DWORD *this, int a2)
{
  _DWORD *v2; // esi
  int v3; // eax

  v2 = this;
  if ( *this == a2 )
    return *v2;
  if ( a2 )
    (*(*a2 + 4))(a2);
  v3 = *v2;
  *v2 = a2;
  if ( v3 )
  {
    (*(*v3 + 8))(v3);
    return *v2;
  }
  return a2;
}

//----- (00FC7640) --------------------------------------------------------
_DWORD *__thiscall sub_FC7640(void *this, char a2)
{
  _DWORD *v2; // esi
  int v3; // ecx
  int v4; // ecx
  int v5; // ecx
  int v6; // ecx

  v2 = this;
  *this = &MixedModeStackWalker::`vftable';
  if ( *(this + 3) )
    *(this + 3) = 0;
  v3 = *(this + 9);
  if ( v3 )
    (*(*v3 + 8))(v2[9]);
  v4 = v2[8];
  if ( v4 )
    (*(*v4 + 8))(v4);
  v5 = v2[7];
  if ( v5 )
    (*(*v5 + 8))(v5);
  v6 = v2[6];
  if ( v6 )
    (*(*v6 + 8))(v6);
  if ( a2 & 1 )
    j__free(v2);
  return v2;
}
// 103F470: using guessed type void *MixedModeStackWalker::`vftable';

//----- (00FC76F0) --------------------------------------------------------
unsigned int __thiscall sub_FC76F0(_DWORD *this, int *a2)
{
  _DWORD *v2; // esi
  unsigned int v3; // edi
  int *v4; // ecx
  int v5; // eax

  v2 = this;
  v3 = this[1];
  if ( v3 >= this[2] && !sub_FC88A0(this, v3 + 1) )
    ATL::AtlThrowImpl(-2147024882);
  v4 = (*v2 + 4 * v3);
  if ( v4 )
  {
    v5 = *a2;
    *v4 = *a2;
    if ( v5 )
      (*(*v5 + 4))(v5);
  }
  ++v2[1];
  return v3;
}

//----- (00FC7740) --------------------------------------------------------
_DWORD *__thiscall sub_FC7740(_DWORD *this, int *a2)
{
  _DWORD *v2; // edi
  int v3; // ebx
  _DWORD *v4; // esi
  int v5; // edx
  int v6; // ecx
  _DWORD *v7; // eax
  _DWORD *result; // eax
  int v9; // [esp+18h] [ebp-10h]

  v2 = this;
  v3 = this[1];
  sub_FC7F70(this);
  v4 = v2[4];
  v5 = *v4;
  v9 = *v4;
  if ( v4 )
  {
    v6 = *a2;
    v4[2] = *a2;
    if ( v6 )
    {
      (*(*v6 + 4))(v6);
      v5 = v9;
    }
  }
  v2[4] = v5;
  v4[1] = v3;
  *v4 = 0;
  ++v2[2];
  v7 = v2[1];
  if ( v7 )
    *v7 = v4;
  else
    *v2 = v4;
  result = v4;
  v2[1] = v4;
  return result;
}

//----- (00FC77E0) --------------------------------------------------------
void __stdcall sub_FC77E0(int *a1)
{
  int *v1; // edx
  unsigned int v2; // edi
  unsigned int v3; // ebx
  unsigned int v4; // ecx
  int v5; // edx
  int v6; // eax
  _DWORD *v7; // eax
  _DWORD *v8; // esi
  int v9; // eax
  _DWORD *v10; // eax
  wchar_t *v11; // ST00_4
  int v12; // eax
  const char *v13; // [esp-4h] [ebp-24h]
  void *v14; // [esp+10h] [ebp-10h]
  int v15; // [esp+1Ch] [ebp-4h]

  v1 = a1;
  v2 = a1[1] - 1;
  v3 = a1[1] - 2;
  if ( (v3 & 0x80000000) == 0 )
  {
    while ( 1 )
    {
      v4 = v1[1];
      if ( v2 >= v4 )
LABEL_26:
        ATL::AtlThrowImpl(-2147024809);
      v5 = *v1;
      if ( *(*(v5 + 4 * v2) + 24) == 3 )
      {
        if ( v3 >= v4 )
          goto LABEL_26;
        v6 = *(v5 + 4 * v3);
        if ( *(v6 + 24) == 1 || !*(v6 + 24) )
          break;
      }
      if ( v3 >= v4 )
        goto LABEL_26;
      if ( *(*(v5 + 4 * v3) + 24) == 3 )
      {
        v9 = *(v5 + 4 * v2);
        if ( *(v9 + 24) == 1 || !*(v9 + 24) )
        {
          v10 = operator new(0x20u);
          v8 = v10;
          v14 = v10;
          v15 = 2;
          if ( v10 )
          {
            *v10 = &SymbolInfo::`vftable';
            v10[1] = 1;
            v10[7] = operator new[](0x800u);
          }
          else
          {
            v8 = 0;
          }
          v15 = -1;
          v14 = v8;
          if ( v8 )
            (*(*v8 + 4))(v8);
          v15 = 3;
          v13 = "[Managed to Unmanaged Transition]";
          goto LABEL_23;
        }
      }
LABEL_24:
      --v2;
      if ( (--v3 & 0x80000000) != 0 )
        return;
      v1 = a1;
    }
    v7 = operator new(0x20u);
    v8 = v7;
    v14 = v7;
    v15 = 0;
    if ( v7 )
    {
      *v7 = &SymbolInfo::`vftable';
      v7[1] = 1;
      v7[7] = operator new[](0x800u);
    }
    else
    {
      v8 = 0;
    }
    v15 = -1;
    v14 = v8;
    if ( v8 )
      (*(*v8 + 4))(v8);
    v15 = 1;
    v13 = "[Unmanaged to Managed Transition]";
LABEL_23:
    v11 = v8[7];
    v8[4] = 0;
    v8[5] = 0;
    swprintf_s(v11, 0x400u, L"%S", v13);
    v8[6] = 1;
    sub_FC8AE0(a1, v2, &v14, 1u);
    v12 = *v8;
    v15 = -1;
    (*(v12 + 8))(v8);
    goto LABEL_24;
  }
}
// 103F420: using guessed type void *SymbolInfo::`vftable';

//----- (00FC79A0) --------------------------------------------------------
void __cdecl sub_FC79A0(_DWORD *a1, int a2)
{
  int v2; // ecx
  _DWORD *v3; // eax

  v2 = a2;
  if ( a2 )
  {
    v3 = a1;
    do
    {
      if ( v3 )
        *v3 = 0;
      ++v3;
      --v2;
    }
    while ( v2 );
  }
}

//----- (00FC79D0) --------------------------------------------------------
int __cdecl sub_FC79D0(int a1, unsigned int a2)
{
  unsigned int v2; // esi
  int v3; // ecx
  int result; // eax

  v2 = 0;
  if ( a2 )
  {
    do
    {
      v3 = *(a1 + 4 * v2);
      if ( v3 )
        result = (*(*v3 + 8))(*(a1 + 4 * v2));
      ++v2;
    }
    while ( v2 < a2 );
  }
  return result;
}

//----- (00FC7A00) --------------------------------------------------------
int __cdecl sub_FC7A00(HWND hWnd, int a2, char a3)
{
  void (__stdcall *v3)(HWND, UINT, WPARAM, LPARAM); // edi
  int v4; // esi
  LRESULT v5; // eax
  char v6; // al
  int v7; // ecx
  unsigned int v8; // eax
  IUnknown *v9; // eax
  int v10; // esi
  int v11; // eax
  char v12; // al
  char v13; // cl
  signed int v14; // eax
  char v16; // [esp-22Ch] [ebp-6D0h]
  const IID *v17; // [esp-14h] [ebp-4B8h]
  IUnknown *v18; // [esp-10h] [ebp-4B4h]
  DWORD v19; // [esp-Ch] [ebp-4B0h]
  const IID *v20; // [esp-8h] [ebp-4ACh]
  LPVOID *v21; // [esp-4h] [ebp-4A8h]
  LPARAM lParam; // [esp+Ch] [ebp-498h]
  int v23; // [esp+10h] [ebp-494h]
  int v24; // [esp+14h] [ebp-490h]
  LPARAM v25; // [esp+2Ch] [ebp-478h]
  int v26; // [esp+40h] [ebp-464h]
  LPVOID *v27; // [esp+44h] [ebp-460h]
  int v28; // [esp+48h] [ebp-45Ch]
  void *v29; // [esp+4Ch] [ebp-458h]
  unsigned int v30; // [esp+50h] [ebp-454h]
  LPVOID ppv; // [esp+54h] [ebp-450h]
  int v32; // [esp+58h] [ebp-44Ch]
  LPVOID *v33; // [esp+5Ch] [ebp-448h]
  unsigned int v34; // [esp+60h] [ebp-444h]
  int v35; // [esp+67h] [ebp-43Dh]
  char v36; // [esp+6Ch] [ebp-438h]
  int v37; // [esp+70h] [ebp-434h]
  int v38; // [esp+7Ch] [ebp-428h]
  int v39; // [esp+80h] [ebp-424h]
  wchar_t Dst; // [esp+90h] [ebp-414h]
  wchar_t Src; // [esp+298h] [ebp-20Ch]

  lParam = 0;
  memset(&v23, 0, 0x30u);
  v21 = &ppv;
  v20 = &stru_103F3BC;
  v19 = 1;
  v18 = 0;
  if ( byte_106A09A )
    v17 = &stru_103F40C;
  else
    v17 = &stru_103F3AC;
  CoCreateInstance(v17, v18, v19, v20, v21);
  v3 = SendMessageW;
  v4 = 0;
  BYTE1(v35) = 0;
  v32 = 0;
  v28 = 0;
  lParam = 4;
  v5 = SendMessageW(hWnd, 0x1004u, 0, 0);
  v24 = 0;
  v23 = v5 - 1;
  if ( SendMessageW(hWnd, 0x104Bu, 0, &lParam) )
  {
    do
    {
      v6 = sub_FF58D0(hWnd, hWnd, &lParam, v25, &v35);
      v7 = BYTE1(v35);
      if ( v6 )
        v7 = 1;
      *(&v35 + 1) = v7;
      *(v25 + 8) = 0;
      if ( v35 )
        ++v4;
    }
    while ( SendMessageW(hWnd, 0x104Bu, 0, &lParam) );
    v28 = v4;
  }
  if ( !(*(*ppv + 16))(ppv, a2, &v27) )
  {
    (*(*v27 + 4))(v27, &v33);
    (*(*v33 + 6))(v33, &v34);
    v29 = operator new[](4 * v34);
    (*(*v33 + 7))(v33, v34, v29, &v34);
    v3 = SendMessageW;
    v8 = 0;
    v30 = 0;
    if ( v34 )
    {
      do
      {
        v21 = &Src;
        v26 = 260;
        v20 = &v26;
        v9 = *(v29 + v8);
        v19 = 260;
        v18 = v9;
        (v9->lpVtbl[1].AddRef)(v9, 260, &v26, &Src);
        v10 = 0;
        if ( (v3)(hWnd, 0x1004u, 0, 0) > 0 )
        {
          while ( 1 )
          {
            lParam = 4;
            v23 = v10;
            v24 = 0;
            v3(hWnd, 0x104Bu, 0, &lParam);
            v11 = *(v25 + 16);
            if ( (v11 == 1 || !v11) && !_wcsicmp(&Src, (v25 + 36)) )
              break;
            if ( ++v10 >= (v3)(hWnd, 0x1004u, 0, 0) )
              goto LABEL_22;
          }
          ++v32;
          v12 = sub_FF8A20(v25);
          v13 = BYTE1(v35);
          if ( v12 )
            v13 = 1;
          BYTE1(v35) = v13;
        }
LABEL_22:
        if ( v10 == (v3)(hWnd, 0x1004u, 0, 0) )
        {
          BYTE1(v35) = 1;
          memset(&v36, 0, 0x22Cu);
          wcscpy_s(&Dst, 0x104u, &Src);
          v37 = 4;
          v14 = 2;
          v39 = 0;
          if ( a3 )
            v14 = 0;
          v38 = v14;
          qmemcpy(&v16, &v36, 0x22Cu);
          sub_FB73D0(hWnd, v16);
          v3 = SendMessageW;
        }
        v8 = v30 + 1;
        v30 = v8;
      }
      while ( v8 < v34 );
      v4 = v28;
    }
    v21 = v33;
    (*(*v33 + 2))(v33);
    j__free(v29);
    if ( v32 != v4 || BYTE1(v35) )
      InvalidateRect(hWnd, 0, 0);
    v21 = v27;
    (*(*v27 + 2))(v27);
  }
  if ( BYTE1(v35) )
    v3(hWnd, 0xBu, 1u, 0);
  v21 = ppv;
  return (*(*ppv + 8))(ppv);
}
// 103F40C: using guessed type GUID stru_103F40C;
// 106A09A: using guessed type char byte_106A09A;

//----- (00FC7DD0) --------------------------------------------------------
signed int __stdcall sub_FC7DD0(int (__stdcall ***a1)(_DWORD, GUID *, int *))
{
  int (__stdcall ***v1)(_DWORD, GUID *, int *); // esi
  int (__stdcall **v2)(_DWORD, GUID *, int *); // eax
  int (__stdcall ***v3)(_DWORD, GUID *, int *); // eax
  signed int v4; // esi
  int (__stdcall **v5)(_DWORD, GUID *, int *); // eax
  int v6; // eax
  int (__stdcall **v7)(_DWORD, GUID *, int *); // eax
  int v8; // ecx
  int *v10; // [esp+8h] [ebp-14h]
  int v11; // [esp+Ch] [ebp-10h]
  int v12; // [esp+18h] [ebp-4h]

  v1 = a1;
  if ( !a1 )
    return 3;
  a1 = 0;
  v2 = *v1;
  v12 = 0;
  if ( (*v2)(v1, &stru_103FBB8, &a1) || (v3 = a1) == 0 )
  {
    v11 = 0;
    v5 = *v1;
    LOBYTE(v12) = 1;
    if ( !(*v5)(v1, &stru_103FBC8, &v11) )
    {
      v6 = v11;
      if ( v11 )
      {
        v4 = 1;
LABEL_11:
        LOBYTE(v12) = 0;
        if ( v6 )
          (*(*v6 + 8))(v6);
        v3 = a1;
        goto LABEL_14;
      }
    }
    v10 = 0;
    v7 = *v1;
    LOBYTE(v12) = 2;
    if ( !(*v7)(v1, &stru_103FBD8, &v10) && v10 )
    {
      v8 = *v10;
      v4 = 2;
      LOBYTE(v12) = 1;
      (*(v8 + 8))(v10);
      v6 = v11;
      goto LABEL_11;
    }
    LOBYTE(v12) = 1;
    if ( v10 )
      (*(*v10 + 8))(v10);
    LOBYTE(v12) = 0;
    if ( v11 )
      (*(*v11 + 8))(v11);
    v12 = -1;
    if ( a1 )
      ((*a1)[2])(a1);
    return 3;
  }
  v4 = 0;
LABEL_14:
  v12 = -1;
  if ( v3 )
    ((*v3)[2])(v3);
  return v4;
}
// 103FBB8: using guessed type GUID stru_103FBB8;
// 103FBC8: using guessed type GUID stru_103FBC8;
// 103FBD8: using guessed type GUID stru_103FBD8;

//----- (00FC7F10) --------------------------------------------------------
int __cdecl sub_FC7F10(int a1, LPCWSTR lpsz, int a3)
{
  wchar_t **v3; // eax
  void **v4; // edi

  *a3 = 0;
  *(a3 + 4) = 0;
  v3 = sub_FCE760(a1, lpsz);
  v4 = v3;
  if ( v3 && sub_FCECA0(v3, a3, 0) )
  {
    sub_FCEC80(v4);
    j__free(v4);
  }
  return a3;
}

//----- (00FC7F60) --------------------------------------------------------
int __thiscall sub_FC7F60(_DWORD *this)
{
  return this[7];
}

//----- (00FC7F70) --------------------------------------------------------
void __thiscall sub_FC7F70(_DWORD *this)
{
  _DWORD *v1; // esi
  unsigned int v2; // edi
  _DWORD *v3; // eax
  int v4; // edx
  _DWORD *v5; // eax
  int i; // edx

  v1 = this;
  if ( !this[4] )
  {
    v2 = 12 * this[5];
    if ( !is_mul_ok(0xCu, this[5]) || v2 > 0xFFFFFFFF || -1 - v2 < 4 || (v3 = malloc(v2 + 4)) == 0 )
      ATL::AtlThrowImpl(-2147024882);
    *v3 = v1[3];
    v1[3] = v3;
    v4 = v1[5];
    v5 = &v3[3 * v4 - 2];
    for ( i = v4 - 1; i >= 0; --i )
    {
      *v5 = v1[4];
      v1[4] = v5;
      v5 -= 3;
    }
  }
}

//----- (00FC7FF0) --------------------------------------------------------
signed int __stdcall sub_FC7FF0(unsigned int a1, _DWORD *a2, unsigned int *a3)
{
  int *v3; // edi
  unsigned int v5; // edx
  void *v6; // esi
  void *v7; // eax
  int v8; // ecx
  void *v9; // eax
  _DWORD *v10; // edi
  unsigned int v11; // edx
  int v12; // [esp+4h] [ebp-4h]

  v3 = a1;
  if ( (*(*a1 + 16))(a1, 0, &a1, 0) )
    return 0;
  v5 = a1;
  v6 = 0;
  if ( a1 )
  {
    v7 = operator new[](4 * a1);
    v8 = *v3;
    v6 = v7;
    v12 = 0;
    if ( (*(v8 + 16))(v3, a1, &v12, v7) )
    {
      j_j__free(v6);
      return 0;
    }
    v5 = a1;
  }
  *a3 = v5;
  if ( v5 )
  {
    v9 = operator new[](4 * v5);
    v10 = a2;
    v11 = 0;
    *a2 = v9;
    if ( a1 )
    {
      do
      {
        *(*v10 + 4 * v11) = *(v6 + v11);
        ++v11;
      }
      while ( v11 < a1 );
    }
  }
  j_j__free(v6);
  return 1;
}

//----- (00FC80C0) --------------------------------------------------------
signed int __stdcall sub_FC80C0(int (__stdcall ***a1)(_DWORD, GUID *, int *), _DWORD *a2)
{
  _DWORD *v2; // ecx
  int v3; // eax
  int v4; // eax
  int v5; // ecx
  signed int v6; // esi
  int (__stdcall **v7)(_DWORD, GUID *, int *); // eax
  _DWORD *v8; // ecx
  int v9; // eax
  int v10; // eax
  int (__stdcall **v11)(_DWORD, GUID *, int *); // eax
  int v12; // ecx
  wchar_t *v13; // ecx
  signed int v14; // edx
  wchar_t v15; // ax
  char v17; // [esp+Ch] [ebp-1B38h]
  char v18; // [esp+10h] [ebp-1B34h]
  char v19; // [esp+14h] [ebp-1B30h]
  char v20; // [esp+18h] [ebp-1B2Ch]
  char v21; // [esp+1Ch] [ebp-1B28h]
  char v22; // [esp+20h] [ebp-1B24h]
  char v23; // [esp+24h] [ebp-1B20h]
  char v24; // [esp+28h] [ebp-1B1Ch]
  char v25; // [esp+2Ch] [ebp-1B18h]
  int v26; // [esp+30h] [ebp-1B14h]
  int v27; // [esp+34h] [ebp-1B10h]
  int v28; // [esp+38h] [ebp-1B0Ch]
  int v29; // [esp+3Ch] [ebp-1B08h]
  int v30; // [esp+40h] [ebp-1B04h]
  int v31; // [esp+44h] [ebp-1B00h]
  int v32; // [esp+48h] [ebp-1AFCh]
  int v33; // [esp+4Ch] [ebp-1AF8h]
  int (__stdcall ***v34)(_DWORD, GUID *, int *); // [esp+50h] [ebp-1AF4h]
  _DWORD *v35; // [esp+54h] [ebp-1AF0h]
  _DWORD *v36; // [esp+58h] [ebp-1AECh]
  int v37; // [esp+5Ch] [ebp-1AE8h]
  int v38; // [esp+60h] [ebp-1AE4h]
  int *v39; // [esp+64h] [ebp-1AE0h]
  int v40; // [esp+68h] [ebp-1ADCh]
  int v41; // [esp+12Ch] [ebp-1A18h]
  wchar_t Dst; // [esp+334h] [ebp-1810h]
  char v43; // [esp+B34h] [ebp-1010h]
  char v44; // [esp+F34h] [ebp-C10h]
  wchar_t Ext; // [esp+1334h] [ebp-810h]
  wchar_t Filename; // [esp+1534h] [ebp-610h]
  wchar_t FullPath; // [esp+1734h] [ebp-410h]
  int v48; // [esp+1B40h] [ebp-4h]

  if ( sub_FC7DD0(a1) == 1 )
  {
    v2 = 0;
    v36 = 0;
    if ( a1 )
    {
      v3 = (**a1)(a1, &stru_103FBC8, &v36);
      v2 = v36;
      if ( v3 < 0 )
        v2 = 0;
      v36 = v2;
    }
    v4 = *v2;
    v48 = 0;
    if ( (*(v4 + 44))(v2, &v29) )
    {
LABEL_15:
      v5 = v36;
      v6 = 0;
    }
    else
    {
      switch ( v29 )
      {
        case 3:
          sub_FC8A30(a2, "[AppDomain Transition]", 0, 0, 1);
          v5 = v36;
          v6 = 1;
          break;
        case 4:
          sub_FC8A30(a2, "[Lightweight function]", 0, 0, 1);
          v5 = v36;
          v6 = 1;
          break;
        case 5:
          sub_FC8A30(a2, "[Func Eval]", 0, 0, 1);
          v5 = v36;
          v6 = 1;
          break;
        case 7:
          sub_FC8A30(a2, "[Class Init]", 0, 0, 1);
          v5 = v36;
          v6 = 1;
          break;
        case 8:
          sub_FC8A30(a2, "[Exception]", 0, 0, 1);
          v5 = v36;
          v6 = 1;
          break;
        case 9:
          sub_FC8A30(a2, "[Security]", 0, 0, 1);
          v5 = v36;
          v6 = 1;
          break;
        case 10:
          sub_FC8A30(a2, "[JIT Compilation]", 0, 0, 1);
          v5 = v36;
          v6 = 1;
          break;
        default:
          goto LABEL_15;
      }
    }
  }
  else
  {
    v34 = 0;
    v7 = *a1;
    v48 = 1;
    if ( (*v7)(a1, &stru_103FBB8, &v34) )
    {
      v6 = 0;
    }
    else
    {
      v8 = 0;
      v35 = 0;
      if ( v34 )
      {
        v9 = (**v34)(v34, &stru_103FD30, &v35);
        v8 = v35;
        if ( v9 < 0 )
          v8 = 0;
        v35 = v8;
      }
      v33 = 0;
      v10 = *v8;
      LOBYTE(v48) = 3;
      if ( (*(v10 + 52))(v8, &v33) || (memset(&v40, 0, 0x2CCu), v40 = 65539, (*(*v33 + 24))(v33, 716, &v40)) )
      {
        v6 = 0;
      }
      else
      {
        v37 = 0;
        v11 = *a1;
        LOBYTE(v48) = 4;
        if ( (v11[5])(a1, &v37) || (*(*v37 + 20))(v37, &v30) )
        {
          v6 = 0;
        }
        else
        {
          v39 = 0;
          LOBYTE(v48) = 5;
          if ( (*(*v37 + 12))(v37, &v39) )
          {
            v6 = 0;
          }
          else
          {
            v38 = 0;
            v12 = *v39;
            LOBYTE(v48) = 6;
            if ( (*(v12 + 56))(v39, &stru_103F3CC, &v38)
              || (*(*v38 + 120))(v38, v30, &v28, &v44, 512, &v21, &v23, &v24, &v18, &v22, &v25)
              || (*(*v38 + 48))(v38, v28, &v43, 512, &v20, &v17, &v19) )
            {
              v6 = 0;
            }
            else
            {
              sub_FC7560(&v31, a1);
              LOBYTE(v48) = 7;
              if ( (*(*v31 + 44))(v31, &v27) )
              {
                v6 = 0;
              }
              else
              {
                v32 = 0;
                LOBYTE(v48) = 8;
                if ( (*(*v39 + 20))(v39, &v32) )
                {
                  v6 = 0;
                }
                else
                {
                  v26 = 512;
                  if ( (*(*v39 + 24))(v39, 512, &v26, &FullPath)
                    || _wsplitpath_s(&FullPath, 0, 0, 0, 0, &Filename, 0x100u, &Ext, 0x100u) )
                  {
                    v13 = &FullPath;
                    v14 = 512;
                    while ( v14 != -2147483134 )
                    {
                      v15 = *(v13 + L"<Unresolved>" - &FullPath);
                      if ( !v15 )
                        break;
                      *v13 = v15;
                      ++v13;
                      if ( !--v14 )
                        goto LABEL_44;
                    }
                    if ( v14 )
                      goto LABEL_45;
LABEL_44:
                    --v13;
LABEL_45:
                    *v13 = 0;
                  }
                  else
                  {
                    swprintf_s(&FullPath, 0x200u, L"%s%s", &Filename, &Ext);
                  }
                  swprintf_s(&Dst, 0x400u, L"%s!%s.%s+0x%x", &FullPath, &v43, &v44, v27);
                  sub_FC8A90(a2, &Dst, v41, 0, 0);
                  v6 = 1;
                }
                LOBYTE(v48) = 7;
                if ( v32 )
                  (*(*v32 + 8))(v32);
              }
              LOBYTE(v48) = 6;
              if ( v31 )
                (*(*v31 + 8))(v31);
            }
            LOBYTE(v48) = 5;
            if ( v38 )
              (*(*v38 + 8))(v38);
          }
          LOBYTE(v48) = 4;
          if ( v39 )
            (*(*v39 + 8))(v39);
        }
        LOBYTE(v48) = 3;
        if ( v37 )
          (*(*v37 + 8))(v37);
      }
      LOBYTE(v48) = 2;
      if ( v33 )
        (*(*v33 + 8))(v33);
      LOBYTE(v48) = 1;
      if ( v35 )
        (*(*v35 + 8))(v35);
    }
    v5 = v34;
  }
  v48 = -1;
  if ( v5 )
    (*(*v5 + 8))(v5);
  return v6;
}
// 103F3CC: using guessed type GUID stru_103F3CC;
// 103FBB8: using guessed type GUID stru_103FBB8;
// 103FBC8: using guessed type GUID stru_103FBC8;
// 103FD30: using guessed type GUID stru_103FD30;
// 103FD40: using guessed type wchar_t aUnresolved[13];

//----- (00FC86C0) --------------------------------------------------------
int __stdcall sub_FC86C0(int a1, _DWORD *a2)
{
  *a2 = 0;
  return 0;
}

//----- (00FC86E0) --------------------------------------------------------
int *__cdecl sub_FC86E0(wchar_t *a1, int a2)
{
  int *result; // eax
  int *v3; // esi
  wchar_t Dst; // [esp+Ch] [ebp-20Ch]

  result = sub_FCED60(a2);
  v3 = result;
  if ( result )
  {
    do
    {
      if ( sub_FCE850(v3, &Dst, 0x104u) && !_wcsnicmp(a1, &Dst, wcslen(a1)) )
        break;
      if ( v3 )
        j__free(v3);
      v3 = sub_FCEE00(a2);
    }
    while ( v3 );
    result = v3;
  }
  return result;
}

//----- (00FC8790) --------------------------------------------------------
int __cdecl sub_FC8790(wchar_t *Src, wchar_t *Dst)
{
  wchar_t *v2; // eax
  int result; // eax

  wcscpy_s(Dst, 0x104u, Src);
  v2 = wcsrchr(Dst, 0x2Eu);
  if ( v2 && v2 != Dst )
    *v2 = 0;
  result = 0;
  Dst[14] = 0;
  return result;
}

//----- (00FC87D0) --------------------------------------------------------
int __stdcall sub_FC87D0(int a1, DWORD dwThreadId, int a3, int a4, int a5)
{
  HANDLE v5; // edi
  HANDLE v7; // eax
  void *v8; // esi
  THREADENTRY32 te; // [esp+10h] [ebp-20h]

  v5 = CreateToolhelp32Snapshot(4u, *(a1 + 12));
  if ( v5 == -1 )
    return -2147467259;
  te.dwSize = 28;
  if ( !Thread32First(v5, &te) )
    goto LABEL_6;
  while ( te.th32OwnerProcessID != *(a1 + 12) || te.th32ThreadID != dwThreadId )
  {
    if ( !Thread32Next(v5, &te) )
      goto LABEL_6;
  }
  v7 = OpenThread(0x1F03FFu, 1, dwThreadId);
  v8 = v7;
  if ( !v7 )
  {
LABEL_6:
    CloseHandle(v5);
    return -2147467259;
  }
  if ( !GetThreadContext(v7, a5) )
  {
    CloseHandle(v8);
    CloseHandle(v5);
    return -2147467259;
  }
  CloseHandle(v8);
  CloseHandle(v5);
  return 0;
}

//----- (00FC88A0) --------------------------------------------------------
char __thiscall sub_FC88A0(const void **this, unsigned int a2)
{
  char *v2; // esi
  const void **v3; // edi
  unsigned int v4; // edx
  void *v5; // eax
  char *v7; // ecx
  void *v8; // ecx
  int v9; // eax
  const void *v10; // [esp+10h] [ebp+8h]

  v2 = a2;
  v3 = this;
  v4 = this[2];
  if ( a2 > v4 )
  {
    if ( *this )
    {
      v7 = this[3];
      if ( !v7 )
      {
        v7 = (v4 >> 1);
        if ( a2 - v4 > v4 >> 1 )
          v7 = (a2 - v4);
      }
      if ( a2 < &v7[v4] )
        v2 = &v7[v4];
      v8 = calloc(v2, 4u);
      v10 = v8;
      if ( !v8 )
        return 0;
      v9 = memmove_s(v8, 4 * v3[1], *v3, 4 * v3[1]);
      sub_FAB650(v9);
      free(*v3);
      *v3 = v10;
    }
    else
    {
      if ( this[3] > a2 )
        v2 = this[3];
      v5 = calloc(v2, 4u);
      *v3 = v5;
      if ( !v5 )
        return 0;
    }
    v3[2] = v2;
  }
  return 1;
}

//----- (00FC8940) --------------------------------------------------------
FARPROC __thiscall sub_FC8940(_DWORD *this, _DWORD *a2)
{
  _DWORD *v2; // esi
  HMODULE v3; // eax
  FARPROC result; // eax
  _DWORD *v5; // eax
  _DWORD *v6; // edi
  int v7; // ecx
  int v8; // edx
  int v9; // ecx
  _DWORD *v10; // eax
  int v11; // edi
  int v12; // ecx
  int v13; // ecx

  v2 = this;
  this[5] = a2;
  this[2] = *a2;
  this[3] = a2[3];
  v3 = LoadLibraryW(L"mscoree.dll");
  result = GetProcAddress(v3, "CLRCreateInstance");
  if ( result )
  {
    if ( (result)(&stru_103F3EC, &stru_103F3DC, v2 + 6) )
    {
      result = 0;
    }
    else
    {
      v5 = operator new(0x10u);
      v6 = v5;
      if ( v5 )
      {
        v7 = v2[3];
        v8 = v2[2];
        *v5 = &CCorDebugDataTarget::`vftable';
        v5[1] = 1;
        v5[2] = v7;
        v5[3] = v8;
      }
      else
      {
        v6 = 0;
      }
      v9 = v2[8];
      if ( v9 )
        (*(*v9 + 8))(v2[8]);
      v2[8] = v6;
      v10 = operator new(0xCu);
      v11 = v10;
      if ( v10 )
      {
        v12 = v2[2];
        *v10 = &CCLRDebuggingLibraryProvider::`vftable';
        v10[1] = 1;
        v10[2] = v12;
      }
      else
      {
        v11 = 0;
      }
      v13 = v2[9];
      if ( v13 )
        (*(*v13 + 8))(v2[9]);
      v2[9] = v11;
      result = (sub_FC9500(v2, v2[8], v2[6], v11) == 0);
    }
  }
  return result;
}
// 103F3DC: using guessed type GUID stru_103F3DC;
// 103F3EC: using guessed type GUID stru_103F3EC;
// 103F440: using guessed type void *CCorDebugDataTarget::`vftable';
// 103F45C: using guessed type void *CCLRDebuggingLibraryProvider::`vftable';

//----- (00FC8A30) --------------------------------------------------------
int __thiscall sub_FC8A30(_DWORD *this, int a2, int a3, int a4, int a5)
{
  _DWORD *v5; // esi
  wchar_t *v6; // ST00_4
  int result; // eax

  v5 = this;
  if ( a2 )
  {
    v6 = this[7];
    this[4] = a3;
    this[5] = a4;
    swprintf_s(v6, 0x400u, L"%S", a2);
    result = a5;
  }
  else
  {
    result = a5;
    this[4] = 0;
    this[5] = 0;
  }
  v5[6] = a5;
  return result;
}

//----- (00FC8A90) --------------------------------------------------------
int __thiscall sub_FC8A90(_DWORD *this, int a2, int a3, int a4, int a5)
{
  _DWORD *v5; // esi
  wchar_t *v6; // ST00_4
  int result; // eax

  v5 = this;
  if ( a2 )
  {
    v6 = this[7];
    this[4] = a3;
    this[5] = a4;
    swprintf_s(v6, 0x400u, L"%s", a2);
    result = a5;
  }
  else
  {
    result = a5;
    this[7] = 0;
  }
  v5[6] = a5;
  return result;
}

//----- (00FC8AE0) --------------------------------------------------------
void __thiscall sub_FC8AE0(int *this, unsigned int a2, int *a3, unsigned int a4)
{
  int *v4; // ebx
  unsigned int v5; // edi
  unsigned int v6; // esi
  int v7; // eax
  unsigned int v8; // edi
  unsigned int v9; // eax
  unsigned int v10; // ebx
  int v11; // ecx
  int v12; // eax
  const void *v13; // edx
  int v14; // eax
  _DWORD *v15; // eax
  int *v16; // ebx
  int v17; // edi
  int v18; // eax
  int v19; // [esp+0h] [ebp-30h]
  unsigned int v20; // [esp+10h] [ebp-20h]
  int *v21; // [esp+14h] [ebp-1Ch]
  unsigned int v22; // [esp+18h] [ebp-18h]
  unsigned int v23; // [esp+1Ch] [ebp-14h]
  int *v24; // [esp+20h] [ebp-10h]
  int v25; // [esp+2Ch] [ebp-4h]

  v24 = &v19;
  v4 = this;
  v21 = this;
  v5 = this[1];
  v6 = a2;
  v23 = v5;
  if ( a2 >= v5 )
  {
    if ( -1 - a2 >= a4 )
    {
      v22 = a2 + a4;
      if ( !sub_FC9B80(this, a2 + a4, -1) )
        ATL::AtlThrowImpl(-2147024882);
      goto LABEL_16;
    }
LABEL_5:
    ATL::AtlThrowImpl(-2147024362);
  }
  v20 = v5;
  if ( -1 - v5 < a4 )
    goto LABEL_5;
  if ( !sub_FC9B80(this, v5 + a4, -1) )
    ATL::AtlThrowImpl(-2147024882);
  v7 = *v4 + 4 * v5;
  v8 = 0;
  v22 = v7;
  v9 = a4;
  if ( a4 )
  {
    v10 = v22;
    do
    {
      v11 = *(v10 + 4 * v8);
      if ( v11 )
      {
        (*(*v11 + 8))(*(v10 + 4 * v8));
        v9 = a4;
      }
      ++v8;
    }
    while ( v8 < v9 );
    v4 = v21;
  }
  v12 = *v4;
  v13 = (*v4 + 4 * a2);
  v23 -= a2;
  v22 = a2 + a4;
  v14 = memmove_s((v12 + 4 * (a2 + a4)), 4 * v23, v13, 4 * v23);
  sub_FAB650(v14);
  v15 = (4 * a2 + *v4);
  v25 = 0;
  sub_FC79A0(v15, a4);
  v25 = -1;
LABEL_16:
  if ( a2 < v22 )
  {
    do
    {
      v16 = (*v4 + 4 * v6);
      v17 = *a3;
      if ( *v16 != *a3 )
      {
        if ( v17 )
          (*(*v17 + 4))(*a3);
        v18 = *v16;
        *v16 = v17;
        if ( v18 )
          (*(*v18 + 8))(v18);
      }
      v4 = v21;
      ++v6;
    }
    while ( v6 < v22 );
  }
}
// 10081AA: using guessed type void __stdcall __noreturn _CxxThrowException(_DWORD, _DWORD);

//----- (00FC8C80) --------------------------------------------------------
int (__stdcall ***__stdcall sub_FC8C80(int (__stdcall ***a1)(_DWORD, GUID *, int *)))(_DWORD, GUID *, int *)
{
  _DWORD *v1; // ecx
  int v2; // eax
  int v3; // eax
  int v4; // eax
  int (__stdcall ***v5)(_DWORD, GUID *, int *); // esi
  _DWORD *v7; // [esp+8h] [ebp-10h]
  int v8; // [esp+14h] [ebp-4h]

  v1 = 0;
  v7 = 0;
  if ( a1 )
  {
    v2 = (**a1)(a1, &stru_103FBC8, &v7);
    v1 = v7;
    if ( v2 < 0 )
      v1 = 0;
    v7 = v1;
  }
  v3 = *v1;
  v8 = 0;
  v4 = (*(v3 + 44))(v1, &a1);
  v5 = a1;
  v8 = -1;
  if ( v4 )
    v5 = 0;
  if ( v7 )
    (*(*v7 + 8))(v7);
  return v5;
}
// 103FBC8: using guessed type GUID stru_103FBC8;

//----- (00FC8D10) --------------------------------------------------------
signed int __thiscall sub_FC8D10(_DWORD *this, int a2)
{
  int v2; // ST08_4
  int v3; // esi
  signed int v4; // esi
  int v6; // [esp+8h] [ebp-18h]
  int v7; // [esp+Ch] [ebp-14h]
  int v8; // [esp+10h] [ebp-10h]
  int v9; // [esp+1Ch] [ebp-4h]

  v8 = 0;
  v2 = this[7];
  v9 = 0;
  if ( !(*(*v2 + 28))(v2, &v8) )
  {
    v7 = 0;
    if ( !(*(*v8 + 28))(v8, 1, &v6, &v7) )
    {
      v3 = a2;
      do
      {
        a2 = 0;
        if ( (*(*v6 + 16))(v6, &a2) )
          break;
        if ( a2 == v3 )
        {
          v4 = 1;
          goto LABEL_8;
        }
      }
      while ( !(*(*v8 + 28))(v8, 1, &v6, &v7) );
    }
  }
  v4 = 0;
LABEL_8:
  v9 = -1;
  if ( v8 )
    (*(*v8 + 8))(v8);
  return v4;
}

//----- (00FC8DE0) --------------------------------------------------------
BOOL __cdecl sub_FC8DE0(int a1)
{
  return !(*(*a1 + 44))(a1, &a1) && (a1 == 6 || a1 == 7 || a1 == 8 || a1 == 9 || a1 == 10);
}

//----- (00FC8E20) --------------------------------------------------------
int __thiscall sub_FC8E20(void *this, int a2, int a3, int *a4, _DWORD *a5, _DWORD *a6, int a7, unsigned int a8, unsigned int *a9)
{
  int v9; // edx
  bool v10; // zf
  int (__stdcall ***v11)(_DWORD, GUID *, int *); // eax
  int v12; // eax
  int v13; // esi
  unsigned int v14; // eax
  int v15; // eax
  int v16; // eax
  int v17; // esi
  int v19; // eax
  unsigned int v20; // eax
  int v21; // ecx
  int v22; // eax
  unsigned int v23; // edi
  unsigned int v24; // ebx
  int v25; // eax
  int v26; // [esp+10h] [ebp-5E4h]
  __int64 v27; // [esp+14h] [ebp-5E0h]
  __int64 v28; // [esp+1Ch] [ebp-5D8h]
  int v29; // [esp+24h] [ebp-5D0h]
  int *v30; // [esp+28h] [ebp-5CCh]
  __int64 v31; // [esp+2Ch] [ebp-5C8h]
  int *v32; // [esp+34h] [ebp-5C0h]
  _DWORD *v33; // [esp+38h] [ebp-5BCh]
  _DWORD *v34; // [esp+3Ch] [ebp-5B8h]
  int (__stdcall ***v35)(_DWORD, GUID *, int *); // [esp+40h] [ebp-5B4h]
  void *v36; // [esp+44h] [ebp-5B0h]
  int v37; // [esp+48h] [ebp-5ACh]
  int v38; // [esp+4Ch] [ebp-5A8h]
  int v39; // [esp+318h] [ebp-2DCh]
  unsigned int v40; // [esp+3DCh] [ebp-218h]
  int v41; // [esp+5F0h] [ebp-4h]

  v36 = this;
  v9 = a3;
  v10 = *a5 == 1;
  HIDWORD(v28) = a2;
  v30 = a4;
  v37 = a3;
  v29 = a7;
  if ( v10 )
    return 0;
  v10 = *a6 == 1;
  v31 = 0i64;
  if ( !v10 )
  {
    *a6 = 1;
    HIDWORD(v31) = 1;
    goto LABEL_29;
  }
  if ( *v30 )
  {
    if ( sub_FC7DD0(*v30) == 1 )
    {
      if ( *a9 < a8 )
        ++*a9;
      v11 = sub_FC8C80(*v30);
      v9 = v37;
      if ( v11 == 5 )
        LODWORD(v31) = 1;
      goto LABEL_29;
    }
    v9 = v37;
  }
  v12 = (*(*v9 + 20))(v9);
  if ( v12 == 1250084 )
  {
    *a5 = 1;
    goto LABEL_12;
  }
  if ( v12 < 0 )
    _CxxThrowException(0, 0);
  v9 = v37;
LABEL_29:
  if ( *a5 )
  {
LABEL_12:
    if ( *a9 < a8 )
    {
      v13 = v29;
      while ( 1 )
      {
        v34 = 0;
        v14 = *a9;
        v41 = 8;
        v10 = (***(v13 + 4 * v14))(*(v13 + 4 * v14), &stru_103FBC8, &v34) == 0;
        v15 = v34;
        if ( !v10 )
          break;
        if ( (*(*v34 + 44))(v34, &v31 + 4)
          || HIDWORD(v31) != 6 && HIDWORD(v31) != 7 && HIDWORD(v31) != 8 && HIDWORD(v31) != 9 && HIDWORD(v31) != 10 )
        {
          *v30 = *(v13 + 4 * *a9);
          v25 = v34;
          goto LABEL_95;
        }
        v41 = -1;
        if ( v34 )
          (*(*v34 + 8))(v34);
        if ( ++*a9 >= a8 )
          return 0;
      }
LABEL_45:
      v41 = -1;
      if ( v15 )
        (*(*v15 + 8))(v15);
    }
    return 0;
  }
  v33 = 0;
  v16 = *v9;
  v41 = 0;
  (*(v16 + 24))(v9, &v33);
  v17 = v33;
  if ( !v33 )
  {
    *v30 = v33;
    return v17 + 1;
  }
  v19 = *v33;
  v34 = v33;
  (*(v19 + 4))(v33);
  if ( *a9 >= a8 )
    goto LABEL_92;
  while ( 1 )
  {
    v35 = 0;
    v20 = *a9;
    LOBYTE(v41) = 2;
    if ( (***(v29 + 4 * v20))(*(v29 + 4 * v20), &stru_103FBC8, &v35) )
      goto LABEL_42;
    if ( !sub_FC8DE0(v35) )
      break;
    LOBYTE(v41) = 1;
    if ( v35 )
      ((*v35)[2])(v35);
    if ( ++*a9 >= a8 )
      goto LABEL_92;
  }
  sub_FC7520(&v32, v35);
  v21 = *v32;
  LOBYTE(v41) = 3;
  if ( (*(v21 + 16))(v32, v17, &v26) )
  {
LABEL_40:
    LOBYTE(v41) = 2;
    if ( v32 )
      (*(*v32 + 8))(v32);
LABEL_42:
    LOBYTE(v41) = 1;
    if ( v35 )
      ((*v35)[2])(v35);
    v22 = *v17;
    LOBYTE(v41) = 0;
    (*(v22 + 8))(v17);
    v15 = v33;
    goto LABEL_45;
  }
  if ( !v26 )
  {
    if ( sub_FC8C80(v35) != 1 )
      goto LABEL_88;
    memset(&v38, 0, 0x2CCu);
    v38 = 65539;
    if ( (*(*v37 + 12))(v37, 65539, 716, &v29, &v38) )
      goto LABEL_40;
    v37 = 0;
    LOBYTE(v41) = 4;
    if ( (*(*HIDWORD(v28) + 12))(HIDWORD(v28), &v37) )
    {
LABEL_54:
      LOBYTE(v41) = 3;
      if ( v37 )
        (*(*v37 + 8))(v37);
      goto LABEL_40;
    }
    if ( v31 == 1 || HIDWORD(v31) == 1 )
      (*(*v37 + 16))(v37, 1, 716, &v38);
    else
      (*(*v37 + 16))(v37, 2, 716, &v38);
    v36 = 0;
    v28 = 0i64;
    v27 = 0i64;
    LOBYTE(v41) = 5;
    if ( (*(*v37 + 24))(v37, &v36) )
    {
      v31 = __PAIR__(v28, HIDWORD(v28));
    }
    else
    {
      memset(&v39, 0, 0x2CCu);
      v39 = 65539;
      if ( (*(*v37 + 12))(v37, 65539, 716, &v28 + 4, &v39) )
        goto LABEL_62;
      HIDWORD(v31) = v40;
      LODWORD(v31) = 0;
    }
    LOBYTE(v41) = 4;
    if ( v36 )
      (*(*v36 + 8))(v36);
    if ( (*(*v37 + 20))(v37) )
    {
      v24 = HIDWORD(v27);
      v23 = v27;
    }
    else
    {
      v36 = 0;
      LOBYTE(v41) = 6;
      if ( (*(*v37 + 24))(v37, &v36) )
      {
        v24 = HIDWORD(v27);
        v23 = v27;
      }
      else
      {
        memset(&v39, 0, 0x2CCu);
        v39 = 65539;
        if ( (*(*v37 + 12))(v37, 65539, 716, &v28 + 4, &v39) )
          goto LABEL_62;
        v23 = v40;
        v24 = 0;
      }
      LOBYTE(v41) = 4;
      if ( v36 )
        (*(*v36 + 8))(v36);
    }
    if ( !v31 || !(v24 | v23) || v31 > v24 || v31 >= v24 && HIDWORD(v31) >= v23 )
    {
LABEL_86:
      LOBYTE(v41) = 3;
      if ( v37 )
        (*(*v37 + 8))(v37);
      goto LABEL_88;
    }
    v36 = 0;
    LOBYTE(v41) = 7;
    (*(*v37 + 24))(v37, &v36);
    if ( !(*(*v32 + 16))(v32, v36, &v28 + 4) )
    {
      if ( HIDWORD(v28) )
      {
        sub_FC7600(&v34, v35);
        v17 = v34;
      }
      LOBYTE(v41) = 4;
      if ( v36 )
        (*(*v36 + 8))(v36);
      goto LABEL_86;
    }
LABEL_62:
    LOBYTE(v41) = 4;
    if ( v36 )
      (*(*v36 + 8))(v36);
    goto LABEL_54;
  }
  sub_FC7600(&v34, *(v29 + 4 * *a9));
  v17 = v34;
LABEL_88:
  LOBYTE(v41) = 2;
  if ( v32 )
    (*(*v32 + 8))(v32);
  LOBYTE(v41) = 1;
  if ( v35 )
    ((*v35)[2])(v35);
LABEL_92:
  LOBYTE(v41) = 0;
  *v30 = v17;
  if ( v17 )
    (*(*v17 + 8))(v17);
  v25 = v33;
LABEL_95:
  v41 = -1;
  if ( v25 )
    (*(*v25 + 8))(v25);
  return 1;
}
// 10081AA: using guessed type void __stdcall __noreturn _CxxThrowException(_DWORD, _DWORD);
// 103FBC8: using guessed type GUID stru_103FBC8;

//----- (00FC9500) --------------------------------------------------------
signed int __thiscall sub_FC9500(_DWORD *this, int a2, int a3, int a4)
{
  _DWORD *v4; // edi
  DWORD v5; // ST24_4
  HANDLE v6; // esi
  char v8; // [esp+14h] [ebp-45Ch]
  int v9; // [esp+18h] [ebp-458h]
  int v10; // [esp+1Ch] [ebp-454h]
  MODULEENTRY32W me; // [esp+20h] [ebp-450h]
  __int16 v12; // [esp+448h] [ebp-28h]
  __int16 v13; // [esp+454h] [ebp-1Ch]
  int v14; // [esp+456h] [ebp-1Ah]
  int v15; // [esp+45Ah] [ebp-16h]
  int v16; // [esp+46Ch] [ebp-4h]

  v4 = this;
  v9 = a2;
  v10 = a4;
  v14 = 4;
  v15 = -1;
  v13 = 0;
  v5 = this[2];
  v16 = 0;
  v12 = 0;
  v6 = CreateToolhelp32Snapshot(8u, v5);
  if ( v6 == -1 )
    return -2147467259;
  me.dwSize = 1064;
  if ( !Module32FirstW(v6, &me) )
  {
LABEL_6:
    CloseHandle(v6);
    return -2147467259;
  }
  while ( me.th32ProcessID != v4[2]
       || (*(*a3 + 12))(a3, me.modBaseAddr, me.modBaseAddr >> 31, v9, v10, &v13, &stru_103FBA8, v4 + 7, &v12, &v8) )
  {
    if ( !Module32NextW(v6, &me) )
      goto LABEL_6;
  }
  CloseHandle(v6);
  return 0;
}
// 103FBA8: using guessed type GUID stru_103FBA8;

//----- (00FC9620) --------------------------------------------------------
signed int __stdcall sub_FC9620(int a1, int a2, int a3, int a4, HMODULE *a5)
{
  signed int v5; // edi
  HANDLE v6; // ebx
  int v7; // eax
  int v8; // edi
  int v9; // eax
  HMODULE v11; // eax
  MODULEENTRY32W me; // [esp+10h] [ebp-638h]
  WCHAR LibFileName; // [esp+438h] [ebp-210h]

  v5 = 0;
  v6 = CreateToolhelp32Snapshot(8u, *(a1 + 8));
  if ( v6 != -1 )
  {
    me.dwSize = 1064;
    if ( Module32FirstW(v6, &me) )
    {
      while ( 1 )
      {
        if ( me.th32ProcessID == *(a1 + 8) )
        {
          v7 = wcscmp(L"clr.dll", me.szModule);
          if ( v7 )
            v7 = -(v7 < 0) | 1;
          if ( !v7 )
            break;
        }
        if ( !Module32NextW(v6, &me) )
          goto LABEL_11;
      }
      v8 = lstrlenW(me.szExePath);
      v9 = lstrlenW(me.szModule);
      sub_FCA440(&LibFileName, 0x105u, me.szExePath, v8 - v9);
      v5 = 1;
LABEL_11:
      CloseHandle(v6);
      if ( !v5 )
        return -2147467259;
      sub_FCA3A0(&LibFileName, 0x105u, a2);
      v11 = LoadLibraryExW(&LibFileName, 0, 8u);
      if ( !v11 )
        return -2147467259;
      *a5 = v11;
    }
    else
    {
      CloseHandle(v6);
    }
  }
  return 0;
}

//----- (00FC9780) --------------------------------------------------------
signed int __stdcall sub_FC9780(int a1, _DWORD *a2, _DWORD *a3)
{
  _DWORD *v3; // ecx
  _DWORD *v4; // edx
  GUID *v5; // esi
  unsigned int v6; // edi
  bool v7; // cf
  GUID *v9; // edx
  unsigned int v10; // esi

  v3 = a2;
  v4 = a2;
  v5 = &CLSID_IUnknown;
  v6 = 12;
  while ( *v4 == v5->Data1 )
  {
    ++v4;
    v5 = (v5 + 4);
    v7 = v6 < 4;
    v6 -= 4;
    if ( v7 )
    {
      *a3 = a1;
      return 0;
    }
  }
  v9 = &stru_103F3FC;
  v10 = 12;
  while ( *v3 == v9->Data1 )
  {
    ++v3;
    v9 = (v9 + 4);
    v7 = v10 < 4;
    v10 -= 4;
    if ( v7 )
    {
      *a3 = a1;
      (*(*a1 + 4))(a1, v9, a1);
      return 0;
    }
  }
  return -2147467262;
}
// 103F3FC: using guessed type GUID stru_103F3FC;
// 1047BBC: using guessed type GUID CLSID_IUnknown;

//----- (00FC9800) --------------------------------------------------------
signed int __stdcall sub_FC9800(int a1, _DWORD *a2, _DWORD *a3)
{
  _DWORD *v3; // ecx
  _DWORD *v4; // edx
  GUID *v5; // esi
  unsigned int v6; // edi
  bool v7; // cf
  GUID *v9; // edx
  unsigned int v10; // esi

  v3 = a2;
  v4 = a2;
  v5 = &CLSID_IUnknown;
  v6 = 12;
  while ( *v4 == v5->Data1 )
  {
    ++v4;
    v5 = (v5 + 4);
    v7 = v6 < 4;
    v6 -= 4;
    if ( v7 )
    {
      *a3 = a1;
      return 0;
    }
  }
  v9 = &stru_103FB98;
  v10 = 12;
  while ( *v3 == v9->Data1 )
  {
    ++v3;
    v9 = (v9 + 4);
    v7 = v10 < 4;
    v10 -= 4;
    if ( v7 )
    {
      *a3 = a1;
      (*(*a1 + 4))(a1, v9, a1);
      return 0;
    }
  }
  return -2147467262;
}
// 103FB98: using guessed type GUID stru_103FB98;
// 1047BBC: using guessed type GUID CLSID_IUnknown;

//----- (00FC9880) --------------------------------------------------------
signed int __stdcall sub_FC9880(int a1, _DWORD *a2, _DWORD *a3)
{
  _DWORD *v3; // ecx
  GUID *v4; // edx
  unsigned int v5; // esi
  bool v6; // cf

  v3 = a2;
  v4 = &CLSID_IUnknown;
  v5 = 12;
  while ( *v3 == v4->Data1 )
  {
    ++v3;
    v4 = (v4 + 4);
    v6 = v5 < 4;
    v5 -= 4;
    if ( v6 )
    {
      *a3 = a1;
      (*(*a1 + 4))(a1, v4, a1);
      return 0;
    }
  }
  return -2147467262;
}
// 1047BBC: using guessed type GUID CLSID_IUnknown;

//----- (00FC98D0) --------------------------------------------------------
signed int __stdcall sub_FC98D0(int a1, int a2, int a3)
{
  return -2147467262;
}

//----- (00FC98E0) --------------------------------------------------------
int __stdcall sub_FC98E0(int a1, LPCVOID lpBaseAddress, int a3, LPVOID lpBuffer, SIZE_T nSize, SIZE_T *lpNumberOfBytesRead)
{
  return ReadProcessMemory(*(a1 + 8), lpBaseAddress, lpBuffer, nSize, lpNumberOfBytesRead) != 1 ? 0x80004005 : 0;
}

//----- (00FC9910) --------------------------------------------------------
int __stdcall sub_FC9910(void *a1)
{
  bool v1; // zf

  v1 = (*(a1 + 1))-- == 1;
  if ( !v1 )
    return *(a1 + 1);
  j__free(a1);
  return 0;
}

//----- (00FC9940) --------------------------------------------------------
int __stdcall sub_FC9940(_DWORD *a1)
{
  bool v1; // zf
  int result; // eax

  v1 = a1[1]-- == 1;
  result = a1[1];
  if ( v1 )
  {
    (*(*a1 + 12))(1);
    result = 0;
  }
  return result;
}

//----- (00FC9960) --------------------------------------------------------
int __stdcall sub_FC9960(void *a1)
{
  bool v1; // zf
  void *v2; // eax

  v1 = (*(a1 + 1))-- == 1;
  if ( !v1 )
    return *(a1 + 1);
  v2 = *(a1 + 6);
  *a1 = &NativeFrame::`vftable';
  if ( v2 )
  {
    j__free(v2);
    *(a1 + 6) = 0;
  }
  j__free(a1);
  return 0;
}
// 103F430: using guessed type void *NativeFrame::`vftable';

//----- (00FC99B0) --------------------------------------------------------
int __stdcall sub_FC99B0(void *a1)
{
  bool v1; // zf
  void *v2; // eax

  v1 = (*(a1 + 1))-- == 1;
  if ( !v1 )
    return *(a1 + 1);
  v2 = *(a1 + 7);
  *a1 = &SymbolInfo::`vftable';
  if ( v2 )
  {
    j__free(v2);
    *(a1 + 7) = 0;
  }
  j__free(a1);
  return 0;
}
// 103F420: using guessed type void *SymbolInfo::`vftable';

//----- (00FC9A00) --------------------------------------------------------
int __cdecl sub_FC9A00(void *Dst, void *Src, int a3)
{
  int v3; // eax

  v3 = memmove_s(Dst, 4 * a3, Src, 4 * a3);
  return sub_FAB650(v3);
}

//----- (00FC9A30) --------------------------------------------------------
_DWORD *__thiscall sub_FC9A30(_DWORD *this)
{
  _DWORD *v1; // esi
  _DWORD *v2; // edi
  int v3; // ecx
  bool v4; // zf
  _DWORD *result; // eax
  _DWORD *v6; // edi

  v1 = this;
  while ( v1[2] )
  {
    v2 = *v1;
    if ( !*v1 )
      ATL::AtlThrowImpl(-2147467259);
    *v1 = *v2;
    v3 = v2[2];
    if ( v3 )
      (*(*v3 + 8))(v2[2]);
    *v2 = v1[4];
    v4 = v1[2]-- == 1;
    v1[4] = v2;
    if ( v4 )
      sub_FC9A30(v1);
  }
  result = v1[3];
  *v1 = 0;
  v1[1] = 0;
  v1[4] = 0;
  if ( result )
  {
    do
    {
      v6 = *result;
      free(result);
      result = v6;
    }
    while ( v6 );
    v1[3] = 0;
  }
  return result;
}

//----- (00FC9AC0) --------------------------------------------------------
_DWORD *__thiscall sub_FC9AC0(int *this, _DWORD *a2)
{
  int *v2; // esi
  int *v3; // edi
  int v4; // ecx
  int v5; // eax
  int v6; // ecx
  bool v7; // zf

  v2 = this;
  v3 = *this;
  if ( !*this )
    ATL::AtlThrowImpl(-2147467259);
  v4 = v3[2];
  *a2 = v4;
  if ( v4 )
    (*(*v4 + 4))(v4);
  v5 = *v3;
  *v2 = *v3;
  if ( v5 )
    *(v5 + 4) = 0;
  else
    v2[1] = 0;
  v6 = v3[2];
  if ( v6 )
    (*(*v6 + 8))(v3[2]);
  *v3 = v2[4];
  v7 = v2[2]-- == 1;
  v2[4] = v3;
  if ( v7 )
    sub_FC9A30(v2);
  return a2;
}

//----- (00FC9B40) --------------------------------------------------------
int __stdcall sub_FC9B40(DWORD dwThreadId)
{
  HANDLE v1; // eax
  void *v2; // esi

  v1 = OpenThread(0x1F03FFu, 1, dwThreadId);
  v2 = v1;
  if ( !v1 )
    return -2147467259;
  ResumeThread(v1);
  CloseHandle(v2);
  return 0;
}

//----- (00FC9B80) --------------------------------------------------------
char __thiscall sub_FC9B80(int this, unsigned int a2, int a3)
{
  int v3; // esi
  unsigned int v4; // edi
  int v5; // ebx
  unsigned int v6; // eax
  int v7; // ecx
  char result; // al
  unsigned int v9; // ecx
  unsigned int v10; // [esp+14h] [ebp+Ch]

  v3 = this;
  if ( a3 != -1 )
    *(this + 12) = a3;
  v4 = a2;
  if ( a2 )
  {
    if ( a2 > *(this + 8) )
    {
      result = sub_FC88A0(this, a2);
      if ( !result )
        return result;
      v9 = *(v3 + 4);
    }
    else
    {
      v9 = *(this + 4);
      if ( v9 >= a2 )
      {
        if ( v9 > a2 )
        {
          sub_FC79D0(*v3 + 4 * a2, v9 - a2);
          *(v3 + 4) = a2;
          return 1;
        }
        goto LABEL_18;
      }
    }
    sub_FC79A0((*v3 + 4 * v9), a2 - v9);
LABEL_18:
    *(v3 + 4) = a2;
    return 1;
  }
  v5 = *this;
  if ( *this )
  {
    v6 = *(this + 4);
    v10 = v6;
    if ( v6 )
    {
      do
      {
        v7 = *(v5 + 4 * v4);
        if ( v7 )
        {
          (*(*v7 + 8))(*(v5 + 4 * v4));
          v6 = v10;
        }
        ++v4;
      }
      while ( v4 < v6 );
    }
    free(*v3);
    *v3 = 0;
  }
  *(v3 + 4) = 0;
  result = 1;
  *(v3 + 8) = 0;
  return result;
}

//----- (00FC9C50) --------------------------------------------------------
int __thiscall sub_FC9C50(_DWORD *this, int a2, int a3, int a4)
{
  int *v4; // edi
  int v5; // ebx
  int result; // eax
  int *v7; // ecx
  void *v8; // esi
  int *v9; // eax
  int *v10; // edi
  unsigned int v11; // eax
  _DWORD *v12; // eax
  _DWORD *v13; // edi
  _DWORD *v14; // esi
  int v15; // ecx
  wchar_t *v16; // ST00_4
  unsigned int v17; // eax
  _DWORD *v18; // eax
  int v19; // eax
  int v20; // eax
  int *v21; // ecx
  void *v22; // esi
  bool v23; // zf
  int v24; // edi
  int (__stdcall **v25)(void *, GUID *, int *); // eax
  _DWORD *v26; // eax
  _DWORD *v27; // ebx
  _DWORD *v28; // ecx
  void *v29; // eax
  _DWORD *v30; // eax
  int *v31; // eax
  void *v32; // ecx
  void *v33; // eax
  _DWORD *v34; // eax
  _DWORD *v35; // ebx
  int v36; // ecx
  wchar_t *v37; // ST00_4
  void *v38; // eax
  _DWORD *v39; // eax
  int v40; // ecx
  int v41; // ecx
  int v42; // eax
  int *v43; // ecx
  int (__stdcall ***v44)(_DWORD, GUID *, int *); // edi
  _DWORD *v45; // eax
  void *v46; // eax
  int v47; // ecx
  _DWORD *v48; // eax
  void *v49; // eax
  int v50; // ecx
  unsigned __int64 v51; // [esp+10h] [ebp-103Ch]
  void *v52; // [esp+18h] [ebp-1034h]
  int (__stdcall ***v53)(_DWORD, GUID *, int *); // [esp+1Ch] [ebp-1030h]
  int *v54; // [esp+20h] [ebp-102Ch]
  _DWORD *v55; // [esp+24h] [ebp-1028h]
  int *v56; // [esp+28h] [ebp-1024h]
  void *v57; // [esp+2Ch] [ebp-1020h]
  void *v58; // [esp+30h] [ebp-101Ch]
  int v59; // [esp+34h] [ebp-1018h]
  int v60; // [esp+38h] [ebp-1014h]
  wchar_t v61; // [esp+3Ch] [ebp-1010h]
  wchar_t Dst; // [esp+83Ch] [ebp-810h]
  int v63; // [esp+1048h] [ebp-4h]

  v55 = this;
  v4 = a3;
  v5 = a4;
  v54 = a3;
  result = *(a3 + 8);
  v59 = a4;
  if ( !result )
  {
    if ( *(a2 + 8) )
    {
      if ( *(a2 + 8) > 0u )
      {
        v7 = *a2;
        if ( *a2 )
        {
          while ( v7 )
          {
            v8 = v7[2];
            v60 = *v7;
            v57 = v8;
            if ( v8 )
              (*(*v8 + 4))(v8);
            v63 = 0;
            v54 = 0;
            v9 = operator new(0x20u);
            v10 = v9;
            v52 = v9;
            LOBYTE(v63) = 2;
            if ( v9 )
            {
              *v9 = &SymbolInfo::`vftable';
              v9[1] = 1;
              v9[7] = operator new[](0x800u);
            }
            else
            {
              v10 = 0;
            }
            LOBYTE(v63) = 1;
            v54 = v10;
            result = sub_FC80C0(v8, v10);
            if ( result )
            {
              v11 = *(a4 + 4);
              v59 = v11;
              if ( v11 >= *(a4 + 8) && !sub_FC88A0(a4, v11 + 1) )
                goto LABEL_24;
              result = *a4 + 4 * v59;
              if ( result )
              {
                *result = v10;
                if ( v10 )
                  result = (*(*v10 + 4))(v10);
              }
              ++*(a4 + 4);
            }
            LOBYTE(v63) = 0;
            if ( v10 )
              result = (*(*v10 + 8))(v10);
            v63 = -1;
            if ( v8 )
              result = (*(*v8 + 8))(v8);
            v7 = v60;
            if ( !v60 )
              return result;
          }
          goto LABEL_41;
        }
      }
    }
    return result;
  }
  if ( !*(a2 + 8) )
  {
    while ( 1 )
    {
      sub_FC9AC0(v4, &v59);
      v63 = 3;
      v55 = 0;
      LOBYTE(v63) = 4;
      v12 = operator new(0x20u);
      v13 = v12;
      v57 = v12;
      LOBYTE(v63) = 5;
      if ( v12 )
      {
        *v12 = &SymbolInfo::`vftable';
        v12[1] = 1;
        v12[7] = operator new[](0x800u);
      }
      else
      {
        v13 = 0;
      }
      v14 = v59;
      LOBYTE(v63) = 4;
      v55 = v13;
      if ( v59 )
        (*(*v59 + 4))(v59);
      swprintf_s(&Dst, 0x400u, L"%s", v14[6]);
      v15 = v14[3];
      v13[4] = v14[2];
      v16 = v13[7];
      v13[5] = v15;
      swprintf_s(v16, 0x400u, L"%s", &Dst);
      v13[6] = 3;
      (*(*v14 + 8))(v14);
      v17 = *(a4 + 4);
      v60 = v17;
      if ( v17 >= *(a4 + 8) && !sub_FC88A0(a4, v17 + 1) )
        break;
      v18 = (*a4 + 4 * v60);
      if ( v18 )
      {
        *v18 = v13;
        (*(*v13 + 4))(v13);
      }
      ++*(a4 + 4);
      v19 = *v13;
      LOBYTE(v63) = 3;
      (*(v19 + 8))(v13);
      v20 = *v14;
      v63 = -1;
      result = (*(v20 + 8))(v14);
      v4 = v54;
      if ( !v54[2] )
        return result;
    }
    goto LABEL_24;
  }
  if ( !result || !*(a2 + 8) )
    return result;
  v21 = *a2;
  v56 = v21;
  result = v21 != 0;
  if ( !v21 )
    goto LABEL_41;
  v22 = v21[2];
  v52 = v22;
  if ( v22 )
    result = (*(*v22 + 4))(v22);
  v23 = *(a3 + 8) == 0;
  v63 = 6;
  if ( !v23 )
  {
    while ( 1 )
    {
      sub_FC9AC0(v4, &v53);
      v24 = v53;
      while ( 1 )
      {
        v60 = 0;
        v25 = *v22;
        LOBYTE(v63) = 8;
        if ( (*v25)(v22, &stru_103FC40, &v60) )
          break;
        (*(*v60 + 12))(v60, &v51);
        LOBYTE(v63) = 7;
        if ( v60 )
          (*(*v60 + 8))(v60);
        if ( !v56 || v51 >= *(v24 + 8) )
          goto LABEL_71;
        v60 = 0;
        LOBYTE(v63) = 9;
        v26 = operator new(0x20u);
        v27 = v26;
        v57 = v26;
        LOBYTE(v63) = 10;
        if ( v26 )
        {
          *v26 = &SymbolInfo::`vftable';
          v26[1] = 1;
          v26[7] = operator new[](0x800u);
        }
        else
        {
          v27 = 0;
        }
        LOBYTE(v63) = 9;
        v60 = v27;
        if ( sub_FC80C0(v22, v27) )
        {
          v28 = v59;
          v29 = *(v59 + 4);
          v58 = v29;
          if ( v29 >= *(v59 + 8) )
          {
            if ( !sub_FC88A0(v59, v29 + 1) )
              goto LABEL_24;
            v28 = v59;
          }
          v30 = (*v28 + 4 * v58);
          if ( v30 )
          {
            *v30 = v27;
            if ( v27 )
            {
              (*(*v27 + 4))(v27);
              v28 = v59;
            }
          }
          ++v28[1];
        }
        v31 = v56;
        v56 = *v56;
        v32 = v31[2];
        v58 = v32;
        if ( v22 != v32 )
        {
          if ( v32 )
          {
            (*(*v32 + 4))(v32);
            v32 = v58;
          }
          v33 = v22;
          v22 = v32;
          v52 = v32;
          if ( v33 )
            (*(*v33 + 8))(v33);
        }
        LOBYTE(v63) = 7;
        if ( v27 )
          (*(*v27 + 8))(v27);
      }
      LOBYTE(v63) = 7;
      if ( v60 )
        (*(*v60 + 8))(v60);
LABEL_71:
      v58 = 0;
      LOBYTE(v63) = 11;
      v34 = operator new(0x20u);
      v35 = v34;
      v60 = v34;
      v57 = v34;
      LOBYTE(v63) = 12;
      if ( v34 )
      {
        *v34 = &SymbolInfo::`vftable';
        v34[1] = 1;
        v34[7] = operator new[](0x800u);
      }
      else
      {
        v35 = 0;
        v60 = 0;
      }
      LOBYTE(v63) = 11;
      v58 = v35;
      if ( v24 )
        (*(*v24 + 4))(v24);
      swprintf_s(&v61, 0x400u, L"%s", *(v24 + 24));
      v36 = *(v24 + 12);
      v35[4] = *(v24 + 8);
      v37 = v35[7];
      v35[5] = v36;
      swprintf_s(v37, 0x400u, L"%s", &v61);
      v35[6] = 3;
      (*(*v24 + 8))(v24);
      v5 = v59;
      v38 = *(v59 + 4);
      v57 = v38;
      if ( v38 >= *(v59 + 8) && !sub_FC88A0(v59, v38 + 1) )
        break;
      v39 = (*v5 + 4 * v57);
      if ( v39 )
      {
        v40 = v60;
        *v39 = v60;
        (*(*v40 + 4))(v40);
      }
      v41 = v60;
      ++*(v5 + 4);
      LOBYTE(v63) = 7;
      (*(*v41 + 8))(v41);
      v42 = *v24;
      LOBYTE(v63) = 6;
      result = (*(v42 + 8))(v24);
      v4 = v54;
      if ( !v54[2] )
        goto LABEL_81;
    }
LABEL_24:
    ATL::AtlThrowImpl(-2147024882);
  }
LABEL_81:
  v43 = v56;
  if ( v56 )
  {
    while ( v43 )
    {
      v44 = v43[2];
      v56 = *v43;
      v53 = v44;
      if ( v44 )
        ((*v44)[1])(v44);
      v57 = 0;
      LOBYTE(v63) = 14;
      v45 = operator new(0x20u);
      v60 = v45;
      v58 = v45;
      LOBYTE(v63) = 15;
      if ( v45 )
      {
        *v45 = &SymbolInfo::`vftable';
        v45[1] = 1;
        v46 = operator new[](0x800u);
        v47 = v60;
        *(v60 + 28) = v46;
        v48 = v47;
      }
      else
      {
        v48 = 0;
        v60 = 0;
      }
      LOBYTE(v63) = 14;
      v57 = v48;
      result = sub_FC80C0(v44, v48);
      if ( result )
      {
        v49 = *(v5 + 4);
        v58 = v49;
        if ( v49 >= *(v5 + 8) && !sub_FC88A0(v5, v49 + 1) )
          goto LABEL_24;
        result = *v5 + 4 * v58;
        if ( result )
        {
          v50 = v60;
          *result = v60;
          if ( v50 )
            result = (*(*v50 + 4))(v50);
        }
        ++*(v5 + 4);
      }
      LOBYTE(v63) = 13;
      if ( v60 )
        result = (*(*v60 + 8))(v60);
      LOBYTE(v63) = 6;
      if ( v44 )
        result = ((*v44)[2])(v44);
      v43 = v56;
      if ( !v56 )
        goto LABEL_100;
    }
LABEL_41:
    ATL::AtlThrowImpl(-2147467259);
  }
LABEL_100:
  v63 = -1;
  if ( v22 )
    result = (*(*v22 + 8))(v22);
  return result;
}
// 103F420: using guessed type void *SymbolInfo::`vftable';
// 103FC40: using guessed type GUID stru_103FC40;

//----- (00FCA3A0) --------------------------------------------------------
signed int __stdcall sub_FCA3A0(_WORD *a1, unsigned int a2, int a3)
{
  signed int result; // eax
  _WORD *v4; // eax
  unsigned int v5; // edx
  signed int v6; // ecx
  int v7; // edi
  __int16 v8; // si
  int v9; // [esp+8h] [ebp-4h]

  result = sub_FCA500(a1, a2, &v9, 0x7FFFFFFFu);
  if ( result >= 0 )
  {
    v4 = &a1[v9];
    v5 = a2 - v9;
    if ( a2 == v9 )
      goto LABEL_13;
    v6 = 0x7FFFFFFF;
    v7 = a3 - v4;
    while ( v6 )
    {
      v8 = *(v4 + v7);
      if ( !v8 )
        break;
      *v4 = v8;
      --v6;
      ++v4;
      if ( !--v5 )
      {
        *(v4 - 1) = 0;
        return -2147024774;
      }
    }
    if ( v5 )
    {
      *v4 = 0;
      result = 0;
    }
    else
    {
LABEL_13:
      *(v4 - 1) = 0;
      result = -2147024774;
    }
  }
  return result;
}

//----- (00FCA440) --------------------------------------------------------
signed int __stdcall sub_FCA440(_WORD *a1, unsigned int a2, int a3, unsigned int a4)
{
  signed int result; // eax

  result = 0;
  if ( !a2 || a2 > 0x7FFFFFFF )
    result = -2147024809;
  if ( result >= 0 )
  {
    if ( a4 <= 0x7FFFFFFE )
    {
      result = sub_FCA490(a1, a2, 0, a3, a4);
    }
    else
    {
      *a1 = 0;
      result = -2147024809;
    }
  }
  return result;
}

//----- (00FCA490) --------------------------------------------------------
signed int __stdcall sub_FCA490(_WORD *a1, int a2, _DWORD *a3, int a4, int a5)
{
  int v5; // ecx
  int v6; // edx
  _WORD *v7; // eax
  int v8; // esi
  __int16 v9; // di
  signed int v10; // edi

  v5 = a2;
  v6 = 0;
  v7 = a1;
  if ( !a2 )
    goto LABEL_15;
  v8 = a5;
  while ( v8 )
  {
    v9 = *(v7 + a4 - a1);
    if ( !v9 )
      break;
    *v7 = v9;
    --v8;
    ++v7;
    ++v6;
    if ( !--v5 )
    {
      --v7;
      v10 = -2147024774;
      --v6;
      goto LABEL_10;
    }
  }
  if ( v5 )
  {
    v10 = 0;
  }
  else
  {
LABEL_15:
    --v7;
    v10 = -2147024774;
    --v6;
  }
LABEL_10:
  *v7 = 0;
  if ( a3 )
    *a3 = v6;
  return v10;
}

//----- (00FCA500) --------------------------------------------------------
signed int __stdcall sub_FCA500(_WORD *a1, unsigned int a2, _DWORD *a3, unsigned int a4)
{
  signed int result; // eax
  _WORD *v5; // eax
  unsigned int v6; // ecx
  signed int v7; // esi

  result = 0;
  if ( !a2 || a2 > a4 )
    result = -2147024809;
  if ( result < 0 )
  {
    *a3 = 0;
  }
  else
  {
    v5 = a1;
    v6 = a2;
    v7 = 0;
    if ( !a2 )
      goto LABEL_10;
    while ( *v5 )
    {
      ++v5;
      if ( !--v6 )
        goto LABEL_10;
    }
    if ( !v6 )
LABEL_10:
      v7 = -2147024809;
    if ( a3 )
    {
      if ( v7 >= 0 )
      {
        *a3 = a2 - v6;
        return v7;
      }
      *a3 = 0;
    }
    result = v7;
  }
  return result;
}

//----- (00FCA570) --------------------------------------------------------
HANDLE __thiscall sub_FCA570(void *this, DWORD dwThreadId, int a3, int a4, int a5, int a6, int a7)
{
  _DWORD *v7; // edi
  HANDLE result; // eax
  unsigned int v9; // ecx
  unsigned int v10; // eax
  signed int v11; // esi
  int v12; // eax
  _DWORD *v13; // eax
  int v14; // esi
  unsigned int v15; // kr00_4
  wchar_t *v16; // eax
  int *v17; // edi
  int v18; // eax
  int **v19; // eax
  int v20; // eax
  int v21; // [esp+0h] [ebp-3E0h]
  int *v22; // [esp+10h] [ebp-3D0h]
  int *v23; // [esp+14h] [ebp-3CCh]
  int v24; // [esp+18h] [ebp-3C8h]
  int v25; // [esp+1Ch] [ebp-3C4h]
  _DWORD *v26; // [esp+20h] [ebp-3C0h]
  int v27; // [esp+24h] [ebp-3BCh]
  int v28; // [esp+28h] [ebp-3B8h]
  HANDLE hThread; // [esp+2Ch] [ebp-3B4h]
  PVOID ContextRecord; // [esp+30h] [ebp-3B0h]
  struct _tagSTACKFRAME64 StackFrame; // [esp+34h] [ebp-3ACh]
  char v32; // [esp+13Ch] [ebp-2A4h]
  char v33; // [esp+170h] [ebp-270h]
  int *v34; // [esp+3D0h] [ebp-10h]
  int v35; // [esp+3DCh] [ebp-4h]

  v34 = &v21;
  v7 = this;
  v26 = this;
  ContextRecord = a3;
  result = OpenThread(0x1F03FFu, 1, dwThreadId);
  hThread = result;
  if ( result )
  {
    memset(&StackFrame, 0, 0x108u);
    v9 = *(a3 + 184);
    StackFrame.AddrStack.Offset = *(a3 + 196);
    v10 = *(a3 + 180);
    v11 = 0;
    StackFrame.AddrFrame.Offset = v10;
    StackFrame.AddrBStore.Offset = v10;
    StackFrame.AddrPC.Offset = v9;
    StackFrame.AddrPC.Mode = 3;
    StackFrame.AddrStack.Mode = 3;
    StackFrame.AddrFrame.Mode = 3;
    StackFrame.AddrBStore.Mode = 3;
    StackFrame.AddrReturn.Mode = 3;
    do
    {
      v35 = 0;
      if ( StackFrame.Virtual == 1 )
        v11 = 1;
      v12 = v7[5];
      v28 = v11;
      sub_FDDD60(1, v9, &v32, v7[3], 0, 0, *(v12 + 20), *(v12 + 16));
      if ( v11 )
      {
        v25 = 0;
        LOBYTE(v35) = 1;
        v13 = operator new(0x20u);
        v14 = v13;
        if ( v13 )
        {
          *v13 = &NativeFrame::`vftable';
          v13[1] = 1;
          v13[6] = 0;
        }
        else
        {
          v14 = 0;
        }
        *(v14 + 8) = StackFrame.AddrFrame.Offset;
        v25 = v14;
        v15 = wcslen(&v33);
        v16 = operator new[](2 * (v15 + 1));
        *(v14 + 24) = v16;
        swprintf_s(v16, v15 + 1, L"%s", &v33);
        v27 = *(a7 + 4);
        sub_FC7F70(a7);
        v17 = *(a7 + 16);
        v23 = v17;
        v22 = v17;
        v18 = *v17;
        v24 = *v17;
        LOBYTE(v35) = 2;
        if ( v17 )
        {
          v17[2] = v14;
          (*(*v14 + 4))(v14);
          v18 = v24;
        }
        *(a7 + 16) = v18;
        v17[1] = v27;
        *v17 = 0;
        ++*(a7 + 8);
        v19 = *(a7 + 4);
        if ( v19 )
          *v19 = v17;
        else
          *a7 = v17;
        *(a7 + 4) = v17;
        v20 = *v14;
        LOBYTE(v35) = 0;
        (*(v20 + 8))(v14);
        v11 = v28;
        v7 = v26;
      }
      if ( !StackWalk64(
              0x14Cu,
              v7[3],
              hThread,
              &StackFrame,
              ContextRecord,
              0,
              SymFunctionTableAccess64,
              SymGetModuleBase64,
              0) )
        break;
      v9 = StackFrame.AddrPC.Offset;
      v35 = -1;
      if ( !StackFrame.AddrPC.Offset )
        break;
    }
    while ( StackFrame.AddrFrame.Offset < __PAIR__(a6, a5) );
    result = HANDLE_FLAG_INHERIT;
  }
  return result;
}
// 103F430: using guessed type void *NativeFrame::`vftable';

//----- (00FCA870) --------------------------------------------------------
char __cdecl sub_FCA870(int a1, WPARAM wParam)
{
  char v2; // bl
  wchar_t *v3; // eax
  int v4; // esi
  PE_PerfInfo_Item *v5; // eax
  WPARAM v6; // edi
  int *v7; // eax
  _QWORD *v8; // eax
  HWND v9; // ST10_4
  unsigned __int8 v10; // al
  char v11; // bl
  double v12; // xmm0_8
  HWND v13; // ST10_4
  bool v14; // al
  PE_PerfInfo_Item *v15; // eax
  int *v16; // eax
  _QWORD *v17; // eax
  HWND v18; // ST10_4
  unsigned __int8 v19; // al
  char v20; // bl
  _QWORD *v21; // eax
  HWND v22; // ST10_4
  unsigned __int8 v23; // al
  char v24; // bl
  _QWORD *v25; // eax
  HWND v26; // ST10_4
  unsigned __int8 v27; // al
  char v28; // bl
  _QWORD *v29; // eax
  HWND v30; // ST10_4
  unsigned __int8 v31; // al
  char v32; // bl
  _QWORD *v33; // eax
  HWND v34; // ST10_4
  unsigned __int8 v35; // al
  char v36; // bl
  _QWORD *v37; // eax
  HWND v38; // ST10_4
  unsigned __int8 v39; // al
  PE_PerfInfo_Item *v40; // eax
  int *v41; // eax
  _QWORD *v42; // eax
  HWND v43; // ST10_4
  unsigned __int8 v44; // al
  PE_PerfInfo_Item *v45; // eax
  int *v46; // eax
  _QWORD *v47; // eax
  HWND v48; // ST10_4
  unsigned __int8 v49; // al
  char v50; // bl
  _QWORD *v51; // eax
  HWND v52; // ST10_4
  unsigned __int8 v53; // al
  char v54; // bl
  _QWORD *v55; // eax
  HWND v56; // ST10_4
  unsigned __int8 v57; // al
  char v58; // bl
  _QWORD *v59; // eax
  HWND v60; // ST10_4
  unsigned __int8 v61; // al
  char v62; // bl
  int v63; // edi
  signed __int64 v64; // rax
  int v65; // ecx
  HWND v66; // ST10_4
  unsigned __int8 v67; // al
  char v68; // bl
  double v69; // xmm0_8
  HWND v70; // ST10_4
  bool v71; // al
  PE_PerfInfo_Item *v72; // eax
  int *v73; // eax
  _QWORD *v74; // eax
  HWND v75; // ST10_4
  unsigned __int8 v76; // al
  PE_PerfInfo v78; // [esp+2Ch] [ebp-250h]
  int v79[2]; // [esp+3Ch] [ebp-240h]
  int v80; // [esp+44h] [ebp-238h]
  unsigned int v81; // [esp+4Ch] [ebp-230h]
  int v82; // [esp+54h] [ebp-228h]
  int v83; // [esp+58h] [ebp-224h]
  void *v84[2]; // [esp+60h] [ebp-21Ch]
  void *v85; // [esp+68h] [ebp-214h]
  void *v86; // [esp+6Ch] [ebp-210h]
  wchar_t Dst; // [esp+70h] [ebp-20Ch]
  __int16 v88; // [esp+8Ch] [ebp-1F0h]

  v2 = 0;
  if ( !*(a1 + 1284) )
    return 0;
  wcscpy_s(&Dst, 0x104u, *(a1 + 60));
  v3 = wcsrchr(&Dst, 0x2Eu);
  if ( v3 && v3 != &Dst )
    *v3 = 0;
  v4 = *(a1 + 1284);
  v82 = *(a1 + 1284);
  v88 = 0;
  unknown_libname_3(&v78, &gPerformanceInfoInMemory, &gPerformanceInfo);
  v5 = PE_PerfInfo::Load(&v78, L".NET CLR Jit");
  v6 = wParam;
  v85 = v5;
  if ( v5 )
  {
    v7 = sub_FC86E0(&Dst, v5);
    v86 = v7;
    if ( v7 )
    {
      v8 = sub_FC7F10(v7, L"# of methods Jitted", &v83);
      v9 = ghWndTreeListView;
      v10 = sub_FFF920(*v8, *v8 >> 32, v4);
      v11 = RedrawColumn(v10, v9, 1094, wParam);
      sub_FC7F10(v86, L"% time in JIT", &v80);
      v84[1] = sub_FCE840(v86);
      sub_FCECA0(v84[1], &v81, 0);
      v12 = 0.0;
      if ( v81 != 0.0 )
        v12 = v80 * 100.0 / v81;
      v13 = ghWndTreeListView;
      v14 = sub_FFF8F0(v12, (v4 + 8));
      v2 = RedrawColumn(v14, v13, 1095, wParam) | v11;
      if ( v84[1] )
      {
        sub_FCEC80(v84[1]);
        j__free(v84[1]);
      }
      j__free(v86);
    }
    j__free(v85);
  }
  v15 = PE_PerfInfo::Load(&v78, L".NET CLR Loading");
  v85 = v15;
  if ( v15 )
  {
    v16 = sub_FC86E0(&Dst, v15);
    v86 = v16;
    if ( v16 )
    {
      v17 = sub_FC7F10(v16, L"Current AppDomains", &v83);
      v18 = ghWndTreeListView;
      v19 = sub_FFF920(*v17, *v17 >> 32, (v4 + 16));
      v20 = RedrawColumn(v19, v18, 1096, wParam) | v2;
      v21 = sub_FC7F10(v86, L"Current Assemblies", &v83);
      v22 = ghWndTreeListView;
      v23 = sub_FFF920(*v21, *v21 >> 32, (v4 + 48));
      v24 = RedrawColumn(v23, v22, 1097, wParam) | v20;
      v25 = sub_FC7F10(v86, L"Current Classes Loaded", &v83);
      v26 = ghWndTreeListView;
      v27 = sub_FFF920(*v25, *v25 >> 32, (v4 + 32));
      v28 = RedrawColumn(v27, v26, 1098, wParam) | v24;
      v29 = sub_FC7F10(v86, L"Total AppDomains", &v83);
      v30 = ghWndTreeListView;
      v31 = sub_FFF920(*v29, *v29 >> 32, (v4 + 24));
      v32 = RedrawColumn(v31, v30, 1099, wParam) | v28;
      v33 = sub_FC7F10(v86, L"Total Assemblies", &v83);
      v34 = ghWndTreeListView;
      v35 = sub_FFF920(*v33, *v33 >> 32, (v4 + 56));
      v36 = RedrawColumn(v35, v34, 1100, wParam) | v32;
      v37 = sub_FC7F10(v86, L"Total Classes Loaded", &v83);
      v38 = ghWndTreeListView;
      v39 = sub_FFF920(*v37, *v37 >> 32, (v4 + 40));
      v2 = RedrawColumn(v39, v38, 1101, wParam) | v36;
      j__free(v86);
    }
    j__free(v85);
  }
  v40 = PE_PerfInfo::Load(&v78, L".NET CLR LocksAndThreads");
  v84[1] = v40;
  if ( v40 )
  {
    v41 = sub_FC86E0(&Dst, v40);
    v85 = v41;
    if ( v41 )
    {
      v42 = sub_FC7F10(v41, L"Total # of contentions", &v83);
      v43 = ghWndTreeListView;
      v44 = sub_FFF920(*v42, *v42 >> 32, (v4 + 128));
      v2 |= RedrawColumn(v44, v43, 1110, wParam);
      j__free(v85);
    }
    j__free(v84[1]);
  }
  v45 = PE_PerfInfo::Load(&v78, L".NET CLR Memory");
  v85 = v45;
  if ( v45 )
  {
    v46 = sub_FC86E0(&Dst, v45);
    v86 = v46;
    if ( v46 )
    {
      v47 = sub_FC7F10(v46, L"# bytes in all heaps", &v83);
      v48 = ghWndTreeListView;
      v49 = sub_FFF920(*v47, *v47 >> 32, (v4 + 112));
      v50 = RedrawColumn(v49, v48, 1103, wParam) | v2;
      v51 = sub_FC7F10(v86, L"# Gen 0 collections", &v83);
      v52 = ghWndTreeListView;
      v53 = sub_FFF920(*v51, *v51 >> 32, (v4 + 64));
      v54 = RedrawColumn(v53, v52, 1104, wParam) | v50;
      v55 = sub_FC7F10(v86, L"# Gen 1 collections", &v83);
      v56 = ghWndTreeListView;
      v57 = sub_FFF920(*v55, *v55 >> 32, (v4 + 72));
      v58 = RedrawColumn(v57, v56, 1105, wParam) | v54;
      v59 = sub_FC7F10(v86, L"# Gen 2 collections", &v83);
      v60 = ghWndTreeListView;
      v61 = sub_FFF920(*v59, *v59 >> 32, (v4 + 80));
      v62 = RedrawColumn(v61, v60, 1106, wParam) | v58;
      sub_FC7F10(v86, L"Allocated bytes/sec", v79);
      v63 = v79[1];
      *v84 = *v79;
      *v84 = *v79 - *(v82 + 96);
      v64 = (*v84 / ((*&gLoadNetClrMemoryPerfInfoTime - *&gLoadNetClrMemoryPerfInfoTimeLast) / 10000000.0));
      v65 = v64;
      LODWORD(v64) = v82;
      *(v82 + 96) = v79[0];
      v4 = v64;
      *(v64 + 100) = v63;
      v6 = wParam;
      v66 = ghWndTreeListView;
      v67 = sub_FFF920(v65, SHIDWORD(v64), (v64 + 104));
      v68 = RedrawColumn(v67, v66, 1108, wParam) | v62;
      sub_FC7F10(v86, L"% time in GC", &v80);
      v84[1] = sub_FCE840(v86);
      sub_FCECA0(v84[1], &v81, 0);
      v69 = 0.0;
      if ( v81 != 0.0 )
        v69 = v80 * 100.0 / v81;
      v70 = ghWndTreeListView;
      v71 = sub_FFF8F0(v69, (v4 + 88));
      v2 = RedrawColumn(v71, v70, 1107, wParam) | v68;
      if ( v84[1] )
      {
        sub_FCEC80(v84[1]);
        j__free(v84[1]);
      }
      j__free(v86);
    }
    j__free(v85);
  }
  v72 = PE_PerfInfo::Load(&v78, L".NET CLR Security");
  v84[1] = v72;
  if ( v72 )
  {
    v73 = sub_FC86E0(&Dst, v72);
    v85 = v73;
    if ( v73 )
    {
      v74 = sub_FC7F10(v73, L"Total runtime checks", &v83);
      v75 = ghWndTreeListView;
      v76 = sub_FFF920(*v74, *v74 >> 32, (v4 + 120));
      v2 |= RedrawColumn(v76, v75, 1109, v6);
      j__free(v85);
    }
    j__free(v84[1]);
  }
  return v2;
}
// 103CDC0: using guessed type double db_onehundred;
// 106A0A8: using guessed type struct _FILETIME gLoadNetClrMemoryPerfInfoTimeLast;

//----- (00FCB0A0) --------------------------------------------------------
int __thiscall sub_FCB0A0(_DWORD *this, DWORD dwThreadId, int a3)
{
  _DWORD *v3; // ebx
  int result; // eax
  int *v5; // ST20_4
  int v6; // ecx
  HANDLE v7; // eax
  void *v8; // esi
  signed int v9; // ebx
  HANDLE v10; // eax
  void *v11; // esi
  int *v12; // ecx
  int v13; // eax
  int v14; // eax
  int v15; // edi
  int v16; // esi
  int v17; // eax
  int v18; // ecx
  int v19; // eax
  int v20; // eax
  int v21; // eax
  int v22; // ecx
  int (__stdcall **v23)(int, GUID *, int *); // eax
  int v24; // eax
  int v25; // ecx
  int v26; // eax
  int (__stdcall **v27)(int, GUID *, int *); // eax
  int v28[2]; // [esp+10h] [ebp-62Ch]
  int v29; // [esp+18h] [ebp-624h]
  int v30; // [esp+1Ch] [ebp-620h]
  int v31; // [esp+20h] [ebp-61Ch]
  int v32; // [esp+24h] [ebp-618h]
  int v33; // [esp+28h] [ebp-614h]
  int v34; // [esp+2Ch] [ebp-610h]
  int v35; // [esp+30h] [ebp-60Ch]
  int v36; // [esp+34h] [ebp-608h]
  int v37; // [esp+38h] [ebp-604h]
  int v38; // [esp+3Ch] [ebp-600h]
  int v39; // [esp+40h] [ebp-5FCh]
  int v40; // [esp+44h] [ebp-5F8h]
  int v41; // [esp+48h] [ebp-5F4h]
  unsigned int v42; // [esp+4Ch] [ebp-5F0h]
  int v43; // [esp+50h] [ebp-5ECh]
  int v44; // [esp+54h] [ebp-5E8h]
  int v45; // [esp+58h] [ebp-5E4h]
  int v46; // [esp+5Ch] [ebp-5E0h]
  int v47; // [esp+60h] [ebp-5DCh]
  int v48; // [esp+64h] [ebp-5D8h]
  int v49; // [esp+68h] [ebp-5D4h]
  int v50; // [esp+6Ch] [ebp-5D0h]
  int v51; // [esp+70h] [ebp-5CCh]
  int v52; // [esp+74h] [ebp-5C8h]
  int v53; // [esp+78h] [ebp-5C4h]
  int v54; // [esp+7Ch] [ebp-5C0h]
  int v55; // [esp+80h] [ebp-5BCh]
  int v56; // [esp+84h] [ebp-5B8h]
  int v57; // [esp+88h] [ebp-5B4h]
  unsigned int v58; // [esp+8Ch] [ebp-5B0h]
  int v59; // [esp+90h] [ebp-5ACh]
  int v60; // [esp+94h] [ebp-5A8h]
  int v61; // [esp+360h] [ebp-2DCh]
  int v62; // [esp+638h] [ebp-4h]

  v3 = this;
  v52 = a3;
  result = sub_FC8D10(this, dwThreadId);
  if ( !result )
    return result;
  v53 = 0;
  v5 = v3[7];
  v6 = *v5;
  v62 = 0;
  (*(v6 + 60))(v5, dwThreadId, &v53);
  if ( !v53 )
  {
    v7 = OpenThread(0x1F03FFu, 1, dwThreadId);
    v8 = v7;
    if ( v7 )
    {
      ResumeThread(v7);
      CloseHandle(v8);
    }
    v9 = 0;
    goto LABEL_72;
  }
  v10 = OpenThread(0x1F03FFu, 1, dwThreadId);
  v11 = v10;
  if ( v10 )
  {
    SuspendThread(v10);
    CloseHandle(v11);
  }
  v12 = 0;
  v58 = 0;
  if ( v53 )
  {
    v13 = (**v53)(v53, &stru_103FC50, &v58);
    v12 = v58;
    if ( v13 < 0 )
      v12 = 0;
    v58 = v12;
  }
  if ( !v12 )
  {
    sub_FC9B40(dwThreadId);
    v9 = 0;
    goto LABEL_70;
  }
  v54 = 0;
  v14 = *v12;
  LOBYTE(v62) = 2;
  if ( (*(v14 + 12))(v12, &v54) )
  {
    sub_FC9B40(dwThreadId);
    v9 = 0;
    goto LABEL_68;
  }
  v43 = 0;
  v44 = 0;
  v29 = 0;
  v30 = 0;
  v31 = 0;
  v32 = 0;
  v33 = 0;
  v34 = 10;
  v48 = 0;
  v35 = 0;
  v36 = 0;
  v37 = 0;
  v38 = 0;
  v39 = 0;
  v40 = 10;
  LOBYTE(v62) = 4;
  if ( !sub_FC7FF0(v58, &v41, &v42) )
  {
    v9 = 0;
    goto LABEL_67;
  }
  v51 = 0;
  v15 = 0;
  *v28 = 0i64;
  v46 = 0;
  v49 = 0;
  v16 = 0;
  v50 = 0;
  LOBYTE(v62) = 6;
  while ( 1 )
  {
    while ( 1 )
    {
      if ( v51 == 1 )
      {
        v47 = v15;
        if ( v15 )
          (*(*v15 + 4))(v15);
        LOBYTE(v62) = 7;
        if ( v15 )
        {
          v55 = 0;
          v56 = 0;
          v17 = (**v15)(v15, &stru_103FC60, &v56);
          v18 = v56;
          if ( v17 < 0 )
            v18 = 0;
          v56 = v18;
          LOBYTE(v62) = 8;
          if ( v18 )
          {
            (*(*v18 + 12))(v18, &v55);
            if ( v55 == 1 && v16 != v15 )
            {
              (*(*v15 + 4))(v15);
              v19 = v16;
              v16 = v15;
              v50 = v15;
              if ( v19 )
                (*(*v19 + 8))(v19);
            }
            v18 = v56;
          }
          LOBYTE(v62) = 7;
          if ( v18 )
            (*(*v18 + 8))(v18);
        }
        LOBYTE(v62) = 6;
        if ( v15 )
          (*(*v15 + 8))(v15);
      }
      v49 = 0;
      v55 = v15;
      v20 = sub_FC8E20(v3, v58, v54, &v55, &v46, &v51, v41, v42, &v48);
      v15 = v55;
      v49 = v55;
      if ( v20 )
      {
        if ( v16 )
          break;
      }
      if ( v20 != 1 )
      {
        sub_FCA570(v3, dwThreadId, &v61, 716, -1, 0x7FFFFFFF, &v35);
        sub_FC9C50(v3, &v29, &v35, v52);
        sub_FC9A30(&v35);
        sub_FC9B40(dwThreadId);
        sub_FC77E0(v52);
        v9 = 1;
        goto LABEL_63;
      }
      if ( !sub_FCB680(v3, dwThreadId, v55, v54, &v29, &v35, &v43, &v60, &v44, &v61, v28, v52) )
      {
        sub_FC9B40(dwThreadId);
        v9 = 0;
        goto LABEL_63;
      }
    }
    v47 = v55;
    if ( v55 )
      (*(*v55 + 4))(v55);
    LOBYTE(v62) = 9;
    if ( v15 )
      break;
LABEL_52:
    LOBYTE(v62) = 6;
    if ( v15 )
      (*(*v15 + 8))(v15);
  }
  v59 = 0;
  v21 = (**v16)(v16, &stru_103FC60, &v59);
  v22 = v59;
  if ( v21 < 0 )
    v22 = 0;
  v59 = v22;
  v57 = 0;
  v23 = *v15;
  LOBYTE(v62) = 10;
  v24 = (*v23)(v15, &stru_103FC60, &v57);
  v25 = v57;
  if ( v24 < 0 )
    v25 = 0;
  v57 = v25;
  LOBYTE(v62) = 11;
  if ( !(*(*v59 + 16))(v59, v25, &v45) )
  {
    if ( v45 == 1 )
    {
      v26 = v16;
      v16 = 0;
      v50 = 0;
      if ( v26 )
        (*(*v26 + 8))(v26);
    }
    LOBYTE(v62) = 10;
    if ( v57 )
      (*(*v57 + 8))(v57);
    LOBYTE(v62) = 9;
    if ( v59 )
      (*(*v59 + 8))(v59);
    goto LABEL_52;
  }
  LOBYTE(v62) = 10;
  if ( v57 )
    (*(*v57 + 8))(v57);
  LOBYTE(v62) = 9;
  if ( v59 )
    (*(*v59 + 8))(v59);
  v27 = *v15;
  LOBYTE(v62) = 6;
  (v27[2])(v15);
  v9 = 0;
LABEL_63:
  LOBYTE(v62) = 5;
  if ( v16 )
    (*(*v16 + 8))(v16);
  LOBYTE(v62) = 4;
  if ( v15 )
    (*(*v15 + 8))(v15);
LABEL_67:
  sub_FC9A30(&v35);
  sub_FC9A30(&v29);
LABEL_68:
  LOBYTE(v62) = 1;
  if ( v54 )
    (*(*v54 + 8))(v54);
LABEL_70:
  LOBYTE(v62) = 0;
  if ( v58 )
    (*(*v58 + 8))(v58);
LABEL_72:
  v62 = -1;
  if ( v53 )
    (*(*v53 + 8))(v53);
  return v9;
}
// 103FC50: using guessed type GUID stru_103FC50;
// 103FC60: using guessed type GUID stru_103FC60;

//----- (00FCB680) --------------------------------------------------------
int __thiscall sub_FCB680(_DWORD *this, DWORD dwThreadId, int a3, int a4, int a5, int a6, int a7, int a8, int a9, int a10, int a11, int a12)
{
  _DWORD *v12; // ebx
  signed int v13; // eax
  _DWORD *v14; // esi
  _DWORD *v16; // edx
  int *v17; // ecx
  int v18; // esi
  int v19; // ST10_4
  _DWORD *v20; // esi
  _DWORD *v21; // ecx
  _DWORD *v22; // eax
  _DWORD *v23; // esi
  int v24; // eax
  signed int v25; // eax
  int v26; // eax

  v12 = this;
  if ( a3 )
  {
    v13 = sub_FC7DD0(a3);
    if ( v13 != 2 )
    {
      v14 = a7;
      if ( v13 != 1 )
      {
        if ( (*(*a4 + 12))(a4, 65539, 716, &a4, a8) )
          return 0;
        v16 = a9;
        *v14 = 1;
LABEL_7:
        v17 = a11;
        *a11 = -1;
        v17[1] = 0x7FFFFFFF;
        if ( *v14 == 1 )
        {
          *v17 = *(a8 + 196);
          v17[1] = 0;
        }
        v18 = a6;
        if ( *v16 == 1 )
          sub_FCA570(v12, dwThreadId, a10, 716, *v17, v17[1], a6);
        v19 = v18;
        v20 = a5;
        sub_FC9C50(v12, a5, v19, a12);
        v21 = a6;
        *a9 = 0;
        sub_FC9A30(v21);
        sub_FC9A30(v20);
        a9 = 0;
        v22 = operator new(0x20u);
        v23 = v22;
        a8 = v22;
        if ( v22 )
        {
          *v22 = &SymbolInfo::`vftable';
          v22[1] = 1;
          v22[7] = operator new[](0x800u);
        }
        else
        {
          v23 = 0;
        }
        a9 = v23;
        v25 = sub_FC7DD0(a3);
        if ( v25 && (v26 = v25 - 1) != 0 )
        {
          if ( v26 != 2 )
            goto LABEL_22;
          sub_FC8A30(v23, "[Native Frame: IL Method without Metadata]", 0, 0, 3);
        }
        else if ( !sub_FC80C0(a3, v23) )
        {
          goto LABEL_22;
        }
        sub_FC76F0(a12, &a9);
LABEL_22:
        if ( v23 )
          (*(*v23 + 8))(v23);
        return 1;
      }
      v16 = a9;
      if ( !*a9 )
        goto LABEL_7;
      v24 = *a3;
      a12 = a3;
      (*(v24 + 4))(a3);
      sub_FC7740(a5, &a12);
      (*(*a3 + 8))(a3);
    }
  }
  else
  {
    if ( (*(*a4 + 12))(a4, 65539, 716, &a8, a10) )
      return 0;
    *a9 = 1;
    *a7 = 0;
  }
  return 1;
}
// 103F420: using guessed type void *SymbolInfo::`vftable';

//----- (00FCB8A0) --------------------------------------------------------
void LoadNetClrMemoryPerformanceInfo()
{
  int v0; // [esp+0h] [ebp-44h]
  int PEPerfInfo[4]; // [esp+10h] [ebp-34h]
  PerformanceInfo Info; // [esp+20h] [ebp-24h]
  PerformanceInfoInMemory Item; // [esp+2Ch] [ebp-18h]
  int *v4; // [esp+34h] [ebp-10h]
  int v5; // [esp+40h] [ebp-4h]

  v4 = &v0;
  SetEnvironmentVariableW(L"COMPLUS_FodPath", L"c:\\no-fod.exe");
  v5 = 0;
  PerformanceInfo::PerformanceInfo(&Info, 0);
  LOBYTE(v5) = 1;
  PE_PerfInfo::PE_PerfInfo(&Item, &Info);
  LOBYTE(v5) = 2;
  PerformanceInfoInMemory::Load(&Item, 0, L".NET CLR Memory");
  unknown_libname_3(PEPerfInfo, &Item, &Info);
  gNetClrMemoryPerfInfoLoaded = PE_PerfInfo::Load(PEPerfInfo, L".NET CLR Memory") != 0;
  if ( gNetClrMemoryPerfInfoLoaded )
  {
    CoInitialize(0);
    if ( gNetClrMemoryPerfInfoLoaded )
    {
      gLoadNetClrMemoryPerfInfoTimeLast = gLoadNetClrMemoryPerfInfoTime;
      GetSystemTimeAsFileTime(&gLoadNetClrMemoryPerfInfoTime);
      PerformanceInfoInMemory::Load(
        &gPerformanceInfoInMemory,
        0,
        L".NET CLR Memory,.NET CLR Exceptions,.NET CLR Remoting,.NET CLR LocksAndThreads,.NET CLR Security,.NET CLR Jit,.N"
         "ET CLR Loading,.NET CLR Interop,.NET CLR Data");
    }
  }
  LOBYTE(v5) = 1;
  PerformanceInfoInMemory::~PerformanceInfoInMemory(&Item);
  LOBYTE(v5) = 0;
  PerformanceInfo::~PerformanceInfo(&Info);
}
// 106A098: using guessed type char gNetClrMemoryPerfInfoLoaded;
// 106A0A8: using guessed type struct _FILETIME gLoadNetClrMemoryPerfInfoTimeLast;

//----- (00FCB9D0) --------------------------------------------------------
void *__cdecl sub_FCB9D0(int a1)
{
  void *v1; // esi
  int v3; // [esp+0h] [ebp-Ch]
  int v4; // [esp+4h] [ebp-8h]
  LPVOID ppv; // [esp+8h] [ebp-4h]

  if ( !gNetClrMemoryPerfInfoLoaded )
    return 0;
  v3 = 0;
  if ( byte_106A09A )
    CoCreateInstance(&stru_103F40C, 0, 1u, &stru_103F3BC, &ppv);
  else
    CoCreateInstance(&stru_103F3AC, 0, 1u, &stru_103F3BC, &ppv);
  if ( !ppv )
    return 0;
  if ( !(*(*ppv + 16))(ppv, a1, &v4) )
  {
    (*(*v4 + 12))(v4, &v3);
    (*(*v4 + 8))(v4);
  }
  (*(*ppv + 8))(ppv);
  if ( !v3 )
    return 0;
  v1 = malloc(0x88u);
  memset(v1, 0, 0x88u);
  return v1;
}
// 103F40C: using guessed type GUID stru_103F40C;
// 106A098: using guessed type char gNetClrMemoryPerfInfoLoaded;
// 106A09A: using guessed type char byte_106A09A;

//----- (00FCBA80) --------------------------------------------------------
int __stdcall PageProcNet(HWND hWnd, unsigned int a2, WPARAM wParam, int a4)
{
  HWND v4; // ebx
  LONG v5; // edi
  int result; // eax
  void *v7; // esi
  CResizer *v8; // eax
  wchar_t *v9; // edi
  HWND v10; // eax
  LONG v11; // eax
  HWND v12; // eax
  HWND v13; // ST0C_4
  HWND v14; // eax
  HWND v15; // eax
  LONG v16; // eax
  PerformanceInfoInMemory *v17; // eax
  PerformanceInfoInMemory *v18; // eax
  HWND v19; // ST08_4
  HWND v20; // eax
  LRESULT v21; // eax
  PE_PerfInfo_Item *v22; // eax
  _DWORD *v23; // eax
  wchar_t **v24; // esi
  int v25; // ebx
  int v26; // eax
  HWND v27; // ST08_4
  int v28; // ST10_4
  HWND v29; // eax
  PE_PerfInfo_Item *v30; // eax
  LRESULT v31; // esi
  HWND v32; // ST08_4
  wchar_t **v33; // eax
  void **v34; // esi
  double v35; // xmm0_8
  HWND v36; // ST08_4
  int v37; // eax
  HWND v38; // ST08_4
  WPARAM ArgList; // [esp+0h] [ebp-3BCh]
  LPARAM lParam; // [esp+14h] [ebp-3A8h]
  int v41; // [esp+1Ch] [ebp-3A0h]
  int v42; // [esp+20h] [ebp-39Ch]
  int v43; // [esp+24h] [ebp-398h]
  char *v44; // [esp+28h] [ebp-394h]
  int v45; // [esp+2Ch] [ebp-390h]
  PE_PerfInfo v46; // [esp+48h] [ebp-374h]
  LVITEMW v47; // [esp+58h] [ebp-364h]
  UINT v48; // [esp+8Ch] [ebp-330h]
  int v49; // [esp+90h] [ebp-32Ch]
  unsigned int v50; // [esp+94h] [ebp-328h]
  HWND v51; // [esp+98h] [ebp-324h]
  UINT pnIDs; // [esp+9Ch] [ebp-320h]
  WORD v53[2]; // [esp+A0h] [ebp-31Ch]
  char v54[4]; // [esp+A4h] [ebp-318h]
  int v55; // [esp+A8h] [ebp-314h]
  WORD pnWidths[2]; // [esp+ACh] [ebp-310h]
  WPARAM v57; // [esp+B0h] [ebp-30Ch]
  LPDRAWITEMSTRUCT pDrawItemStruct; // [esp+B4h] [ebp-308h]
  char v59; // [esp+B8h] [ebp-304h]
  WCHAR sz; // [esp+1B8h] [ebp-204h]
  wchar_t Dst; // [esp+2B8h] [ebp-104h]

  v4 = hWnd;
  pDrawItemStruct = a4;
  v51 = hWnd;
  v47.mask = 0;
  memset(&v47.iItem, 0, 0x30u);
  v5 = GetWindowLongW(hWnd, -21);
  v48 = 1093;
  v49 = 1058;
  v53[0] = MulDiv(100, gLogPixelSize.x, 96);
  v53[1] = MulDiv(-100, gLogPixelSize.x, 96);
  pnIDs = 1096;
  pnWidths[0] = MulDiv(100, gLogPixelSize.x, 96);
  if ( a2 > 0x111 )
  {
    switch ( a2 )
    {
      case 0x113u:
        v28 = dword_106A0CC;
        v29 = GetDlgItem(hWnd, 1094);
        sub_FC7A00(v29, v28, 0);
        PerformanceInfoInMemory::Load(*(v5 + 804), 0, (v5 + 28));
        unknown_libname_3(&v46, *(v5 + 804), &gPerformanceInfo);
        v30 = PE_PerfInfo::Load(&v46, (v5 + 28));
        if ( v30 )
        {
          pDrawItemStruct = sub_FC86E0((v5 + 284), v30);
          GetSystemTimeAsFileTime((v5 + 8));
          v31 = 0;
          v32 = *(v5 + 16);
          v57 = 0;
          if ( SendMessageW(v32, LVM_GETITEMCOUNT, 0, 0) > 0 )
          {
            do
            {
              v47.mask = 1;
              v47.pszText = &sz;
              v47.iItem = v31;
              v47.iSubItem = 0;
              v47.cchTextMax = 128;
              SendMessageW(*(v5 + 16), LVM_GETITEMW, 0, &v47);
              if ( pDrawItemStruct && sub_FC7F10(pDrawItemStruct, &sz, v54) )
              {
                v33 = sub_FCE760(pDrawItemStruct, &sz);
                v34 = v33;
                if ( v33 && v33[1] & 0x20000 )
                {
                  v34 = sub_FCE840(pDrawItemStruct);
                  sub_FCECA0(v34, &v50, 0);
                  v35 = 0.0;
                  if ( v50 != 0.0 )
                    v35 = *v54 * 100.0 / v50;
                  sub_FC7500(&Dst, L"%02.02f", LODWORD(v35), HIDWORD(v35));
                }
                else
                {
                  sub_FC7500(&Dst, L"%I64d", *v54, v55);
                  sub_FC3290(&Dst, 0x80u);
                }
                if ( v34 )
                {
                  sub_FCEC80(v34);
                  j__free(v34);
                }
                v31 = v57;
              }
              else
              {
                sub_FC7500(&Dst, L"0");
              }
              v41 = 1;
              v44 = &v59;
              v36 = *(v5 + 16);
              v45 = 128;
              SendMessageW(v36, 0x1073u, v31, &lParam);
              v37 = wcscmp(&v59, &Dst);
              if ( v37 )
                v37 = -(v37 < 0) | 1;
              if ( v37 )
              {
                v47.mask = 1;
                v47.pszText = &Dst;
                v47.iSubItem = 1;
                v47.cchTextMax = 128;
                SendMessageW(*(v5 + 16), 0x104Cu, 0, &v47);
                SendMessageW(*(v5 + 16), 0x1015u, v47.iItem, v47.iItem);
              }
              v38 = *(v5 + 16);
              v57 = ++v31;
            }
            while ( v31 < SendMessageW(v38, 0x1004u, 0, 0) );
          }
        }
        *v5 = *(v5 + 8);
        *(v5 + 4) = *(v5 + 12);
        return 0;
      case 0x133u:
      case 0x136u:
      case 0x138u:
        return PE_FillControl(hWnd, wParam);
      default:
        return 0;
    }
    return 0;
  }
  if ( a2 == 273 )
  {
    switch ( wParam )
    {
      case 0x9C41u:
        ArgList = 40014;
        goto LABEL_25;
      case 0x9C42u:
        SetEvent(ghRefreshEventHandle);
        break;
      case 0x9C9Cu:
      case 0x9C9Du:
        ArgList = wParam;
LABEL_25:
        v20 = GetParent(hWnd);
        PostMessageW(v20, 0x111u, ArgList, 0);
        break;
      default:
        break;
    }
    if ( wParam >> 16 == 1 && wParam == 1093 )
    {
      SendMessageW(*(v5 + 16), 0x1009u, 0, 0);
      v21 = SendMessageW(*(v5 + 20), 0x147u, 0, 0);
      SendMessageW(*(v5 + 20), 0x148u, v21, v5 + 28);
      PerformanceInfoInMemory::Load(*(v5 + 804), 0, (v5 + 28));
      unknown_libname_3(&v46, *(v5 + 804), &gPerformanceInfo);
      v22 = PE_PerfInfo::Load(&v46, (v5 + 28));
      if ( v22 )
      {
        v23 = sub_FCED60(v22);
        v57 = v23;
        if ( v23 )
        {
          v24 = sub_FCE830(v23);
          if ( v24 )
          {
            v25 = v57;
            do
            {
              if ( !(v24[1] & 0x400000) )
              {
                wcscpy_s(&Dst, 0x80u, *v24);
                v26 = wcscmp(L"Not Displayed", &Dst);
                if ( v26 )
                  v26 = -(v26 < 0) | 1;
                if ( v26 )
                  sub_FF7F90(*(v5 + 16), &Dst, &gszNullString);
              }
              sub_FCEC80(v24);
              j__free(v24);
              v24 = sub_FCE840(v25);
            }
            while ( v24 );
            v4 = v51;
          }
        }
      }
      SendMessageW(v4, 0x113u, 0, 0);
      SendMessageW(*(v5 + 16), 0x101Eu, 0, 0xFFFF);
      SendMessageW(*(v5 + 16), 0x101Eu, 1u, 65534);
      v43 = 2;
      v27 = *(v5 + 16);
      v42 = 2;
      SendMessageW(v27, 0x102Bu, 0, &lParam);
    }
    return 0;
  }
  if ( a2 > 0x2C )
  {
    if ( a2 == 256 )
    {
      if ( wParam == 116 )
        PostMessageW(hWnd, 0x113u, 1u, 0);
      return 0;
    }
    if ( a2 != 272 )
      return 0;
    v8 = operator new(0x40u);
    if ( v8 )
      CResizer::CResizer(v8, hWnd);
    PropSheet_UpdateTab(hWnd);
    v9 = malloc(0x328u);
    memset(v9, 0, 0x328u);
    SetWindowLongW(hWnd, -21, v9);
    v10 = GetDlgItem(hWnd, 1094);
    *(v9 + 6) = v10;
    v11 = GetWindowLongW(v10, -16);
    SetWindowLongW(*(v9 + 6), -16, v11 & 0xFFFFFFFD | 1);
    SetWindowLongW(*(v9 + 6), -21, 1);
    SendMessageW(*(v9 + 6), 0x1036u, 0x4020u, 16416);
    v12 = SendMessageW(*(v9 + 6), 0x104Eu, 0, 0);
    CTreeList::InitToolTips(v12);
    gOldListWndProc = SetWindowLongW(*(v9 + 6), -4, Proxy_ListCtrlWndProc);
    SendMessageW(*(v9 + 6), 0x30u, ghConfigFont, 0);
    CTreeView::InitListHeader(*(v9 + 6), &pnIDs, pnWidths, 1u);
    v13 = *(v9 + 6);
    dword_106A0CC = pDrawItemStruct[1].hwndItem;
    sub_FC7A00(v13, dword_106A0CC, 1);
    SendMessageW(*(v9 + 6), 0x101Eu, 0, 65534);
    sub_FC8790(pDrawItemStruct[1].itemAction, v9 + 142);
    v14 = GetDlgItem(hWnd, 1093);
    *(v9 + 5) = v14;
    SendMessageW(v14, 0x143u, 0, L".NET CLR Memory");
    SendMessageW(*(v9 + 5), 0x143u, 0, L".NET CLR Jit");
    SendMessageW(*(v9 + 5), 0x143u, 0, L".NET CLR Exceptions");
    SendMessageW(*(v9 + 5), 0x143u, 0, L".NET CLR LocksAndThreads");
    SendMessageW(*(v9 + 5), 0x143u, 0, L".NET CLR Data");
    SendMessageW(*(v9 + 5), 0x143u, 0, L".NET CLR Interop");
    SendMessageW(*(v9 + 5), 0x143u, 0, L".NET CLR Loading");
    SendMessageW(*(v9 + 5), 0x143u, 0, L".NET CLR Remoting");
    SendMessageW(*(v9 + 5), 0x143u, 0, L".NET CLR Security");
    SendMessageW(*(v9 + 5), 0x14Eu, 0, 0);
    v15 = GetDlgItem(hWnd, 1091);
    *(v9 + 4) = v15;
    v16 = GetWindowLongW(v15, -16);
    SetWindowLongW(*(v9 + 4), -16, v16 & 0xFFFFFFFD | 1);
    v17 = operator new(8u);
    if ( v17 )
      v18 = PE_PerfInfo::PE_PerfInfo(v17, &gPerformanceInfo);
    else
      v18 = 0;
    v19 = *(v9 + 4);
    *(v9 + 201) = v18;
    SendMessageW(v19, 0x1036u, 0x4020u, 16416);
    gOldListWndProc = SetWindowLongW(*(v9 + 4), -4, Proxy_ListCtrlWndProc);
    SendMessageW(*(v9 + 4), 0x30u, ghConfigFont, 0);
    CTreeView::InitListHeader(*(v9 + 4), &v48, v53, 2u);
    SendMessageW(hWnd, 0x111u, 0x10445u, 0);
    SendMessageW(*(v9 + 4), 0x101Eu, 0, 0xFFFF);
    SendMessageW(*(v9 + 4), 0x101Eu, 1u, 65534);
    *v9 = 0;
    *(v9 + 1) = 0;
    SendMessageW(hWnd, 0x113u, 0, 0);
    result = 1;
  }
  else
  {
    if ( a2 != 44 )
    {
      if ( a2 == 2 )
      {
        v7 = *(v5 + 804);
        if ( v7 )
        {
          PerformanceInfoInMemory::~PerformanceInfoInMemory(*(v5 + 804));
          j__free(v7);
        }
        free(v5);
      }
      else if ( a2 == 43 )
      {
        CMainWnd::DrawList(pDrawItemStruct);
      }
      return 0;
    }
    result = CMainWnd::HandleMeasureItem(hWnd, 0x2Cu, wParam, pDrawItemStruct);
  }
  return result;
}
// 103CDC0: using guessed type double db_onehundred;
// 103F4BC: using guessed type wchar_t aNetClrExceptio[20];
// 103F518: using guessed type wchar_t aNetClrData[14];
// 103F534: using guessed type wchar_t aNetClrInterop[17];
// 103F57C: using guessed type wchar_t aNetClrRemoting[18];
// 103F5C4: using guessed type wchar_t aNotDisplayed[14];

//----- (00FCC500) --------------------------------------------------------
int dynamic_initializer_for_gPerformanceInfoInMemory__()
{
  int result; // eax

  if ( gNetClrMemoryPerfInfoLoaded )
  {
    gLoadNetClrMemoryPerfInfoTimeLast = gLoadNetClrMemoryPerfInfoTime;
    GetSystemTimeAsFileTime(&gLoadNetClrMemoryPerfInfoTime);
    result = PerformanceInfoInMemory::Load(
               &gPerformanceInfoInMemory,
               0,
               L".NET CLR Memory,.NET CLR Exceptions,.NET CLR Remoting,.NET CLR LocksAndThreads,.NET CLR Security,.NET CLR"
                " Jit,.NET CLR Loading,.NET CLR Interop,.NET CLR Data");
  }
  return result;
}
// 106A098: using guessed type char gNetClrMemoryPerfInfoLoaded;
// 106A0A8: using guessed type struct _FILETIME gLoadNetClrMemoryPerfInfoTimeLast;

//----- (00FCC540) --------------------------------------------------------
char __cdecl sub_FCC540(int a1, WPARAM wParam)
{
  char result; // al

  result = 0;
  if ( !byte_106A099 )
    result = sub_FCA870(a1, wParam);
  return result;
}
// 106A099: using guessed type char byte_106A099;

//----- (00FCC600) --------------------------------------------------------
CSystemProcessInfoMapNode *__thiscall std::_Tree_comp_alloc<std::_Tmap_traits<unsigned long,_SYSTEM_PROCESSOR_IDLE_CYCLE_TIME_INFORMATION *,std::less<unsigned long>,std::allocator<std::pair<unsigned long const,_SYSTEM_PROCESSOR_IDLE_CYCLE_TIME_INFORMATION *>>,0>>::_Buynode<std::piecewise_construct_t const &,std::tuple<unsigned long &&>,std::tuple<>>(CSystemProcessInfoMap *this, CSystemProcessInfoMapPair *a1)
{
  CSystemProcessInfoMapNode *result; // eax

  result = std::_Tree_comp_alloc<std::_Tmap_traits<unsigned long,_SYSTEM_PROCESSOR_IDLE_CYCLE_TIME_INFORMATION *,std::less<unsigned long>,std::allocator<std::pair<unsigned long const,_SYSTEM_PROCESSOR_IDLE_CYCLE_TIME_INFORMATION *>>,0>>::_Buynode0(this);
  *&result->baseclass._Color = 0;
  if ( result != -16 )
    result->_Keyvalue = *a1;
  return result;
}

//----- (00FCC630) --------------------------------------------------------
CSystemProcessInfoMapNode **__thiscall sub_FCC630(CSystemProcessInfoMap *thisMap, CSystemProcessInfoMapNode **ppNode, char a3, CSystemProcessInfoMapNode *pNode, CSystemProcessInfoMapPair *pair, int a6)
{
  CSystemProcessInfoMap *this; // edi
  CSystemProcessInfoMapNode *v7; // eax
  CSystemProcessInfoMapNode *v8; // ebx
  std__Tree_node *v9; // eax
  std__Tree_node *v10; // eax
  std__Tree_node *v11; // ecx
  std__Tree_node *v12; // esi
  std__Tree_node *v13; // edx
  std__Tree_node *v14; // edx
  std__Tree_node *v15; // ecx
  std__Tree_node *v16; // edx
  std__Tree_node *v17; // esi
  std__Tree_node_For__bstr_t *v18; // ecx
  std__Tree_node *v19; // ecx
  std__Tree_node *v20; // edx
  std__Tree_node_For__bstr_t *v21; // ecx
  std__Tree_node *v22; // ecx
  std__Tree_node *v23; // ecx
  CSystemProcessInfoMapNode **result; // eax

  this = thisMap;
  if ( thisMap->_Size >= 0xAAAAAA9u )
    std::_Xlength_error("map/set<T> too long");
  v7 = std::_Tree_comp_alloc<std::_Tmap_traits<unsigned long,_SYSTEM_PROCESSOR_IDLE_CYCLE_TIME_INFORMATION *,std::less<unsigned long>,std::allocator<std::pair<unsigned long const,_SYSTEM_PROCESSOR_IDLE_CYCLE_TIME_INFORMATION *>>,0>>::_Buynode<std::piecewise_construct_t const &,std::tuple<unsigned long &&>,std::tuple<>>(
         thisMap,
         pair);
  ++this->_Size;
  v8 = v7;
  v7->baseclass._Parent = pNode;
  if ( pNode == this->_Header )
  {
    this->_Header->_Parent = v7;
    this->_Header->_Left = v7;
    v9 = this->_Header;
LABEL_8:
    v9->_Right = v8;
    goto LABEL_9;
  }
  if ( !a3 )
  {
    pNode->baseclass._Right = v7;
    v9 = this->_Header;
    if ( pNode != this->_Header->_Right )
      goto LABEL_9;
    goto LABEL_8;
  }
  pNode->baseclass._Left = v7;
  if ( pNode == this->_Header->_Left )
    this->_Header->_Left = v7;
LABEL_9:
  v10 = v8;
  if ( !v8->baseclass._Parent->baseclass._Color )
  {
    do
    {
      v11 = v10->_Parent;
      v12 = v11->_Parent;
      v13 = v12->_Left;
      if ( v11 == v12->_Left )
      {
        v13 = v12->_Right;
        if ( v13->_Color )
        {
          if ( v10 == v11->_Right )
          {
            v10 = v10->_Parent;
            v14 = v11->_Right;
            v11->_Right = v14->_Left;
            if ( !v14->_Left->_IsNil )
              v14->_Left->_Parent = v11;
            v14->_Parent = v11->_Parent;
            if ( v11 == this->_Header->_Parent )
            {
              this->_Header->_Parent = v14;
            }
            else
            {
              v15 = v11->_Parent;
              if ( v10 == v15->_Left )
                v15->_Left = v14;
              else
                v15->_Right = v14;
            }
            v14->_Left = v10;
            v10->_Parent = v14;
          }
          v10->_Parent->_Color = 1;
          v10->_Parent->_Parent->_Color = 0;
          v16 = v10->_Parent->_Parent;
          v17 = v16->_Left;
          v16->_Left = v16->_Left->_Right;
          v18 = v17->_Right;
          if ( !v18->_IsNil )
            v18->_Parent = v16;
          v17->_Parent = v16->_Parent;
          if ( v16 == this->_Header->_Parent )
          {
            this->_Header->_Parent = v17;
            v17->_Right = v16;
          }
          else
          {
            v19 = v16->_Parent;
            if ( v16 == v19->_Right )
              v19->_Right = v17;
            else
              v19->_Left = v17;
            v17->_Right = v16;
          }
LABEL_48:
          v16->_Parent = v17;
          continue;
        }
      }
      else if ( v13->_Color )
      {
        if ( v10 == v11->_Left )
        {
          v10 = v10->_Parent;
          v20 = v11->_Left;
          v11->_Left = v11->_Left->_Right;
          v21 = v20->_Right;
          if ( !v21->_IsNil )
            v21->_Parent = v10;
          v20->_Parent = v10->_Parent;
          if ( v10 == this->_Header->_Parent )
          {
            this->_Header->_Parent = v20;
          }
          else
          {
            v22 = v10->_Parent;
            if ( v10 == v22->_Right )
              v22->_Right = v20;
            else
              v22->_Left = v20;
          }
          v20->_Right = v10;
          v10->_Parent = v20;
        }
        v10->_Parent->_Color = 1;
        v10->_Parent->_Parent->_Color = 0;
        v16 = v10->_Parent->_Parent;
        v17 = v16->_Right;
        v16->_Right = v17->_Left;
        if ( !v17->_Left->_IsNil )
          v17->_Left->_Parent = v16;
        v17->_Parent = v16->_Parent;
        if ( v16 == this->_Header->_Parent )
        {
          this->_Header->_Parent = v17;
        }
        else
        {
          v23 = v16->_Parent;
          if ( v16 == v23->_Left )
            v23->_Left = v17;
          else
            v23->_Right = v17;
        }
        v17->_Left = v16;
        goto LABEL_48;
      }
      v11->_Color = 1;
      v13->_Color = 1;
      v10->_Parent->_Parent->_Color = 0;
      v10 = v10->_Parent->_Parent;
    }
    while ( !v10->_Parent->_Color );
  }
  this->_Header->_Parent->_Color = 1;
  result = ppNode;
  *ppNode = v8;
  return result;
}

//----- (00FCC840) --------------------------------------------------------
int __thiscall std::map<unsigned long,unsigned long,std::less<unsigned long>,std::allocator<std::pair<unsigned long const,unsigned long>>>::operator[](CSystemProcessInfoMap *thisMap, int a2, _DWORD *a3, _DWORD *dwThreadId, int a5)
{
  CSystemProcessInfoMap *v5; // ebx
  std__Tree_node *v6; // ecx
  bool v7; // dl
  CSystemProcessInfoMapPair *v8; // edi
  CSystemProcessInfoMapNode *v9; // esi
  CSystemProcessInfoMapNode *v10; // eax
  unsigned int v11; // ecx
  CSystemProcessInfoMapNode *v12; // eax
  CSystemProcessInfoMapNode **v13; // eax
  CSystemProcessInfoMapNode *v14; // ecx
  int result; // eax
  int v16; // [esp+0h] [ebp-2Ch]
  CSystemProcessInfoMap *v17; // [esp+10h] [ebp-1Ch]
  std__Tree_node *v18; // [esp+14h] [ebp-18h]
  int v19; // [esp+18h] [ebp-14h]
  int *v20; // [esp+1Ch] [ebp-10h]
  int v21; // [esp+28h] [ebp-4h]

  v20 = &v16;
  v5 = thisMap;
  v17 = thisMap;
  v6 = thisMap->_Header;
  v7 = 1;
  v8 = dwThreadId;
  v9 = v6;
  v21 = 0;
  v18 = v6;
  v10 = v6->_Parent;
  LOBYTE(v19) = 1;
  if ( !v10->baseclass._isnil )
  {
    v11 = *dwThreadId;
    do
    {
      v9 = v10;
      if ( a3 )
        v7 = v10->_Keyvalue._Key >= v11;
      else
        v7 = v11 < v10->_Keyvalue._Key;
      LOBYTE(v19) = v7;
      if ( v7 )
        v10 = v10->baseclass._Left;
      else
        v10 = v10->baseclass._Right;
    }
    while ( !v10->baseclass._isnil );
    v6 = v18;
    v5 = v17;
  }
  v12 = v9;
  a3 = &v9->baseclass._Left;
  if ( v7 )
  {
    if ( v9 == v6->_Left )
    {
      v13 = sub_FCC630(v5, &a3, 1, v9, dwThreadId, a5);
LABEL_14:
      v14 = *v13;
      result = a2;
      *a2 = v14;
      *(a2 + 4) = 1;
      return result;
    }
    std::_Tree_unchecked_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<unsigned long const,_SYSTEM_PROCESSOR_IDLE_CYCLE_TIME_INFORMATION *>>>,std::_Iterator_base0>::operator--(&a3);
    v12 = a3;
  }
  if ( v12->_Keyvalue._Key < v8->_Key )
  {
    v13 = sub_FCC630(v5, &dwThreadId, v19, v9, v8, a5);
    goto LABEL_14;
  }
  *a2 = v12;
  result = a2;
  *(a2 + 4) = 0;
  return result;
}
// 10081AA: using guessed type void __stdcall __noreturn _CxxThrowException(_DWORD, _DWORD);

//----- (00FCCA10) --------------------------------------------------------
signed int __stdcall LogBufferCallback(int a1)
{
  return 1;
}

//----- (00FCCA20) --------------------------------------------------------
HANDLE ScanAllThreads()
{
  HANDLE hFound; // eax
  HANDLE hFound_1; // esi
  int a2; // [esp+4h] [ebp-30h]
  DWORD ThreadId; // [esp+Ch] [ebp-28h]
  DWORD v4; // [esp+10h] [ebp-24h]
  THREADENTRY32 ThreadEntry; // [esp+14h] [ebp-20h]

  hFound = CreateToolhelp32Snapshot(TH32CS_SNAPTHREAD, 0);
  hFound_1 = hFound;
  if ( hFound != INVALID_HANDLE_VALUE )
  {
    ThreadEntry.dwSize = sizeof(THREADENTRY32);
    if ( Thread32First(hFound, &ThreadEntry) )
    {
      do
      {
        ThreadId = ThreadEntry.th32ThreadID;
        v4 = ThreadEntry.th32OwnerProcessID;
        std::map<unsigned long,unsigned long,std::less<unsigned long>,std::allocator<std::pair<unsigned long const,unsigned long>>>::operator[](
          &gThreadProcessMap,
          &a2,
          0,
          &ThreadId,
          byte_106A100);
      }
      while ( Thread32Next(hFound_1, &ThreadEntry) );
    }
    hFound = CloseHandle(hFound_1);
  }
  return hFound;
}
// 106A100: using guessed type char byte_106A100;

//----- (00FCCAB0) --------------------------------------------------------
ULONG __thiscall TraceEventThreadProc(EVENT_TRACE_PROPERTIES_EXT *this)
{
  EVENT_TRACE_PROPERTIES_EXT *Properties; // edi
  __int64 *v2; // ebx
  WCHAR *pszLoggerName; // eax
  TRACEHANDLE v4; // rax
  ULONG ret; // esi
  TRACEHANDLE v6; // rax
  ULONG result; // eax
  _EVENT_TRACE_LOGFILEW LogFile; // [esp+8h] [ebp-1A4h]

  Properties = this;
  memset(&LogFile.LoggerName, 0, 0x19Cu);
  LogFile.LogFileName = 0;
  v2 = &Properties->TraceHandle;
  LogFile.Context = 0;
  pszLoggerName = L"PROCEXP TRACE";
  LogFile.BufferCallback = LogBufferCallback;
  if ( gdwVersion < 3 )
    pszLoggerName = L"NT Kernel Logger";
  LogFile.BuffersRead = 0;
  LogFile.LoggerName = pszLoggerName;
  LogFile.CurrentTime = 0i64;
  LogFile.u2.EventCallback = LogEventCallback;
  LogFile.u.LogFileMode = 0x1100;
  v4 = OpenTraceW_0(&LogFile);
  *v2 = v4;
  HIDWORD(Properties->TraceHandle) = HIDWORD(v4);
  if ( v4 )
  {
    do
    {
      ret = ProcessTrace_0(&Properties->TraceHandle, 1u, 0, 0);
      if ( ret )
        break;
      if ( WaitForSingleObject(Properties->EventHandle, 0) == WAIT_TIMEOUT )
      {
        ret = PE_RunTrace(Properties, 1);
        v6 = OpenTraceW_0(&LogFile);
        *v2 = v6;
        HIDWORD(Properties->TraceHandle) = HIDWORD(v6);
        if ( ret )
          break;
      }
    }
    while ( WaitForSingleObject(Properties->EventHandle, 0) == WAIT_TIMEOUT );
    result = ret;
  }
  else
  {
    result = -1;
  }
  Properties->fTraceStarted = 0;
  return result;
}
// 1040784: using guessed type wchar_t aProcexpTrace[14];
// 1064E54: using guessed type int gdwVersion;

//----- (00FCCBD0) --------------------------------------------------------
ULONG __stdcall TraceEventThreadProcEx(EVENT_TRACE_PROPERTIES_EXT *a1)
{
  return TraceEventThreadProc(a1);
}

//----- (00FCCBE0) --------------------------------------------------------
__int64 __thiscall PE_ComputeTime(PE_TIME *this, __int64 time)
{
  __int64 result; // rax

  if ( time >= 0 )
    result = (10000000 * (time % this->Frequency)) / this->Frequency + 10000000 * (time / this->Frequency);
  else
    result = -PE_ComputeTime(this, -time);
  return result;
}

//----- (00FCCC70) --------------------------------------------------------
unsigned __int8 *__cdecl sub_FCCC70(int a1, int a2, int a3, wchar_t *Dst, rsize_t SizeInWords)
{
  int v5; // ecx
  int v6; // eax
  wchar_t *v7; // edi
  wchar_t *v8; // esi
  unsigned int v9; // edx
  wchar_t v10; // ax
  unsigned __int8 *result; // eax
  unsigned int v12; // edx
  wchar_t v13; // ax
  unsigned int v14; // edx
  wchar_t v15; // ax
  int v16; // edi
  int v17; // edi
  int v18; // edi
  double v19; // xmm0_8
  int v20; // ST48_4
  int v21; // ecx
  unsigned int v22; // edx
  int i; // esi
  int v24; // ebx
  rsize_t v25; // edx
  int v26; // esi
  _WORD *v27; // eax
  unsigned int v28; // edx
  unsigned int v29; // edx
  int v30; // edi
  unsigned __int8 *v31; // edi
  int v32; // ebx
  const wchar_t *v33; // eax
  wchar_t *v34; // esi
  const wchar_t *v35; // eax
  int v36; // [esp+14h] [ebp-4h]

  v5 = a3;
  v6 = *(a3 + 8);
  v7 = a1;
  v36 = a1;
  switch ( v6 )
  {
    case 0:
      v8 = Dst;
      v9 = 0;
      if ( *(a3 + 12) )
      {
        do
        {
          v10 = *v7;
          v7 = (v7 + 1);
          v8[v9++] = v10;
        }
        while ( v9 < *(v5 + 12) );
      }
      goto LABEL_4;
    case 1:
      v8 = Dst;
      v14 = 0;
      if ( !*(a3 + 12) )
        goto LABEL_4;
      do
      {
        v15 = *v7;
        ++v7;
        v8[v14++] = v15;
      }
      while ( v14 < *(v5 + 12) );
      v8[*(v5 + 12)] = 0;
      return v7 - v36;
    case 2:
      v8 = Dst;
      v12 = 0;
      if ( *(a3 + 12) )
      {
        do
        {
          v13 = *v7;
          v7 = (v7 + 1);
          v8[v12++] = v13;
        }
        while ( v12 < *(v5 + 12) );
        v8[*(v5 + 12)] = 0;
        result = v7 - v36;
      }
      else
      {
LABEL_4:
        v8[*(v5 + 12)] = 0;
        result = v7 - v36;
      }
      return result;
    case 3:
      swprintf_s(Dst, SizeInWords, L"%d", *a1);
      return (v7 - v36 + 1);
    case 4:
      swprintf_s(Dst, SizeInWords, L"%d", *a1);
      return (v7 - v36 + 2);
    case 5:
      swprintf_s(Dst, SizeInWords, L"%u", *a1);
      return (v7 - v36 + 2);
    case 6:
      swprintf_s(Dst, SizeInWords, L"%d", *a1);
      goto LABEL_69;
    case 7:
      swprintf_s(Dst, SizeInWords, L"%lu", *a1);
      goto LABEL_69;
    case 8:
      goto LABEL_17;
    case 9:
      v16 = a1 + 8;
      swprintf_s(Dst, SizeInWords, L"%I64d", *a1, *(a1 + 4));
      return (v16 - v36);
    case 10:
      v17 = a1 + 8;
      swprintf_s(Dst, SizeInWords, L"%I64u", *a1, *(a1 + 4));
      return (v17 - v36);
    case 11:
      v18 = a1 + 4;
      v19 = *a1;
      goto LABEL_21;
    case 12:
      v19 = *a1;
      v18 = a1 + 8;
LABEL_21:
      swprintf_s(Dst, SizeInWords, L"%f", LODWORD(v19), HIDWORD(v19));
      return (v18 - v36);
    case 13:
    case 15:
    case 17:
    case 22:
      switch ( v6 )
      {
        case 13:
        case 22:
          v21 = a1;
          v22 = strlen(a1);
          for ( i = a1 + 1 + v22; v22; --v22 )
          {
            if ( *(a1 + v22 - 1) != 255 )
              break;
          }
          break;
        case 15:
          v22 = *a1;
          v7 = (a1 + 1);
          v21 = a1 + 1;
          i = v22 + a1 + 1;
          break;
        case 17:
          v22 = *(a1 + 1) + (*a1 << 8);
          v7 = (a1 + 2);
          v21 = a1 + 2;
          i = v22 + a1 + 2;
          break;
        default:
          v21 = a1;
          v22 = a1;
          i = a1;
          break;
      }
      if ( v22 > a2 - v21 )
        v22 = a2 - v21;
      if ( v22 > SizeInWords - 3 )
        v22 = SizeInWords - 3;
      swprintf_s(Dst, SizeInWords, L"\"%*S\"", v22, v7);
      return (i - v36);
    case 14:
    case 16:
    case 18:
    case 23:
      switch ( v6 )
      {
        case 14:
          v24 = a1;
          v25 = wcslen(a1);
          v26 = a1 + 2 + 2 * v25;
          if ( v25 )
          {
            v27 = (a1 - 2 + 2 * v25);
            do
            {
              v7 = a1;
              if ( *v27 != -1 )
                break;
              --v27;
              --v25;
            }
            while ( v25 );
          }
          break;
        case 16:
          v29 = *a1;
          v7 = (a1 + 1);
          v24 = a1 + 1;
          v26 = v29 + a1 + 1;
          v25 = v29 >> 1;
          break;
        case 18:
          v7 = (a1 + 2);
          v24 = a1 + 2;
          v28 = *(a1 + 1) + (*a1 << 8);
          v26 = v28 + a1 + 2;
          v25 = v28 >> 1;
          break;
        case 23:
          v24 = a1;
          v26 = a2;
          v25 = (a2 - a1) >> 1;
          break;
        default:
          v24 = a1;
          v25 = a1;
          v26 = a1;
          break;
      }
      if ( 2 * v25 > a2 - v24 )
        v25 = (a2 - v24) >> 1;
      if ( v25 > SizeInWords - 3 )
        v25 = SizeInWords - 3;
      swprintf_s(Dst, SizeInWords, L"\"%*ws\"", v25, v7);
      return (v26 - v36);
    case 19:
      if ( *a1 )
      {
        if ( dword_105E0D0 == 64 )
          v31 = (a1 + 16);
        else
          v31 = (a1 + 8);
        v32 = 4 * v31[1] + 8;
        sub_FCE4E0(&a1, v31);
        if ( a1 )
          v33 = *a1;
        else
          v33 = 0;
        v34 = Dst;
        wcscpy_s(Dst, SizeInWords, v33);
        *v34 = 0;
        _bstr_t::_Free(&a1);
        result = &v31[v32 - v36];
      }
      else
      {
        v30 = a1 + 4;
        swprintf_s(Dst, SizeInWords, L"0");
        result = (v30 - v36);
      }
      return result;
    case 20:
      swprintf_s(Dst, SizeInWords, L"%03d.%03d.%03d.%03d", *a1, *a1 >> 8, (*a1 >> 16) & 0xFF, *a1 >> 24);
      return (v7 - v36 + 4);
    case 21:
      v20 = ntohs(*a1);
      swprintf_s(Dst, SizeInWords, L"%u", v20);
      return (v7 - v36 + 2);
    case 24:
      if ( dword_105E0D0 == 64 )
      {
        swprintf_s(Dst, SizeInWords, L"0x%X", *a1);
        result = (v7 - v36 + 8);
      }
      else
      {
LABEL_17:
        swprintf_s(Dst, SizeInWords, L"0x%08X", *a1);
LABEL_69:
        result = (v7 - v36 + 4);
      }
      return result;
    case 25:
      sub_F992A0(Dst, SizeInWords, a1);
      return (v7 - v36 + 16);
    case 26:
      v35 = L"TRUE";
      if ( !*a1 )
        v35 = L"FALSE";
      swprintf_s(Dst, SizeInWords, L"%s", v35);
      goto LABEL_69;
    case 27:
      swprintf_s(
        Dst,
        SizeInWords,
        L"%02x%02x:%02x%02x:%02x%02x:%02x%02x:%02x%02x:%02x%02x:%02x%02x:%02x%02x",
        *a1,
        *(a1 + 1),
        *(a1 + 2),
        *(a1 + 3),
        *(a1 + 4),
        *(a1 + 5),
        *(a1 + 6),
        *(a1 + 7),
        *(a1 + 8),
        *(a1 + 9),
        *(a1 + 10),
        *(a1 + 11),
        *(a1 + 12),
        *(a1 + 13),
        *(a1 + 14),
        *(a1 + 15));
      return (v7 - v36 + 16);
    default:
      goto LABEL_69;
  }
}
// 103E200: using guessed type wchar_t a0x08x[7];
// 105E0D0: using guessed type int dword_105E0D0;

//----- (00FCD220) --------------------------------------------------------
ULONG __thiscall PE_FlushTrace(LPEVENT_TRACE_PROPERTIES_EXT Properties)
{
  return FlushTraceW(Properties->TraceHandle, 0, &Properties->baseclass);
}

//----- (00FCD240) --------------------------------------------------------
int __cdecl NetworkMsgItem2_FindID(WCHAR *lpszText)
{
  int index; // esi
  int v2; // eax

  index = 0;
  while ( 1 )
  {
    v2 = wcscmp(gNetworkMsgItem2[index].szText, lpszText);
    if ( v2 )
      v2 = -(v2 < 0) | 1;
    if ( !v2 )
      break;
    if ( ++index >= 56 )
      return 0;
  }
  return gNetworkMsgItem2[index].nID;
}

//----- (00FCD2B0) --------------------------------------------------------
std__Tree_node *__cdecl sub_FCD2B0(unsigned int a1)
{
  std__Tree_node *v1; // ecx
  std__Tree_node *v2; // eax
  std__Tree_node *result; // eax
  std__Tree_node *v4; // [esp+4h] [ebp-4h]

  v1 = gThreadProcessMap._Header;
  v2 = gThreadProcessMap._Header->_Parent;
  if ( v2->_IsNil )
    goto LABEL_14;
  do
  {
    if ( v2[1]._Left >= a1 )
    {
      v1 = v2;
      v2 = v2->_Left;
    }
    else
    {
      v2 = v2->_Right;
    }
  }
  while ( !v2->_IsNil );
  if ( v1 == gThreadProcessMap._Header || (v4 = v1, a1 < v1[1]._Left) )
LABEL_14:
    v4 = gThreadProcessMap._Header;
  if ( v4 == gThreadProcessMap._Header )
    result = -1;
  else
    result = v4[1]._Parent;
  return result;
}

//----- (00FCD310) --------------------------------------------------------
signed int __thiscall PE_RunTrace(EVENT_TRACE_PROPERTIES_EXT *PropertiesIn, char fStart)
{
  EVENT_TRACE_PROPERTIES_EXT *Properties; // ebx
  HMODULE v4; // edi
  MACRO_EVENT_TRACE_TYPE LogMode; // eax
  bool v6; // sf
  unsigned __int8 v7; // of
  const wchar_t *pszSessionName; // eax
  int EnableFlags; // eax
  int uret; // eax
  int lRet; // esi
  HANDLE v12; // ST14_4
  DWORD ThreadId; // [esp+4h] [ebp-4h]

  Properties = PropertiesIn;
  if ( PropertiesIn->fTraceStarted == fStart )
    return 0;
  if ( !PropertiesIn->ApiLoaded )
  {
    v4 = LoadLibraryW(L"advapi32.dll");
    StartTraceW_0 = GetProcAddress(v4, "StartTraceW");
    ControlTraceW_0 = GetProcAddress(v4, "ControlTraceW");
    *OpenTraceW_0 = GetProcAddress(v4, "OpenTraceW");
    *ProcessTrace_0 = GetProcAddress(v4, "ProcessTrace");
    Properties->ApiLoaded = 1;
  }
  if ( !StartTraceW_0 )
    return 1;
  LogMode = 0;
  Properties->baseclass.Wnode.BufferSize = 0x4B0;
  Properties->baseclass.Wnode.Flags = WNODE_FLAG_TRACED_GUID;
  Properties->baseclass.FlushTimer = 1;
  v7 = __OFSUB__(gdwVersion, 3);
  v6 = gdwVersion - 3 < 0;
  Properties->baseclass.Wnode.ClientContext = 1;
  if ( !(v6 ^ v7) )
    LogMode = EVENT_TRACE_FLAG_FILE_IO;
  Properties->baseclass.LogFileMode = LogMode | EVENT_TRACE_REAL_TIME_MODE;
  if ( gdwVersion < 3 )
    _mm_storeu_si128(&Properties->baseclass.Wnode.Guid, _mm_loadu_si128(&stru_10400E0));
  Properties->baseclass.LoggerNameOffset = 120;
  Properties->baseclass.LogFileNameOffset = 640;
  pszSessionName = L"PROCEXP TRACE";
  if ( gdwVersion < 3 )
    pszSessionName = L"NT Kernel Logger";
  wcscpy_s(Properties->szSessionName, MAX_PATH, pszSessionName);
  wcscpy_s(Properties->szLogFileName, MAX_PATH, &gszNullString);
  EnableFlags = Properties->baseclass.EnableFlags | 0x10100;// EVENT_TRACE_FLAG_DISK_IO|EVENT_TRACE_FLAG_NETWORK_TCPIP
  Properties->baseclass.EnableFlags = EnableFlags;
  if ( gdwVersion >= 3 )
    Properties->baseclass.EnableFlags = EnableFlags | EVENT_TRACE_FLAG_THREAD;
  if ( fStart )
  {
    uret = StartTraceW_0(&Properties->SessionHandle, Properties->szSessionName, &Properties->baseclass);
    lRet = uret;
    if ( !uret || uret == ERROR_ALREADY_EXISTS )
    {
      Properties->fTraceStarted = 1;
      lRet = 0;
      Properties->ThreadHandle = _beginthreadex(0, 0, TraceEventThreadProcEx, Properties, 0, &ThreadId);
      if ( gdwVersion >= 3 )
      {
        ScanAllThreads();
        return 0;
      }
    }
  }
  else
  {
    SetEvent(Properties->EventHandle);
    lRet = ControlTraceW_0(
             Properties->SessionHandle,
             Properties->szSessionName,
             &Properties->baseclass,
             EVENT_TRACE_CONTROL_STOP);
    WaitForSingleObject(Properties->ThreadHandle, 0xFFFFFFFF);
    CloseHandle(Properties->ThreadHandle);
    v12 = Properties->EventHandle;
    Properties->ThreadHandle = 0;
    ResetEvent(v12);
  }
  return lRet;
}
// 10400E0: using guessed type GUID stru_10400E0;
// 1040784: using guessed type wchar_t aProcexpTrace[14];
// 1064E54: using guessed type int gdwVersion;

//----- (00FCD510) --------------------------------------------------------
void __cdecl sub_FCD510(EVENT_TRACE *EventTrace, EventList *Param)
{
  ULONG ThreadId; // eax
  Data_t_bstr_t *v3; // eax
  Data_t_bstr_t *v4; // esi
  EventListNode *v5; // eax
  OLECHAR *v6; // eax
  EventListNode *v7; // edi
  int v8; // esi
  const unsigned __int16 *v9; // eax
  int v10; // eax
  int v11; // eax
  UCHAR Type; // cl
  EVENT_TRACE *v13; // ecx
  EventListNode *v14; // eax
  int *v15; // ebx
  EventListNode *v16; // edi
  _bstr_t *v17; // esi
  unsigned int v18; // eax
  WCHAR *v19; // eax
  int v20; // eax
  Data_t_bstr_t *v21; // eax
  Data_t_bstr_t *v22; // esi
  int v23; // eax
  int v24; // eax
  int v25; // eax
  int v26; // eax
  int v27; // eax
  int v28; // eax
  int v29; // eax
  int v30; // eax
  unsigned int v31; // eax
  Data_t_bstr_t *v32; // eax
  Data_t_bstr_t *v33; // esi
  Data_t_bstr_t *v34; // esi
  Data_t_bstr_t *v35; // eax
  Data_t_bstr_t *v36; // esi
  Data_t_bstr_t *v37; // eax
  Data_t_bstr_t *v38; // edi
  Data_t_bstr_t *v39; // esi
  Data_t_bstr_t *v40; // esi
  __int64 v41; // [esp-8h] [ebp-894h]
  ULONG ProcessId; // [esp+14h] [ebp-878h]
  int Buffer[19]; // [esp+18h] [ebp-874h]
  _bstr_t a2a; // [esp+64h] [ebp-828h]
  EventList *ParamIn; // [esp+6Ch] [ebp-820h]
  void *v46; // [esp+70h] [ebp-81Ch]
  _bstr_t a3; // [esp+74h] [ebp-818h]
  EVENT_TRACE *EventTrace_1; // [esp+78h] [ebp-814h]
  WCHAR psz[1024]; // [esp+7Ch] [ebp-810h]
  int v50; // [esp+888h] [ebp-4h]

  EventTrace_1 = EventTrace;
  ParamIn = Param;
  memset(Buffer, 0, 76u);
  a2a.m_Data = 0;
  ProcessId = EventTrace->Header.ProcessId;
  ThreadId = EventTrace->Header.ThreadId;
  HIDWORD(v41) = 0;
  if ( ThreadId == -1 )
    ThreadId = 0;
  v50 = 0;
  Buffer[0] = ThreadId;
  LODWORD(v41) = EventTrace->Header.u4.s.KernelTime + EventTrace->Header.u4.s.UserTime;
  Buffer[1] = 1;
  *&Buffer[3] = PE_ComputeTime(&gTime, v41);
  v3 = operator new(0xCu);
  v4 = v3;
  if ( v3 )
  {
    v3->m_str = 0;
    v3->m_RefCount = 1;
    v3->m_wstr = SysAllocString(0);
  }
  else
  {
    v4 = 0;
  }
  LOBYTE(v50) = 0;
  a2a.m_Data = v4;
  if ( !v4 )
LABEL_7:
    _com_issue_error(E_OUTOFMEMORY);
  v5 = Param[4]._Myheader;
  if ( v5 && (v6 = v5->field_0) != 0 && SysStringLen(v6) )
  {
    v7 = Param[4]._Myheader;
    v8 = 0;
    Buffer[1] = 0;
    while ( 1 )
    {
      if ( v7 )
        v9 = v7->field_0;
      else
        v9 = 0;
      v10 = wcscmp(v9, gReadWriteMsgItem[v8].szText);
      if ( v10 )
        v10 = -(v10 < 0) | 1;
      if ( !v10 )
        break;
      if ( ++v8 >= 3 )
        goto LABEL_25;
    }
    v11 = gReadWriteMsgItem[v8].nID;
  }
  else
  {
    Type = EventTrace->Header.u2.Class.Type;
    if ( Type == 0xB )
    {
      Buffer[1] = 3;
      goto LABEL_25;
    }
    v11 = (Type == 10) + 1;
  }
  Buffer[1] = v11;
LABEL_25:
  v13 = EventTrace_1;
  v14 = ParamIn[3]._Myheader;
  v15 = EventTrace_1->MofData;
  v16 = v14->field_0;
  if ( v14->field_0 != v14 )
  {
    while ( v15 < v13->MofData + v13->MofLength )
    {
      v17 = v16[1].field_0;
      v18 = &v17[1].m_Data->m_wstr + 1;
      while ( 2 )
      {
        switch ( v18 )
        {
          case 0u:
            if ( v17->m_Data )
              v19 = v17->m_Data->m_wstr;
            else
              v19 = 0;
            v20 = NetworkMsgItem2_FindID(v19);
            v17[1].m_Data = v20;
            v18 = v20 + 1;
            if ( v18 > 0x15 )
              goto LABEL_33;
            continue;
          case 1u:
          case 2u:
          case 3u:
          case 4u:
          case 5u:
          case 6u:
          case 7u:
          case 8u:
          case 9u:
          case 0xAu:
          case 0xBu:
          case 0xCu:
LABEL_33:
            v13 = EventTrace_1;
            goto LABEL_34;
          case 0xDu:
            v23 = *v15;
            ++v15;
            Buffer[5] = v23;
            goto LABEL_69;
          case 0xEu:
            v24 = *v15;
            ++v15;
            Buffer[6] = v24;
            goto LABEL_69;
          case 0xFu:
            v25 = *v15;
            ++v15;
            Buffer[7] = v25;
            Buffer[8] = 0;
            goto LABEL_69;
          case 0x10u:
            v26 = *v15;
            ++v15;
            Buffer[9] = v26;
            goto LABEL_69;
          case 0x11u:
            Buffer[11] = *v15;
            v27 = v15[1];
            v15 += 2;
            Buffer[12] = v27;
            goto LABEL_69;
          case 0x12u:
            Buffer[13] = *v15;
            if ( dword_105E0D0 == 64 )
            {
              v28 = v15[1];
              v15 += 2;
              Buffer[14] = v28;
            }
            else
            {
              Buffer[14] = 0;
              ++v15;
            }
            goto LABEL_69;
          case 0x13u:
            Buffer[15] = *v15;
            if ( dword_105E0D0 == 64 )
            {
              v29 = v15[1];
              v15 += 2;
              Buffer[16] = v29;
            }
            else
            {
              Buffer[16] = 0;
              ++v15;
            }
            goto LABEL_69;
          case 0x14u:
            Buffer[17] = *v15;
            v30 = v15[1];
            v15 += 2;
            Buffer[18] = v30;
            goto LABEL_69;
          case 0x15u:
            v31 = *v15;
            Buffer[0] = *v15;
            if ( ProcessId == -1 )
              ProcessId = sub_FCD2B0(v31);
            goto LABEL_69;
          default:
LABEL_34:
            psz[0] = 0;
            v15 = (v15 + sub_FCCC70(v15, v13->MofData + v13->MofLength, v17, psz, 0x400u));
            _bstr_t::operator+=(&a2a, v17);
            v21 = operator new(0xCu);
            v46 = v21;
            LOBYTE(v50) = 2;
            if ( v21 )
              v22 = _bstr_t::Data_t::Data_t(v21, &a2a, &gNullString);
            else
              v22 = 0;
            LOBYTE(v50) = 0;
            if ( !v22 )
              goto LABEL_7;
            _bstr_t::_Free(&a2a);
            a2a.m_Data = v22;
            _bstr_t::_bstr_t(&a3, psz);
            LOBYTE(v50) = 3;
            v32 = operator new(0xCu);
            v46 = v32;
            LOBYTE(v50) = 4;
            v33 = (v32 ? _bstr_t::Data_t::Data_t(v32, &a2a, &a3) : 0);
            LOBYTE(v50) = 3;
            if ( !v33 )
              goto LABEL_7;
            _bstr_t::_Free(&a2a);
            a2a.m_Data = v33;
            v34 = a3.m_Data;
            LOBYTE(v50) = 0;
            if ( a3.m_Data )
            {
              if ( !InterlockedDecrement(&a3.m_Data->m_RefCount) )
              {
                if ( v34->m_wstr )
                {
                  SysFreeString(v34->m_wstr);
                  v34->m_wstr = 0;
                }
                if ( v34->m_str )
                {
                  j_j__free(v34->m_str);
                  v34->m_str = 0;
                }
                j__free(v34);
              }
              a3.m_Data = 0;
            }
            v35 = operator new(0xCu);
            v46 = v35;
            LOBYTE(v50) = 5;
            v36 = (v35 ? _bstr_t::Data_t::Data_t(v35, &a2a, &gNullString) : 0);
            LOBYTE(v50) = 0;
            if ( !v36 )
              goto LABEL_7;
            _bstr_t::_Free(&a2a);
            a2a.m_Data = v36;
LABEL_69:
            v16 = v16->field_0;
            v13 = EventTrace_1;
            if ( v16 == ParamIn[3]._Myheader )
              goto LABEL_70;
            break;
        }
        break;
      }
    }
  }
LABEL_70:
  v37 = operator new(0xCu);
  v46 = v37;
  LOBYTE(v50) = 6;
  if ( v37 )
    v38 = _bstr_t::Data_t::Data_t(v37, &a2a, &gNullString);
  else
    v38 = 0;
  LOBYTE(v50) = 0;
  if ( !v38 )
    _com_issue_error(E_OUTOFMEMORY);
  v39 = a2a.m_Data;
  if ( a2a.m_Data && !InterlockedDecrement(&a2a.m_Data->m_RefCount) && v39 )
  {
    if ( v39->m_wstr )
    {
      SysFreeString(v39->m_wstr);
      v39->m_wstr = 0;
    }
    if ( v39->m_str )
    {
      j_j__free(v39->m_str);
      v39->m_str = 0;
    }
    j__free(v39);
  }
  a2a.m_Data = v38;
  sub_FF5250(&ProcessId);
  v40 = a2a.m_Data;
  if ( a2a.m_Data && !InterlockedDecrement(&a2a.m_Data->m_RefCount) && v40 )
  {
    if ( v40->m_wstr )
    {
      SysFreeString(v40->m_wstr);
      v40->m_wstr = 0;
    }
    if ( v40->m_str )
    {
      j_j__free(v40->m_str);
      v40->m_str = 0;
    }
    j__free(v40);
  }
}
// 10406FC: using guessed type NetworkMsgItem gReadWriteMsgItem[3];
// 105E0D0: using guessed type int dword_105E0D0;

//----- (00FCDB10) --------------------------------------------------------
void __stdcall LogEventCallback(PEVENT_TRACE EventTrace)
{
  _bstr_t *v1; // eax

  if ( EventTrace )
  {
    v1 = sub_F98730(
           &gWbemServiceList,
           &EventTrace->Header.u3.Guid,
           EventTrace->Header.u2.Class.Type,
           EventTrace->Header.u2.Class.Version,
           EventTrace->Header.u2.Class.Level);
    if ( v1 )
      sub_FCDB50(EventTrace, v1);
  }
}

//----- (00FCDB50) --------------------------------------------------------
void __cdecl sub_FCDB50(EVENT_TRACE *EventTrace, EventList *a2)
{
  EventListNode *v2; // esi
  const unsigned __int16 *v3; // eax
  int v4; // eax
  const unsigned __int16 *v5; // eax
  int v6; // eax
  const unsigned __int16 *v7; // eax
  int v8; // eax
  const unsigned __int16 *v9; // eax
  int v10; // eax
  const unsigned __int16 *v11; // eax
  int v12; // eax

  if ( EventTrace->MofData || !EventTrace->MofLength )
  {
    v2 = a2->_Myheader;
    if ( a2->_Myheader )
      v3 = v2->field_0;
    else
      v3 = 0;
    v4 = wcscmp(v3, L"DiskIo");
    if ( v4 )
      v4 = -(v4 < 0) | 1;
    if ( v4 )
    {
      if ( v2 )
        v5 = v2->field_0;
      else
        v5 = 0;
      v6 = wcscmp(v5, L"Thread");
      if ( v6 )
        v6 = -(v6 < 0) | 1;
      if ( v6 )
      {
        if ( v2 )
          v7 = v2->field_0;
        else
          v7 = 0;
        v8 = wcscmp(v7, L"TcpIp");
        if ( v8 )
          v8 = -(v8 < 0) | 1;
        if ( !v8 )
          goto LABEL_38;
        if ( v2 )
          v9 = v2->field_0;
        else
          v9 = 0;
        v10 = wcscmp(v9, L"UdpIp");
        if ( v10 )
          v10 = -(v10 < 0) | 1;
        if ( !v10 )
          goto LABEL_38;
        v11 = (v2 ? v2->field_0 : 0);
        v12 = wcscmp(v11, L"MSNT_TcpIpInformation");
        if ( v12 )
          v12 = -(v12 < 0) | 1;
        if ( !v12 )
LABEL_38:
          sub_FCDCE0(EventTrace, a2);
      }
      else
      {
        sub_FCE310(EventTrace, a2);
      }
    }
    else
    {
      sub_FCD510(EventTrace, a2);
    }
  }
}
// 1040730: using guessed type wchar_t aDiskio[7];
// 1040740: using guessed type wchar_t aTcpip[6];
// 104074C: using guessed type wchar_t aUdpip[6];
// 1040758: using guessed type wchar_t aMsntTcpipinfor[22];

//----- (00FCDCE0) --------------------------------------------------------
void __cdecl sub_FCDCE0(EVENT_TRACE *EventTrace, EventList *a2)
{
  ULONG v2; // eax
  Data_t_bstr_t *v3; // eax
  Data_t_bstr_t *v4; // esi
  EventList *v5; // edi
  const wchar_t *v6; // eax
  OLECHAR **v7; // eax
  OLECHAR *v8; // eax
  const unsigned __int16 **v9; // edi
  int nIndex; // esi
  const unsigned __int16 *v11; // eax
  int v12; // eax
  EVENT_TRACE *v13; // edx
  EventListNode *v14; // eax
  unsigned int v15; // esi
  EventListNode *v16; // edi
  int v17; // ecx
  unsigned int v18; // eax
  UCHAR v19; // cl
  WCHAR *v20; // eax
  int v21; // eax
  Data_t_bstr_t *v22; // esi
  Data_t_bstr_t *v23; // eax
  Data_t_bstr_t *v24; // edi
  __m128i v25; // xmm0
  int v26; // eax
  __m128i v27; // xmm0
  int v28; // eax
  int v29; // eax
  ULONG v30; // eax
  Data_t_bstr_t *v31; // esi
  __m128i v32; // xmm1
  int v33; // edx
  __m128i v34; // xmm0
  __int16 v35; // cx
  __int16 v36; // ax
  Data_t_bstr_t *v37; // esi
  unsigned __int8 *v38; // [esp+10h] [ebp-874h]
  _bstr_t *a2a; // [esp+14h] [ebp-870h]
  _bstr_t v40; // [esp+18h] [ebp-86Ch]
  EventList *v41; // [esp+1Ch] [ebp-868h]
  EVENT_TRACE *v42; // [esp+20h] [ebp-864h]
  ULONG v43; // [esp+24h] [ebp-860h]
  ULONG v44; // [esp+28h] [ebp-85Ch]
  int v45; // [esp+2Ch] [ebp-858h]
  __int64 v46; // [esp+34h] [ebp-850h]
  int v47; // [esp+3Ch] [ebp-848h]
  int v48; // [esp+40h] [ebp-844h]
  __int128 v49; // [esp+44h] [ebp-840h]
  int v50; // [esp+54h] [ebp-830h]
  __int128 v51; // [esp+58h] [ebp-82Ch]
  int v52; // [esp+68h] [ebp-81Ch]
  int v53; // [esp+6Ch] [ebp-818h]
  _bstr_t v54; // [esp+70h] [ebp-814h]
  OLECHAR psz; // [esp+74h] [ebp-810h]
  int v56; // [esp+880h] [ebp-4h]

  v41 = a2;
  v42 = EventTrace;
  memset(&v44, 0, 0x48u);
  v54.m_Data = 0;
  v43 = EventTrace->Header.ProcessId;
  v2 = EventTrace->Header.ThreadId;
  v56 = 0;
  if ( v2 == -1 )
    v2 = 0;
  v47 = 0;
  v44 = v2;
  v45 = 1;
  v48 = 0;
  v50 = 0;
  v52 = 0;
  v53 = 0;
  _mm_storeu_si128(&v49, 0i64);
  _mm_storeu_si128(&v51, 0i64);
  v3 = operator new(0xCu);
  v4 = v3;
  if ( v3 )
  {
    v3->m_str = 0;
    v3->m_RefCount = 1;
    v3->m_wstr = SysAllocString(0);
  }
  else
  {
    v4 = 0;
  }
  LOBYTE(v56) = 0;
  v54.m_Data = v4;
  if ( !v4 )
    _com_issue_error(E_OUTOFMEMORY);
  v5 = v41;
  v46 = PE_ComputeTime(&gTime, EventTrace->Header.u4.s.KernelTime + EventTrace->Header.u4.s.UserTime);
  if ( v41->_Myheader )
    v6 = v41->_Myheader->field_0;
  else
    v6 = 0;
  v47 = 2 - (_wcsnicmp(v6, L"Udp", 3u) != 0);
  v7 = v41[4]._Myheader;
  if ( !v7 || (v8 = *v7) == 0 || !SysStringLen(v8) )
  {
    v13 = v42;
    v19 = v42->Header.u2.Class.Type;
    if ( v19 == 11 )
      v45 = 3;
    else
      v45 = (v19 == 10) + 1;
    goto LABEL_25;
  }
  v9 = v41[4]._Myheader;
  nIndex = 0;
  v45 = 0;
  while ( 1 )
  {
    if ( v9 )
      v11 = *v9;
    else
      v11 = 0;
    v12 = wcscmp(v11, gNetworkMsgItem[nIndex].szText);
    if ( v12 )
      v12 = -(v12 < 0) | 1;
    if ( !v12 )
      break;
    if ( ++nIndex >= 24 )
      goto LABEL_74;
  }
  v45 = gNetworkMsgItem[nIndex].nID;
  if ( v45 )
  {
    v13 = v42;
    v5 = v41;
LABEL_25:
    v14 = v5[3]._Myheader;
    v15 = v13->MofData;
    v16 = v14->field_0;
    if ( v14->field_0 != v14 )
    {
      do
      {
        if ( v15 >= v13->MofData + v13->MofLength )
          break;
        v17 = v16[1].field_0;
        a2a = v17;
        v18 = *(v17 + 4) + 1;
        while ( 2 )
        {
          switch ( v18 )
          {
            case 0u:
              if ( *v17 )
                v20 = **v17;
              else
                v20 = 0;
              v21 = NetworkMsgItem2_FindID(v20);
              v17 = a2a;
              a2a[1].m_Data = v21;
              v18 = v21 + 1;
              if ( v18 <= 9 )
                continue;
              goto LABEL_36;
            case 1u:
            case 2u:
            case 3u:
LABEL_36:
              v13 = v42;
              goto LABEL_37;
            case 4u:
              if ( *(v17 + 8) == 27 )
              {
                LOBYTE(v51) = 1;
                v25 = _mm_loadu_si128(v15);
                v15 += 16;
                _mm_storeu_si128((&v51 + 4), v25);
              }
              else
              {
                LOBYTE(v51) = 0;
                v26 = *v15;
                v15 += 4;
                DWORD1(v51) = v26;
              }
              break;
            case 5u:
              if ( *(v17 + 8) == 27 )
              {
                LOBYTE(v49) = 1;
                v27 = _mm_loadu_si128(v15);
                v15 += 16;
                _mm_storeu_si128((&v49 + 4), v27);
              }
              else
              {
                LOBYTE(v49) = 0;
                v28 = *v15;
                v15 += 4;
                DWORD1(v49) = v28;
              }
              break;
            case 6u:
              HIWORD(v53) = ntohs(*v15);
              v15 += 2;
              break;
            case 7u:
              LOWORD(v53) = ntohs(*v15);
              v15 += 2;
              break;
            case 8u:
              v29 = *v15;
              v15 += 4;
              v48 = v29;
              break;
            case 9u:
              v30 = *v15;
              v15 += 4;
              v43 = v30;
              break;
            default:
LABEL_37:
              psz = 0;
              v38 = &sub_FCCC70(v15, v13->MofData + v13->MofLength, v17, &psz, 0x400u)[v15];
              _bstr_t::operator+=(&v54, a2a);
              _bstr_t::operator+=(&v54, &gNullString);
              _bstr_t::_bstr_t(&v40, &psz);
              LOBYTE(v56) = 2;
              _bstr_t::operator+=(&v54, &v40);
              v22 = v40.m_Data;
              LOBYTE(v56) = 0;
              if ( v40.m_Data )
              {
                if ( !InterlockedDecrement(&v40.m_Data->m_RefCount) )
                {
                  if ( v22->m_wstr )
                  {
                    SysFreeString(v22->m_wstr);
                    v22->m_wstr = 0;
                  }
                  if ( v22->m_str )
                  {
                    j_j__free(v22->m_str);
                    v22->m_str = 0;
                  }
                  j__free(v22);
                }
                v40.m_Data = 0;
              }
              _bstr_t::operator+=(&v54, &gNullString);
              v15 = v38;
              break;
          }
          break;
        }
        v16 = v16->field_0;
        v13 = v42;
      }
      while ( v16 != v41[3]._Myheader );
    }
    v23 = operator new(0xCu);
    LOBYTE(v56) = 3;
    if ( v23 )
      v24 = _bstr_t::Data_t::Data_t(v23, &v54, &gNullString);
    else
      v24 = 0;
    LOBYTE(v56) = 0;
    if ( !v24 )
      _com_issue_error(E_OUTOFMEMORY);
    v31 = v54.m_Data;
    if ( v54.m_Data && !InterlockedDecrement(&v54.m_Data->m_RefCount) && v31 )
    {
      if ( v31->m_wstr )
      {
        SysFreeString(v31->m_wstr);
        v31->m_wstr = 0;
      }
      if ( v31->m_str )
      {
        j_j__free(v31->m_str);
        v31->m_str = 0;
      }
      j__free(v31);
    }
    v54.m_Data = v24;
    if ( v47 == 2 && v45 == 3 )
    {
      v32 = _mm_loadu_si128(&v51);
      v33 = v52;
      v34 = _mm_loadu_si128(&v49);
      v35 = HIWORD(v53);
      v52 = v50;
      v36 = v53;
      _mm_storeu_si128(&v51, v34);
      HIWORD(v53) = v36;
      _mm_storeu_si128(&v49, v32);
      v50 = v33;
      LOWORD(v53) = v35;
    }
    sub_FF5310(&v43);
  }
LABEL_74:
  v37 = v54.m_Data;
  if ( v54.m_Data && !InterlockedDecrement(&v54.m_Data->m_RefCount) && v37 )
  {
    if ( v37->m_wstr )
    {
      SysFreeString(v37->m_wstr);
      v37->m_wstr = 0;
    }
    if ( v37->m_str )
    {
      j_j__free(v37->m_str);
      v37->m_str = 0;
    }
    j__free(v37);
  }
}

//----- (00FCE310) --------------------------------------------------------
int **__cdecl sub_FCE310(int a1, int a2)
{
  int *v2; // edi
  const unsigned __int16 **v3; // eax
  const unsigned __int16 *v4; // eax
  int v5; // eax
  const unsigned __int16 **v6; // eax
  const unsigned __int16 *v7; // eax
  int **result; // eax
  int v9; // ecx
  int v10; // edx
  _DWORD *v11; // eax
  int **v12; // ebx
  _DWORD *v13; // esi
  int v14; // edi
  int v15; // eax
  WCHAR *v16; // eax
  int *v17; // eax
  const unsigned __int16 **v18; // eax
  const unsigned __int16 *v19; // eax
  int v20; // eax
  int dwThreadId; // [esp+8h] [ebp-10h]
  int *v22; // [esp+Ch] [ebp-Ch]
  int a2a; // [esp+10h] [ebp-8h]
  int *a4; // [esp+14h] [ebp-4h]

  v2 = -1;
  a4 = -1;
  v22 = -1;
  v3 = *(a2 + 32);
  if ( v3 )
    v4 = *v3;
  else
    v4 = 0;
  v5 = wcscmp(v4, L"Start");
  if ( v5 )
    v5 = -(v5 < 0) | 1;
  if ( !v5 )
    goto LABEL_39;
  v6 = *(a2 + 32);
  if ( v6 )
    v7 = *v6;
  else
    v7 = 0;
  result = wcscmp(v7, L"End");
  if ( result )
    result = (-(result < 0) | 1);
  if ( !result )
  {
LABEL_39:
    v9 = a1;
    v10 = a2;
    v11 = *(a2 + 24);
    v12 = *(a1 + 72);
    v13 = *v11;
    if ( *v11 != v11 )
    {
      while ( 1 )
      {
        if ( v12 >= *(v9 + 72) + *(v9 + 76) )
          goto LABEL_29;
        v14 = v13[2];
        v15 = *(v14 + 4);
        if ( v15 == -1 )
        {
          do
          {
            if ( *v14 )
              v16 = **v14;
            else
              v16 = 0;
            v15 = NetworkMsgItem2_FindID(v16);
            *(v14 + 4) = v15;
          }
          while ( v15 == -1 );
          v9 = a1;
          v10 = a2;
        }
        if ( v15 == 53 )
          break;
        v2 = v22;
        if ( v15 != 54 )
          goto LABEL_25;
        v17 = *v12;
        ++v12;
        a4 = v17;
LABEL_26:
        if ( v2 == -1 || v17 == -1 )
        {
          v13 = *v13;
          if ( v13 != *(v10 + 24) )
            continue;
        }
        goto LABEL_29;
      }
      v2 = *v12;
      ++v12;
      v22 = v2;
LABEL_25:
      v17 = a4;
      goto LABEL_26;
    }
LABEL_29:
    v18 = *(v10 + 32);
    if ( v18 )
      v19 = *v18;
    else
      v19 = 0;
    v20 = wcscmp(v19, L"Start");
    if ( v20 )
      v20 = -(v20 < 0) | 1;
    if ( v20 )
    {
      sub_FCE560(&gThreadProcessMap, &a2a, &v22);
      result = sub_FF5510(&gThreadProcessMap, &a2, a2a, a4);
    }
    else
    {
      v22 = a4;
      dwThreadId = v2;
      result = std::map<unsigned long,unsigned long,std::less<unsigned long>,std::allocator<std::pair<unsigned long const,unsigned long>>>::operator[](
                 &gThreadProcessMap,
                 &a2a,
                 0,
                 &dwThreadId,
                 byte_106A100);
    }
  }
  return result;
}
// 10406F4: using guessed type wchar_t aEnd[4];
// 106A100: using guessed type char byte_106A100;

//----- (00FCE4E0) --------------------------------------------------------
int __cdecl sub_FCE4E0(int a1, PSID Sid)
{
  LPWSTR StringSid; // [esp+Ch] [ebp-10h]
  int v4; // [esp+18h] [ebp-4h]

  StringSid = 0;
  *a1 = 0;
  v4 = 0;
  if ( ConvertSidToStringSidW(Sid, &StringSid) )
  {
    _bstr_t::operator=(a1, StringSid);
    LocalFree(StringSid);
  }
  return a1;
}

//----- (00FCE560) --------------------------------------------------------
_DWORD *__thiscall sub_FCE560(int *this, _DWORD *a2, unsigned int *a3)
{
  int v3; // ebx
  int v4; // edx
  int v5; // eax
  int v6; // ecx
  unsigned int v7; // edi
  unsigned int v8; // esi
  _DWORD *result; // eax

  v3 = *this;
  v4 = *this;
  v5 = *(*this + 4);
  v6 = *(*this + 4);
  if ( !*(v6 + 13) )
  {
    v7 = *a3;
    do
    {
      v8 = *(v6 + 16);
      if ( v8 >= v7 )
      {
        if ( *(v4 + 13) && v7 < v8 )
          v4 = v6;
        v3 = v6;
        v6 = *v6;
      }
      else
      {
        v6 = *(v6 + 8);
      }
    }
    while ( !*(v6 + 13) );
  }
  if ( !*(v4 + 13) )
    v5 = *v4;
  while ( !*(v5 + 13) )
  {
    if ( *a3 >= *(v5 + 16) )
    {
      v5 = *(v5 + 8);
    }
    else
    {
      v4 = v5;
      v5 = *v5;
    }
  }
  result = a2;
  *a2 = v3;
  a2[1] = v4;
  return result;
}

//----- (00FCE5E0) --------------------------------------------------------
void __stdcall sub_FCE5E0(CSystemProcessInfoMapNode *a1)
{
  CSystemProcessInfoMapNode *v1; // edi
  CSystemProcessInfoMapNode *i; // esi

  v1 = a1;
  for ( i = a1; !i->baseclass._isnil; v1 = i )
  {
    sub_FCE5E0(i->baseclass._Right);
    i = i->baseclass._Left;
    j__free(v1);
  }
}

//----- (00FCE620) --------------------------------------------------------
CSystemProcessInfoMapNode *__thiscall sub_FCE620(CSystemProcessInfoMap *this)
{
  CSystemProcessInfoMap *v1; // edi
  std__Tree_node *v2; // ebx
  std__Tree_node *i; // esi
  CSystemProcessInfoMapNode *result; // eax

  v1 = this;
  v2 = this->_Header->_Parent;
  for ( i = v2; !i->_IsNil; v2 = i )
  {
    sub_FCE5E0(i->_Right);
    i = i->_Left;
    j__free(v2);
  }
  v1->_Header->_Parent = v1->_Header;
  v1->_Header->_Left = v1->_Header;
  result = v1->_Header;
  result->baseclass._Right = result;
  v1->_Size = 0;
  return result;
}

//----- (00FCE670) --------------------------------------------------------
_DWORD *__thiscall sub_FCE670(_DWORD *this, int a2, int a3, int a4, int a5, int a6)
{
  *this = a2;
  this[3] = a3;
  this[1] = a4;
  this[4] = a5;
  this[6] = a6;
  return this;
}

//----- (00FCE6A0) --------------------------------------------------------
wchar_t **__thiscall sub_FCE6A0(int **this, wchar_t *a2)
{
  int **v2; // edi
  wchar_t *v3; // eax
  int *v4; // esi
  int v5; // ebx
  wchar_t **v6; // eax
  wchar_t **result; // eax
  wchar_t *v8; // [esp+28h] [ebp+8h]

  v2 = this;
  v3 = a2;
  if ( a2 >= this[1] )
    goto LABEL_13;
  v4 = this[3];
  if ( a2 )
  {
    do
    {
      v4 = (v4 + *v4);
      v3 = (v3 - 1);
    }
    while ( v3 );
  }
  if ( *v4 && ((v8 = sub_FB2D20(this[4], v4[1]), !v2[6]) ? (v5 = **v2) : (v5 = 0), (v6 = operator new(0x10u)) != 0) )
    result = sub_FCEC40(v6, v8, v4[7], *v2 + v4[9] + v5, v4[8]);
  else
LABEL_13:
    result = 0;
  return result;
}

//----- (00FCE760) --------------------------------------------------------
wchar_t **__thiscall sub_FCE760(PerformanceInfo **this, LPCWSTR lpsz)
{
  PerformanceInfo **v2; // esi
  int v3; // eax
  PerformanceInfo *v4; // ecx
  PerformanceInfo *v5; // edi
  wchar_t **result; // eax
  signed int v7; // ebx
  wchar_t **v8; // eax
  wchar_t *lpsza; // [esp+28h] [ebp+8h]

  v2 = this;
  v3 = PerformanceInfo::FindPerf(this[4], lpsz);
  if ( !v3 )
    goto LABEL_5;
  v4 = v2[1];
  v5 = v2[3];
  v2[2] = 0;
  if ( !v4 )
    goto LABEL_5;
  while ( v5->m_LastCounterOfLastHelp != v3 )
  {
    v5 = (v5 + v5->m_dwLastCounterOfLastHelp);
    v2[2] = (v2[2] + 1);
    if ( v2[2] >= v4 )
      goto LABEL_5;
  }
  lpsza = sub_FB2D20(v2[4], v5->m_LastCounterOfLastHelp);
  v7 = v2[6] ? 0 : (*v2)->m_dwLastCounterOfLastHelp;
  v8 = operator new(0x10u);
  if ( v8 )
    result = sub_FCEC40(
               v8,
               lpsza,
               v5[2].m_LastCounterOfLastHelp,
               *v2 + v5[3].m_dwLastCounterOfLastHelp + v7,
               v5[2].m_PerfValue);
  else
LABEL_5:
    result = 0;
  return result;
}

//----- (00FCE830) --------------------------------------------------------
wchar_t **__thiscall sub_FCE830(int this)
{
  *(this + 8) = 0;
  return sub_FCE6A0(this, 0);
}

//----- (00FCE840) --------------------------------------------------------
wchar_t **__thiscall sub_FCE840(int this)
{
  return sub_FCE6A0(this, ++*(this + 8));
}

//----- (00FCE850) --------------------------------------------------------
int __thiscall sub_FCE850(int *this, wchar_t *Dst, rsize_t SizeInWords)
{
  int v4; // ecx

  if ( this[6] )
  {
    *Dst = 0;
    return 0;
  }
  v4 = *this;
  if ( SizeInWords < *(v4 + 20) >> 1 )
    return 0;
  wcscpy_s(Dst, SizeInWords, (v4 + *(v4 + 16)));
  return 1;
}

//----- (00FCE8B0) --------------------------------------------------------
PE_PerfInfo_Item *__thiscall PE_PerfInfo::Load(PE_PerfInfo *this, LPCWSTR lpszName)
{
  PE_PerfInfo *v2; // ebx
  WCHAR *pszText; // esi
  unsigned int v4; // edi
  PE_PerfInfo_Item *result; // eax
  PE_PerfInfo_Item *pItem; // eax
  LPCWSTR index; // [esp+24h] [ebp+8h]

  v2 = this;
  index = PerformanceInfo::FindPerf(this->m_PerfInfo, lpszName);
  if ( !index )
    goto LABEL_5;
  pszText = sub_FCEFA0(v2->m_PerfInfoInMemory);
  v4 = 0;
  if ( !sub_FCEF90(v2->m_PerfInfoInMemory) )
    goto LABEL_5;
  while ( *(pszText + 3) != index )
  {
    ++v4;
    pszText = (pszText + *pszText);
    if ( v4 >= sub_FCEF90(v2->m_PerfInfoInMemory) )
      goto LABEL_5;
  }
  pItem = operator new(0x10u);
  if ( pItem )
    result = sub_FCED40(pItem, pszText, v2->m_PerfInfo);
  else
LABEL_5:
    result = 0;
  return result;
}

//----- (00FCE970) --------------------------------------------------------
char __cdecl sub_FCE970(LPCWSTR lpFileName, int a2, HANDLE hObject, LPCVOID lpBaseAddress)
{
  _WORD *v4; // ebx
  _BYTE *v5; // edi
  HANDLE v6; // eax
  void *v7; // esi
  HANDLE v8; // eax
  _DWORD *v10; // eax
  _DWORD *v11; // esi
  __int16 v12; // ax
  int v13; // esi
  _DWORD *v14; // eax
  signed int v15; // edx
  signed int v16; // esi
  int v17; // ecx
  _DWORD *v18; // ecx
  signed int v19; // esi
  signed int v20; // edi
  int v21; // edx
  unsigned int v22; // eax
  unsigned int v23; // eax
  HANDLE v24; // [esp+Ch] [ebp-8h]
  char v25; // [esp+13h] [ebp-1h]
  HANDLE hObjecta; // [esp+24h] [ebp+10h]
  _DWORD *lpBaseAddressa; // [esp+28h] [ebp+14h]

  v4 = lpBaseAddress;
  v5 = hObject;
  *lpBaseAddress = 0;
  *a2 = 0;
  v25 = 0;
  *hObject = 0;
  v6 = CreateFileW(lpFileName, 0x80000000, 1u, 0, 3u, 0x80u, 0);
  v7 = v6;
  v24 = v6;
  if ( v6 == -1 )
    return 0;
  v8 = CreateFileMappingW(v6, 0, 2u, 0, 0, 0);
  hObjecta = v8;
  if ( !v8 )
  {
    CloseHandle(v7);
    return 0;
  }
  v10 = MapViewOfFile(v8, 4u, 0, 0, 0);
  lpBaseAddressa = v10;
  if ( !v10 )
  {
    CloseHandle(hObjecta);
    CloseHandle(v24);
    return 0;
  }
  if ( *v10 == 23117 )
  {
    v11 = (v10 + v10[15]);
    if ( *(v11 + 11) & 0x100 && (v12 = *(v11 + 2), v12 != -31132) && v12 != 512 )
      *v5 = 1;
    else
      *v5 = 2;
    *a2 = v11[2];
    *v4 = *(v11 + 47) | 1;
    if ( *v5 == 2 )
    {
      v13 = lpBaseAddressa + lpBaseAddressa[15];
      if ( IsBadReadPtr(lpBaseAddressa + lpBaseAddressa[15], 0x108u) )
        goto LABEL_59;
      if ( *v13 != 17744 )
        goto LABEL_59;
      v14 = (v13 + 264);
      v15 = 1;
      v16 = *(v13 + 6);
      if ( v16 < 1 )
        goto LABEL_59;
      while ( 1 )
      {
        if ( !v14[4]
          && (*v14 != 2019914798 || v14[1] != 1936941684)
          && (*v14 != 1936487470 || v14[1])
          && (*v14 != 1936941614 || v14[1] && (*v14 != 1936941614 || v14[1]))
          && (*v14 != 1650422898 || v14[1] != 29555) )
        {
          v17 = v14[9];
          if ( v17 & 0x20000000 )
          {
            if ( v17 & 0xC0 )
              break;
          }
        }
        ++v15;
        v14 += 10;
        if ( v15 > v16 )
          goto LABEL_59;
      }
    }
    else
    {
      if ( IsBadReadPtr(v11, 0xF8u) )
        goto LABEL_59;
      if ( *v11 != 17744 )
        goto LABEL_59;
      v18 = v11 + 62;
      v19 = *(v11 + 3);
      v20 = 1;
      if ( v19 < 1 )
        goto LABEL_59;
      while ( 1 )
      {
        v21 = v18[9];
        if ( v21 & 0x20 )
        {
          v22 = v18[2];
          if ( v22 > 0x1000 && v18[4] < v22 - 4096 )
            break;
        }
        if ( *v18 == 2019914798 && v18[1] == 116 )
        {
          v23 = v18[2];
          if ( v23 > 0x1000 && v18[4] < v23 - 4096 )
            break;
        }
        if ( !*v18 && v18[4] < v18[2]
          || !v18[4]
          && v18[2] >= 0x1000u
          && (*v18 != 2019914798 || v18[1] != 1936941684)
          && (*v18 != 1936487470 || v18[1])
          && (*v18 != 1936941614 || v18[1])
          && (*v18 != 1952539694 || v18[1] != 97)
          && v21 & 0x20000000
          && v21 & 0xC0 )
        {
          break;
        }
        ++v20;
        v18 += 10;
        if ( v20 > v19 )
          goto LABEL_59;
      }
    }
    v25 = 1;
  }
LABEL_59:
  UnmapViewOfFile(lpBaseAddressa);
  CloseHandle(hObjecta);
  CloseHandle(v24);
  return v25;
}

//----- (00FCEC40) --------------------------------------------------------
wchar_t **__thiscall sub_FCEC40(wchar_t **this, wchar_t *a2, int a3, void *a4, unsigned int a5)
{
  wchar_t **v5; // esi
  wchar_t *v6; // eax
  size_t v7; // ST08_4

  v5 = this;
  *this = _wcsdup(a2);
  v5[1] = a3;
  v5[3] = a5;
  v6 = operator new[](a5);
  v7 = v5[3];
  v5[2] = v6;
  memmove_0(v6, a4, v7);
  return v5;
}

//----- (00FCEC80) --------------------------------------------------------
void __thiscall sub_FCEC80(void **this)
{
  void **v1; // esi

  v1 = this;
  free(*this);
  j_j__free(v1[2]);
}

//----- (00FCECA0) --------------------------------------------------------
signed int __thiscall sub_FCECA0(int this, _DWORD *a2, int a3)
{
  __int64 v3; // rax
  signed int result; // eax
  __int64 v5; // rax
  _DWORD *v6; // edx

  switch ( *(this + 12) )
  {
    case 1:
      v3 = **(this + 8);
      *a2 = v3;
      result = 1;
      a2[1] = HIDWORD(v3);
      break;
    case 2:
      v5 = **(this + 8);
      *a2 = v5;
      result = 1;
      a2[1] = HIDWORD(v5);
      break;
    case 4:
      *a2 = **(this + 8);
      result = 1;
      a2[1] = 0;
      break;
    case 8:
      v6 = *(this + 8);
      *a2 = *v6;
      a2[1] = v6[1];
      result = 1;
      break;
    default:
      result = 0;
      break;
  }
  return result;
}

//----- (00FCED40) --------------------------------------------------------
PE_PerfInfo_Item *__thiscall sub_FCED40(PE_PerfInfo_Item *this, int a2, PerformanceInfo *a3)
{
  this->m_Text = a2;
  this->m_PerfInfo = a3;
  return this;
}

//----- (00FCED60) --------------------------------------------------------
_DWORD *__thiscall sub_FCED60(_DWORD *this)
{
  _DWORD *v1; // esi
  int v2; // ecx
  _DWORD *v3; // edi
  _DWORD *result; // eax

  v1 = this;
  v2 = *this;
  v1[1] = 0;
  if ( *(v2 + 40) && (v1[2] = v2 + *(v2 + 4), (v3 = operator new(0x1Cu)) != 0) )
    result = sub_FCE670(v3, v1[2], *v1 + *(*v1 + 8), *(*v1 + 32), v1[3], *(*v1 + 40) == -1);
  else
    result = 0;
  return result;
}

//----- (00FCEE00) --------------------------------------------------------
_DWORD *__thiscall sub_FCEE00(_DWORD *this)
{
  _DWORD *v1; // esi
  int v2; // ecx
  _DWORD *v3; // ecx
  _DWORD *v4; // edx
  _DWORD *result; // eax

  v1 = this;
  v2 = *this;
  if ( *(v2 + 40) != -1
    && (++v1[1], v1[1] < *(v2 + 40))
    && (v3 = (*v1[2] + v1[2]), v1[2] = v3 + *v3, (v4 = operator new(0x1Cu)) != 0) )
  {
    result = sub_FCE670(v4, v1[2], *v1 + *(*v1 + 8), *(*v1 + 32), v1[3], 0);
  }
  else
  {
    result = 0;
  }
  return result;
}

//----- (00FCEEA0) --------------------------------------------------------
PerformanceInfoInMemory *__thiscall PE_PerfInfo::PE_PerfInfo(PerformanceInfoInMemory *this, PerformanceInfo *a2)
{
  PerformanceInfoInMemory *result; // eax

  this->m_PerfInfo = a2;
  result = this;
  this->m_pBuffer = 0;
  return result;
}

//----- (00FCEEC0) --------------------------------------------------------
int __thiscall PerformanceInfoInMemory::FindPerf(PerformanceInfoInMemory *this, LPCWSTR lpszName, wchar_t *pszBuffer, int nLength)
{
  wchar_t *pszBuf; // esi
  wchar_t *pszName; // edi
  int nPerfIndex; // eax
  int nLen; // eax
  wchar_t *lpszName_1; // [esp+4h] [ebp-Ch]
  PerformanceInfoInMemory *v10; // [esp+8h] [ebp-8h]
  wchar_t *Context; // [esp+Ch] [ebp-4h]
  LPCWSTR lpsza; // [esp+18h] [ebp+8h]

  v10 = this;
  if ( IsBadStringPtrW(lpszName, 0xFFFFFFFF) )
    return 0;
  lpszName_1 = _wcsdup(lpszName);
  pszBuf = pszBuffer;
  Context = 0;
  pszName = wcstok_s(lpszName_1, ",", &Context);
  if ( pszName )
  {
    lpsza = (2 * nLength);
    do
    {
      nPerfIndex = PerformanceInfo::FindPerf(v10->m_PerfInfo, pszName);
      if ( nPerfIndex )
        nLen = swprintf_s(pszBuf, (pszBuffer + lpsza - pszBuf) >> 1, L"%u ", nPerfIndex);
      else
        nLen = swprintf_s(pszBuf, (pszBuffer + lpsza - pszBuf) >> 1, L"%s ", pszName);
      pszBuf += nLen;
      pszName = wcstok_s(0, ",", &Context);
    }
    while ( pszName );
  }
  free(lpszName_1);
  return 1;
}
// 1040800: using guessed type wchar_t aU_0[4];

//----- (00FCEF90) --------------------------------------------------------
int __thiscall sub_FCEF90(PerformanceInfoInMemory *this)
{
  int result; // eax

  if ( this->m_pBuffer )
    result = *(this->m_pBuffer + 7);
  else
    result = 0;
  return result;
}

//----- (00FCEFA0) --------------------------------------------------------
WCHAR *__thiscall sub_FCEFA0(PerformanceInfoInMemory *this)
{
  WCHAR *v1; // ecx
  WCHAR *result; // eax

  v1 = this->m_pBuffer;
  if ( v1 )
    result = (v1 + *(v1 + 6));
  else
    result = 0;
  return result;
}

//----- (00FCEFB0) --------------------------------------------------------
int __thiscall PerformanceInfoInMemory::Load(PerformanceInfoInMemory *pThis, LPCWSTR lpszRootName, LPCWSTR lpszName)
{
  PerformanceInfoInMemory *this; // edi
  unsigned int dwLength; // esi
  LSTATUS lRet; // eax
  WCHAR *v6; // eax
  HKEY hSubKey; // [esp+Ch] [ebp-20Ch]
  DWORD cbData; // [esp+10h] [ebp-208h]
  WCHAR szValueName[256]; // [esp+14h] [ebp-204h]

  this = pThis;
  j__free(pThis->m_pBuffer);
  this->m_pBuffer = 0;
  if ( lpszRootName )
  {
    if ( RegConnectRegistryW(lpszRootName, HKEY_PERFORMANCE_DATA, &hSubKey) )
      return 0;
  }
  else
  {
    hSubKey = HKEY_PERFORMANCE_DATA;
  }
  if ( PerformanceInfoInMemory::FindPerf(this, lpszName, szValueName, 256) )
  {
    dwLength = 0;
    cbData = 0;
    this->m_pBuffer = 0;
    lRet = RegQueryValueExW(hSubKey, szValueName, 0, 0, 0, &cbData);
    if ( lRet )
    {
      while ( lRet == ERROR_MORE_DATA )
      {
        j_j__free(this->m_pBuffer);
        if ( cbData <= dwLength )
          dwLength += 4096;
        else
          dwLength = cbData + 4096;
        v6 = operator new[](dwLength);
        this->m_pBuffer = v6;
        if ( !v6 )
          break;
        cbData = dwLength;
        lRet = RegQueryValueExW(hSubKey, szValueName, 0, 0, v6, &cbData);
        if ( !lRet )
          goto LABEL_13;
      }
    }
    else
    {
LABEL_13:
      if ( *this->m_pBuffer == 0x450050 && *(this->m_pBuffer + 1) == 0x460052 )
        return 1;
    }
    j_j__free(this->m_pBuffer);
    this->m_pBuffer = 0;
  }
  return 0;
}

//----- (00FCF110) --------------------------------------------------------
int __cdecl CMainWnd::HandleMsg7FD(int _8, int a2, int a3, void *a1)
{
  TreeViewListItemParam_Release(a1);
  return 0;
}

//----- (00FCF130) --------------------------------------------------------
int __cdecl CMainWnd::HandleDeviceChange(HWND a1, unsigned int a2, unsigned int wParam, _DEV_BROADCAST_HDR *lParam)
{
  if ( wParam == DBT_DEVICEARRIVAL && lParam->dbch_devicetype == DBT_DEVTYP_VOLUME )
    GetDriverNameAndLinkInfo();
  return 0;
}

//----- (00FCF150) --------------------------------------------------------
int __cdecl CMainWnd::HandleMsg7F9(int a1, int a2, int a3, int a4)
{
  tagTREEVIEWLISTITEMPARAM *v4; // esi
  tagTREEVIEWLISTITEMPARAM *v5; // ebx
  ListItemData1 *v6; // edi
  char v7; // dl
  WCHAR *v8; // ecx
  const wchar_t **v9; // eax
  const wchar_t *v10; // eax
  DLLLISTITEMPARAM *v11; // esi
  char v12; // bl
  const wchar_t *v13; // eax
  const wchar_t **v14; // ecx
  const wchar_t *v15; // ecx
  char v17; // [esp+23h] [ebp+17h]

  v4 = gpTreeViewListItemParam;
  v5 = 0;
  v6 = a4;
  if ( a4 )
  {
    v7 = 0;
    v17 = 0;
    if ( gpTreeViewListItemParam )
    {
      do
      {
        v8 = v4->szProcessName;
        if ( v4->dwProcessId == gdwProcessIdSelected )
          v5 = v4;
        if ( v8 )
        {
          v9 = v6[2].field_4;
          if ( v9 )
            v10 = *v9;
          else
            v10 = 0;
          if ( _wcsicmp(v8, v10) )
          {
            v7 = v17;
          }
          else
          {
            v7 = 1;
            v4->m_ItemDataForVirusTotal = v6;
            v17 = 1;
          }
        }
        v4 = v4->m_Prev;
      }
      while ( v4 );
      if ( v7 )
      {
        if ( RedrawColumn(1, ghWndTreeListView, 1670, 0) )
        {
          InvalidateRect(ghWndTreeListView, 0, 0);
          sub_FBFAA0(0x65);
        }
        else if ( IsColumnIDValid(ghWndTreeListView, 0x686u) )
        {
          InvalidateRect(ghWndTreeListView, 0, 0);
        }
      }
      if ( v5 )
      {
        if ( IsWindowVisible(ghWndDllsListCtrl) )
        {
          v11 = gpDllListItemParamHeader;
          v12 = 0;
          if ( gpDllListItemParamHeader )
          {
            do
            {
              v13 = v11->m_strPath.pszData;
              if ( v13 )
              {
                v14 = v6[2].field_4;
                if ( v14 )
                  v15 = *v14;
                else
                  v15 = 0;
                if ( !_wcsicmp(v13, v15) )
                {
                  v11->m_HashData = v6;
                  v12 = 1;
                }
              }
              v11 = v11->m_Prev;
            }
            while ( v11 );
            if ( v12 )
            {
              InvalidateRect(ghWndDllsListCtrl, 0, 0);
              sub_FBFAA0(0x68);
              return 0;
            }
          }
        }
      }
    }
  }
  else
  {
    if ( RedrawColumn(1, ghWndTreeListView, 1670, 0) )
    {
      InvalidateRect(ghWndTreeListView, 0, 0);
      sub_FBFAA0(0x65);
    }
    else if ( IsColumnIDValid(ghWndTreeListView, 0x686u) )
    {
      InvalidateRect(ghWndTreeListView, 0, 0);
    }
    if ( IsWindowVisible(ghWndDllsListCtrl) )
    {
      InvalidateRect(ghWndDllsListCtrl, 0, 0);
      sub_FBFAA0(0x68);
    }
  }
  return 0;
}

//----- (00FCF350) --------------------------------------------------------
int __cdecl Command_CreateDump(HWND a1, __int16 a2)
{
  HWND v2; // esi
  LRESULT v3; // eax
  int v4; // esi
  HANDLE v5; // ebx
  int result; // eax
  HANDLE v7; // edi
  HCURSOR v8; // eax
  LPARAM lParam; // [esp+Ch] [ebp-4A4h]
  LRESULT v10; // [esp+10h] [ebp-4A0h]
  int v11; // [esp+14h] [ebp-49Ch]
  int v12; // [esp+2Ch] [ebp-484h]
  struct tagOFNW v13; // [esp+40h] [ebp-470h]
  HCURSOR hCursor; // [esp+98h] [ebp-418h]
  wchar_t pszBuffer; // [esp+9Ch] [ebp-414h]
  wchar_t Dst; // [esp+2A4h] [ebp-20Ch]
  char v17; // [esp+2A6h] [ebp-20Ah]

  lParam = 0;
  memset(&v10, 0, 0x30u);
  Dst = 0;
  memset(&v17, 0, 0x206u);
  v2 = ghWndTreeListView;
  v3 = SendMessageW(ghWndTreeListView, 0x100Cu, 0xFFFFFFFF, 2);
  if ( v3 == -1
    || (v10 = v3, v11 = 0, lParam = 4, !SendMessageW(v2, 0x104Bu, 0, &lParam))
    || (v4 = v12, SetFocus(ghWndTreeListView), !v4) )
  {
    MessageBoxW(ghWndTreeListView, L"No process is selected", L"Process Explorer Error", 0x10u);
    return 0;
  }
  v5 = OpenProcess(0x10000000u, 0, *(v4 + 68));
  if ( !v5 )
  {
    ReportMsg(L"Error opening process", ghMainWnd);
    return 0;
  }
  wcscpy_s(&Dst, 0x104u, *(v4 + 60));
  if ( wcschr(&Dst, 0x2Eu) )
    *wcschr(&Dst, 0x2Eu) = 0;
  swprintf(&pszBuffer, L"Create dump of %s", *(v4 + 60));
  wcscat_s(&Dst, 0x104u, L".dmp");
  v13.hwndOwner = ghMainWnd;
  v13.hInstance = ghInstance;
  v13.lpstrFile = &Dst;
  *&v13.nFileOffset = 0;
  v13.lpfnHook = 0;
  v13.lpstrTitle = &pszBuffer;
  v13.lStructSize = 76;
  v13.lpstrCustomFilter = 0;
  v13.nMaxCustFilter = 0;
  v13.nFilterIndex = 1;
  v13.nMaxFile = 256;
  v13.lpstrFileTitle = 0;
  v13.nMaxFileTitle = 0;
  v13.lpstrInitialDir = 0;
  v13.Flags = 2097156;
  v13.lpstrDefExt = L"*.dmp";
  v13.lpstrFilter = L"Dump File (*.DMP)";
  if ( !GetSaveFileNameW(&v13) )
    return 0;
  v7 = CreateFileW(&Dst, 0x40000000u, 7u, 0, 2u, 0x80u, 0);
  if ( v7 == -1 )
  {
    ReportMsg(L"Error creating dump file", ghMainWnd);
    result = 0;
  }
  else
  {
    v8 = LoadCursorW(0, 0x7F02);
    hCursor = SetCursor(v8);
    if ( !DumpFileProcess(v7, v5, a2 == -24806) )
    {
      ReportMsg(L"Error writing dump file", ghMainWnd);
      DeleteFileW(&Dst);
    }
    SetCursor(hCursor);
    CloseHandle(v5);
    CloseHandle(v7);
    result = 0;
  }
  return result;
}
// 1042088: using guessed type wchar_t aErrorOpeningPr[22];
// 10420E4: using guessed type wchar_t aDmp_0[6];
// 10420F0: using guessed type wchar_t aDumpFileDmp[18];
// 1042140: using guessed type wchar_t aErrorCreatingD[25];
// 1042174: using guessed type wchar_t aErrorWritingDu[24];

//----- (00FCF670) --------------------------------------------------------
int Command_RestartProcess()
{
  HWND v0; // esi
  LRESULT v1; // eax
  int v2; // esi
  const unsigned __int16 *v3; // eax
  int v4; // eax
  struct _STARTUPINFOW StartupInfo; // [esp+4h] [ebp-88h]
  LPARAM lParam; // [esp+48h] [ebp-44h]
  LRESULT v8; // [esp+4Ch] [ebp-40h]
  int v9; // [esp+50h] [ebp-3Ch]
  int v10; // [esp+68h] [ebp-24h]
  struct _PROCESS_INFORMATION ProcessInformation; // [esp+7Ch] [ebp-10h]

  lParam = 0;
  memset(&v8, 0, 0x30u);
  v0 = ghWndTreeListView;
  v1 = SendMessageW(ghWndTreeListView, 0x100Cu, 0xFFFFFFFF, 2);
  if ( v1 == -1
    || (v8 = v1, v9 = 0, lParam = 4, !SendMessageW(v0, 0x104Bu, 0, &lParam))
    || (v2 = v10, SetFocus(ghWndTreeListView), !v2) )
  {
    MessageBoxW(ghWndTreeListView, L"No process is selected", L"Process Explorer Error", 0x10u);
    return 0;
  }
  v3 = *(v2 + 88);
  if ( !v3 )
    goto LABEL_18;
  v4 = wcscmp(gszMainTitle, v3);
  if ( v4 )
    v4 = -(v4 < 0) | 1;
  if ( v4 )
  {
LABEL_18:
    if ( MessageBoxW(
           ghWndTreeListView,
           L"The selected process is running in a different account than Process Explorer and so may fail to run, behave d"
            "ifferently, and run with different security rights when restarted under Process Explorer's credentials.\n"
            "\n"
            "Continue with process restart?",
           L"Process Explorer Warning",
           0x34u) == 7 )
      return 0;
  }
  if ( !sub_FF8030(*(v2 + 60), *(v2 + 68)) )
    return 0;
  memset(&StartupInfo, 0, 0x44u);
  StartupInfo.cb = 68;
  StartupInfo.dwFlags = 1;
  StartupInfo.wShowWindow = 5;
  if ( CreateProcessW(
         *(v2 + 792),
         *(v2 + 800),
         0,
         0,
         0,
         0x400u,
         *(v2 + 808),
         *(v2 + 804),
         &StartupInfo,
         &ProcessInformation) )
  {
    CloseHandle(ProcessInformation.hThread);
    CloseHandle(ProcessInformation.hProcess);
  }
  else
  {
    ReportMsg(L"Error restarting process", ghMainWnd);
  }
  return 0;
}
// 1042394: using guessed type wchar_t aErrorRestartin[25];

//----- (00FCF820) --------------------------------------------------------
int Command_KillProcess()
{
  LRESULT v0; // eax
  LPARAM v2; // [esp+4h] [ebp-68h]
  int v3; // [esp+10h] [ebp-5Ch]
  int v4; // [esp+14h] [ebp-58h]
  LPARAM lParam; // [esp+38h] [ebp-34h]
  LRESULT v6; // [esp+3Ch] [ebp-30h]
  int v7; // [esp+40h] [ebp-2Ch]
  int v8; // [esp+58h] [ebp-14h]

  lParam = 0;
  memset(&v6, 0, 0x30u);
  v0 = SendMessageW(ghWndTreeListView, 0x100Cu, 0xFFFFFFFF, 2);
  if ( v0 == -1 )
  {
    MessageBoxW(ghWndTreeListView, L"No process selected", L"Process Explorer Error", 0x10u);
  }
  else
  {
    v6 = v0;
    v7 = 0;
    lParam = 4;
    if ( SendMessageW(ghWndTreeListView, 0x104Bu, 0, &lParam) )
    {
      sub_FF8140(*(v8 + 60), *(v8 + 68));
      SetEvent(ghRefreshEventHandle);
      v4 = 2;
      v3 = 2;
      SendMessageW(ghWndTreeListView, 0x102Bu, 0, &v2);
      return 0;
    }
  }
  return 0;
}

//----- (00FCF8F0) --------------------------------------------------------
int __cdecl Command_Exit(HWND hWnd)
{
  DestroyWindow(hWnd);
  return 0;
}

//----- (00FCF900) --------------------------------------------------------
int Command_OpenProcExp()
{
  int result; // eax
  WINDOWPLACEMENT wp; // [esp+0h] [ebp-30h]

  wp.length = 44;
  GetWindowPlacement(ghMainWnd, &wp);
  ShowWindow(ghMainWnd, 4 * (wp.showCmd == SW_SHOWMINIMIZED) + 5);
  SetForegroundWindow(ghMainWnd);
  SetFocus(ghMainWnd);
  result = 0;
  gbMainWndMinimized1 = 1;
  gbMainWndMinimized = 0;
  return result;
}
// 106A389: using guessed type char gbMainWndMinimized;
// 106A393: using guessed type char gbMainWndMinimized1;

//----- (00FCF980) --------------------------------------------------------
int Command_CopyAllThreadStack()
{
  HWND v0; // eax
  HWND v1; // esi
  HGLOBAL v2; // ebx
  wchar_t *v3; // edi
  LONG v4; // eax
  HWND v5; // edx
  int v6; // ecx
  tagLVITEMW lvitem; // [esp+4h] [ebp-1074h]
  tagLVITEMW lvitem_1; // [esp+38h] [ebp-1040h]
  int v10; // [esp+6Ch] [ebp-100Ch]
  int v11; // [esp+70h] [ebp-1008h]
  wchar_t Dst; // [esp+74h] [ebp-1004h]

  lvitem_1.mask = 0;
  memset(&lvitem_1.iItem, 0, 0x30u);
  v0 = GetFocus();
  v1 = v0;
  if ( v0 == ghWndTreeListView || v0 == ghWndDllsListCtrl || v0 == ghWndHandlesListCtrl )
  {
    lvitem_1.iItem = SendMessageW(v0, LVM_GETNEXTITEM, 0xFFFFFFFF, 2);
    if ( lvitem_1.iItem != -1 )
    {
      v2 = 0;
      v3 = 0;
      v10 = 0;
      lvitem_1.iSubItem = 0;
      v4 = GetWindowLongW(v1, GWLP_USERDATA);
      v5 = ghWndTreeListView;
      v11 = v4;
      if ( v1 == ghWndTreeListView )
        v11 = ++v4;
      v6 = 0;
      lvitem_1.iSubItem = 0;
      if ( v4 > 0 )
      {
        while ( 1 )
        {
          if ( v1 != v5 || v3 )
          {
            lvitem.iSubItem = v6;
            lvitem.pszText = &Dst;
            lvitem.cchTextMax = 2048;
            SendMessageW(v1, LVM_GETITEMTEXTW, lvitem_1.iItem, &lvitem);
          }
          else
          {
            lvitem_1.mask = 4;
            if ( SendMessageW(v1, LVM_GETITEMW, 0, &lvitem_1) )
            {
              wcscpy_s(&Dst, 0x800u, lvitem_1.lParam->field_3C);
              --lvitem_1.iSubItem;
              --v11;
            }
          }
          v10 += 2 * wcslen(&Dst) + 1;
          if ( v3 )
          {
            v2 = GlobalReAlloc(v2, 2 * v10 + 2, 0);
            v3 = GlobalLock(v2);
            wcscat_s(v3, v10 + 1, L"\t");
          }
          else
          {
            v2 = GlobalAlloc(0x2002u, 2 * v10 + 2);
            v3 = GlobalLock(v2);
            *v3 = 0;
          }
          wcscat_s(v3, v10 + 1, &Dst);
          GlobalUnlock(v2);
          v6 = lvitem_1.iSubItem + 1;
          lvitem_1.iSubItem = v6;
          if ( v6 >= v11 )
            break;
          v5 = ghWndTreeListView;
        }
        if ( v2 && OpenClipboard(ghMainWnd) )
        {
          EmptyClipboard();
          SetClipboardData(0xDu, v2);
          CloseClipboard();
        }
      }
    }
  }
  return 0;
}

//----- (00FCFBD0) --------------------------------------------------------
int Command_RefreshNow()
{
  SetEvent(ghTimerRefreshEvent);
  return 0;
}

//----- (00FCFBE0) --------------------------------------------------------
int __cdecl Command_SelectColumn(HWND hWnd, signed __int16 uID)
{
  signed __int16 nID; // di
  HWND hWndFocus; // eax
  UINT nStartPage; // eax
  signed int nPageIndex_1; // esi
  char bAdministrative; // al
  HINSTANCE ghInstance; // ecx
  signed int nPageIndex_2; // eax
  int nPageIndex_3; // esi
  bool fNoAdapterRuntime; // zf
  int nPageIndex_4; // eax
  int nPageIndex_5; // eax
  UINT nPageIndex_6; // edx
  int nPageIndex_7; // esi
  int nPageIndex_8; // eax
  int nPageIndex; // esi
  int nPageIndex_9; // eax
  int nPageIndex_10; // eax
  PROPSHEETHEADERW PropSheet; // [esp+Ch] [ebp-4E8h]
  char ZeroParam; // [esp+43h] [ebp-4B1h]
  PE_PROPSHEETPAGEW Pages[13]; // [esp+44h] [ebp-4B0h]
  WCHAR Dst[260]; // [esp+2E8h] [ebp-20Ch]

  ZeroParam = 0;
  nID = uID;
  PropSheet.dwSize = 0;
  if ( uID == 40041 )
  {
    hWndFocus = GetFocus();
    if ( hWndFocus == ghWndTreeListView )
    {
      nID = 40105;
    }
    else if ( hWndFocus == ghWndDllsListCtrl )
    {
      nID = 40104;
    }
    else if ( hWndFocus == ghWndHandlesListCtrl )
    {
      nID = 40106;
    }
  }
  Pages[0].dwSize = &ZeroParam;
  nStartPage = PropSheet.nStartPage;
  Pages[0].dwSize = sizeof(PE_PROPSHEETPAGEW);
  Pages[0].dwFlags = PSP_USETITLE;
  if ( nID == 40105 )
    nStartPage = 0;
  Pages[0].hInstance = ::ghInstance;
  PropSheet.nStartPage = nStartPage;
  nPageIndex_1 = 3;
  Pages[0].u.pszTemplate = L"PROCCOLUMNS";
  Pages[0].u2.hIcon = 0;
  Pages[0].pfnDlgProc = PropColumnSetsForProcess;
  Pages[0].pszTitle = L"Process Image";
  Pages[0].pfnCallback = 0;
  Pages[1].dwSize = sizeof(PE_PROPSHEETPAGEW);
  Pages[1].dwFlags = PSP_USETITLE;
  Pages[1].hInstance = ::ghInstance;
  Pages[1].u.pszTemplate = L"PROCPERFCOLUMNS";
  Pages[1].u2.hIcon = 0;
  Pages[1].pfnDlgProc = PropColumnSetsForProcess;
  Pages[1].pszTitle = L"Process Performance";
  Pages[1].lParam = &ZeroParam;
  Pages[1].pfnCallback = 0;
  Pages[2].dwSize = sizeof(PE_PROPSHEETPAGEW);
  Pages[2].dwFlags = PSP_USETITLE;
  Pages[2].hInstance = ::ghInstance;
  Pages[2].u.pszTemplate = L"PROCIOCOLUMNS";
  Pages[2].u2.hIcon = 0;
  Pages[2].pfnDlgProc = PropColumnSetsForProcess;
  Pages[2].pszTitle = L"Process I/O";
  Pages[2].lParam = &ZeroParam;
  Pages[2].pfnCallback = 0;
  bAdministrative = IsBuiltinAdministrative();
  ghInstance = ::ghInstance;
  if ( bAdministrative || gConfig.bETWStandardUserWarning == 1 )
  {
    Pages[3].dwSize = sizeof(PE_PROPSHEETPAGEW);
    Pages[3].dwFlags = PSP_USETITLE;
    nPageIndex_1 = 5;
    Pages[3].hInstance = ::ghInstance;
    Pages[3].u.pszTemplate = L"PROCNETWORKCOLUMNS";
    Pages[3].u2.hIcon = 0;
    Pages[3].pfnDlgProc = PropColumnSetsForProcess;
    Pages[3].pszTitle = L"Process Network";
    Pages[3].lParam = &ZeroParam;
    Pages[3].pfnCallback = 0;
    Pages[4].dwSize = sizeof(PE_PROPSHEETPAGEW);
    Pages[4].dwFlags = PSP_USETITLE;
    Pages[4].hInstance = ::ghInstance;
    Pages[4].u.pszTemplate = L"PROCDISKCOLUMNS";
    Pages[4].u2.hIcon = 0;
    Pages[4].pfnDlgProc = PropColumnSetsForProcess;
    Pages[4].pszTitle = L"Process Disk";
    Pages[4].lParam = &ZeroParam;
    Pages[4].pfnCallback = 0;
  }
  nPageIndex_2 = nPageIndex_1;
  nPageIndex_3 = nPageIndex_1 + 1;
  fNoAdapterRuntime = gdwAdapterRuntingTime == 0;
  Pages[nPageIndex_2].dwSize = sizeof(PE_PROPSHEETPAGEW);
  Pages[nPageIndex_2].dwFlags = PSP_USETITLE;
  Pages[nPageIndex_2].hInstance = ghInstance;
  Pages[nPageIndex_2].u.pszTemplate = L"PROCMEMCOLUMNS";
  Pages[nPageIndex_2].u2.hIcon = 0;
  Pages[nPageIndex_2].pfnDlgProc = PropColumnSetsForProcess;
  Pages[nPageIndex_2].pszTitle = L"Process Memory";
  Pages[nPageIndex_2].lParam = &ZeroParam;
  Pages[nPageIndex_2].pfnCallback = 0;
  if ( !fNoAdapterRuntime )
  {
    nPageIndex_4 = nPageIndex_3++;
    Pages[nPageIndex_4].dwSize = sizeof(PE_PROPSHEETPAGEW);
    Pages[nPageIndex_4].dwFlags = PSP_USETITLE;
    Pages[nPageIndex_4].hInstance = ghInstance;
    Pages[nPageIndex_4].u.pszTemplate = L"PROCGPUCOLUMNS";
    Pages[nPageIndex_4].u2.hIcon = 0;
    Pages[nPageIndex_4].pfnDlgProc = PropColumnSetsForProcess;
    Pages[nPageIndex_4].pszTitle = L"Process GPU";
    Pages[nPageIndex_4].lParam = &ZeroParam;
    Pages[nPageIndex_4].pfnCallback = 0;
  }
  nPageIndex_5 = nPageIndex_3;
  Pages[nPageIndex_5].lParam = &ZeroParam;
  nPageIndex_6 = PropSheet.nStartPage;
  Pages[nPageIndex_5].dwSize = sizeof(PE_PROPSHEETPAGEW);
  if ( nID == 40106 )
    nPageIndex_6 = nPageIndex_3;
  Pages[nPageIndex_5].dwFlags = PSP_USETITLE;
  nPageIndex_7 = nPageIndex_3 + 1;
  Pages[nPageIndex_5].hInstance = ghInstance;
  Pages[nPageIndex_5].u.pszTemplate = L"HANDLECOLUMNS";
  Pages[nPageIndex_5].u2.hIcon = 0;
  Pages[nPageIndex_5].pfnDlgProc = PropColumnSetsForHandles;
  Pages[nPageIndex_5].pszTitle = L"Handle";
  Pages[nPageIndex_5].pfnCallback = 0;
  nPageIndex_8 = nPageIndex_7;
  Pages[nPageIndex_8].dwSize = sizeof(PE_PROPSHEETPAGEW);
  Pages[nPageIndex_8].dwFlags = PSP_USETITLE;
  Pages[nPageIndex_8].hInstance = ghInstance;
  Pages[nPageIndex_8].u.pszTemplate = L"DLLCOLUMNS";
  Pages[nPageIndex_8].u2.hIcon = 0;
  Pages[nPageIndex_8].pfnDlgProc = PropColumnSetsForDlls;
  Pages[nPageIndex_8].pszTitle = L"DLL";
  Pages[nPageIndex_8].lParam = &ZeroParam;
  Pages[nPageIndex_8].pfnCallback = 0;
  if ( nID == 40104 )
    nPageIndex_6 = nPageIndex_7;
  nPageIndex = nPageIndex_7 + 1;
  if ( gNetClrMemoryPerfInfoLoaded )
  {
    nPageIndex_9 = nPageIndex++;
    Pages[nPageIndex_9].dwSize = sizeof(PE_PROPSHEETPAGEW);
    Pages[nPageIndex_9].dwFlags = PSP_USETITLE;
    Pages[nPageIndex_9].hInstance = ghInstance;
    Pages[nPageIndex_9].u.pszTemplate = L"NETCOLUMNS";
    Pages[nPageIndex_9].u2.hIcon = 0;
    Pages[nPageIndex_9].pfnDlgProc = PropColumnSetsForNet;
    Pages[nPageIndex_9].pszTitle = L".NET";
    Pages[nPageIndex_9].lParam = &ZeroParam;
    Pages[nPageIndex_9].pfnCallback = 0;
  }
  nPageIndex_10 = nPageIndex;
  PropSheet.dwFlags = 0x88;                     // PSH_NOAPPLYNOW| PSH_PROPSHEETPAGE
  PropSheet.dwSize = sizeof(PROPSHEETHEADERW);
  PropSheet.hInstance = ghInstance;
  Pages[nPageIndex_10].dwSize = sizeof(PE_PROPSHEETPAGEW);
  Pages[nPageIndex_10].dwFlags = PSP_USETITLE;
  Pages[nPageIndex_10].hInstance = ghInstance;
  Pages[nPageIndex_10].u.pszTemplate = L"STATUSBARCOLUMNS";
  Pages[nPageIndex_10].u2.hIcon = 0;
  Pages[nPageIndex_10].pfnDlgProc = PropColumnSetsForStatusBar;
  Pages[nPageIndex_10].pszTitle = L"Status Bar";
  Pages[nPageIndex_10].lParam = 0;
  Pages[nPageIndex_10].pfnCallback = 0;
  PropSheet.nPages = nPageIndex + 1;
  PropSheet.ppsp = Pages;
  if ( nID == 40107 )
    nPageIndex_6 = nPageIndex;
  PropSheet.hwndParent = ghMainWnd;
  PropSheet.nStartPage = nPageIndex_6;
  swprintf(Dst, L"Select Columns");
  PropSheet.pfnCallback = 0;
  PropSheet.pszCaption = Dst;
  PropertySheetW(&PropSheet);
  if ( ZeroParam )
    UpdateWindowPlacement(ghMainWnd, 1);
  return 0;
}
// 1041188: using guessed type wchar_t aProccolumns[12];
// 10411A0: using guessed type wchar_t aProcessImage[14];
// 10411BC: using guessed type wchar_t aProcperfcolumn[16];
// 10411DC: using guessed type wchar_t aProcessPerform[20];
// 1041204: using guessed type wchar_t aProciocolumns[14];
// 1041220: using guessed type wchar_t aProcessIO[12];
// 1041238: using guessed type wchar_t aProcnetworkcol[19];
// 1041260: using guessed type wchar_t aProcessNetwork[16];
// 1041280: using guessed type wchar_t aProcdiskcolumn[16];
// 10412A0: using guessed type wchar_t aProcessDisk[13];
// 10412BC: using guessed type wchar_t aProcmemcolumns[15];
// 10412DC: using guessed type wchar_t aProcessMemory[15];
// 10412FC: using guessed type wchar_t aProcgpucolumns[15];
// 104131C: using guessed type wchar_t aProcessGpu[12];
// 1041334: using guessed type wchar_t aHandlecolumns_0[14];
// 1041350: using guessed type wchar_t aHandle[7];
// 1041360: using guessed type wchar_t aDllcolumns_0[11];
// 1041380: using guessed type wchar_t aNetcolumns[11];
// 1041398: using guessed type wchar_t aNet[5];
// 10413A4: using guessed type wchar_t aStatusbarcolum_0[17];
// 10413C8: using guessed type wchar_t aStatusBar[11];
// 106A098: using guessed type char gNetClrMemoryPerfInfoLoaded;
// FD0037: user specified stroff has not been processed: PROPSHEETHEADERW offset 52

//----- (00FD0150) --------------------------------------------------------
int __cdecl Command_ShowDllsPane(HWND hWnd)
{
  HMENU v1; // eax
  signed int v2; // eax
  UINT v3; // ST10_4
  HMENU v4; // eax
  LPARAM v5; // eax
  int v6; // eax
  int v7; // eax
  HMENU v8; // eax
  UINT_PTR v9; // ST0C_4
  HMENU v10; // eax
  LRESULT v11; // eax

  gConfig.bShowDllView = 1;
  v1 = GetMenu(hWnd);
  CheckMenuItem(v1, 0x9C4Bu, 8u);
  v2 = 0;
  if ( !gConfig.bShowDllView )
    v2 = 8;
  v3 = v2;
  v4 = GetMenu(hWnd);
  CheckMenuItem(v4, 0x9C46u, v3);
  v5 = 1;
  if ( gConfig.bShowDllView )
    v5 = 4;
  PostMessageW(ghWndToolbar, 0x42Bu, 0x9C5Eu, v5);
  InvalidateRect(ghWndToolbar, 0, 1);
  if ( hWnd )
    SetEvent(ghRefreshEventHandle);
  v6 = 5;
  if ( gConfig.bShowDllView )
    v6 = 0;
  ShowWindow(ghWndHandlesListCtrl, v6);
  v7 = 0;
  if ( gConfig.bShowDllView )
    v7 = 5;
  ShowWindow(ghWndDllsListCtrl, v7);
  if ( gConfig.bShowLowerPane )
  {
    v8 = GetMenu(ghMainWnd);
    RemoveMenu(v8, 5u, 0x400u);
    v9 = ghDllMenuPopup;
    v10 = GetMenu(ghMainWnd);
    InsertMenuW(v10, 5u, 0x410u, v9, L"&DLL");
  }
  v11 = SendMessageW(ghWndDllsListCtrl, 0x100Cu, 0xFFFFFFFF, 2);
  UpdateMenuStatus(v11 != -1, 5);
  DrawMenuBar(ghMainWnd);
  if ( !gConfig.bShowLowerPane )
    Command_ShowLowerPane(ghMainWnd);
  return 0;
}

//----- (00FD02B0) --------------------------------------------------------
int __cdecl Command_ShowHandlesPane(HWND hWnd)
{
  HMENU v1; // eax
  signed int v2; // eax
  UINT v3; // ST10_4
  HMENU v4; // eax
  LPARAM v5; // eax
  int v6; // eax
  int v7; // eax
  HMENU v8; // eax
  UINT_PTR v9; // ST0C_4
  HMENU v10; // eax
  LRESULT v11; // eax

  gConfig.bShowDllView = 0;
  v1 = GetMenu(hWnd);
  CheckMenuItem(v1, 0x9C4Bu, 0);
  v2 = 0;
  if ( !gConfig.bShowDllView )
    v2 = 8;
  v3 = v2;
  v4 = GetMenu(hWnd);
  CheckMenuItem(v4, 0x9C46u, v3);
  v5 = 1;
  if ( gConfig.bShowDllView )
    v5 = 4;
  PostMessageW(ghWndToolbar, 0x42Bu, 0x9C5Eu, v5);
  PostMessageW(ghWndToolbar, 0x401u, 0x9C47u, gConfig.bShowDllView == 0);
  InvalidateRect(ghWndToolbar, 0, 1);
  if ( hWnd )
    SetEvent(ghRefreshEventHandle);
  v6 = 5;
  if ( gConfig.bShowDllView )
    v6 = 0;
  ShowWindow(ghWndHandlesListCtrl, v6);
  v7 = 0;
  if ( gConfig.bShowDllView )
    v7 = 5;
  ShowWindow(ghWndDllsListCtrl, v7);
  if ( !gConfig.bShowLowerPane )
    goto LABEL_17;
  v8 = GetMenu(ghMainWnd);
  RemoveMenu(v8, 5u, 0x400u);
  v9 = ghHandleMenuPopup;
  v10 = GetMenu(ghMainWnd);
  InsertMenuW(v10, 5u, 0x410u, v9, L"H&andle");
  v11 = SendMessageW(ghWndHandlesListCtrl, 0x100Cu, 0xFFFFFFFF, 2);
  UpdateMenuStatus(v11 != -1, 5);
  DrawMenuBar(ghMainWnd);
  if ( !gConfig.bShowLowerPane )
LABEL_17:
    Command_ShowLowerPane(ghMainWnd);
  return 0;
}

//----- (00FD0430) --------------------------------------------------------
int __cdecl Command_ViewDllsProperties(HWND hWnd)
{
  if ( gConfig.bShowDllView )
    Command_ShowHandlesPane(hWnd);
  else
    Command_ShowDllsPane(hWnd);
  if ( ghFindDlg )
    SendMessageW(ghFindDlg, 0x18u, 0, 0);
  return 0;
}

//----- (00FD0480) --------------------------------------------------------
int __cdecl Command_UnnamedHandlesAndMappings(HWND hWnd)
{
  signed int v1; // eax
  bool v2; // zf
  UINT v3; // ST0C_4
  HMENU v4; // eax

  v1 = 0;
  v2 = gConfig.bShowUnnamedHandles != 0;
  gConfig.bShowUnnamedHandles = gConfig.bShowUnnamedHandles == 0;
  if ( !v2 )
    v1 = 8;
  v3 = v1;
  v4 = GetMenu(hWnd);
  CheckMenuItem(v4, 0x9C47u, v3);
  if ( gConfig.bShowLowerPane && gdwProcessIdSelected != -1 )
    SetEvent(ghEvent2);
  SendMessageW(ghWndToolbar, 0x403u, 0x9C47u, gConfig.bShowUnnamedHandles);
  return 0;
}

//----- (00FD0500) --------------------------------------------------------
int __cdecl Command_HighlightRelocatedDlls(HWND hWnd)
{
  signed int v1; // eax
  bool v2; // zf
  UINT v3; // ST08_4
  HMENU v4; // eax

  v1 = 0;
  v2 = gConfig.bHighlightRelocatedDlls != 0;
  gConfig.bHighlightRelocatedDlls = gConfig.bHighlightRelocatedDlls == 0;
  if ( !v2 )
    v1 = 8;
  v3 = v1;
  v4 = GetMenu(hWnd);
  CheckMenuItem(v4, 0x9C50u, v3);
  InvalidateRgn(ghWndDllsListCtrl, 0, 1);
  return 0;
}

//----- (00FD0550) --------------------------------------------------------
int __cdecl Command_ScrollToNewProcess(HWND hWnd)
{
  signed int v1; // eax
  bool v2; // zf
  UINT v3; // ST08_4
  HMENU v4; // eax

  v1 = 0;
  v2 = gConfig.bShowNewProcesses != 0;
  gConfig.bShowNewProcesses = gConfig.bShowNewProcesses == 0;
  if ( !v2 )
    v1 = 8;
  v3 = v1;
  v4 = GetMenu(hWnd);
  CheckMenuItem(v4, 0x9F0Du, v3);
  UpdateWindowPlacement(ghMainWnd, 1);
  return 0;
}

//----- (00FD05A0) --------------------------------------------------------
int __cdecl Command_Help(int a1)
{
  wchar_t *v1; // eax
  WCHAR FileName; // [esp+4h] [ebp-414h]
  WCHAR Filename; // [esp+20Ch] [ebp-20Ch]

  GetModuleFileNameW(0, &Filename, 0x104u);
  v1 = wcsrchr(&Filename, 0x5Cu);
  wcscpy_s(v1, 260 - (v1 - &Filename), L"\\procexp.chm");
  swprintf(&FileName, L"%s:Zone.Identifier", &Filename);
  DeleteFileW(&FileName);
  if ( !sub_F71149(a1, &Filename, 0, 0) )
  {
    SetLastError(0);
    ReportMsg(L"Unable to open help file", ghMainWnd);
  }
  return 0;
}
// 1041864: using guessed type wchar_t aUnableToOpenHe[25];

//----- (00FD0660) --------------------------------------------------------
int __cdecl Command_SearchOnline(HWND hWnd, __int16 a2)
{
  HWND v2; // esi
  HWND v3; // eax
  LRESULT v4; // eax
  const WCHAR *v5; // eax
  int v6; // esi
  LPARAM lParam; // [esp+4h] [ebp-34h]
  LRESULT v9; // [esp+8h] [ebp-30h]
  int v10; // [esp+Ch] [ebp-2Ch]
  int v11; // [esp+24h] [ebp-14h]

  lParam = 0;
  memset(&v9, 0, 0x30u);
  if ( a2 == -25424 )
  {
    v2 = ghWndDllsListCtrl;
  }
  else
  {
    v3 = GetFocus();
    v2 = ghWndTreeListView;
    if ( v3 == ghWndDllsListCtrl )
      v2 = ghWndDllsListCtrl;
  }
  v4 = SendMessageW(v2, 0x100Cu, 0xFFFFFFFF, 2);
  if ( v4 != -1 )
  {
    v9 = v4;
    v10 = 0;
    lParam = 4;
    if ( SendMessageW(v2, 0x104Bu, 0, &lParam) )
    {
      if ( v2 == ghWndTreeListView )
      {
        v5 = *(v11 + 60);
      }
      else
      {
        v6 = v11;
        if ( *(v11 + 44) & 8 )
        {
          MessageBoxW(
            ghWndTreeListView,
            L"Search not supported on pagefile-backed sections",
            L"Process Explorer Error",
            0x10u);
          return 0;
        }
        if ( wcsrchr(*(v11 + 344), 0x5Cu) )
          v5 = wcsrchr(*(v6 + 344), 0x5Cu) + 1;
        else
          v5 = *(v6 + 344);
      }
      LaunchWebBrowser(hWnd, 1, v5);
    }
  }
  return 0;
}

//----- (00FD0770) --------------------------------------------------------
int __cdecl Command_FindInProcess(HWND a1, __int16 nID)
{
  byte_105E104 = nID == 40062;
  if ( ghFindDlg )
  {
    ShowWindow(ghFindDlg, 5);
    SetFocus(ghFindDlg);
  }
  else
  {
    ghFindDlg = CreateDialogParamW(ghInstance, L"FINDDIALOG", ghMainWnd, DlgFind, ghFindDlg);
  }
  return 0;
}
// 105E104: using guessed type char byte_105E104;

//----- (00FD07D0) --------------------------------------------------------
int __cdecl Command_Cancel(HWND hWnd)
{
  int result; // eax

  if ( gbWindowFinding )
  {
    SearchWindow(hWnd);
    result = 0;
  }
  else
  {
    if ( gConfig.bHideWhenMinimized )
      CMainWnd::Hide(ghMainWnd);
    else
      CMainWnd::HandleDestroy(hWnd);
    result = 0;
  }
  return result;
}
// 106A38B: using guessed type char gbWindowFinding;

//----- (00FD0830) --------------------------------------------------------
int Options_ShowHiddenProcess()
{
  WCHAR **v0; // eax
  int v1; // esi
  WCHAR **v2; // ecx
  WCHAR **v3; // eax
  tagTREEVIEWLISTITEMPARAM *i; // eax
  HMENU v5; // eax

  v0 = gpHiddenProcesses;
  v1 = 0;
  if ( *gpHiddenProcesses )
  {
    v2 = gpHiddenProcesses;
    do
    {
      free(*v2);
      v0 = gpHiddenProcesses;
      v2 = &gpHiddenProcesses[++v1];
    }
    while ( *v2 );
  }
  free(v0);
  v3 = malloc(4u);
  gpHiddenProcesses = v3;
  *v3 = 0;
  for ( i = gpTreeViewListItemParam; i; i = i->m_Prev )
    i->dwStyle &= 0xFFFFFFFE;
  SaveHiddenProcessesToRegistry();
  v5 = GetMenu(ghMainWnd);
  EnableMenuItem(v5, 0x9C9Bu, 1u);
  SetEvent(ghTimerRefreshEvent);
  return 0;
}

//----- (00FD08C0) --------------------------------------------------------
int __cdecl Command_Font(HWND hWnd)
{
  sub_FB9980(hWnd);
  return 0;
}

//----- (00FD08E0) --------------------------------------------------------
int Command_OnProperties()
{
  HWND v0; // esi
  int nIndex; // eax
  tagLVITEMW ItemInfo; // [esp+4h] [ebp-34h]

  ItemInfo.mask = 0;
  memset(&ItemInfo.iItem, 0, 0x30u);
  v0 = ghWndTreeListView;
  nIndex = SendMessageW(ghWndTreeListView, LVM_GETNEXTITEM, 0xFFFFFFFF, LVFI_STRING);
  if ( nIndex != -1 )
  {
    ItemInfo.iItem = nIndex;
    ItemInfo.iSubItem = 0;
    ItemInfo.mask = LVIF_PARAM;
    if ( SendMessageW(v0, LVM_GETITEMW, 0, &ItemInfo) )
    {
      InterlockedIncrement(&ItemInfo.lParam->field_0);
      ItemInfo.lParam->dwProcessId = gdwProcessIdSelected;
      _beginthread(PropertiesThreadProc, 0, ItemInfo.lParam);
    }
  }
  return 0;
}

//----- (00FD0970) --------------------------------------------------------
int __cdecl sub_FD0970(int a1, __int16 a2)
{
  tagTREEVIEWLISTITEMPARAM *v2; // esi
  int FindInfoParam; // eax
  int v4; // ecx
  int v5; // eax
  unsigned int v6; // eax
  LRESULT v7; // eax
  tagLVITEMW ItemInfo2; // [esp+0h] [ebp-80h]
  tagLVITEMW ItemInfo; // [esp+34h] [ebp-4Ch]
  tagLVFINDINFOW FindInfo; // [esp+68h] [ebp-18h]

  if ( GetFocus() != ghWndTreeListView )
    return 0;
  ItemInfo.iItem = SendMessageW(ghWndTreeListView, LVM_GETNEXTITEM, 0xFFFFFFFF, 2);
  if ( ItemInfo.iItem != -1 )
  {
    ItemInfo.iSubItem = 0;
    ItemInfo.mask = 4;
    if ( SendMessageW(ghWndTreeListView, LVM_GETITEMW, 0, &ItemInfo) )
    {
      v2 = ItemInfo.lParam;
      if ( a2 == 40087 )
      {
        if ( ItemInfo.lParam->field_28 & 4 )
        {
          ItemInfo2.stateMask = 3;
          ++ItemInfo.iItem;
          ItemInfo2.state = 3;
          SendMessageW(ghWndTreeListView, LVM_SETITEMSTATE, ItemInfo.iItem, &ItemInfo2);
LABEL_20:
          v7 = SendMessageW(ghWndTreeListView, LVM_GETNEXTITEM, 0xFFFFFFFF, 2);
          SendMessageW(ghWndTreeListView, LVM_ENSUREVISIBLE, v7, 0);
          return 0;
        }
      }
      else if ( a2 == 40088 && !(ItemInfo.lParam->field_28 & 4) )
      {
        FindInfoParam = ItemInfo.lParam[1].field_0;
        if ( FindInfoParam )
        {
          while ( 1 )
          {
            v4 = *(FindInfoParam + 40);
            if ( v4 & 2 )
            {
              if ( !(v4 & 1) || !gConfig.byte_14012ADFE )
                break;
            }
            FindInfoParam = *(FindInfoParam + 84);
            if ( !FindInfoParam )
              goto LABEL_20;
          }
          FindInfo.lParam = FindInfoParam;
          FindInfo.flags = 1;
          ItemInfo.iItem = SendMessageW(ghWndTreeListView, LVM_FINDITEMW, 0xFFFFFFFF, &FindInfo);
          ItemInfo2.stateMask = 3;
          ItemInfo2.state = 3;
          SendMessageW(ghWndTreeListView, LVM_SETITEMSTATE, ItemInfo.iItem, &ItemInfo2);
        }
        goto LABEL_20;
      }
      v5 = ItemInfo.lParam->field_28;
      if ( v5 & 4 )
        v6 = v5 & 0xFFFFFFFB;
      else
        v6 = v5 | 4;
      ItemInfo.lParam->field_28 = v6;
      SendMessageW(ghWndTreeListView, TREELIST_MSG_2001, v2->field_5B8, (v6 >> 2) & 1);
      sub_FB8DA0(v2);
      goto LABEL_20;
    }
  }
  return 0;
}

//----- (00FD0B10) --------------------------------------------------------
int Command_OptionsToConfirmKill()
{
  signed int v0; // eax
  bool v1; // zf
  UINT v2; // ST08_4
  HMENU v3; // eax

  v0 = 0;
  v1 = gConfig.bConfirmKill != 0;
  gConfig.bConfirmKill = gConfig.bConfirmKill == 0;
  if ( !v1 )
    v0 = 8;
  v2 = v0;
  v3 = GetMenu(ghMainWnd);
  CheckMenuItem(v3, IDM_OPTIONS_CONFIRM_KILL, v2);
  UpdateWindowPlacement(ghMainWnd, 1);
  return 0;
}

//----- (00FD0B60) --------------------------------------------------------
int Command_ShowNewProcesses()
{
  signed int v0; // eax
  bool v1; // zf
  UINT v2; // ST08_4
  HMENU v3; // eax

  v0 = 0;
  v1 = gConfig.bFormatIoBytes != 0;
  gConfig.bFormatIoBytes = gConfig.bFormatIoBytes == 0;
  if ( !v1 )
    v0 = 8;
  v2 = v0;
  v3 = GetMenu(ghMainWnd);
  CheckMenuItem(v3, 0x9F25u, v2);
  UpdateWindowPlacement(ghMainWnd, 1);
  InvalidateRect(ghMainWnd, 0, 0);
  return 0;
}

//----- (00FD0BC0) --------------------------------------------------------
int Command_SaveHiddenProcesses()
{
  int v0; // eax
  tagTREEVIEWLISTITEMPARAM *v1; // esi
  tagTREEVIEWITEMPARAM *i; // edi
  int v3; // eax
  unsigned int v4; // eax
  int v5; // esi
  HMENU v6; // eax
  WCHAR **v8; // eax
  int v9; // ecx
  bool v10; // zf
  WCHAR **j; // ecx
  tagLVITEMW ItemInfo; // [esp+4h] [ebp-34h]

  ItemInfo.mask = 0;
  memset(&ItemInfo.iItem, 0, 0x30u);
  v0 = SendMessageW(ghWndTreeListView, LVM_GETNEXTITEM, 0xFFFFFFFF, 2);
  if ( v0 == -1 )
    return 0;
  ItemInfo.iItem = v0;
  ItemInfo.iSubItem = 0;
  ItemInfo.mask = LVIF_PARAM;
  if ( !SendMessageW(ghWndTreeListView, LVM_GETITEMW, 0, &ItemInfo) )
    return 0;
  v1 = gpTreeViewListItemParam;
  for ( i = ItemInfo.lParam; v1; v1 = v1->m_Prev )
  {
    if ( !_wcsicmp(v1->szProcessName2, i->field_3C) )
    {
      v3 = v1->dwStyle;
      if ( v3 & 1 )
        v4 = v3 & 0xFFFFFFFE;
      else
        v4 = v3 | 1;
      v1->dwStyle = v4;
    }
  }
  v5 = 0;
  if ( !(i->field_28 & 1) )
  {
    v8 = gpHiddenProcesses;
    if ( *gpHiddenProcesses )
    {
      v9 = 0;
      while ( 1 )
      {
        v10 = _wcsicmp(v8[v9], i->field_3C) == 0;
        v8 = gpHiddenProcesses;
        if ( v10 )
          break;
        v9 = ++v5;
        if ( !gpHiddenProcesses[v5] )
        {
          SaveHiddenProcessesToRegistry();
          return 0;
        }
      }
      free(gpHiddenProcesses[v5]);
      for ( j = &gpHiddenProcesses[v5]; gpHiddenProcesses[v5]; j = &gpHiddenProcesses[v5] )
      {
        ++v5;
        *j = j[1];
      }
    }
    SaveHiddenProcessesToRegistry();
    return 0;
  }
  if ( *gpHiddenProcesses )
  {
    do
      ++v5;
    while ( gpHiddenProcesses[v5] );
  }
  gpHiddenProcesses = realloc(gpHiddenProcesses, 4 * v5 + 8);
  gpHiddenProcesses[v5] = _wcsdup(i->field_3C);
  gpHiddenProcesses[v5 + 1] = 0;
  SetEvent(ghTimerRefreshEvent);
  v6 = GetMenu(ghMainWnd);
  EnableMenuItem(v6, IDM_VIEW_SHOW_HIDDEN_PROCESSES, 0);
  SaveHiddenProcessesToRegistry();
  return 0;
}

//----- (00FD0D80) --------------------------------------------------------
int __cdecl Command_DifferenceHiliteDuration(HWND hWndParent)
{
  DialogBoxParamW(ghInstance, L"DIFFDURATION", hWndParent, DialogFunc, 0);
  return 0;
}

//----- (00FD0DB0) --------------------------------------------------------
int Command_Save()
{
  sub_FFE3B0(0);
  return 0;
}

//----- (00FD0DC0) --------------------------------------------------------
int __cdecl Command_CpuHistory(HWND hWndParent)
{
  HWND v1; // esi
  LRESULT v2; // eax
  HANDLE v3; // eax
  void *v4; // esi
  LPARAM lParam; // [esp+4h] [ebp-34h]
  LRESULT v7; // [esp+8h] [ebp-30h]
  int v8; // [esp+Ch] [ebp-2Ch]
  int v9; // [esp+24h] [ebp-14h]

  lParam = 0;
  memset(&v7, 0, 0x30u);
  v1 = ghWndTreeListView;
  v2 = SendMessageW(ghWndTreeListView, 0x100Cu, 0xFFFFFFFF, 2);
  if ( v2 != -1 )
  {
    v7 = v2;
    v8 = 0;
    lParam = 4;
    if ( SendMessageW(v1, 0x104Bu, 0, &lParam) )
    {
      if ( v1 == ghWndTreeListView )
      {
        v3 = OpenProcess(0x600u, 0, *(v9 + 68));
        v4 = v3;
        if ( !v3 )
        {
          ReportMsg(L"Unable to set process affinity", ghMainWnd);
          return 0;
        }
        DialogBoxParamW(ghInstance, L"CPUAFFINITY", hWndParent, sub_FFEDC0, v3);
        CloseHandle(v4);
      }
    }
  }
  return 0;
}
// 104141C: using guessed type wchar_t aUnableToSetPro[31];

//----- (00FD0E90) --------------------------------------------------------
int Command_SaveAs()
{
  sub_FFE3B0(1);
  return 0;
}

//----- (00FD0EA0) --------------------------------------------------------
int Command_CloseHandle()
{
  HWND v0; // esi
  LRESULT v1; // eax
  _DWORD *v2; // esi
  LPARAM v4; // [esp+8h] [ebp-78h]
  int v5; // [esp+14h] [ebp-6Ch]
  int v6; // [esp+18h] [ebp-68h]
  LPARAM lParam; // [esp+3Ch] [ebp-44h]
  LRESULT v8; // [esp+40h] [ebp-40h]
  int v9; // [esp+44h] [ebp-3Ch]
  _DWORD *v10; // [esp+5Ch] [ebp-24h]
  int InBuffer; // [esp+70h] [ebp-10h]
  int v12; // [esp+74h] [ebp-Ch]
  int v13; // [esp+7Ch] [ebp-4h]

  lParam = 0;
  memset(&v8, 0, 0x30u);
  v0 = GetFocus();
  if ( v0 == ghWndDllsListCtrl )
    v0 = ghWndTreeListView;
  v1 = SendMessageW(v0, 0x100Cu, 0xFFFFFFFF, 2);
  if ( v1 == -1 )
  {
    if ( v0 == ghWndTreeListView )
    {
      MessageBoxW(ghWndTreeListView, L"No process selected", L"Process Explorer Error", 0x10u);
      return 0;
    }
    if ( v0 == ghWndHandlesListCtrl )
    {
      MessageBoxW(ghWndTreeListView, L"No handle selected", L"Process Explorer Error", 0x10u);
      return 0;
    }
    MessageBoxW(ghWndTreeListView, L"No handle or process selected", L"Process Explorer Error", 0x10u);
    return 0;
  }
  v8 = v1;
  v9 = 0;
  lParam = 4;
  if ( !SendMessageW(v0, 0x104Bu, 0, &lParam) )
    return 0;
  if ( v0 == ghWndTreeListView || v0 == ghWndDllsListCtrl )
  {
    if ( sub_FF8030(v10[15], v10[17]) )
    {
      SetEvent(ghRefreshEventHandle);
      v6 = 3;
      v5 = 3;
      SendMessageW(ghWndTreeListView, 0x102Bu, v8 - 1, &v4);
      return 0;
    }
    return 0;
  }
  if ( v0 != ghWndHandlesListCtrl )
    return 0;
  v2 = v10;
  if ( !IsBuiltinAdministrative() )
  {
    MessageBoxW(
      ghWndHandlesListCtrl,
      L"Closing handles requires administrative rights.",
      L"Process Explorer Error",
      0x10u);
    return 0;
  }
  if ( !v2[9] )
  {
    MessageBoxW(
      ghWndHandlesListCtrl,
      L"Handles in the Idle process cannot be closed.",
      L"Process Explorer Error",
      0x10u);
    return 0;
  }
  if ( gConfig.bConfirmKill
    && MessageBoxW(
         ghWndHandlesListCtrl,
         L"Forcing a handle closed can lead to an application crash and system instability.\nContinue with close?",
         L"Process Explorer Warning",
         0x34u) != 6 )
  {
    return 0;
  }
  v13 = v2[11];
  InBuffer = v2[9];
  v12 = v2[10];
  if ( CDriver::Control(0x83350004, &InBuffer, 0x10u, 0, 0) )
  {
    SetEvent(ghRefreshEventHandle);
    v6 = 3;
    v5 = 3;
    SendMessageW(ghWndHandlesListCtrl, LVM_SETITEMSTATE, v8 - 1, &v4);
    SetFocus(ghWndHandlesListCtrl);
  }
  else
  {
    ReportMsg(L"Error opening process", ghMainWnd);
  }
  return 0;
}
// 1042088: using guessed type wchar_t aErrorOpeningPr[22];

//----- (00FD10F0) --------------------------------------------------------
int Command_SuspendProcess()
{
  HWND v0; // esi
  LRESULT v1; // eax
  int v2; // esi
  int v3; // eax
  unsigned int v4; // eax
  const WCHAR *v5; // eax
  const WCHAR *v6; // ST10_4
  HMENU v7; // eax
  int result; // eax
  LPARAM lParam; // [esp+8h] [ebp-38h]
  WPARAM wParam; // [esp+Ch] [ebp-34h]
  int v11; // [esp+10h] [ebp-30h]
  int v12; // [esp+28h] [ebp-18h]
  char v13; // [esp+3Ch] [ebp-4h]

  lParam = 0;
  memset(&wParam, 0, 0x30u);
  v0 = ghWndTreeListView;
  v1 = SendMessageW(ghWndTreeListView, 0x100Cu, 0xFFFFFFFF, 2);
  if ( v1 != -1
    && (wParam = v1, v11 = 0, lParam = 4, SendMessageW(v0, 0x104Bu, 0, &lParam))
    && (v2 = v12, SetFocus(ghWndTreeListView), v2) )
  {
    if ( sub_FFF0A0(~(*(v2 + 40) >> 7) & 1, *(v2 + 68), &v13) )
    {
      ReportMsg(L"Unable to suspend the process", ghMainWnd);
    }
    else
    {
      v3 = *(v2 + 40);
      if ( (v3 & 0x80u) == 0 )
        v4 = v3 | 0x80;
      else
        v4 = v3 & 0xFFFFFF7F;
      *(v2 + 40) = v4;
    }
    SendMessageW(ghWndTreeListView, 0x1015u, wParam, wParam);
    v5 = L"R&esume";
    if ( *(v12 + 40) >= 0 )
      v5 = L"S&uspend";
    v6 = v5;
    v7 = GetMenu(ghMainWnd);
    ModifyMenuW(v7, 0x9C6Au, 0, 0x9C6Au, v6);
    result = 0;
  }
  else
  {
    MessageBoxW(ghWndTreeListView, L"No process is selected", L"Process Explorer Error", 0x10u);
    result = 0;
  }
  return result;
}
// 103E398: using guessed type wchar_t aREsume[8];
// 1042024: using guessed type wchar_t aUnableToSuspen[30];

//----- (00FD1230) --------------------------------------------------------
int __cdecl Command_ShowLowerPane(HWND a1)
{
  HMENU v1; // ebx
  UINT v2; // ecx
  bool v3; // zf
  HMENU v4; // eax
  HWND v6; // edi
  LRESULT v7; // eax
  const WCHAR *v8; // eax
  UINT_PTR v9; // eax
  LRESULT v10; // eax
  const WCHAR *v11; // [esp-4h] [ebp-24h]
  struct tagRECT Rect; // [esp+Ch] [ebp-14h]

  v1 = GetMenu(ghMainWnd);
  v2 = 0;
  v3 = gConfig.bShowLowerPane != 0;
  gConfig.bShowLowerPane = gConfig.bShowLowerPane == 0;
  if ( !v3 )
    v2 = 8;
  CheckMenuItem(v1, 0x9C6Eu, v2);
  SendMessageW(ghWndToolbar, 0x42Bu, 0x9C6Eu, (gConfig.bShowLowerPane != 0) + 9);
  InvalidateRect(ghWndToolbar, 0, 1);
  GetClientRect(ghMainWnd, &Rect);
  if ( gConfig.bShowLowerPane )
  {
    gConfig.dbDivider = gConfig.dbSavedDivider;
    CMainWnd::HandleSize(
      ghMainWnd,
      0,
      0,
      (LOWORD(Rect.right) - LOWORD(Rect.left)) | ((LOWORD(Rect.bottom) - LOWORD(Rect.top)) << 16));
    v6 = ghWndHandlesListCtrl;
    if ( gConfig.bShowDllView )
      v6 = ghWndDllsListCtrl;
    v7 = SendMessageW(ghWndTreeListView, 0x100Cu, 0xFFFFFFFF, 2);
    SendMessageW(ghWndTreeListView, 0x1013u, v7, 0);
    ShowWindow(v6, 5);
    if ( a1 )
      SetEvent(ghRefreshEventHandle);
    v8 = L"&DLL";
    if ( !gConfig.bShowDllView )
      v8 = L"H&andle";
    v11 = v8;
    v9 = ghHandleMenuPopup;
    if ( gConfig.bShowDllView )
      v9 = ghDllMenuPopup;
    InsertMenuW(v1, 5u, 0x410u, v9, v11);
    DrawMenuBar(ghMainWnd);
    v10 = SendMessageW(v6, 0x100Cu, 0xFFFFFFFF, 2);
    UpdateMenuStatus(v10 != -1, 5);
  }
  else if ( IsWindowVisible(ghWndHandlesListCtrl) || IsWindowVisible(ghWndDllsListCtrl) )
  {
    ShowWindow(ghWndHandlesListCtrl, 0);
    ShowWindow(ghWndDllsListCtrl, 0);
    v4 = GetMenu(ghMainWnd);
    RemoveMenu(v4, 5u, 0x400u);
    DrawMenuBar(ghMainWnd);
    gConfig.dbSavedDivider = gConfig.dbDivider;
    gConfig.dbDivider = db_one;
    CMainWnd::HandleSize(
      ghMainWnd,
      0,
      0,
      (LOWORD(Rect.right) - LOWORD(Rect.left)) | ((LOWORD(Rect.bottom) - LOWORD(Rect.top)) << 16));
    return 0;
  }
  return 0;
}

//----- (00FD1490) --------------------------------------------------------
int __cdecl OnProperties(HWND a1, __int16 a2)
{
  HWND v2; // esi
  int nItem; // eax
  tagTREEVIEWITEMPARAM *v4; // esi
  tagLVITEMW ItemInfo; // [esp+4h] [ebp-34h]

  ItemInfo.mask = 0;
  memset(&ItemInfo.iItem, 0, 0x30u);
  switch ( a2 )
  {
    case IDM_DLL_PROPERTIES:
      v2 = ghWndDllsListCtrl;
      break;
    case IDM_HANDLE_PROPERTIES:
      v2 = ghWndHandlesListCtrl;
      break;
    case IDM_PROCESS_PROPERTIES:
      v2 = ghWndTreeListView;
      break;
    default:
      v2 = GetFocus();
      break;
  }
  nItem = SendMessageW(v2, LVM_GETNEXTITEM, 0xFFFFFFFF, LVFI_STRING);
  if ( nItem == -1 )
  {
    if ( v2 == ghWndTreeListView )
    {
      MessageBoxW(ghWndTreeListView, L"No process is selected", L"Process Explorer Error", 0x10u);
      return 0;
    }
    if ( v2 == ghWndDllsListCtrl )
    {
      MessageBoxW(ghWndTreeListView, L"No DLL is selected", L"Process Explorer Error", 0x10u);
      return 0;
    }
    if ( v2 == ghWndHandlesListCtrl )
      MessageBoxW(ghWndTreeListView, L"No object is selected", L"Process Explorer Error", 0x10u);
    return 0;
  }
  ItemInfo.iItem = nItem;
  ItemInfo.iSubItem = 0;
  ItemInfo.mask = LVIF_PARAM;
  if ( !SendMessageW(v2, LVM_GETITEMW, 0, &ItemInfo) )
    return 0;
  if ( v2 == ghWndDllsListCtrl )
  {
    v4 = ItemInfo.lParam;
    if ( ItemInfo.lParam->field_2C & 8 )
    {
      MessageBoxW(
        ghWndTreeListView,
        L"Properties not supported on pagefile-backed sections",
        L"Process Explorer Error",
        0x10u);
      return 0;
    }
    if ( ItemInfo.lParam[4].field_8 )
    {
      InterlockedIncrement(&ItemInfo.lParam->field_0);
      v4->field_28 = gdwProcessIdSelected;
      _beginthread(PropertiesThreadProc, 0, v4);
      return 0;
    }
    return 0;
  }
  if ( v2 == ghWndHandlesListCtrl )
    FillHandleListParam(v2, ItemInfo.lParam);
  else
    CTreeList::FillTreeViewParam(ItemInfo.lParam);
  return 0;
}

//----- (00FD1620) --------------------------------------------------------
int __cdecl UpdateSpeedOptions_Update(HWND a1, UINT a2)
{
  signed int v2; // eax
  UINT v3; // ebx
  signed int v4; // eax
  HMENU v5; // eax
  HMENU v6; // eax
  UINT v8; // [esp-14h] [ebp-14h]

  v2 = gConfig.dwRefreshRate;
  if ( gdwRefreshMenuIDLast == -1 )
  {
    if ( gConfig.dwRefreshRate > 2000 )
    {
      if ( gConfig.dwRefreshRate == 5000 )
      {
        gdwRefreshMenuIDLast = IDM_VIEW_UPDATESPEED_FIVE_SECONDS;
      }
      else if ( gConfig.dwRefreshRate == 10000 )
      {
        gdwRefreshMenuIDLast = 40022;
      }
    }
    else if ( gConfig.dwRefreshRate == 2000 )
    {
      gdwRefreshMenuIDLast = 40019;
    }
    else if ( gConfig.dwRefreshRate )
    {
      if ( gConfig.dwRefreshRate == 500 )
      {
        gdwRefreshMenuIDLast = 40023;
      }
      else if ( gConfig.dwRefreshRate == 1000 )
      {
        gdwRefreshMenuIDLast = 40021;
      }
    }
    else
    {
      gdwRefreshMenuIDLast = 40018;
    }
  }
  LOWORD(v3) = a2;
  if ( a2 == -25518 && !gConfig.dwRefreshRate )
  {
    SendMessageW(ghWndStatusBar, 0x40Bu, gnStatusBarItemCount - 1, &gszNullString);
    v4 = gdwRefreshMenuIDLast;
    if ( gdwRefreshMenuIDLast == -1 )
      v4 = 1000;
    v3 = v4;
    gdwRefreshMenuIDLast = v4;
    v2 = gConfig.dwRefreshRate;
    a2 = v3;
  }
  if ( v2 > 2000 )
  {
    if ( v2 == 5000 )
    {
      v8 = 40020;
    }
    else
    {
      if ( v2 != 10000 )
        goto LABEL_34;
      v8 = 40022;
    }
  }
  else if ( v2 == 2000 )
  {
    v8 = 40019;
  }
  else if ( v2 )
  {
    if ( v2 == 500 )
    {
      v8 = 40023;
    }
    else
    {
      if ( v2 != 1000 )
        goto LABEL_34;
      v8 = 40021;
    }
  }
  else
  {
    v8 = 40018;
  }
  v5 = GetMenu(ghMainWnd);
  CheckMenuItem(v5, v8, 0);
LABEL_34:
  v3 = v3;
  switch ( v3 )
  {
    case 0x9C52u:
      gConfig.dwRefreshRate = 0;
      SendMessageW(ghWndStatusBar, 0x40Bu, gnStatusBarItemCount - 1, L"Paused");
      break;
    case 0x9C53u:
      gConfig.dwRefreshRate = 2000;
      break;
    case 0x9C54u:
      gConfig.dwRefreshRate = 5000;
      break;
    case 0x9C55u:
      gConfig.dwRefreshRate = 1000;
      break;
    case 0x9C56u:
      gConfig.dwRefreshRate = 10000;
      break;
    case 0x9C57u:
      gConfig.dwRefreshRate = 500;
      break;
    default:
      break;
  }
  v6 = GetMenu(ghMainWnd);
  CheckMenuItem(v6, v3, 8u);
  if ( a2 != -25518 )
  {
    SendMessageW(ghWndStatusBar, 0x40Bu, gnStatusBarItemCount - 1, &gszNullString);
    SetEvent(ghRefreshEventHandle);
    gdwRefreshMenuIDLast = v3;
  }
  return 0;
}
// 1040D80: using guessed type wchar_t aPaused[7];
// 105E10C: using guessed type int gdwRefreshMenuIDLast;
// 1085720: using guessed type int gnStatusBarItemCount;

//----- (00FD1850) --------------------------------------------------------
int OnProcessProperties()
{
  HWND hWndTreeListView; // [esp+0h] [ebp-2Ch]
  __int128 v2; // [esp+4h] [ebp-28h]
  __int128 v3; // [esp+14h] [ebp-18h]
  __int64 v4; // [esp+24h] [ebp-8h]

  hWndTreeListView = ghWndTreeListView;
  _mm_storeu_si128(&v2, 0i64);
  gConfig.bShowProcessTree = 0;
  gConfig.bProcessSortDirection = 0;
  _mm_storeu_si128(&v3, 0i64);
  LODWORD(v2) = 101;
  v4 = 0i64;
  HIDWORD(v2) = 0;
  sub_FBD040(101u, &hWndTreeListView);
  return 0;
}

//----- (00FD18A0) --------------------------------------------------------
int __usercall ProcessPriority_Update@<eax>(int a1@<edi>, HWND a2, __int16 a3)
{
  HWND v3; // esi
  LRESULT v4; // eax
  signed int v5; // ebx
  UINT v6; // esi
  signed int v7; // edi
  HANDLE v8; // eax
  DWORD v9; // ST0C_4
  void *v10; // edi
  HMENU v11; // eax
  int v13; // [esp-4h] [ebp-4Ch]
  int v14; // [esp+0h] [ebp-48h]
  LPARAM lParam; // [esp+8h] [ebp-40h]
  WPARAM wParam; // [esp+Ch] [ebp-3Ch]
  int v17; // [esp+10h] [ebp-38h]
  int v18; // [esp+28h] [ebp-20h]
  UINT v19; // [esp+3Ch] [ebp-Ch]
  int v20; // [esp+40h] [ebp-8h]
  int v21; // [esp+44h] [ebp-4h]

  lParam = 0;
  memset(&wParam, 0, 0x30u);
  v3 = ghWndTreeListView;
  v4 = SendMessageW(ghWndTreeListView, 0x100Cu, 0xFFFFFFFF, 2);
  if ( v4 == -1 )
  {
    if ( v3 == ghWndTreeListView )
      MessageBoxW(ghWndTreeListView, L"No process selected", L"Process Explorer Error", 0x10u);
    return 0;
  }
  wParam = v4;
  v17 = 0;
  lParam = 4;
  if ( !SendMessageW(v3, 0x104Bu, 0, &lParam) || v3 != ghWndTreeListView )
    return 0;
  v13 = a1;
  switch ( a3 )
  {
    case 0x9CBB:
      v5 = 4;
      v6 = 40123;
      v7 = 64;
      break;
    case 0x9CBC:
      v5 = 4;
      v6 = 40124;
      v7 = 64;
      break;
    case 0x9CBD:
      v5 = 6;
      v6 = 40125;
      v7 = 0x4000;
      break;
    case 0x9CBE:
      v5 = 8;
      v6 = 40126;
      v7 = 32;
      break;
    case 0x9CBF:
      v5 = 10;
      v6 = 40127;
      v7 = 0x8000;
      break;
    case 0x9CC0:
      v5 = 13;
      v6 = 40128;
      v7 = 128;
      break;
    case 0x9CC1:
      v5 = 24;
      v6 = 40129;
      v7 = 256;
      break;
    default:
      v5 = v19;
      v6 = v19;
      v7 = v19;
      break;
  }
  v8 = OpenProcess(0x200u, 0, *(v18 + 68));
  if ( v8 )
  {
    v9 = v7;
    v10 = v8;
    if ( SetPriorityClass(v8, v9) )
    {
      if ( v6 == 40124 )
      {
        v21 = 0;
        NtSetInformationProcess(v10, 33, &v21, 4, v13);
        v20 = 1;
      }
      else
      {
        v21 = 2;
        NtSetInformationProcess(v10, 33, &v21, 4, v13);
        v20 = 5;
      }
      NtSetInformationProcess(v10, 39, &v20, 4, v14);
      *(v18 + 1368) = v5;
      v11 = GetMenu(ghMainWnd);
      CheckMenuRadioItem(v11, 0x9CBBu, 0x9CC1u, v6, 0);
      SendMessageW(ghWndTreeListView, 0x1015u, wParam, wParam);
      goto LABEL_21;
    }
  }
  else
  {
    v10 = 0;
  }
  MessageBoxW(ghWndTreeListView, L"Unable to set process priority", L"Process Explorer Error", 0x10u);
LABEL_21:
  if ( v10 )
    CloseHandle(v10);
  return 0;
}
// FD18A0: could not find valid save-restore pair for edi
// 106B1C8: using guessed type int (__stdcall *NtSetInformationProcess)(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD);

//----- (00FD1AD0) --------------------------------------------------------
int Options_AllowOneInstance()
{
  signed int v0; // eax
  bool v1; // zf
  UINT v2; // ST08_4
  HMENU v3; // eax

  v0 = 0;
  v1 = gConfig.bAllOneInstance != 0;
  gConfig.bAllOneInstance = gConfig.bAllOneInstance == 0;
  if ( !v1 )
    v0 = 8;
  v2 = v0;
  v3 = GetMenu(ghMainWnd);
  CheckMenuItem(v3, IDM_OPTIONS_ALLOW_ONLY_ONE_INSTANCE, v2);
  UpdateWindowPlacement(ghMainWnd, 1);
  return 0;
}

//----- (00FD1B20) --------------------------------------------------------
int __cdecl Command_Run(HWND hWndParent, int a2)
{
  HMODULE v2; // eax
  FARPROC v3; // eax

  v2 = LoadLibraryW(L"shell32.dll");
  v3 = GetProcAddress(v2, 0x3D);
  dword_106A8D8 = v3;
  if ( v3 )
    (v3)(hWndParent, 0, 0, 0, 0, 0);
  else
    DialogBoxParamW(ghInstance, L"RUNDLG", hWndParent, sub_FD7F60, a2);
  return 0;
}
// 106A8D8: using guessed type int dword_106A8D8;

//----- (00FD1B80) --------------------------------------------------------
int __cdecl Command_RunAs(HWND hWndParent, int a2)
{
  DialogBoxParamW(ghInstance, L"RUNDLG", hWndParent, sub_FD7F60, a2);
  return 0;
}

//----- (00FD1BB0) --------------------------------------------------------
int __cdecl Options_HideWhenMinimized(HWND hWnd)
{
  signed int v1; // eax
  bool v2; // zf
  UINT v3; // ST0C_4
  HMENU v4; // eax

  v1 = 0;
  v2 = gConfig.bHideWhenMinimized != 0;
  gConfig.bHideWhenMinimized = gConfig.bHideWhenMinimized == 0;
  if ( !v2 )
    v1 = 8;
  v3 = v1;
  v4 = GetMenu(hWnd);
  CheckMenuItem(v4, 0x9C75u, v3);
  if ( gConfig.bHideWhenMinimized
    && !gConfig.bTrayCPUHistory
    && !gConfig.bShowCommitTray
    && !gConfig.bShowPhysTray
    && !gConfig.bShowIoTray )
  {
    Command_ViewCpuHistory(hWnd);
  }
  UpdateWindowPlacement(ghMainWnd, 1);
  return 0;
}

//----- (00FD1C40) --------------------------------------------------------
int __cdecl OpacityOptions_Update(HWND hWnd, int a2)
{
  UINT v2; // ST08_4
  HMENU v3; // eax
  LONG v4; // eax
  UINT v5; // ST08_4
  HMENU v6; // eax

  v2 = (((1717986919i64 * gConfig.dwOpacity) >> 32) >> 2) + (((1717986919i64 * gConfig.dwOpacity) >> 32) >> 31) + 40093;
  v3 = GetMenu(hWnd);
  CheckMenuItem(v3, v2, 0);
  gConfig.dwOpacity = 10 * (a2 - 40093);
  v4 = GetWindowLongW(ghMainWnd, -20);
  if ( gConfig.dwOpacity == 100 )
  {
    SetWindowLongW(ghMainWnd, -20, v4 & 0xFFF7FFFF);
  }
  else
  {
    SetWindowLongW(ghMainWnd, -20, v4 | 0x80000);
    SetLayeredWindowAttributes(ghMainWnd, 0, (255 * gConfig.dwOpacity) / 100, 2u);
  }
  RedrawWindow(ghMainWnd, 0, 0, 0x485u);
  v5 = (((1717986919i64 * gConfig.dwOpacity) >> 32) >> 2) + (((1717986919i64 * gConfig.dwOpacity) >> 32) >> 31) + 40093;
  v6 = GetMenu(hWnd);
  CheckMenuItem(v6, v5, 8u);
  return 0;
}

//----- (00FD1D40) --------------------------------------------------------
int __cdecl UserAccount_Refresh(HWND a1, __int16 a2)
{
  char v2; // al
  char v4; // [esp+7h] [ebp-405h]
  WCHAR Text; // [esp+8h] [ebp-404h]
  wchar_t Dst; // [esp+208h] [ebp-204h]

  switch ( a2 )
  {
    case 0x9C84:
      wcscpy_s(&Dst, 0x100u, L"logoff");
      break;
    case 0x9C85:
      wcscpy_s(&Dst, 0x100u, L"shutdown");
      break;
    case 0x9C86:
      wcscpy_s(&Dst, 0x100u, L"restart");
      break;
    case 0x9C87:
      wcscpy_s(&Dst, 0x100u, L"hibernate");
      break;
    case 0x9C88:
      wcscpy_s(&Dst, 0x100u, L"stand by");
      break;
    case 0x9C92:
      wcscpy_s(&Dst, 0x100u, L"lock the computer");
      break;
    default:
      break;
  }
  wsprintf(&Text, L"Do you really want to %s?", &Dst);
  if ( MessageBoxW(ghWndTreeListView, &Text, L"Process Explorer Shutdown", 0x24u) != 7 )
  {
    UpdateWindowPlacement(ghMainWnd, 1);
    TmAdjustPrivilege(L"SeShutdownPrivilege");
    switch ( a2 )
    {
      case 0:
        v2 = ExitWindowsEx(0, 0);
        break;
      case 1:
        if ( ExitWindowsEx(8u, 0) )
          return 0;
        v2 = ExitWindowsEx(1u, 0);
        break;
      case 2:
        v2 = ExitWindowsEx(2u, 0);
        break;
      case 3:
        v2 = SetSuspendState(1u, 1u, 0);
        break;
      case 4:
        v2 = SetSuspendState(0, 1u, 0);
        break;
      case 0xE:
        v2 = LockWorkStation();
        break;
      default:
        v2 = v4;
        break;
    }
    if ( !v2 )
    {
      wsprintf(&Text, L"Error trying to %s", &Dst);
      ReportMsg(&Text, ghMainWnd);
    }
  }
  return 0;
}
// 1041C74: using guessed type wchar_t aShutdown[9];
// 1041C88: using guessed type wchar_t aRestart[8];
// 1041C98: using guessed type wchar_t aLogoff[7];
// 1041CA8: using guessed type wchar_t aHibernate[10];
// 1041CBC: using guessed type wchar_t aStandBy[9];

//----- (00FD1F10) --------------------------------------------------------
int __cdecl Command_ReplaceTaskManager(HWND hWnd)
{
  HKEY v1; // ecx
  UINT v2; // ST08_4
  HMENU v3; // eax

  if ( gdwVersion < 1 || IsBuiltinAdministrative() )
  {
    if ( CanReplaceTaskManager() )
      sub_FC5E40(v1);
    else
      ReplaceTaskManager(hWnd, 1);
  }
  else
  {
    sub_FC6180(L"/rt", 5, 1);
  }
  v2 = CanReplaceTaskManager() != 0 ? 8 : 0;
  v3 = GetMenu(hWnd);
  CheckMenuItem(v3, 0x9C7Bu, v2);
  return 0;
}
// 10416AC: using guessed type wchar_t aRt_0[4];
// 1064E54: using guessed type int gdwVersion;

//----- (00FD1F80) --------------------------------------------------------
int __cdecl Command_ConfigSymbols(HWND hWndParent)
{
  DialogBoxParamW(ghInstance, L"SYMBOLCONFIG", hWndParent, DlgSymbolConfig, 0);
  return 0;
}

//----- (00FD1FB0) --------------------------------------------------------
int Command_SystemInformation()
{
  HCURSOR v1; // eax
  HCURSOR v2; // esi

  if ( ghWndSysinfoPropSheet )
  {
    ShowWindow(ghWndSysinfoPropSheet, SW_RESTORE);
    SetFocus(ghWndSysinfoPropSheet);
    SetForegroundWindow(ghWndSysinfoPropSheet);
  }
  else
  {
    v1 = LoadCursorW(0, IDC_WAIT);
    v2 = SetCursor(v1);
    _beginthread(BackendSysInfoPropSheetThreadProc, 0, 0);
    WaitForSingleObject(ghSystemInfoSheetThreadEvent, 0xFFFFFFFF);
    SetCursor(v2);
  }
  return 0;
}

//----- (00FD2020) --------------------------------------------------------
int __cdecl Command_ConfirmToKillProcess(HWND hWnd)
{
  signed int v1; // eax
  bool v2; // zf
  UINT v3; // ST08_4
  HMENU v4; // eax

  v1 = 0;
  v2 = gConfig.bShowCpuFractions != 0;
  gConfig.bShowCpuFractions = gConfig.bShowCpuFractions == 0;
  if ( !v2 )
    v1 = 8;
  v3 = v1;
  v4 = GetMenu(hWnd);
  CheckMenuItem(v4, 0x9C6Du, v3);
  InvalidateRgn(ghWndTreeListView, 0, 1);
  return 0;
}

//----- (00FD2070) --------------------------------------------------------
int __cdecl Command_ConfigColors(HWND hWndParent)
{
  DialogBoxParamW(ghInstance, L"CHOOSECOLORS", hWndParent, DlgSelectColor, 0);
  return 0;
}

//----- (00FD20A0) --------------------------------------------------------
int Process_CleanMemory()
{
  HWND ghWndTreeListView; // esi
  int nCurItem; // eax
  HANDLE ProcessHandle; // eax
  void *v3; // esi
  LVITEMW Item; // [esp+4h] [ebp-34h]

  Item.mask = 0;
  memset(&Item.iItem, 0, 0x30u);
  ghWndTreeListView = ::ghWndTreeListView;
  nCurItem = SendMessageW(::ghWndTreeListView, 0x100Cu, 0xFFFFFFFF, 2);
  if ( nCurItem == -1 )
  {
    if ( ghWndTreeListView == ::ghWndTreeListView )
      MessageBoxW(::ghWndTreeListView, L"No process selected", L"Process Explorer Error", MB_ICONSTOP);
  }
  else
  {
    Item.iItem = nCurItem;
    Item.iSubItem = 0;
    Item.mask = LVIF_PARAM;
    if ( SendMessageW(ghWndTreeListView, LVM_GETITEMW, 0, &Item) )
    {
      ProcessHandle = OpenProcess(0x100u, 0, Item.lParam->dwProcessId);
      v3 = ProcessHandle;
      // If both dwMinimumWorkingSetSize and dwMaximumWorkingSetSize have the value (SIZE_T)–1, the function removes as many pages as possible from the working set of the specified process.
      if ( ProcessHandle && SetProcessWorkingSetSize(ProcessHandle, 0xFFFFFFFF, 0xFFFFFFFF) )
        SetEvent(ghRefreshEventHandle);
      else
        ReportMsg(L"Unable to trim process working set", ghMainWnd);
      if ( v3 )
      {
        CloseHandle(v3);
        return 0;
      }
    }
  }
  return 0;
}
// 10425B8: using guessed type wchar_t aUnableToTrimPr[35];

//----- (00FD2190) --------------------------------------------------------
int __cdecl WindowOptions_Refresh(HWND a1, int a2)
{
  HWND v2; // esi
  LRESULT v3; // eax
  tagTREEVIEWLISTITEMPARAM *v4; // esi
  LPARAM lParam; // [esp+4h] [ebp-34h]
  LRESULT v7; // [esp+8h] [ebp-30h]
  int v8; // [esp+Ch] [ebp-2Ch]
  tagTREEVIEWLISTITEMPARAM *pItem; // [esp+24h] [ebp-14h]

  lParam = 0;
  memset(&v7, 0, 0x30u);
  v2 = ghWndTreeListView;
  v3 = SendMessageW(ghWndTreeListView, 0x100Cu, 0xFFFFFFFF, 2);
  if ( v3 != -1 )
  {
    v7 = v3;
    v8 = 0;
    lParam = 4;
    if ( SendMessageW(v2, 0x104Bu, 0, &lParam) )
    {
      v4 = pItem;
      sub_FC6B90(0, a2, pItem->dwProcessId);
      RefreshMenuWithTreeViewItemStatus(v4);
    }
  }
  return 0;
}

//----- (00FD2210) --------------------------------------------------------
int Command_ShowColumnHeatmaps()
{
  signed int v0; // eax
  bool v1; // zf
  UINT v2; // ST08_4
  HMENU v3; // eax

  v0 = 0;
  v1 = gConfig.bShowColumnHeatmaps != 0;
  gConfig.bShowColumnHeatmaps = gConfig.bShowColumnHeatmaps == 0;
  if ( !v1 )
    v0 = 8;
  v2 = v0;
  v3 = GetMenu(ghMainWnd);
  CheckMenuItem(v3, 0x9C99u, v2);
  SetEvent(ghTimerRefreshEvent);
  return 0;
}

//----- (00FD2260) --------------------------------------------------------
int __cdecl Command_VerifyImage(HWND hWnd)
{
  signed int v1; // eax
  bool v2; // zf
  UINT v3; // ST24_4
  HMENU v4; // eax
  int v5; // edi
  tagTREEVIEWITEMPARAM *v6; // esi
  tagLVITEMW ItemInfo; // [esp+0h] [ebp-34h]

  ItemInfo.mask = 0;
  memset(&ItemInfo.iItem, 0, 0x30u);
  v1 = 0;
  v2 = gConfig.bVerifySignatures != 0;
  gConfig.bVerifySignatures = gConfig.bVerifySignatures == 0;
  if ( !v2 )
    v1 = 8;
  v3 = v1;
  v4 = GetMenu(hWnd);
  CheckMenuItem(v4, IDM_OPTIONS_VERIFY_IMAGE_SIGNATURE, v3);
  if ( !gConfig.bVerifySignatures )
    return 0;
  TreeView_InsertVerifyColumn(
    ghWndTreeListView,
    IDS_VERIFIED_SIGNER,
    gConfig.dwProcessColumnMap,
    &gConfig.dwProcessColumnCount);
  TreeView_InsertVerifyColumn(ghWndDllsListCtrl, IDS_VERIFIED_SIGNER, gConfig.dwDllColumnMap, &gConfig.dwDllColumnCount);
  v5 = SendMessageW(ghWndTreeListView, LVM_GETITEMCOUNT, 0, 0);
  ItemInfo.iItem = 0;
  if ( v5 <= 0 )
    return 0;
  do
  {
    ItemInfo.iSubItem = 0;
    ItemInfo.mask = LVIF_PARAM;
    if ( SendMessageW(ghWndTreeListView, LVM_GETITEMW, 0, &ItemInfo) )
    {
      v6 = ItemInfo.lParam;
      InterlockedIncrement(&ItemInfo.lParam->field_24);
      _beginthread(VerifyImageThreadProc, 0, v6);
    }
    ++ItemInfo.iItem;
  }
  while ( ItemInfo.iItem < v5 );
  return 0;
}

//----- (00FD2390) --------------------------------------------------------
int __cdecl Command_CheckVirusTotalDotCom(HWND hWnd)
{
  signed int v1; // eax
  UINT v2; // ST0C_4
  HMENU v3; // eax
  BOOL v4; // ST0C_4
  HMENU v5; // eax
  DLLLISTITEMPARAM *v6; // esi
  DLLLISTITEMPARAM *v7; // edi
  int v8; // eax
  DLLLISTITEMPARAM *i; // esi
  int v10; // eax

  if ( !SubmitExeToVirusTotalDotCom() )
    return 0;
  v1 = 0;
  gConfig.bCheckVirusTotal = gConfig.bCheckVirusTotal == 0;
  if ( gConfig.bCheckVirusTotal )
    v1 = 8;
  v2 = v1;
  v3 = GetMenu(hWnd);
  CheckMenuItem(v3, 0x9CB3u, v2);
  v4 = gConfig.bCheckVirusTotal == 0;
  v5 = GetMenu(hWnd);
  EnableMenuItem(v5, 0x9F36u, v4);
  if ( gConfig.bCheckVirusTotal )
  {
    v6 = gpTreeViewListItemParam;
    v7 = 0;
    TreeView_InsertVerifyColumn(ghWndTreeListView, 0x686u, gConfig.dwProcessColumnMap, &gConfig.dwProcessColumnCount);
    for ( ; v6; v6 = v6[3].field_118 )
    {
      v8 = v6[2].field_3C;
      if ( v6->field_44 == gdwProcessIdSelected )
        v7 = v6;
      if ( v8 && *(v8 + 4) == 1 )
        *(v8 + 4) = 6;
      if ( v6[2].field_8 )
        sub_1001C30(v6, 1, 0);
    }
    InvalidateRect(ghWndTreeListView, 0, 0);
    TreeView_InsertVerifyColumn(ghWndDllsListCtrl, 0x686u, gConfig.dwDllColumnMap, &gConfig.dwDllColumnCount);
    if ( v7 && IsWindowVisible(ghWndDllsListCtrl) )
    {
      for ( i = gpDllListItemParamHeader; i; i = i->m_Prev )
      {
        v10 = i->m_HashData;
        if ( v10 && *(v10 + 4) == 1 )
          *(v10 + 4) = 6;
        if ( i->m_strPath.pszData )
          sub_1001C30(i, ~(i->field_2C >> 1) & 1, 0);
      }
      InvalidateRect(ghWndDllsListCtrl, 0, 0);
    }
  }
  return 0;
}

//----- (00FD2520) --------------------------------------------------------
int __cdecl Command_SubmitUnkownExecutables(HWND hWnd)
{
  signed int v1; // eax
  bool v2; // zf
  UINT v3; // ST10_4
  HMENU v4; // eax
  DLLLISTITEMPARAM *v5; // esi
  DLLLISTITEMPARAM *v6; // edi
  int v7; // eax
  DLLLISTITEMPARAM *i; // esi
  int v9; // eax
  unsigned int v10; // eax

  if ( !SubmitExeToVirusTotalDotCom() )
    return 0;
  v1 = 0;
  v2 = gConfig.bVirusTotalSubmitUnknown != 0;
  gConfig.bVirusTotalSubmitUnknown = gConfig.bVirusTotalSubmitUnknown == 0;
  if ( !v2 )
    v1 = 8;
  v3 = v1;
  v4 = GetMenu(hWnd);
  CheckMenuItem(v4, 0x9F36u, v3);
  if ( !gConfig.bVirusTotalSubmitUnknown )
    return 0;
  v5 = gpTreeViewListItemParam;
  v6 = 0;
  if ( gpTreeViewListItemParam )
  {
    do
    {
      v7 = v5[2].field_3C;
      if ( v5->field_44 == gdwProcessIdSelected )
        v6 = v5;
      if ( v7 && *(v7 + 4) == 6 && *v7 )
        sub_1001C30(v5, 1, 1);
      v5 = v5[3].field_118;
    }
    while ( v5 );
  }
  InvalidateRect(ghWndTreeListView, 0, 0);
  if ( v6 && IsWindowVisible(ghWndDllsListCtrl) )
  {
    for ( i = gpDllListItemParamHeader; i; i = i->m_Prev )
    {
      v9 = i->m_HashData;
      if ( v9 && *(v9 + 4) == 6 )
      {
        v10 = i->field_2C >> 1;
        if ( !(v10 & 1) )
          sub_1001C30(i, ~v10 & 1, 1);
      }
    }
    InvalidateRect(ghWndDllsListCtrl, 0, 0);
  }
  return 0;
}

//----- (00FD2640) --------------------------------------------------------
int Command_CheckVirusTotalDotCom()
{
  HWND v0; // esi
  char v1; // bl
  LRESULT v2; // eax
  DLLLISTITEMPARAM *v3; // esi
  int v4; // eax
  LPARAM lParam; // [esp+8h] [ebp-34h]
  LRESULT v7; // [esp+Ch] [ebp-30h]
  int v8; // [esp+10h] [ebp-2Ch]
  DLLLISTITEMPARAM *pItemParam; // [esp+28h] [ebp-14h]

  lParam = 0;
  memset(&v7, 0, 0x30u);
  v0 = ghWndTreeListView;
  v1 = 0;
  v2 = SendMessageW(ghWndTreeListView, 0x100Cu, 0xFFFFFFFF, 2);
  if ( v2 != -1 )
  {
    v7 = v2;
    v8 = 0;
    lParam = 4;
    if ( SendMessageW(v0, 0x104Bu, 0, &lParam) )
    {
      v3 = pItemParam;
      SetFocus(ghWndTreeListView);
      if ( v3 )
      {
        if ( SubmitExeToVirusTotalDotCom() )
        {
          TreeView_InsertVerifyColumn(
            ghWndTreeListView,
            0x686u,
            gConfig.dwProcessColumnMap,
            &gConfig.dwProcessColumnCount);
          v4 = v3[2].field_3C;
          if ( v4 )
          {
            if ( *(v4 + 4) == 6 )
            {
              v1 = 1;
            }
            else if ( v4 && *(v4 + 4) == 1 )
            {
              *(v4 + 4) = 6;
            }
          }
          sub_1001C30(v3, 1, v1 != 0);
          InvalidateRect(ghWndTreeListView, 0, 0);
        }
      }
    }
  }
  return 0;
}

//----- (00FD2740) --------------------------------------------------------
int Command_Check_VirusTotalDotCom()
{
  HWND v0; // esi
  char v1; // bl
  LRESULT v2; // eax
  DLLLISTITEMPARAM *v3; // esi
  int v4; // eax
  LPARAM lParam; // [esp+8h] [ebp-34h]
  LRESULT v7; // [esp+Ch] [ebp-30h]
  int v8; // [esp+10h] [ebp-2Ch]
  DLLLISTITEMPARAM *pItemParam; // [esp+28h] [ebp-14h]

  lParam = 0;
  memset(&v7, 0, 0x30u);
  v0 = ghWndDllsListCtrl;
  v1 = 0;
  v2 = SendMessageW(ghWndDllsListCtrl, 0x100Cu, 0xFFFFFFFF, 2);
  if ( v2 != -1 )
  {
    v7 = v2;
    v8 = 0;
    lParam = 4;
    if ( SendMessageW(v0, 0x104Bu, 0, &lParam) )
    {
      v3 = pItemParam;
      SetFocus(ghWndTreeListView);
      if ( v3 )
      {
        if ( SubmitExeToVirusTotalDotCom() )
        {
          TreeView_InsertVerifyColumn(ghWndDllsListCtrl, 0x686u, gConfig.dwDllColumnMap, &gConfig.dwDllColumnCount);
          v4 = v3->m_HashData;
          if ( v4 )
          {
            if ( *(v4 + 4) == 6 )
            {
              v1 = 1;
            }
            else if ( v4 && *(v4 + 4) == 1 )
            {
              *(v4 + 4) = 6;
            }
          }
          sub_1001C30(v3, 1, v1 != 0);
          InvalidateRect(ghWndDllsListCtrl, 0, 0);
        }
      }
    }
  }
  return 0;
}

//----- (00FD2840) --------------------------------------------------------
int Command_ShowDetailsForAllProcesses()
{
  DWORD v0; // eax

  UpdateWindowPlacement(ghMainWnd, 1);
  CreateEventW(0, 0, 1, L"ProcessExplorerElevating");
  v0 = sub_FC6180(gszCmdLine, 5, 0);
  if ( v0 )
  {
    if ( v0 != 1223 )
    {
      ReportMsg(L"Error elevating", ghMainWnd);
      return 0;
    }
  }
  else
  {
    DestroyWindow(ghMainWnd);
  }
  return 0;
}
// 1041D84: using guessed type wchar_t aErrorElevating[16];
// 106A38C: using guessed type int gszCmdLine;

//----- (00FD28B0) --------------------------------------------------------
int __cdecl Command_SetTopmost(HWND hWnd)
{
  signed int v1; // eax
  UINT v2; // ST18_4
  HMENU v3; // eax

  v1 = 0;
  gConfig.bAlwaysOntop = gConfig.bAlwaysOntop == 0;
  if ( gConfig.bAlwaysOntop )
    v1 = 8;
  v2 = v1;
  v3 = GetMenu(hWnd);
  CheckMenuItem(v3, 0x9C82u, v2);
  if ( gConfig.bAlwaysOntop )
  {
    SetWindowPos(hWnd, HWND_MESSAGE|0x2, 0, 0, 0, 0, SWP_NOMOVE|SWP_NOSIZE);
    if ( ghWndSysinfoPropSheet )
    {
      SetWindowPos(ghWndSysinfoPropSheet, HWND_MESSAGE|0x2, 0, 0, 0, 0, SWP_NOMOVE|SWP_NOSIZE);
      return 0;
    }
  }
  else
  {
    if ( ghWndSysinfoPropSheet )
      SetWindowPos(ghWndSysinfoPropSheet, HWND_NOTOPMOST, 0, 0, 0, 0, SWP_NOMOVE|SWP_NOSIZE);
    SetWindowPos(hWnd, HWND_NOTOPMOST, 0, 0, 0, 0, SWP_NOMOVE|SWP_NOSIZE);
  }
  return 0;
}

//----- (00FD2960) --------------------------------------------------------
int __cdecl Command_ViewCpuHistory(HWND hWnd)
{
  signed int v1; // eax
  UINT v2; // ST08_4
  HMENU v3; // eax

  if ( !sub_FD79E0(gConfig.bTrayCPUHistory == 0) )
  {
    v1 = 0;
    gConfig.bTrayCPUHistory = gConfig.bTrayCPUHistory == 0;
    if ( gConfig.bTrayCPUHistory )
      v1 = 8;
    v2 = v1;
    v3 = GetMenu(hWnd);
    CheckMenuItem(v3, 0x9EC4u, v2);
    HandleTaskbarCreated();
  }
  return 0;
}

//----- (00FD29C0) --------------------------------------------------------
int __cdecl Command_ViewIoHistory(HWND hWnd)
{
  signed int v1; // eax
  UINT v2; // ST08_4
  HMENU v3; // eax

  if ( !sub_FD79E0(gConfig.bShowIoTray == 0) )
  {
    v1 = 0;
    gConfig.bShowIoTray = gConfig.bShowIoTray == 0;
    if ( gConfig.bShowIoTray )
      v1 = 8;
    v2 = v1;
    v3 = GetMenu(hWnd);
    CheckMenuItem(v3, 0x9F0Fu, v2);
    HandleTaskbarCreated();
  }
  return 0;
}

//----- (00FD2A20) --------------------------------------------------------
int __cdecl Command_CommitNetworkHistory(HWND hWnd)
{
  signed int v1; // eax
  UINT v2; // ST08_4
  HMENU v3; // eax

  if ( !sub_FD79E0(gConfig.bShowNetTray == 0) )
  {
    v1 = 0;
    gConfig.bShowNetTray = gConfig.bShowNetTray == 0;
    if ( gConfig.bShowNetTray )
      v1 = 8;
    v2 = v1;
    v3 = GetMenu(hWnd);
    CheckMenuItem(v3, 0x9F2Bu, v2);
    HandleTaskbarCreated();
  }
  return 0;
}

//----- (00FD2A80) --------------------------------------------------------
int __cdecl Command_CommitDiskHistory(HWND hWnd)
{
  signed int v1; // eax
  UINT v2; // ST08_4
  HMENU v3; // eax

  if ( !sub_FD79E0(gConfig.bShowDiskTray == 0) )
  {
    v1 = 0;
    gConfig.bShowDiskTray = gConfig.bShowDiskTray == 0;
    if ( gConfig.bShowDiskTray )
      v1 = 8;
    v2 = v1;
    v3 = GetMenu(hWnd);
    CheckMenuItem(v3, 0x9F2Au, v2);
    HandleTaskbarCreated();
  }
  return 0;
}

//----- (00FD2AE0) --------------------------------------------------------
int __cdecl Command_CommitGPUHistory(HWND hWnd)
{
  signed int v1; // eax
  UINT v2; // ST08_4
  HMENU v3; // eax

  if ( !sub_FD79E0(gConfig.bShowGpuHistory == 0) )
  {
    v1 = 0;
    gConfig.bShowGpuHistory = gConfig.bShowGpuHistory == 0;
    if ( gConfig.bShowGpuHistory )
      v1 = 8;
    v2 = v1;
    v3 = GetMenu(hWnd);
    CheckMenuItem(v3, 0x9F2Cu, v2);
    HandleTaskbarCreated();
  }
  return 0;
}

//----- (00FD2B40) --------------------------------------------------------
int __usercall Command_RunAtLogon@<eax>(_DWORD *a1@<edi>, HWND hWnd)
{
  bool v2; // al
  UINT v3; // ST08_4
  HMENU v4; // eax
  int savedregs; // [esp+0h] [ebp+0h]

  v2 = IsProcessExplorerRunAtStartup(&savedregs, a1);
  sub_FC37F0(v2 == 0);
  v3 = IsProcessExplorerRunAtStartup(&savedregs, a1) != 0 ? 8 : 0;
  v4 = GetMenu(hWnd);
  CheckMenuItem(v4, 0x9F30u, v3);
  return 0;
}

//----- (00FD2B90) --------------------------------------------------------
int __cdecl Command_ViewCommitHistory(HWND hWnd)
{
  signed int v1; // eax
  UINT v2; // ST08_4
  HMENU v3; // eax

  if ( !sub_FD79E0(gConfig.bShowCommitTray == 0) )
  {
    v1 = 0;
    gConfig.bShowCommitTray = gConfig.bShowCommitTray == 0;
    if ( gConfig.bShowCommitTray )
      v1 = 8;
    v2 = v1;
    v3 = GetMenu(hWnd);
    CheckMenuItem(v3, 0x9F16u, v2);
    HandleTaskbarCreated();
  }
  return 0;
}

//----- (00FD2BF0) --------------------------------------------------------
int __cdecl Command_ViewPhysicalMemoryHistory(HWND hWnd)
{
  signed int v1; // eax
  UINT v2; // ST08_4
  HMENU v3; // eax

  if ( !sub_FD79E0(gConfig.bShowPhysTray == 0) )
  {
    v1 = 0;
    gConfig.bShowPhysTray = gConfig.bShowPhysTray == 0;
    if ( gConfig.bShowPhysTray )
      v1 = 8;
    v2 = v1;
    v3 = GetMenu(hWnd);
    CheckMenuItem(v3, 0x9F17u, v2);
    HandleTaskbarCreated();
  }
  return 0;
}

//----- (00FD2C50) --------------------------------------------------------
signed int __usercall Command_SetColumn@<eax>(double a1@<st0>, double a2@<st1>, HWND hWnd, unsigned __int16 uID)
{
  __int32 index; // esi
  BOOL v6; // ST2C_4
  HMENU v7; // eax
  LRESULT v8; // eax
  char v9; // [esp+0h] [ebp-A0h]
  char v10; // [esp+8h] [ebp-98h]
  int pThis; // [esp+10h] [ebp-90h]
  __int128 v12; // [esp+14h] [ebp-8Ch]
  __int128 v13; // [esp+24h] [ebp-7Ch]
  __int64 v14; // [esp+34h] [ebp-6Ch]
  char v15; // [esp+3Ch] [ebp-64h]
  struct tagRECT Rect; // [esp+8Ch] [ebp-14h]

  index = uID - IDM_PROCESS_PRIORITY_BASE;
  pThis = 0;
  _mm_storeu_si128(&v12, 0i64);
  _mm_storeu_si128(&v13, 0i64);
  v14 = 0i64;
  if ( index >= gConfig.dwNumColumnsets )
    return 1;
  SendMessageW(ghWndTreeListView, WM_SETREDRAW, 0, 0);
  SendMessageW(ghWndHandlesListCtrl, WM_SETREDRAW, 0, 0);
  SendMessageW(ghWndDllsListCtrl, WM_SETREDRAW, 0, 0);
  qmemcpy(gConfig.szColumnSetName, &gConfig.strMenuCulumnSet[index], 0x5F4u);
  sub_FD7930(gConfig.szColumnSetName);
  CTreeView::InitListHeader(
    ghWndTreeListView,
    gConfig.dwProcessColumnMap,
    gConfig.dwProcessColumns,
    gConfig.dwProcessColumnCount);
  CTreeView::InitListHeader(
    ghWndHandlesListCtrl,
    gConfig.dwIdsOfHandleColumnMap,
    gConfig.dwHandleColumns,
    gConfig.dwHandleColumnCount);
  CTreeView::InitListHeader(ghWndDllsListCtrl, gConfig.dwDllColumnMap, gConfig.dwDllColumns, gConfig.dwDllColumnCount);
  GetClientRect(ghMainWnd, &Rect);
  CMainWnd::HandleSize(ghMainWnd, 0, 0, LOWORD(Rect.right) | (LOWORD(Rect.bottom) << 16));
  CTreeList::InitHeaderColumn(
    ghWndHandlesListCtrl,
    0xFFFFFFFF,
    gConfig.dwHandleSortColumn,
    gConfig.bHandleSortDirection);
  CTreeList::InitHeaderColumn(ghWndDllsListCtrl, 0xFFFFFFFF, gConfig.dwDllSortColumn, gConfig.bDllSortDirection);
  LODWORD(v12) = 101;
  pThis = ghWndTreeListView;
  if ( gConfig.bShowProcessTree )
  {
    gConfig.bShowProcessTree = 0;
    gConfig.bProcessSortDirection = 0;
    HIDWORD(v12) = 0;
  }
  else
  {
    gConfig.bProcessSortDirection = gConfig.bProcessSortDirection == 0;
    HIDWORD(v12) = gConfig.dwProcessSortColumn;
  }
  sub_FBD040(0x65u, &pThis);
  SendMessageW(ghWndToolbar, 0x401u, 0x9C67u, gConfig.bShowProcessTree == 0);
  v6 = gConfig.bShowProcessTree != 0;
  v7 = GetMenu(ghMainWnd);
  EnableMenuItem(v7, 0x9C67u, v6);
  memset(&v15, 0, 0x50u);
  sub_1000410(a1, a2, 0, &v15, &v9, &v10);
  CMainWnd::InitStatusBar(ghWndStatusBar);
  sub_FBFAA0(0x66);
  sub_FBFAA0(0x68);
  SendMessageW(ghWndTreeListView, 0xBu, 1u, 0);
  SendMessageW(ghWndHandlesListCtrl, 0xBu, 1u, 0);
  SendMessageW(ghWndDllsListCtrl, 0xBu, 1u, 0);
  v8 = SendMessageW(ghWndTreeListView, 0x100Cu, 0xFFFFFFFF, 2);
  SendMessageW(ghWndTreeListView, 0x1013u, v8, 0);
  return 0;
}

//----- (00FD2F00) --------------------------------------------------------
int sub_FD2F00()
{
  gConfig.bUseGoogle = 1;
  return 0;
}

//----- (00FD2F10) --------------------------------------------------------
int sub_FD2F10()
{
  gConfig.bUseGoogle = 0;
  return 0;
}

//----- (00FD2F20) --------------------------------------------------------
int __cdecl Command_LaunchDepends(HWND a1, __int16 a2)
{
  HWND v2; // edi
  const WCHAR *v3; // esi
  LRESULT v4; // eax
  struct _STARTUPINFOW StartupInfo; // [esp+8h] [ebp-8E8h]
  SHELLEXECUTEINFOW pExecInfo; // [esp+4Ch] [ebp-8A4h]
  LPARAM lParam; // [esp+88h] [ebp-868h]
  LRESULT v9; // [esp+8Ch] [ebp-864h]
  int v10; // [esp+90h] [ebp-860h]
  int v11; // [esp+A8h] [ebp-848h]
  struct _PROCESS_INFORMATION ProcessInformation; // [esp+BCh] [ebp-834h]
  WCHAR CommandLine; // [esp+CCh] [ebp-824h]

  lParam = 0;
  memset(&v9, 0, 0x30u);
  v2 = ghWndTreeListView;
  v3 = 0;
  if ( a2 == -25504 )
    v2 = ghWndDllsListCtrl;
  if ( v2 == ghWndHandlesListCtrl )
    v2 = ghWndTreeListView;
  v4 = SendMessageW(v2, 0x100Cu, 0xFFFFFFFF, 2);
  if ( v4 != -1 )
  {
    v9 = v4;
    v10 = 0;
    lParam = 4;
    if ( SendMessageW(v2, 0x104Bu, 0, &lParam) )
    {
      if ( v2 == ghWndDllsListCtrl )
      {
        if ( *(v11 + 44) & 8 )
        {
          MessageBoxW(
            ghWndTreeListView,
            L"Depends not supported on pagefile-backed sections",
            L"Process Explorer Error",
            0x10u);
          return 0;
        }
        v3 = *(v11 + 344);
        SetFocus(ghWndDllsListCtrl);
      }
      else
      {
        v3 = *(v11 + 792);
        if ( !v3 )
        {
          MessageBoxW(ghWndTreeListView, L"No process image file.", L"Process Explorer Error", 0x10u);
          return 0;
        }
        SetFocus(ghWndTreeListView);
      }
    }
  }
  if ( !*v3 )
  {
    MessageBoxW(ghWndTreeListView, L"No process or DLL is selected", L"Process Explorer Error", 0x10u);
    return 0;
  }
  if ( gstrApplicationName )
  {
    sub_FD68E0(&CommandLine, L"depends \"%s\"", v3);
    memset(&StartupInfo, 0, 0x44u);
    StartupInfo.dwFlags = 1;
    StartupInfo.cb = 68;
    StartupInfo.wShowWindow = 5;
    _mm_storeu_si128(&ProcessInformation, 0i64);
    if ( CreateProcessW(&gstrApplicationName, &CommandLine, 0, 0, 0, 0x200u, 0, 0, &StartupInfo, &ProcessInformation) )
    {
      CloseHandle(ProcessInformation.hThread);
      CloseHandle(ProcessInformation.hProcess);
      return 0;
    }
  }
  else
  {
    memset(&pExecInfo, 0, 0x3Cu);
    pExecInfo.cbSize = 60;
    pExecInfo.lpFile = v3;
    pExecInfo.lpVerb = L"View Dependencies";
    pExecInfo.fMask = 0;
    pExecInfo.nShow = 5;
    ShellExecuteExW(&pExecInfo);
  }
  return 0;
}
// 1041F14: using guessed type wchar_t aViewDependenci[18];

//----- (00FD31A0) --------------------------------------------------------
int Command_DebugProcess()
{
  HWND v0; // edi
  int v1; // esi
  LRESULT v2; // eax
  struct _STARTUPINFOW StartupInfo; // [esp+8h] [ebp-49Ch]
  LPARAM lParam; // [esp+4Ch] [ebp-458h]
  LRESULT v6; // [esp+50h] [ebp-454h]
  int v7; // [esp+54h] [ebp-450h]
  int v8; // [esp+6Ch] [ebp-438h]
  struct _PROCESS_INFORMATION ProcessInformation; // [esp+80h] [ebp-424h]
  WCHAR CommandLine; // [esp+90h] [ebp-414h]

  lParam = 0;
  memset(&v6, 0, 0x30u);
  v0 = ghWndTreeListView;
  v1 = 0;
  v2 = SendMessageW(ghWndTreeListView, 0x100Cu, 0xFFFFFFFF, 2);
  if ( v2 != -1
    && (v6 = v2, v7 = 0, lParam = 4, SendMessageW(v0, 0x104Bu, 0, &lParam))
    && (v1 = v8, SetFocus(ghWndTreeListView), v1) )
  {
    if ( MessageBoxW(
           ghWndTreeListView,
           L"WARNING: Debugging this process may result in loss of data.\nAre you sure you wish to attach the debugger?",
           L"Process Explorer Warning",
           0x31u) == 2 )
      return 0;
  }
  else
  {
    MessageBoxW(ghWndTreeListView, L"No process is selected", L"Process Explorer Error", 0x10u);
  }
  MakeHandlePropSheetCaption(&CommandLine, L"\"%s\" -p %d", gszAeDebuggerPath, *(v1 + 68));
  memset(&StartupInfo, 0, 0x44u);
  StartupInfo.dwFlags = 1;
  StartupInfo.cb = 68;
  StartupInfo.wShowWindow = 5;
  _mm_storeu_si128(&ProcessInformation, 0i64);
  if ( CreateProcessW(0, &CommandLine, 0, 0, 0, 0x200u, 0, 0, &StartupInfo, &ProcessInformation) )
  {
    CloseHandle(ProcessInformation.hThread);
    CloseHandle(ProcessInformation.hProcess);
  }
  return 0;
}

//----- (00FD3330) --------------------------------------------------------
int __cdecl Command_ShowProcessesForAllUsers(HWND hWnd)
{
  signed int v1; // eax
  bool v2; // zf
  UINT v3; // ST0C_4
  HMENU v4; // eax
  tagTREEVIEWLISTITEMPARAM *i; // eax
  int v6; // ecx
  LRESULT v7; // ebx
  void *v8; // edi
  int v9; // esi
  LRESULT k; // edi
  int v11; // esi
  int v12; // eax
  LPARAM lParam; // [esp+Ch] [ebp-38h]
  int v15; // [esp+10h] [ebp-34h]
  int v16; // [esp+14h] [ebp-30h]
  int v17; // [esp+2Ch] [ebp-18h]
  void *j; // [esp+40h] [ebp-4h]

  SendMessageW(ghWndTreeListView, 0xBu, 0, 0);
  v1 = 0;
  v2 = gConfig.bShowAllUsers != 0;
  gConfig.bShowAllUsers = gConfig.bShowAllUsers == 0;
  if ( !v2 )
    v1 = 8;
  v3 = v1;
  v4 = GetMenu(hWnd);
  CheckMenuItem(v4, 0x9C77u, v3);
  for ( i = gpTreeViewListItemParam; i; i = i->m_Prev )
  {
    if ( gConfig.bShowAllUsers || (v6 = i->dwStyle, v6 & 0x40) )
      i->dwStyle |= 2u;
    else
      i->dwStyle = v6 & 0xFFFFFFFD;
  }
  v7 = SendMessageW(ghWndTreeListView, 0x1004u, 0, 0);
  v8 = operator new[](4 * v7);
  v9 = 0;
  for ( j = v8; v9 < v7; ++v9 )
  {
    v15 = v9;
    v16 = 0;
    lParam = 4;
    SendMessageW(ghWndTreeListView, 0x104Bu, 0, &lParam);
    *(v8 + v9) = v17;
  }
  SendMessageW(ghWndTreeListView, 0x1009u, 0, 0);
  for ( k = 0; k < v7; *(v11 + 1464) = v12 )
  {
    v11 = *(j + k);
    v12 = sub_FB7F20(ghWndTreeListView, *(j + k++));
  }
  j_j__free(j);
  byte_10653B5 = 1;
  SetEvent(ghTimerRefreshEvent);
  return 0;
}
// 10653B5: using guessed type char byte_10653B5;

//----- (00FD3490) --------------------------------------------------------
int __cdecl Command_SaveColumnSet(HWND hWndParent)
{
  DialogBoxParamW(ghInstance, L"COLUMNSETSAVE", hWndParent, DlgColumnSetSave, 0);
  return 0;
}

//----- (00FD34C0) --------------------------------------------------------
int __cdecl Command_OrganizeColumnSets(HWND hWnd)
{
  if ( gConfig.dwNumColumnsets )
    DialogBoxParamW(ghInstance, L"COLUMNSETS", hWnd, DlgColumnSets, 0);
  else
    MessageBoxW(
      hWnd,
      L"There are no column sets defined. Use View->Save Column Set to save a column set.",
      L"Process Explorer",
      0x30u);
  return 0;
}

//----- (00FD3510) --------------------------------------------------------
LRESULT __cdecl CMainWnd::HandleCommand(HWND hWnd, int a2, WPARAM wParam, LPARAM lParam)
{
  return HandleCmdHandler(&CMainWnd::gCmdHandler, hWnd, wParam, lParam);
}
// 105E11C: using guessed type struct tagMSGHANDLER CMainWnd::gCmdHandler;

//----- (00FD3530) --------------------------------------------------------
int __cdecl CMainWnd::HandlePaint(HWND hWnd)
{
  HDC v1; // eax
  struct tagPAINTSTRUCT Paint; // [esp+4h] [ebp-44h]

  v1 = BeginPaint(hWnd, &Paint);
  if ( gConfig.bShowLowerPane )
    DrawEdge(v1, &gRectPane, 5u, 0x80Au);
  EndPaint(hWnd, &Paint);
  return 0;
}

//----- (00FD3590) --------------------------------------------------------
int __cdecl CMainWnd::HandleSize(HWND hWnd, UINT msg, WPARAM wParam, LPARAM lParam)
{
  int nHeight; // edi
  HWND hWndRebar; // eax
  LONG top; // ebx
  int v8; // ST14_4
  int v9; // ST10_4
  HWND v10; // eax
  struct tagRECT rcStatusBar; // [esp+Ch] [ebp-24h]
  struct tagRECT rcReBar; // [esp+1Ch] [ebp-14h]

  if ( wParam == 1 )
  {
    if ( gConfig.bHideWhenMinimized )
    {
      CMainWnd::Hide(ghMainWnd);
      return 0;
    }
  }
  else
  {
    GetWindowRect(ghWndStatusBar, &rcStatusBar);
    nHeight = rcStatusBar.bottom - rcStatusBar.top;
    hWndRebar = GetParent(ghWndCPUGraph);
    GetWindowRect(hWndRebar, &rcReBar);
    GetClientRect(hWnd, &gRectWindow);
    top = (lParam >> 16) - (rcReBar.bottom - rcReBar.top + gRectWindow.top);
    gRectWindow.top += rcReBar.bottom - rcReBar.top;
    gRectWindow.right = lParam;
    gRectWindow.bottom = top;
    InvalidateRect(hWnd, &gRectPane, 0);
    gRectPane.right = lParam;
    gRectPane.top = ((gRectWindow.top + gRectWindow.bottom - nHeight) * gConfig.dbDivider);
    gRectPane.bottom = gRectPane.top + 7;
    MoveWindow(ghWndTreeListView, 0, gRectWindow.top, lParam, gRectPane.top - gRectWindow.top, 1);
    MoveWindow(
      ghWndHandlesListCtrl,
      0,
      gRectPane.bottom - 1,
      lParam,
      gRectWindow.bottom - gRectPane.bottom - nHeight + gRectWindow.top + 1,
      TRUE);
    MoveWindow(
      ghWndDllsListCtrl,
      0,
      gRectPane.bottom - 1,
      lParam,
      gRectWindow.bottom - gRectPane.bottom - nHeight + gRectWindow.top + 1,
      TRUE);
    MoveWindow(ghWndStatusBar, 0, gRectWindow.top + gRectWindow.bottom - nHeight, lParam, nHeight, 1);
    v8 = gnToolbarHeight;
    v9 = gRectWindow.right;
    v10 = GetDlgItem(hWnd, IDC_MAINTOOLBAR);
    MoveWindow(v10, 0, 0, v9, v8, TRUE);
    InvalidateRgn(ghWndStatusBar, 0, FALSE);
    MoveWindow(ghWndReBar, 0, 0, gRectWindow.right - gRectWindow.left, 0, TRUE);
  }
  return 0;
}

//----- (00FD3780) --------------------------------------------------------
int __cdecl CMainWnd::HandleGetMinmaxInfo(HWND a1, unsigned int a2, unsigned int a3, MINMAXINFO *a4)
{
  a4->ptMinTrackSize.x = 200;
  a4->ptMinTrackSize.y = 200;
  return 0;
}

//----- (00FD37A0) --------------------------------------------------------
int __cdecl CMainWnd::HandleLBtnDown(HWND hWnd, int a2, int a3, int a4)
{
  POINT v4; // ST04_8

  v4.y = a4 >> 16;
  v4.x = a4;
  if ( PtInRect(&gRectPane, v4) )
  {
    SetCursor(ghResizeCursor);
    SetCapture(hWnd);
    DrawLine(hWnd, (a4 >> 16) - 6);
    gyMouseDown = (a4 >> 16) - 6;
  }
  return 0;
}

//----- (00FD37F0) --------------------------------------------------------
int __cdecl CMainWnd::HandleLBtnUp(HWND hWnd, UINT msg, WPARAM wParam, LPARAM lParam)
{
  signed int v4; // esi
  struct tagRECT Rect; // [esp+Ch] [ebp-14h]

  v4 = lParam >> 16;
  if ( gbWindowFinding )
  {
    SearchWindow(hWnd);
    return 0;
  }
  if ( GetCapture() )
  {
    SetCursor(ghResizeCursor);
    ReleaseCapture();
    DrawLine(hWnd, gyMouseDown);
    if ( v4 > gRectWindow.bottom - 30 )
      return Command_ShowLowerPane(hWnd);
    if ( v4 < gRectWindow.top + 40 )
      LOWORD(v4) = LOWORD(gRectWindow.top) + 40;
    gRectPane.top = v4 - 3;
    gRectPane.bottom = gRectPane.top + 7;
    gConfig.dbDivider = (v4 - 3) / (gRectWindow.top + gRectWindow.bottom);
    GetClientRect(ghMainWnd, &Rect);
    CMainWnd::HandleSize(
      ghMainWnd,
      0,
      0,
      (LOWORD(Rect.right) - LOWORD(Rect.left)) | ((LOWORD(Rect.bottom) - LOWORD(Rect.top)) << 16));
    InvalidateRect(hWnd, &gRectPane, 0);
  }
  return 0;
}
// 106A38B: using guessed type char gbWindowFinding;

//----- (00FD3940) --------------------------------------------------------
int __cdecl CMainWnd::HandleMouseMove(HWND hWnd, UINT msg, WPARAM wParam, LPARAM lParam)
{
  signed int y; // esi
  HWND hWndTemp; // edi
  HWND hWndParent; // eax
  HCURSOR v7; // eax
  int result; // eax
  HCURSOR v9; // eax
  int v10; // esi
  POINT v11; // ST08_8
  struct tagPOINT Point; // [esp+8h] [ebp-8h]

  y = lParam >> 16;
  if ( gbWindowFinding )
  {
    Point.x = lParam;
    Point.y = SHIWORD(lParam);
    ClientToScreen(hWnd, &Point);
    hWndTemp = WindowFromPoint(Point);
    if ( hWndTemp != ghWndHungWindow )
    {
      if ( ghWndHungWindow )
        DrawHungWindow(ghWndHungWindow);
      hWndParent = hWndTemp;
      while ( hWndParent != ghMainWnd )
      {
        hWndParent = GetParent(hWndParent);
        if ( !hWndParent )
        {
          if ( ghMainWnd )
          {
            ghWndHungWindow = hWndTemp;
            DrawHungWindow(hWndTemp);
            v7 = LoadCursorW(ghInstance, 10);
            SetCursor(v7);
            return 0;
          }
          break;
        }
      }
      ghWndHungWindow = 0;
    }
    v9 = LoadCursorW(ghInstance, 0xA);
    SetCursor(v9);
    result = 0;
  }
  else if ( GetCapture() )
  {
    if ( y > gRectWindow.bottom - 5 )
      LOWORD(y) = LOWORD(gRectWindow.bottom) - 5;
    if ( y < gRectWindow.top + 40 )
      LOWORD(y) = LOWORD(gRectWindow.top) + 40;
    DrawLine(hWnd, gyMouseDown);
    v10 = (y - 3);
    DrawLine(hWnd, v10);
    gyMouseDown = v10;
    result = 0;
  }
  else
  {
    v11.y = lParam >> 16;
    v11.x = lParam;
    if ( PtInRect(&gRectPane, v11) )
      SetCursor(ghResizeCursor);
    result = 0;
  }
  return result;
}
// 106A38B: using guessed type char gbWindowFinding;

//----- (00FD3AA0) --------------------------------------------------------
BOOL __cdecl CMainWnd::HandleMeasureItem(HWND a1, unsigned int a2, unsigned int a3, LPMEASUREITEMSTRUCT lpmis)
{
  HDC hDC; // ebx
  BOOL result; // eax
  int v6; // edi
  struct tagTEXTMETRICW tm; // [esp+8h] [ebp-40h]

  if ( lpmis->CtlType == IDC_LISTCTRL_HANDLES || lpmis->CtlID == IDC_TREEVIEW_LIST )
  {
    hDC = GetDC(ghWndTreeListView);
    SelectObject(hDC, ghConfigFont);
    result = GetTextMetricsW(hDC, &tm);
    if ( !result )
      return result;
    if ( lpmis->CtlID == IDC_TREEVIEW_LIST )
    {
      v6 = tm.tmHeight + 2;
      if ( v6 <= GetSystemMetrics(SM_CYSMICON) )
        v6 = GetSystemMetrics(SM_CYSMICON);
      lpmis->itemHeight = v6;
    }
    else
    {
      lpmis->itemHeight = tm.tmHeight + 2;
    }
    ReleaseDC(ghWndTreeListView, hDC);
  }
  else if ( lpmis->CtlType == ODT_MENU )
  {
    lpmis->itemWidth = 16;
    lpmis->itemHeight = 16;
  }
  return 1;
}

//----- (00FD3B70) --------------------------------------------------------
int __cdecl CMainWnd::HandleNotify(HWND hWnd, UINT msg, WPARAM wParam, NMHDR *lParam)
{
  UINT code; // eax
  int v5; // eax
  struct tagPOINT Point; // [esp+4h] [ebp-1Ch]
  struct tagRECT Rect; // [esp+Ch] [ebp-14h]

  code = lParam->code;
  if ( code > LVN_GETDISPINFOW )
  {
    switch ( code )
    {
      case 4294967121u:
        // LVN_DELETEITEM
        return 1;
      case 4294967141u:
        return sub_FBF490(wParam, lParam);
      case 4294967188u:
        return sub_FBD040(wParam, lParam);
      case 4294967193u:
        return sub_FBD4B0(wParam, lParam);
      case 4294967195u:
        return sub_FBF4D0(wParam);
      case 4294967274u:
        if ( wParam == 103 )
          GetButtonSize();
        return 0;
      case 4294967291u:
        GetCursorPos(&Point);
        return UpdateListViewContextMenu(wParam, lParam, &Point);
      case 4294967293u:
        return FillList(wParam);
      case 4294967294u:
        return sub_FBCDD0(wParam, lParam);
      default:
        return 0;
    }
  }
  else
  {
    if ( code == LVN_GETDISPINFOW )
      return sub_FBD7B0(wParam, lParam);
    if ( code > 0xFFFFFCC1 )
    {
      switch ( code )
      {
        case 0xFFFFFD43:
          if ( lParam[1].hwndFrom == 40109 )
          {
            SearchWindow(hWnd);
            return 0;
          }
          break;
        case 0xFFFFFDEE:
          return sub_FFFA90(wParam, lParam);
        case 0xFFFFFF4D:
          return sub_FBD7A0(wParam);
      }
    }
    else
    {
      if ( code == 0xFFFFFCC1 )
      {
        GetClientRect(ghMainWnd, &Rect);
        CMainWnd::HandleSize(
          ghMainWnd,
          0,
          0,
          (LOWORD(Rect.right) - LOWORD(Rect.left)) | ((LOWORD(Rect.bottom) - LOWORD(Rect.top)) << 16));
        InvalidateRect(ghWndTreeListView, 0, 0);
        return 0;
      }
      if ( code > 0x7D4 )
      {
        if ( code == 2005 )
          return sub_FC1C50(wParam, lParam);
        if ( code == -839 )
        {
          InvalidateRect(lParam->hwndFrom, 0, 0);
          return 0;
        }
      }
      else
      {
        if ( code == 2004 )
          return sub_FC1B70(wParam, &lParam->hwndFrom);
        v5 = code - 2001;
        if ( !v5 )
          return sub_101F550();
        if ( v5 == 1 )
          return CAboutWnd::HandleInitDialog();
      }
    }
  }
  return 0;
}

//----- (00FD3F40) --------------------------------------------------------
int __cdecl CMainWnd::HandleCreate(HWND hWnd)
{
  HMODULE v1; // eax
  bool v2; // al
  HMENU hMainMenuHandle; // edi
  HCURSOR v4; // eax
  HGDIOBJ v5; // eax
  int dwMenuItemPosLast; // ST20_4
  HMENU hMainMenu; // eax
  HMENU hSubMenuView_1; // eax
  HMENU v9; // eax
  signed int i; // esi
  int nIdIndex; // eax
  int v12; // ST1C_4
  HMENU hMainMenu_1; // eax
  HMENU hSubMenuView; // eax
  HMENU v15; // eax
  HMENU v16; // eax
  HMENU hFileSubMenu; // eax
  HMENU hSubMenuFile; // eax
  HMENU hSubMenuFile_1; // eax
  HMENU (__stdcall *GetMenu)(HWND); // esi
  HMENU hMainMenu_2; // eax
  HMENU hOpacityPopupMenuHandle; // eax
  UINT v23; // eax
  UINT v24; // eax
  MACRO_MF v25; // eax
  UINT v26; // ST28_4
  HMENU v27; // eax
  MACRO_MF v28; // eax
  UINT v29; // ST28_4
  HMENU v30; // eax
  MACRO_MF v31; // eax
  UINT v32; // ST28_4
  HMENU v33; // eax
  MACRO_MF v34; // eax
  UINT v35; // ST28_4
  HMENU v36; // eax
  UINT v37; // eax
  UINT v38; // eax
  UINT v39; // eax
  UINT v40; // eax
  UINT v41; // eax
  UINT v42; // eax
  MACRO_MF v43; // eax
  UINT v44; // ST28_4
  HMENU v45; // eax
  float v46; // xmm0_4
  double v47; // xmm0_8
  float v48; // xmm0_4
  double v49; // xmm0_8
  UINT v50; // ST28_4
  HMENU v51; // eax
  UINT v52; // ST28_4
  HMENU v53; // eax
  UINT v54; // eax
  DWORD dwProcessId; // ST04_4
  HANDLE hProcessHandle; // eax
  const WCHAR **psz_1; // eax
  unsigned int nLength; // kr00_4
  HMENU hProcessMenu; // eax
  int NumberOfProcessors; // eax
  int index; // esi
  CGraphData *v62; // ecx
  CGraphData *v63; // edx
  HMODULE v64; // eax
  HMODULE v65; // eax
  HMODULE v66; // eax
  HMODULE v67; // eax
  HMODULE v68; // eax
  HMODULE v69; // eax
  HMENU v70; // eax
  UINT v71; // ecx
  signed int v72; // eax
  UINT v73; // ST28_4
  HMENU v74; // eax
  void (__stdcall *RegCloseKey)(HKEY); // esi
  DWORD dwRet; // eax
  DWORD dwSize; // esi
  int dwSize_1; // ST24_4
  wchar_t *pszPath_1; // esi
  wchar_t *psz; // eax
  HWND hWnd_2; // esi
  HINSTANCE hInst; // ST1C_4
  HWND hWndTreeListView; // eax
  CTreeList *pTreeList; // eax
  CTreeList *pTreeList_1; // esi
  HCURSOR v87; // eax
  HWND v88; // eax
  HWND v89; // eax
  HWND v90; // eax
  int dwProcessColumnCount; // eax
  __int16 wProcessImageColumnWidth; // ax
  int v93; // ST18_4
  int v94; // eax
  HIMAGELIST hImgList; // eax
  CTreeList *pTreeList_2; // esi
  HICON v97; // ST28_4
  struct _IMAGELIST *v98; // eax
  struct _IMAGELIST *v99; // eax
  HWND v100; // esi
  HWND v101; // ecx
  HWND v102; // ecx
  signed int v103; // eax
  UINT v104; // ST28_4
  HMENU v105; // eax
  HMENU v106; // eax
  HMENU v107; // eax
  LPARAM nBmpIndex; // eax
  BOOL v109; // ST28_4
  HMENU v110; // eax
  HMENU v111; // eax
  double v112; // xmm0_8
  signed int v113; // eax
  UINT v114; // ST28_4
  HMENU v115; // eax
  signed int v116; // eax
  UINT v117; // ST28_4
  HMENU v118; // eax
  HWND v119; // ebx
  signed int v120; // eax
  UINT v121; // ST28_4
  HMENU v122; // eax
  HMENU hMenuMain; // eax
  HMENU hMenuMain_1; // eax
  HMODULE v125; // eax
  HMODULE v126; // eax
  int (__stdcall *v127)(HWND, RECT *, DWORD, DWORD); // eax
  signed int dwOpacity; // ecx
  LONG v129; // eax
  UINT uId; // ST24_4
  HMENU v131; // eax
  UINT v132; // [esp-8h] [ebp-CE4h]
  const WCHAR *v133; // [esp-4h] [ebp-CE0h]
  tagLVITEMW lvItem; // [esp+Ch] [ebp-CD0h]
  tagLVITEMW Item; // [esp+40h] [ebp-C9Ch]
  DWORD Type; // [esp+74h] [ebp-C68h]
  __int64 dwNbSegments; // [esp+78h] [ebp-C64h]
  __int64 dwMinSegments; // [esp+80h] [ebp-C5Ch]
  int pSessionInfo; // [esp+88h] [ebp-C54h]
  int nSessionCount; // [esp+8Ch] [ebp-C50h]
  HCURSOR hCursor_____; // [esp+90h] [ebp-C4Ch]
  wchar_t *pszPath; // [esp+94h] [ebp-C48h]
  HKEY hSubKey; // [esp+98h] [ebp-C44h]
  size_t cbData; // [esp+9Ch] [ebp-C40h]
  HWND hWnd_1; // [esp+A0h] [ebp-C3Ch]
  struct WSAData WSAData; // [esp+A4h] [ebp-C38h]
  tagLOGFONTW LogFont; // [esp+234h] [ebp-AA8h]
  RECT rcTreeList; // [esp+290h] [ebp-A4Ch]
  struct tagRECT rcToolbar; // [esp+2A0h] [ebp-A3Ch]
  wchar_t szUserName[260]; // [esp+2B0h] [ebp-A2Ch]
  wchar_t szMenuItemName[260]; // [esp+4B8h] [ebp-824h]
  __int16 szDomainName[260]; // [esp+6C0h] [ebp-61Ch]
  WCHAR szMainName[260]; // [esp+8C8h] [ebp-414h]
  WCHAR szPathName[260]; // [esp+AD0h] [ebp-20Ch]
  int savedregs; // [esp+CDCh] [ebp+0h]

  hWnd_1 = hWnd;
  _mm_storeu_si128(&rcToolbar, 0i64);
  lvItem.mask = 0;
  memset(&lvItem.iItem, 0, 0x30u);
  CoInitialize(0);
  WSAStartup(0x101u, &WSAData);
  GetLocaleInfoW(LOCALE_USER_DEFAULT, 0xEu, &gszLocaleInfo, 16);
  InitializeCriticalSection(&gSysInfoPropSheetLock);
  InitializeCriticalSection(&gLock2);
  InitializeCriticalSection(&gLock3);
  InitializeCriticalSection(&gProcThreadsLock);
  LoadHiddenProcessesFromRegistry();
  LoadProcessCommentsFromRegistry();
  v1 = LoadLibraryW(L"Advapi32.dll");
  gpfnCreateRestrictedToken = GetProcAddress(v1, "CreateRestrictedToken");
  gbWintrustInited = LoadWintrust();
  v2 = GetProcessDEPStatus();
  ghMainWnd = hWnd;
  gbIsProcessDEPEnabled = v2;
  hMainMenuHandle = ::GetMenu(hWnd);
  v4 = LoadCursorW(0, IDC_WAIT);
  hCursor_____ = SetCursor(v4);
  ghArrowCursor = LoadCursorW(0, IDC_ARROW);
  ghFindCursor = LoadCursorW(ghInstance, 10);
  EnableMenuItem(hMainMenuHandle, IDM_VIEW_SHOW_HIDDEN_PROCESSES, *gpHiddenProcesses == 0);
  v5 = GetStockObject(DEFAULT_GUI_FONT);
  GetObjectW(v5, sizeof(LOGFONTW), &LogFont);
  LogFont.lfUnderline = 1;
  ghDefaultUnderlineFontHandle = CreateFontIndirectW(&LogFont);
  gdwComdlg_FindReplaceMessageID = RegisterWindowMessageW(L"commdlg_FindReplace");
  DeleteMenu(hMainMenuHandle, IDM_VIEW_LOADCOLUMNSET_TEST, 0);
  dwMenuItemPosLast = gdwMenuItemPosLast;
  hMainMenu = ::GetMenu(ghMainWnd);
  hSubMenuView_1 = GetSubMenu(hMainMenu, 2);
  v9 = GetSubMenu(hSubMenuView_1, dwMenuItemPosLast);
  DeleteMenu(v9, 0, MF_BYPOSITION);
  for ( i = 0; i < gConfig.dwNumColumnsets; ++i )
  {
    if ( i >= 10 )
    {
      wcscpy_s(szMenuItemName, MAX_PATH, gConfig.strMenuCulumnSet[i].ColumnSetName);
    }
    else
    {
      if ( i == 9 )
        nIdIndex = 0;
      else
        nIdIndex = i + 1;
      swprintf(szMenuItemName, L"%s\tCtrl+%i", &gConfig.strMenuCulumnSet[i], nIdIndex);
    }
    v12 = gdwMenuItemPosLast;
    hMainMenu_1 = ::GetMenu(ghMainWnd);
    hSubMenuView = GetSubMenu(hMainMenu_1, 2);
    v15 = GetSubMenu(hSubMenuView, v12);
    AppendMenuW(v15, 0, i + IDM_PROCESS_PRIORITY_BASE, szMenuItemName);
  }
  ghPriorityPopMenuHandle = LoadMenuW(ghInstance, L"PRIORITY");
  if ( gpfnCreateRestrictedToken )
  {
    v16 = GetSubMenu(hMainMenuHandle, 0);
    InsertMenuW(v16, 1u, MF_BYPOSITION, IDM_RUN_AS_LIMITED_USER, L"Run as &Limited User...");
    ++gdwMenuItemCountAppendedInRuntime;
  }
  if ( gdwVersion < 1 )
  {
    v133 = L"R&unas...";
    goto LABEL_15;
  }
  if ( !IsBuiltinAdministrative() )
  {
    v133 = L"R&un as Administrator...";
LABEL_15:
    hFileSubMenu = GetSubMenu(hMainMenuHandle, 0);
    InsertMenuW(hFileSubMenu, 1u, MF_BYPOSITION, IDM_RUN_AS, v133);
    ++gdwMenuItemCountAppendedInRuntime;
  }
  InsertMenuW(hMainMenuHandle, IDM_PRIORITY_NORMAL, 0, IDM_PROCESS_SETPRIORITY_ABOVE_NORMAL_TEN, L"&Above Normal: 10");
  InsertMenuW(
    ghPriorityPopMenuHandle,
    IDM_PROCESS_SETPRIORITY_NORMAL,
    0,
    IDM_PROCESS_SETPRIORITY_ABOVE_NORMAL_TEN,
    L"&Above Normal: 10");
  InsertMenuW(
    hMainMenuHandle,
    IDM_PROCESS_SETPRIORITY_IDLE,
    0,
    IDM_PROCESS_SETPRIORITY_BELOW_NORMAL_SIX,
    L"&Below Normal: 6");
  InsertMenuW(
    ghPriorityPopMenuHandle,
    IDM_PROCESS_SETPRIORITY_IDLE,
    0,
    IDM_PROCESS_SETPRIORITY_BELOW_NORMAL_SIX,
    L"&Below Normal: 6");
  if ( gdwVersion < WINDOWS_VISTA
    || (InsertMenuW(
          hMainMenuHandle,
          IDM_PRIORITY_IDLE,
          0,
          IDM_PROCESS_SETPRIORITY_BACKGROUND_FOUR,
          L"Back&ground: 4 (Low I/O and Memory Priority)"),
        InsertMenuW(
          ghPriorityPopMenuHandle,
          IDM_PRIORITY_IDLE,
          0,
          IDM_PROCESS_SETPRIORITY_BACKGROUND_FOUR,
          L"Back&ground: 4 (Low I/O and Memory Priority)"),
        gdwVersion < WINDOWS_VISTA)
    || IsBuiltinAdministrative() )
  {
    if ( ChangeWindowMessageFilter )
      ChangeWindowMessageFilter(WM_MSG_7F2, 1);
    GetMenu = ::GetMenu;
  }
  else
  {
    hSubMenuFile = GetSubMenu(hMainMenuHandle, 0);
    InsertMenuW(hSubMenuFile, 3u, 0xC00u, 0, 0);// 0xC00 = MF_BYPOSITION|MF_SEPARATOR
    ++gdwMenuItemCountAppendedInRuntime;
    hSubMenuFile_1 = GetSubMenu(hMainMenuHandle, 0);
    InsertMenuW(
      hSubMenuFile_1,
      4u,
      MF_BYPOSITION,
      IDM_SHOW_DETAILS_FOR_ALL_PROCESSES,
      L"Show &Details for All Processes");
    GetMenu = ::GetMenu;
    hMainMenu_2 = ::GetMenu(hWnd_1);
    ReplaceMenuIconFromStockIcon(hMainMenu_2, IDM_SHOW_DETAILS_FOR_ALL_PROCESSES);
    ++gdwMenuItemCountAppendedInRuntime;
  }
  hOpacityPopupMenuHandle = LoadMenuW(ghInstance, L"OPACITY");
  InsertMenuW(hMainMenuHandle, IDM_VIEW_SHOW_LOWER_PANE, MF_POPUP, hOpacityPopupMenuHandle, L"Opacity");
  InsertMenuW(hMainMenuHandle, IDM_VIEW_SHOW_LOWER_PANE, MF_SEPARATOR, 0, 0);
  v23 = 0;
  if ( gConfig.bVerifySignatures )
    v23 = MF_CHECKED;
  CheckMenuItem(hMainMenuHandle, IDM_OPTIONS_VERIFY_IMAGE_SIGNATURE, v23);
  v24 = 0;
  if ( gConfig.bCheckVirusTotal )
    v24 = MF_CHECKED;
  CheckMenuItem(hMainMenuHandle, IDM_OPTIONS_CHECK_VIRTULTOALDOTCOM, v24);
  EnableMenuItem(hMainMenuHandle, IDM_OPTIONS_SUBMIT_UNKNOWN_EXECUTABLES, gConfig.bCheckVirusTotal == 0);
  if ( gConfig.bCheckVirusTotal )
    SubmitExeToVirusTotalDotCom();
  v25 = 0;
  if ( gConfig.bTrayCPUHistory )
    v25 = MF_CHECKED;
  v26 = v25;
  v27 = GetMenu(hWnd_1);
  CheckMenuItem(v27, IDM_OPTIONS_TRAYICON_CPU_HISTORY, v26);
  v28 = 0;
  if ( gConfig.bShowIoTray )
    v28 = MF_CHECKED;
  v29 = v28;
  v30 = GetMenu(hWnd_1);
  CheckMenuItem(v30, IDM_OPTIONS_TRAYICON_IO_HISTORY, v29);
  v31 = 0;
  if ( gConfig.bShowCommitTray )
    v31 = MF_CHECKED;
  v32 = v31;
  v33 = GetMenu(hWnd_1);
  CheckMenuItem(v33, IDM_OPTIONS_TRAYICON_COMMIT_HISTORY, v32);
  v34 = 0;
  if ( gConfig.bShowPhysTray )
    v34 = MF_CHECKED;
  v35 = v34;
  v36 = GetMenu(hWnd_1);
  CheckMenuItem(v36, IDM_OPTIONS_TRAYICON_PHYSICAL_MEMORY_HISTORY, v35);
  v37 = 0;
  if ( gConfig.bAllOneInstance )
    v37 = MF_CHECKED;
  CheckMenuItem(hMainMenuHandle, IDM_OPTIONS_ALLOW_ONLY_ONE_INSTANCE, v37);
  v38 = 0;
  if ( gConfig.bHideWhenMinimized )
    v38 = MF_CHECKED;
  CheckMenuItem(hMainMenuHandle, IDM_OPTIONS_HIDE_WHEN_MINIMIZED, v38);
  v39 = 0;
  if ( gConfig.bShowColumnHeatmaps )
    v39 = MF_CHECKED;
  CheckMenuItem(hMainMenuHandle, IDM_VIEW_SHOW_COLUMN_HEATMAPS, v39);
  gConfig.bAlwaysOntop = gConfig.bAlwaysOntop == 0;
  Command_SetTopmost(ghMainWnd);
  v40 = 0;
  if ( gConfig.bShowCpuFractions )
    v40 = MF_CHECKED;
  CheckMenuItem(hMainMenuHandle, IDM_PROCESS_CONFIRM_TO_KILL, v40);
  v41 = 0;
  if ( gConfig.bConfirmKill )
    v41 = MF_CHECKED;
  CheckMenuItem(hMainMenuHandle, IDM_OPTIONS_CONFIRM_KILL, v41);
  v42 = 0;
  if ( gConfig.bFormatIoBytes )
    v42 = MF_CHECKED;
  CheckMenuItem(hMainMenuHandle, IDM_SHOW_NEW_PROCESS, v42);
  v43 = 0;
  if ( gConfig.bShowNewProcesses )
    v43 = MF_CHECKED;
  v44 = v43;
  v45 = GetMenu(hWnd_1);
  CheckMenuItem(v45, IDM_VIEW_SCROLL_TO_NEW_PROCESSES, v44);
  InsertMenuW(
    hMainMenuHandle,
    IDM_VIEW_SHOW_PROCESS_TREE,
    0,
    IDM_TRAYMENU_CONTEXT_SYSTEM_INFORMATION,
    L"System &Information...\tCtrl+I");
  if ( Init3DStatistics(&dwMinSegments, &dwNbSegments) )
  {
    gpGraphInfoOfGPU = InitGraphData(1, 1, 1);
    gpGraphInfoOfGPU->m_nItemID = 4;
    gpGraphInfoOfGPU->m_Color = 0x8080FF;
    gpGraphInfoOfGPU->m_dbMemorySize = db_onehundred;
    gpGraphInfoOfSystemMemory = InitGraphData(1, 1, 0);
    gpGraphInfoOfSystemMemory->m_nItemID = 5;
    gpGraphInfoOfSystemMemory->m_Color = 0xAAAA;
    if ( dwMinSegments )
    {
      v46 = dwMinSegments;
      v47 = v46;
    }
    else
    {
      v47 = db_one;
    }
    gpGraphInfoOfSystemMemory->m_dbMemorySize = v47;
    gpGraphInfoOfDedicatedMemory = InitGraphData(1, 1, 0);
    gpGraphInfoOfDedicatedMemory->m_nItemID = 6;
    gpGraphInfoOfDedicatedMemory->m_Color = 0x4080FF;
    if ( dwNbSegments )
    {
      v48 = dwNbSegments;
      v49 = v48;
    }
    else
    {
      v49 = db_one;
    }
    gpGraphInfoOfDedicatedMemory->m_dbMemorySize = v49;
  }
  InsertMenuW(hMainMenuHandle, IDM_VIEW_SHOW_PROCESS_TREE, MF_SEPARATOR, 0, 0);
  InsertMenuW(
    hMainMenuHandle,
    IDM_OPTIONS_HIDE_WHEN_MINIMIZED,
    0,
    IDM_OPTIONS_REPLACE_TASK_MANAGER,
    L"Replace &Task Manager");
  v50 = CanReplaceTaskManager() != 0 ? MF_CHECKED : 0;
  v51 = GetMenu(hWnd_1);
  CheckMenuItem(v51, IDM_OPTIONS_REPLACE_TASK_MANAGER, v50);
  if ( gdwVersion >= 1 && !IsBuiltinAdministrative() )
    ReplaceMenuIconFromStockIcon(hMainMenuHandle, IDM_OPTIONS_REPLACE_TASK_MANAGER);
  if ( CanReplaceTaskManager() )
    ReplaceTaskManager(hWnd_1, 0);
  v52 = IsProcessExplorerRunAtStartup(&savedregs, hMainMenuHandle) != 0 ? MF_CHECKED : 0;
  v53 = GetMenu(hWnd_1);
  CheckMenuItem(v53, IDM_OPTIONS_RUN_AT_LOGON, v52);
  v54 = 0;
  if ( gConfig.bShowAllUsers )
    v54 = MF_CHECKED;
  CheckMenuItem(hMainMenuHandle, IDM_VIEW_SHOW_PROCESSES_FROM_ALL_USERS, v54);
  InsertMenuW(
    hMainMenuHandle,
    IDM_OPTIONS_DIFFERENCE_HIGHLIGHT_DURATION,
    0,
    IDM_VIEW_CONFIGURE_SYMBOLS,
    L"Configure &Symbols...");
  DeleteMenu(hMainMenuHandle, IDM_OPTIONS_HIGHLIGHT_RELOCATED_DLLS, 0);
  InsertMenuW(
    hMainMenuHandle,
    IDM_OPTIONS_DIFFERENCE_HIGHLIGHT_DURATION,
    0,
    IDM_VIEW_CONFIGURE_COLORS,
    L"&Configure Colors...");
  if ( WTSEnumerateSessionsW
    && *SetMenuInfo
    && WTSEnumerateSessionsW(0, 0, 1u, &pSessionInfo, &nSessionCount)
    && nSessionCount )
  {
    Item.cchTextMax = sizeof(MENUINFO);
    Item.iImage = 0x80000010;
    Item.lParam = MNS_NOTIFYBYPOS;
    SetMenuInfo(hMainMenuHandle, &Item.cchTextMax);
    ghUserPopupMenuHandle = CreateMenu();
    InsertMenuW(hMainMenuHandle, 5u, 0x410u, ghUserPopupMenuHandle, L"&Users");
    WTSFreeMemory(pSessionInfo);
  }
  dwProcessId = GetCurrentProcessId();
  hProcessHandle = GetCurrentProcess();
  QueryProcessUsers(hProcessHandle, dwProcessId, 0, szUserName, MAX_PATH, szDomainName, MAX_PATH, 0, 0, 0, 0);
  if ( !szDomainName[0] || (psz_1 = L"\\", !szUserName[0]) )
    psz_1 = &gszNullString;
  swprintf(gszMainTitle, L"%s%s%s", szDomainName, psz_1, szUserName);
  GetWindowTextW(ghMainWnd, szMainName, 260);
  nLength = wcslen(szMainName);
  swprintf_s(&szMainName[nLength], 260 - nLength, L" [%s]", gszMainTitle);
  SetWindowTextW(ghMainWnd, szMainName);
  gColorCustomized[0] = gConfig.ColorOwn;
  gColorCustomized[1] = gConfig.ColorService;
  gColorCustomized[2] = gConfig.ColorRelocatedDlls;
  gColorCustomized[3] = gConfig.ColorJobs;
  gColorCustomized[4] = gConfig.ColorNet;
  QueryCurrentAuthorityInfo(&gpszCurAuthInfo);
  if ( gSystemInfo.dwNumberOfProcessors > 1 )
  {
    hProcessMenu = GetSubMenu(hMainMenuHandle, 3);
    InsertMenuW(hProcessMenu, 2u, MF_BYPOSITION, IDC_PROCESS_SET_AFFINITY, L"Set &Affinity...");
    CheckMenuItem(hMainMenuHandle, (gConfig.bShowAllCpus != 0) + IDM_PROCESSOR_ONE_GRAPH_ALL_CPUS, MF_CHECKED);
    if ( *GetLogicalProcessorInformation )
    {
      cbData = 0;
      GetLogicalProcessorInformation(0, &cbData);
      if ( GetLastError() == ERROR_INSUFFICIENT_BUFFER )
      {
        gpLogicalProcessorInfo = malloc(cbData);
        GetLogicalProcessorInformation(gpLogicalProcessorInfo, &cbData);
        gdwLogicalProcessorInfoItemCount = cbData / sizeof(SYSTEM_LOGICAL_PROCESSOR_INFORMATION);
      }
    }
    else
    {
      gpLogicalProcessorInfo = Fake_GetLogicalProcessorInformation(&gdwLogicalProcessorInfoItemCount);
    }
    gppGraphInfo = malloc(4 * gSystemInfo.dwNumberOfProcessors);
    NumberOfProcessors = gSystemInfo.dwNumberOfProcessors;
    for ( index = 0; index < gSystemInfo.dwNumberOfProcessors; ++index )
    {
      gppGraphInfo[index] = InitGraphData(NumberOfProcessors, 2, 0);
      gppGraphInfo[index]->m_ProcessorID = index;
      sub_FC3E70(
        gpLogicalProcessorInfo,
        gdwLogicalProcessorInfoItemCount,
        index,
        &gppGraphInfo[index]->field_874,
        &gppGraphInfo[index]->field_870);
      gppGraphInfo[index]->m_nChildID = 2;
      gppGraphInfo[index]->m_nItemID = 0;
      gppGraphInfo[index]->m_Color = 0x3C943C;
      gppGraphInfo[index]->m_dbMemorySize = db_onehundred;
      gppGraphInfo[index]->m_Item[0].Color = 255;
      gppGraphInfo[index]->m_Item[0].dbMemorySize = db_onehundred;
      gppGraphInfo[index]->m_GraphData = gpGraphInfoOfCPU;
      if ( index )
      {
        v62 = *gppGraphInfo;
        v63 = gppGraphInfo[index];
        v63->m_Time.dwLowDateTime = (*gppGraphInfo)->m_Time.dwLowDateTime;
        v63->m_Time.dwHighDateTime = v62->m_Time.dwHighDateTime;
      }
      NumberOfProcessors = gSystemInfo.dwNumberOfProcessors;
    }
    GetMenu = ::GetMenu;
  }
  v64 = LoadLibraryW(L"Powrprof.dll");
  *SetSuspendState = GetProcAddress(v64, "SetSuspendState");
  if ( *SetSuspendState )
  {
    v65 = LoadLibraryW(L"Powrprof.dll");
    *IsPwrHibernateAllowed = GetProcAddress(v65, "IsPwrHibernateAllowed");
    if ( IsPwrHibernateAllowed() )
      InsertMenuW(hMainMenuHandle, IDM_FILE_SHUTDOWN_RESTART, MF_BYCOMMAND, IDC_FILE_HIBERNATE, L"&Hibernate");
    v66 = LoadLibraryW(L"Powrprof.dll");
    *IsPwrSuspendAllowed = GetProcAddress(v66, "IsPwrSuspendAllowed");
    if ( IsPwrSuspendAllowed() )
      InsertMenuW(hMainMenuHandle, IDM_FILE_SHUTDOWN_RESTART, MF_BYCOMMAND, IDC_FILE_STANDBY, L"Stand &By");
  }
  v67 = LoadLibraryW(L"User32.dll");
  *LockWorkStation = GetProcAddress(v67, "LockWorkStation");
  if ( *LockWorkStation )
    InsertMenuW(hMainMenuHandle, IDM_FILE_SHUTDOWN_RESTART, MF_BYCOMMAND, IDC_THREADSTACK_BUTTON_COPY, L"Loc&k");
  v68 = LoadLibraryW(L"User32.dll");
  *GetMonitorInfoA = GetProcAddress(v68, "GetMonitorInfoA");
  v69 = LoadLibraryW(L"User32.dll");
  *MonitorFromPoint = GetProcAddress(v69, "MonitorFromPoint");
  v70 = LoadMenuW(ghInstance, L"DLLMENU");
  v71 = 0;
  ghDllMenuPopup = v70;
  if ( gConfig.bHighlightRelocatedDlls )
    v71 = 8;
  CheckMenuItem(v70, IDM_OPTIONS_HIGHLIGHT_RELOCATED_DLLS, v71);
  ghHandleMenuPopup = LoadMenuW(ghInstance, L"HANDLEMENU");
  v72 = 0;
  if ( gConfig.bShowUnnamedHandles )
    v72 = 8;
  v73 = v72;
  v74 = GetMenu(hWnd_1);
  CheckMenuItem(v74, IDM_VIEW_SHOW_UNNAMED_HANDLES_AND_MAPPINGS, v73);
  RegCloseKey = ::RegCloseKey;
  if ( RegOpenKeyW(HKEY_CLASSES_ROOT, L"exefile\\shell\\View Dependencies", &hSubKey) )
  {
    gstrApplicationName = 0;
    dwRet = GetEnvironmentVariableW(L"PATH", 0, 0);
    dwSize = dwRet;
    if ( dwRet )
    {
      pszPath = malloc(2 * dwRet + 2);
      GetEnvironmentVariableW(L"PATH", pszPath, dwSize);
      dwSize_1 = dwSize;
      pszPath_1 = pszPath;
      if ( MakeApplicationName(L"depends.exe", pszPath, dwSize_1, &gstrApplicationName) )
      {
        InsertMenuW(hMainMenuHandle, IDM_PROCESS_TEMP, MF_BYCOMMAND, IDM_PROCESS_LAUNCH_DEPENDS, L"&Launch Depends...");
        InsertMenuW(
          ghDllMenuPopup,
          IDM_DLLMENU_BASE_ITEM,
          MF_BYCOMMAND,
          IDM_DLLMENU_LAUNCH_DEPENDS,
          L"&Launch Depends...");
        gbLaunchDepends = 1;
      }
      else
      {
        gstrApplicationName = 0;
      }
      free(pszPath_1);
    }
    RegCloseKey = ::RegCloseKey;
  }
  else
  {
    gbLaunchDepends = 1;
    InsertMenuW(hMainMenuHandle, IDM_PROCESS_TEMP, MF_BYCOMMAND, IDM_PROCESS_LAUNCH_DEPENDS, L"&Launch Depends...");
    InsertMenuW(ghDllMenuPopup, IDM_DLLMENU_BASE_ITEM, MF_BYCOMMAND, IDM_DLLMENU_LAUNCH_DEPENDS, L"&Launch Depends...");
    gstrApplicationName = 0;
    ::RegCloseKey(hSubKey);
  }
  if ( !RegOpenKeyW(HKEY_LOCAL_MACHINE, L"Software\\Microsoft\\Windows NT\\CurrentVersion\\AeDebug", &hSubKey) )
  {
    cbData = 520;
    if ( !RegQueryValueExW(hSubKey, L"Debugger", 0, &Type, szPathName, &cbData) )
    {
      _wcslwr_s(gszAeDebuggerPath, MAX_PATH);
      if ( szPathName[0] == '"' )
      {
        wcscpy_s(gszAeDebuggerPath, MAX_PATH, &szPathName[1]);
        if ( wcschr(gszAeDebuggerPath, '"') )
        {
          psz = wcschr(gszAeDebuggerPath, '"');
LABEL_110:
          *psz = 0;
          goto LABEL_111;
        }
      }
      else
      {
        wcscpy_s(gszAeDebuggerPath, MAX_PATH, szPathName);
        if ( wcschr(gszAeDebuggerPath, ' ') )
        {
          psz = wcschr(gszAeDebuggerPath, ' ');
          goto LABEL_110;
        }
      }
    }
LABEL_111:
    RegCloseKey(hSubKey);
  }
  if ( gszAeDebuggerPath[0] )
    InsertMenuW(hMainMenuHandle, IDM_PROCESS_TEMP, MF_BYCOMMAND, IDM_PROCESS_DEBUG, L"&Debug");
  DeleteMenu(hMainMenuHandle, IDM_PROCESS_TEMP, MF_BYCOMMAND);
  hWnd_2 = hWnd_1;
  ghWndToolbar = InitToolbar(hWnd_1, IDC_MAINTOOLBAR);
  if ( !ghWndToolbar )
    return -1;
  UpdateMenuStatus(0, 3);
  GetWindowRect(ghWndToolbar, &rcToolbar);
  gnToolbarHeight = rcToolbar.bottom - rcToolbar.top + 2;
  hInst = ghInstance;
  _mm_storeu_si128(&rcTreeList, 0i64);
  hWndTreeListView = CTreeList::Init(hWnd_2, hInst, IDC_TREEVIEW_LIST, 0x40810200, &rcTreeList);
  ghWndTreeListView = hWndTreeListView;
  if ( !hWndTreeListView )
    return -1;
  InitTreeList(hWndTreeListView, ghConfigFont);
  pTreeList = CTreeList::GetTreeList(ghWndTreeListView);
  pTreeList_1 = pTreeList;
  pszPath = pTreeList;
  pTreeList->m_pfnDrawBack = CMainWnd::Draw;
  CTreeList::UpdateSB(pTreeList, 0);
  pTreeList_1->m_pfnGetChildCursor = CMainWnd::GetDynamicCursor;
  v87 = LoadCursorW(ghInstance, 0x6A);
  CTreeList::SetSplitterCursor(pTreeList_1, v87);
  sub_F9BDA0(pTreeList_1, 1);
  sub_F9F210(pTreeList_1, 0);
  sub_F9F230(pTreeList_1, 0);
  v88 = CTreeList::GetTooltipOfTreeList(pTreeList_1);
  CTreeList::InitToolTips(v88);
  v89 = CTreeList::GetTooltipOfLeftHeader(pTreeList_1);
  CTreeList::InitToolTips(v89);
  v90 = CTreeList::GetTooltipOfRightHeader(pTreeList_1);
  CTreeList::InitToolTips(v90);
  dwProcessColumnCount = gConfig.dwProcessColumnCount;
  if ( gConfig.dwProcessColumnMap[0] != IDS_PROCESS )
  {
    memmove(&gConfig.dwProcessColumnMap[1], gConfig.dwProcessColumnMap, 4 * gConfig.dwProcessColumnCount);
    gConfig.dwProcessColumnMap[0] = IDS_PROCESS;
    memmove(&gConfig.dwProcessColumns[1], gConfig.dwProcessColumns, 2 * gConfig.dwProcessColumnCount);
    wProcessImageColumnWidth = gConfig.wProcessImageColumnWidth;
    if ( !gConfig.wProcessImageColumnWidth )
      wProcessImageColumnWidth = 200;
    gConfig.dwProcessColumns[0] = wProcessImageColumnWidth;
    dwProcessColumnCount = gConfig.dwProcessColumnCount++ + 1;
  }
  if ( !CTreeView::InitListHeader(
          ghWndTreeListView,
          gConfig.dwProcessColumnMap,
          gConfig.dwProcessColumns,
          dwProcessColumnCount) )
    return -1;
  v93 = GetSystemMetrics(SM_CYSMICON);
  v94 = GetSystemMetrics(SM_CXSMICON);
  hImgList = ImageList_Create(v94, v93, 0x21u, 256, 256);
  pTreeList_2 = pszPath;
  CTreeList::ResetImageList(pszPath, hImgList, 0);
  v97 = LoadIconW(0, IDC_ARROW);
  v98 = CTreeList::GetImageList(pTreeList_2);
  ImageList_ReplaceIcon(v98, -1, v97);
  v99 = InitSortableImageList();
  CTreeList::SetSortFlagsImageList(pTreeList_2, v99, 1, 0);
  if ( !gConfig.bShowProcessTree )
    CTreeList::InitHeaderColumn(
      ghWndTreeListView,
      0xFFFFFFFF,
      gConfig.dwProcessSortColumn,
      gConfig.bProcessSortDirection);
  v100 = hWnd_1;
  v101 = CreateListCtrl(
           hWnd_1,
           0x40810605u,
           gConfig.dwIdsOfHandleColumnMap,
           gConfig.dwHandleColumns,
           gConfig.dwHandleColumnCount,
           IDC_LISTCTRL_HANDLES);
  ghWndHandlesListCtrl = v101;
  if ( !v101 )
    return -1;
  CTreeList::InitHeaderColumn(v101, 0xFFFFFFFF, gConfig.dwHandleSortColumn, gConfig.bHandleSortDirection);
  v102 = CreateListCtrl(
           v100,
           0x40810605u,
           gConfig.dwDllColumnMap,
           gConfig.dwDllColumns,
           gConfig.dwDllColumnCount,
           IDC_LISTCTRL_DLLS);
  ghWndDllsListCtrl = v102;
  if ( !v102 )
    return -1;
  CTreeList::InitHeaderColumn(v102, 0xFFFFFFFF, gConfig.dwDllSortColumn, gConfig.bDllSortDirection);
  ghWndStatusBar = CreateStatusWindowW(0x50000000, &gszNullString, v100, 0x6Au);
  CMainWnd::InitStatusBar(ghWndStatusBar);
  ghResizeCursor = LoadCursorW(ghInstance, 0x69);
  if ( !ghResizeCursor )
    ghResizeCursor = LoadCursorW(0, 0x7F00);
  ghSplitterCursor = LoadCursorW(ghInstance, 0x6A);
  if ( !ghSplitterCursor )
    ghSplitterCursor = LoadCursorW(0, 0x7F00);
  v103 = 0;
  if ( gConfig.bHighlightRelocatedDlls )
    v103 = 8;
  v104 = v103;
  v105 = ::GetMenu(v100);
  CheckMenuItem(v105, IDM_OPTIONS_HIGHLIGHT_RELOCATED_DLLS, v104);
  ShowWindow(ghWndTreeListView, SW_SHOW);
  if ( gConfig.bShowLowerPane )
  {
    if ( gConfig.bShowDllView )
    {
      v106 = ::GetMenu(hWnd_1);
      CheckMenuItem(v106, IDM_VIEW_LOWERPANEVIEW_DLLS, MF_CHECKED);
      ShowWindow(ghWndDllsListCtrl, SW_SHOW);
    }
    else
    {
      v107 = ::GetMenu(hWnd_1);
      CheckMenuItem(v107, IDM_VIEW_LOWERPANEVIEW_HANDLES, MF_CHECKED);
      ShowWindow(ghWndHandlesListCtrl, SW_SHOW);
    }
  }
  nBmpIndex = 1;
  if ( gConfig.bShowDllView )
    nBmpIndex = 4;
  SendMessageW(ghWndToolbar, TB_CHANGEBITMAP, IDM_POPUP_DLL_PROPERTIES, nBmpIndex);
  SendMessageW(ghWndToolbar, TB_ENABLEBUTTON, IDM_VIEW_SHOW_PROCESS_TREE, gConfig.bShowProcessTree == 0);
  v109 = gConfig.bShowProcessTree != 0;
  v110 = ::GetMenu(ghMainWnd);
  EnableMenuItem(v110, IDM_VIEW_SHOW_PROCESS_TREE, v109);
  v111 = ::GetMenu(ghMainWnd);
  EnableMenuItem(v111, IDM_PROCESS_KILL_PROCESS_TREE, MF_GRAYED);
  ghSystemInfoSheetThreadEvent = CreateEventW(0, 0, 0, 0);
  GetClientRect(hWnd_1, &gRectWindow);
  gRectPane.left = 0;
  gRectWindow.top = gRectWindow.top - 1 + gnToolbarHeight;
  gRectWindow.bottom -= gRectWindow.top;
  gRectPane.top = gRectWindow.top + ((gRectWindow.bottom - gRectWindow.top) * gConfig.dbDivider);
  gRectPane.bottom = gRectPane.top + 7;
  gRectPane.right = gRectWindow.right;
  if ( gConfig.bShowLowerPane )
    v112 = gConfig.dbSavedDivider;
  else
    v112 = db_one;
  gConfig.dbDivider = v112;
  gConfig.bShowLowerPane = gConfig.bShowLowerPane == 0;
  Command_ShowLowerPane(0);
  gShellIconMsg = RegisterWindowMessageW(L"TaskbarCreated");
  StartBackendThread();
  CTreeList::InitTreeList(ghWndTreeListView, 1);
  SendMessageW(ghMainWnd, WM_TREEVIEW_SORT, IDC_TREEVIEW_LIST, gConfig.bShowProcessTree);
  SetFocus(ghWndTreeListView);
  lvItem.iItem = SendMessageW(ghWndTreeListView, LVM_GETNEXTITEM, 0xFFFFFFFF, LVFI_STRING);
  lvItem.iSubItem = 0;
  lvItem.mask = 4;
  SendMessageW(ghWndTreeListView, LVM_GETITEMW, 0, &lvItem);
  RefreshVirusTotalMenuItem(lvItem.lParam);
  Item.stateMask = 3;
  Item.state = 3;
  SendMessageW(ghWndDllsListCtrl, LVM_SETITEMSTATE, 0, &Item);
  Item.stateMask = 3;
  Item.state = 3;
  SendMessageW(ghWndHandlesListCtrl, LVM_SETITEMSTATE, 0, &Item);
  if ( IsBuiltinAdministrative() && !PE_RunTrace(&gProperties, 1) )
  {
    InsertMenuW(
      hMainMenuHandle,
      IDM_OPTIONS_TRAYICON_COMMIT_HISTORY,
      MF_BYCOMMAND,
      IDM_OPTIONS_COMMIT_DISK_HISTORY,
      L"&Disk History");
    v113 = 0;
    if ( gConfig.bShowDiskTray )
      v113 = 8;
    v114 = v113;
    v115 = ::GetMenu(hWnd_1);
    CheckMenuItem(v115, IDM_OPTIONS_COMMIT_DISK_HISTORY, v114);
    InsertMenuW(hMainMenuHandle, 40726u, MF_BYCOMMAND, IDM_OPTIONS_COMMIT_NETWORK_HISTORY, L"&Network History");
    v116 = 0;
    if ( gConfig.bShowNetTray )
      v116 = 8;
    v117 = v116;
    v118 = ::GetMenu(hWnd_1);
    CheckMenuItem(v118, IDM_OPTIONS_COMMIT_NETWORK_HISTORY, v117);
  }
  if ( gdwAdapterRuntingTime )
  {
    InsertMenuW(hMainMenuHandle, IDM_OPTIONS_TRAYICON_COMMIT_HISTORY, MF_BYCOMMAND, 40748u, L"&GPU History");
    v119 = hWnd_1;
    v120 = 0;
    if ( gConfig.bShowGpuHistory )
      v120 = 8;
    v121 = v120;
    v122 = ::GetMenu(hWnd_1);
    CheckMenuItem(v122, IDM_OPTIONS_COMMIT_GPU_HISTORY, v121);
  }
  else
  {
    v119 = hWnd_1;
  }
  ghRefreshEventHandle = CreateEventW(0, 0, 0, 0);
  ghEvent2 = CreateEventW(0, 0, 0, 0);
  ghEvent3 = CreateEventW(0, 1, 0, 0);
  ghTimerRefreshEvent = CreateEventW(0, 0, 0, 0);
  ghTimerRefreshProcPageEventHandle = CreateEventW(0, 1, 0, 0);
  ghEvent6 = CreateEventW(0, 0, 0, 0);
  ghBackupRefreshThreadHandle = _beginthreadex(0, 0, CMainWnd::BackendRefreshThreadProc, 0, 0, 0);
  if ( gConfig.dwRefreshRate > 2000 )
  {
    if ( gConfig.dwRefreshRate == 5000 )
    {
      v132 = IDM_VIEW_UPDATESPEED_FIVE_SECONDS;
      goto __RefreshMenuItem;
    }
    if ( gConfig.dwRefreshRate == 10000 )
    {
      v132 = IDM_VIEW_UPDATESPEED_TEN_SECONDS;
      goto __RefreshMenuItem;
    }
  }
  else
  {
    if ( gConfig.dwRefreshRate == 2000 )
    {
      v132 = IDM_VIEW_UPDATESPEED_TWO_SECONDS;
      goto __RefreshMenuItem;
    }
    if ( gConfig.dwRefreshRate )
    {
      if ( gConfig.dwRefreshRate == 500 )
      {
        v132 = IDM_VIEW_UPDATESPEED_HALF_SECONDS;
        goto __RefreshMenuItem;
      }
      if ( gConfig.dwRefreshRate == 1000 )
      {
        v132 = IDM_VIEW_UPDATESPEED_ONE_SECOND;
__RefreshMenuItem:
        hMenuMain_1 = ::GetMenu(ghMainWnd);
        CheckMenuRadioItem(hMenuMain_1, IDM_VIEW_UPDATESPEED_PAUSED_SPACE, IDM_VIEW_UPDATESPEED_HALF_SECONDS, v132, 0);
        goto LABEL_167;
      }
    }
    else
    {
      hMenuMain = ::GetMenu(ghMainWnd);
      CheckMenuRadioItem(
        hMenuMain,
        IDM_VIEW_UPDATESPEED_PAUSED_SPACE,
        IDM_VIEW_UPDATESPEED_HALF_SECONDS,
        IDM_VIEW_UPDATESPEED_PAUSED_SPACE,
        0);
      SendMessageW(ghWndStatusBar, SB_SETTEXTW, gnStatusBarItemCount - 1, L"Paused");
    }
  }
LABEL_167:
  InvalidateRect(ghWndToolbar, 0, 1);
  SetCursor(hCursor_____);
  if ( !gIOGraphInfo.pGraphData )
    DeleteMenu(hMainMenuHandle, IDM_OPTIONS_TRAYICON_IO_HISTORY, 0);
  HandleTaskbarCreated();
  v125 = GetModuleHandleW(L"Shlwapi.dll");
  gpfnSHAutoComplete = GetProcAddress(v125, "SHAutoComplete");
  v126 = LoadLibraryW(L"user32.dll");
  v127 = GetProcAddress(v126, "SetLayeredWindowAttributes");
  dwOpacity = gConfig.dwOpacity;
  SetLayeredWindowAttributes = v127;
  if ( gConfig.dwOpacity != 100 )
  {
    v129 = GetWindowLongW(ghMainWnd, GWL_EXSTYLE);
    SetWindowLongW(ghMainWnd, -20, v129 | WS_EX_LAYERED);
    SetLayeredWindowAttributes(ghMainWnd, 0, (255 * gConfig.dwOpacity) / 100, LWA_ALPHA);
    RedrawWindow(ghMainWnd, 0, 0, 0x485u);
    dwOpacity = gConfig.dwOpacity;
  }
  uId = (((0x66666667i64 * dwOpacity) >> 32) >> 2) + (((0x66666667i64 * dwOpacity) >> 32) >> 31) + 40093;
  v131 = ::GetMenu(v119);
  CheckMenuItem(v131, uId, 8u);
  if ( gbHide )
    CMainWnd::Hide(ghMainWnd);
  return 0;
}
// F99F40: using guessed type bool __cdecl LoadWintrust();
// FF6620: using guessed type bool __cdecl GetProcessDEPStatus();
// 103CDC0: using guessed type double db_onehundred;
// 10408AC: using guessed type wchar_t aRUnAsAdministr[25];
// 1040D80: using guessed type wchar_t aPaused[7];
// 1064E54: using guessed type int gdwVersion;
// 106A118: using guessed type int (__stdcall *gpfnCreateRestrictedToken)(void *, unsigned int, unsigned int, struct _SID_AND_ATTRIBUTES *, unsigned int, struct _LUID_AND_ATTRIBUTES *, unsigned int, struct _SID_AND_ATTRIBUTES *, void **);
// 106A32C: using guessed type int gdwComdlg_FindReplaceMessageID;
// 106A388: using guessed type char gbHide;
// 106A390: using guessed type char gbIsProcessDEPEnabled;
// 106A391: using guessed type char gbWintrustInited;
// 106A392: using guessed type char gbLaunchDepends;
// 106A884: using guessed type int gShellIconMsg;
// 106A8F4: using guessed type int (__stdcall *gpfnSHAutoComplete)(struct HWND__ *, unsigned int);
// 106A908: using guessed type int ghSplitterCursor;
// 106F360: using guessed type int (__stdcall *ChangeWindowMessageFilter)(_DWORD, _DWORD);
// 1085720: using guessed type int gnStatusBarItemCount;

//----- (00FD57D0) --------------------------------------------------------
int __cdecl CMainWnd::HandleClose(HWND hWnd)
{
  if ( gConfig.bHideWhenMinimized )
    CMainWnd::Hide(ghMainWnd);
  else
    CMainWnd::HandleDestroy(hWnd);
  return 0;
}

//----- (00FD5810) --------------------------------------------------------
int CMainWnd::HandleEndSession()
{
  UpdateWindowPlacement(ghMainWnd, 1);
  return 0;
}

//----- (00FD5830) --------------------------------------------------------
int __cdecl CMainWnd::HandleDestroy(HWND hWnd)
{
  signed int nIndex; // esi
  HANDLE v2; // eax

  ShowWindow(hWnd, 0);
  UpdateWindowPlacement(ghMainWnd, 1);
  nIndex = 1;
  do
    TrayIcon_Delete(hWnd, nIndex++);
  while ( nIndex < 8 );
  SetEvent(ghEvent3);
  PE_RunTrace(&gProperties, 0);
  TerminateThread(ghBackupRefreshThreadHandle, 0);
  v2 = GetCurrentProcess();
  TerminateProcess(v2, 0);
  PostQuitMessage(0);
  return 0;
}

//----- (00FD58B0) --------------------------------------------------------
int __cdecl CMainWnd::HandleDrawItem(HWND a1, unsigned int a2, unsigned int a3, LPDRAWITEMSTRUCT a4)
{
  if ( a4->CtlType != 1 )
    return CMainWnd::DrawList(a4);
  DrawIconEx(a4->hDC, a4->rcItem.left - 15, a4->rcItem.top, a4->itemData, 16, 16, 0, 0, 3u);
  return 0;
}

//----- (00FD58F0) --------------------------------------------------------
signed int __cdecl CMainWnd::HandleSetFocus(HWND a1)
{
  signed int result; // eax

  gdwTickLast = GetTickCount();
  if ( ghWndFocusedLast )
  {
    SetFocus(ghWndFocusedLast);
    result = 1;
  }
  else if ( a1 == ghMainWnd )
  {
    SetFocus(ghWndTreeListView);
    result = 1;
  }
  else
  {
    result = 0;
  }
  return result;
}
// 106A380: using guessed type unsigned int gdwTickLast;

//----- (00FD5940) --------------------------------------------------------
LRESULT __cdecl CMainWnd::HandleContextMenu(HWND hWnd_1, UINT Msg, HWND hWnd, LPARAM a4)
{
  UINT uID; // edi
  LRESULT v5; // eax
  HWND hWnd_2; // [esp+8h] [ebp-48h]
  struct tagPOINT Point; // [esp+34h] [ebp-1Ch]
  RECT lParam; // [esp+3Ch] [ebp-14h]

  if ( hWnd == ghWndTreeListView )
  {
    uID = IDC_TREEVIEW_LIST;
  }
  else if ( hWnd == ghWndHandlesListCtrl )
  {
    uID = IDC_LISTCTRL_HANDLES;
  }
  else
  {
    if ( hWnd != ghWndDllsListCtrl )
      return DefWindowProcW(hWnd_1, Msg, hWnd, a4);
    uID = IDC_LISTCTRL_DLLS;
  }
  hWnd_2 = hWnd_1;
  Point.x = a4;
  Point.y = SHIWORD(a4);
  if ( a4 != -1 )
    return 0;
  v5 = SendMessageW(hWnd, LVM_GETNEXTITEM, a4, 2);
  if ( v5 != -1 )
  {
    lParam.left = 0;
    SendMessageW(hWnd, LVM_GETITEMRECT, v5, &lParam);
    Point.y = lParam.bottom;
    Point.x = lParam.left + 10;
    ClientToScreen(hWnd, &Point);
  }
  return UpdateListViewContextMenu(uID, &hWnd_2, &Point);
}

//----- (00FD5A40) --------------------------------------------------------
int __cdecl CMainWnd::HandleMsg7EF(int _8, int a2, int a3, void *a1)
{
  sub_FB8460(a1);
  return 0;
}

//----- (00FD5A60) --------------------------------------------------------
int __cdecl CMainWnd::HandleMsg7F8(HWND a1, unsigned int a2, unsigned int a3, const wchar_t **a4)
{
  tagTREEVIEWLISTITEMPARAM *v4; // esi
  char v5; // cl
  tagTREEVIEWLISTITEMPARAM *v6; // ebx
  const wchar_t *v7; // eax
  wchar_t *v8; // eax
  const wchar_t *v9; // eax
  DLLLISTITEMPARAM *v10; // esi
  char v11; // bl
  const wchar_t *v12; // eax
  char v14; // [esp+Bh] [ebp-1h]

  v4 = gpTreeViewListItemParam;
  v5 = 0;
  v6 = 0;
  v14 = 0;
  if ( !gpTreeViewListItemParam )
    return 0;
  do
  {
    v7 = v4->szProcessName;
    if ( v4->dwProcessId == gdwProcessIdSelected )
      v6 = v4;
    if ( v7 )
    {
      if ( _wcsicmp(v7, a4[1]) || _wcsicmp(L"system", *a4) && _wcsicmp(v4->pszName, *a4) )
      {
        v5 = v14;
      }
      else
      {
        v8 = _wcsdup(a4[2]);
        v5 = 1;
        v4->field_33C = v8;
        v14 = 1;
      }
    }
    v4 = v4->m_Prev;
  }
  while ( v4 );
  if ( v5 )
  {
    if ( RedrawColumn(1, ghWndTreeListView, 1656, 0) )
    {
      InvalidateRect(ghWndTreeListView, 0, 0);
      sub_FBFAA0(0x65);
    }
    else if ( IsColumnIDValid(ghWndTreeListView, 0x678u) )
    {
      InvalidateRect(ghWndTreeListView, 0, 0);
    }
  }
  if ( v6 )
  {
    if ( IsWindowVisible(ghWndDllsListCtrl) )
    {
      if ( !_wcsicmp(L"system", *a4) || (v9 = v6->pszName) != 0 && !_wcsicmp(v9, *a4) )
      {
        v10 = gpDllListItemParamHeader;
        v11 = 0;
        if ( gpDllListItemParamHeader )
        {
          do
          {
            v12 = v10->m_strPath.pszData;
            if ( v12 && !_wcsicmp(v12, a4[1]) )
            {
              v10->m_strLocation = _wcsdup(a4[2]);
              v11 = 1;
            }
            v10 = v10->m_Prev;
          }
          while ( v10 );
          if ( v11 )
          {
            InvalidateRect(ghWndDllsListCtrl, 0, 0);
            sub_FBFAA0(0x68);
          }
        }
      }
    }
  }
  return 0;
}

//----- (00FD5C10) --------------------------------------------------------
int __cdecl CMainWnd::HandleMsg7F6(int a1, int a2, int a3, HWND hWnd)
{
  InvalidateRect(hWnd, 0, 0);
  return 0;
}

//----- (00FD5C30) --------------------------------------------------------
signed int CMainWnd::HandleKillFocus()
{
  ghWndFocusedLast = GetFocus();
  return 1;
}

//----- (00FD5C50) --------------------------------------------------------
int __cdecl CMainWnd::HandleMsg7F0(HWND a1, unsigned int a2, unsigned int a3, int pListItem)
{
  if ( *(pListItem + 4) )
  {
    if ( *(pListItem + 356) )
      free(*(pListItem + 356));
    *(pListItem + 356) = _wcsdup(*(pListItem + 360));
    if ( IsColumnIDValid(ghWndDllsListCtrl, 0x4A3u) )
      InvalidateRect(ghWndDllsListCtrl, 0, 0);
  }
  else
  {
    if ( *(pListItem + 836) )
      free(*(pListItem + 836));
    *(pListItem + 836) = _wcsdup(*(pListItem + 840));
    if ( RedrawColumn(1, ghWndTreeListView, 1187, 0) )
    {
      InvalidateRect(ghWndTreeListView, 0, 0);
      sub_FBFAA0(0x65);
      return 0;
    }
    if ( IsColumnIDValid(ghWndTreeListView, 0x4A3u) )
    {
      InvalidateRect(ghWndTreeListView, 0, 0);
      return 0;
    }
  }
  return 0;
}

//----- (00FD5D40) --------------------------------------------------------
_DWORD *__cdecl CMainWnd::HandleMsg7EE(HWND hWnd, UINT msg, WPARAM wParam, LPARAM lParam)
{
  LRESULT ret; // esi
  tagTREEVIEWLISTITEMPARAM *nItem; // ebx

  ret = -1;
  if ( !gConfig.bShowNewProcesses )
  {
    ret = SendMessageW(ghWndTreeListView, LVM_GETNEXTITEM, 0xFFFFFFFF, 2);
    if ( !SendMessageW(ghWndTreeListView, LVM_ISITEMVISIBLE, ret, 0) )
      ret = -1;
  }
  nItem = CTreeList::FindItem(ghWndTreeListView, lParam);
  if ( ret != -1 )
    SendMessageW(ghWndTreeListView, LVM_ENSUREVISIBLE, ret, 0);
  return &nItem->field_0;
}

//----- (00FD5DC0) --------------------------------------------------------
int __cdecl CMainWnd::HandleInitMenuPopup(HWND hWnd, unsigned int nPos, HMENU hMenu)
{
  UINT v3; // esi
  DWORD v4; // esi
  int nIndex; // ebx
  HMENU hMenuUser; // esi
  UINT_PTR v7; // ST0C_4
  UINT v8; // esi
  MENUINFO MenuInfo; // [esp+0h] [ebp-244h]
  DWORD cbRet; // [esp+1Ch] [ebp-228h]
  UINT uPosition; // [esp+20h] [ebp-224h]
  PWTS_SESSION_INFOW pszDomainName; // [esp+24h] [ebp-220h]
  DWORD v14; // [esp+28h] [ebp-21Ch]
  PWTS_SESSION_INFOW pszUserName; // [esp+2Ch] [ebp-218h]
  DWORD nCount; // [esp+30h] [ebp-214h]
  PWTS_SESSION_INFOW pSessionInfo; // [esp+34h] [ebp-210h]
  __int16 NewItem[260]; // [esp+38h] [ebp-20Ch]

  if ( hMenu != ghUserPopupMenuHandle )
    return 0;
  nCount = GetMenuItemCount(ghUserPopupMenuHandle);
  v3 = nCount - 1;
  if ( nCount )
  {
    do
      DeleteMenu(ghUserPopupMenuHandle, v3--, MF_BYPOSITION);
    while ( v3 != -1 );
  }
  if ( WTSEnumerateSessionsW(0, 0, 1u, &pSessionInfo, &nCount) )
  {
    v4 = 0;
    uPosition = 0;
    v14 = 0;
    if ( nCount )
    {
      nIndex = 0;
      do
      {
        if ( WTSQuerySessionInformationW(0, pSessionInfo[nIndex].SessionId, WTSUserName, &pszUserName, &cbRet) )
        {
          if ( WTSQuerySessionInformationW(0, pSessionInfo[nIndex].SessionId, WTSDomainName, &pszDomainName, &cbRet) )
          {
            if ( LOWORD(pszUserName->SessionId) )
            {
              swprintf(NewItem, L"%d: %s\\%s", pSessionInfo[nIndex].SessionId, pszDomainName, pszUserName);
              hMenuUser = LoadMenuW(ghInstance, L"USERS");
              MenuInfo.cbSize = 28;
              MenuInfo.fMask = 0x80000018;
              MenuInfo.dwStyle = MNS_NOTIFYBYPOS;
              MenuInfo.dwMenuData = pSessionInfo[nIndex].SessionId;
              SetMenuInfo(hMenuUser, &MenuInfo);
              switch ( pSessionInfo[nIndex].State )
              {
                case WTSActive:
                case WTSShadow:
                  break;
                case WTSConnected:
                  EnableMenuItem(hMenuUser, IDM_USERS_CONNECT, MF_GRAYED);
                  EnableMenuItem(hMenuUser, IDM_USERS_LOGOFF, MF_GRAYED);
                  EnableMenuItem(hMenuUser, IDM_USERS_SEND_MESSAGE, MF_GRAYED);
                  break;
                case WTSDisconnected:
                  EnableMenuItem(hMenuUser, IDM_USERS_DISCONNECT, MF_GRAYED);
                  EnableMenuItem(hMenuUser, IDM_USERS_SEND_MESSAGE, MF_GRAYED);
                  break;
                default:
                  EnableMenuItem(hMenuUser, IDM_USERS_CONNECT, MF_GRAYED);
                  EnableMenuItem(hMenuUser, IDM_USERS_SEND_MESSAGE, MF_GRAYED);
                  EnableMenuItem(hMenuUser, IDM_USERS_LOGOFF, MF_GRAYED);
                  EnableMenuItem(hMenuUser, IDM_USERS_DISCONNECT, MF_GRAYED);
                  EnableMenuItem(hMenuUser, IDM_USERS_REMOTE_CONTROL, MF_GRAYED);
                  break;
              }
              v7 = hMenuUser;
              v8 = uPosition;
              InsertMenuW(ghUserPopupMenuHandle, uPosition, 0x410u, v7, NewItem);
              uPosition = v8 + 1;
              v4 = v14;
            }
            WTSFreeMemory(pszDomainName);
          }
          WTSFreeMemory(pszUserName);
        }
        ++v4;
        ++nIndex;
        v14 = v4;
      }
      while ( v4 < nCount );
    }
    WTSFreeMemory(pSessionInfo);
  }
  return 0;
}

//----- (00FD6050) --------------------------------------------------------
LRESULT __cdecl CMainWnd::HandleMenuCommand(HWND hWnd, int a2, int nPos, HMENU hMenu)
{
  UINT v4; // eax
  UINT v5; // esi
  LRESULT result; // eax
  int v7; // eax
  int *v8; // eax
  int v9; // eax
  char v10; // bl
  DWORD v11; // eax
  int v12; // [esp+Ch] [ebp-458h]
  HWND v13; // [esp+10h] [ebp-454h]
  const wchar_t *v14; // [esp+14h] [ebp-450h]
  const wchar_t *v15; // [esp+18h] [ebp-44Ch]
  int v16; // [esp+1Ch] [ebp-448h]
  struct tagMENUINFO v17; // [esp+20h] [ebp-444h]
  LPWSTR ppBuffer; // [esp+3Ch] [ebp-428h]
  _bstr_t v19; // [esp+40h] [ebp-424h]
  int v20; // [esp+44h] [ebp-420h]
  int v21; // [esp+48h] [ebp-41Ch]
  DWORD nSize; // [esp+4Ch] [ebp-418h]
  WCHAR Buffer; // [esp+50h] [ebp-414h]
  OLECHAR psz; // [esp+258h] [ebp-20Ch]
  char v25; // [esp+25Ah] [ebp-20Ah]

  psz = 0;
  memset(&v25, 0, 0x206u);
  v4 = GetMenuItemID(hMenu, nPos);
  v5 = v4;
  if ( v4 != 40621 && v4 != 40622 && v4 != 40623 && v4 != 40625 && v4 != 40743 && v4 != 40744 )
    return HandleCmdHandler(&CMainWnd::gCmdHandler, hWnd, v4, 0);
  v17.cbSize = 28;
  v17.fMask = 8;
  GetMenuInfo(hMenu, &v17);
  switch ( v5 )
  {
    case 0x9EADu:
      if ( WTSDisconnectSession(0, v17.dwMenuData, 0) )
        goto LABEL_32;
      ReportMsg(L"Error disconnecting session", ghMainWnd);
      return 0;
    case 0x9EAEu:
      if ( WTSLogoffSessio(0, v17.dwMenuData, 0) )
        goto LABEL_32;
      ReportMsg(L"Error logging off session", ghMainWnd);
      return 0;
    case 0x9EAFu:
      DialogBoxParamW(ghInstance, L"SENDMESSAGE", ghMainWnd, sub_FD85F0, v17.dwMenuData);
      goto LABEL_32;
    case 0x9EB1u:
      DialogBoxParamW(ghInstance, L"TSINFO", ghMainWnd, sub_FD8DE0, v17.dwMenuData);
      goto LABEL_32;
    case 0x9F27u:
      if ( WTSQuerySessionInformationW(0, v17.dwMenuData, WTSUserName, &ppBuffer, &nSize) )
      {
        v13 = hWnd;
        v20 = 0;
        v12 = 20;
        v14 = L"Enter the selected user's password";
        v15 = L"Process Explorer Connect Password";
        v16 = 0;
        do
        {
          v7 = CredUIPromptForCredentialsW(&v12, &gszNullString, 0, 1326, ppBuffer, nSize, &psz, 260, &v20, 1310850);
          if ( !v7 )
          {
            v8 = *_bstr_t::_bstr_t(&v19, &psz);
            if ( v8 )
              v9 = *v8;
            else
              v9 = 0;
            v10 = WinStationConnectW(0, v17.dwMenuData, -1, v9, 1);
            _bstr_t::_Free(&v19);
            if ( v10 )
              goto LABEL_32;
            v7 = GetLastError();
          }
        }
        while ( v7 == 1326 );
      }
      else
      {
        v7 = GetLastError();
      }
      if ( !v7 )
        goto LABEL_32;
      SetLastError(v7);
      ReportMsg(L"Error connecting to session", ghMainWnd);
      result = 0;
      break;
    case 0x9F28u:
      v11 = GetCurrentProcessId();
      gpfnProcessIdToSessionId(v11, &v21);
      if ( WTSGetActiveConsoleSessionId() == v21 )
      {
        ReportMsg(L"Remote control is not supported from a console session", ghMainWnd);
        result = 0;
      }
      else
      {
        nSize = 260;
        GetComputerNameW(&Buffer, &nSize);
        if ( WinStationShadow(0, &Buffer, v17.dwMenuData, 112, 2) )
        {
LABEL_32:
          result = 0;
        }
        else
        {
          ReportMsg(L"Error starting remote control", ghMainWnd);
          result = 0;
        }
      }
      break;
    default:
      goto LABEL_32;
  }
  return result;
}
// 102C83C: using guessed type int __stdcall CredUIPromptForCredentialsW(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 1040F14: using guessed type wchar_t aErrorDisconnec[28];
// 1040F50: using guessed type wchar_t aEnterTheSelect[35];
// 1040F98: using guessed type wchar_t aProcessExplore_5[34];
// 1040FDC: using guessed type wchar_t aErrorConnectin[28];
// 1041018: using guessed type wchar_t aRemoteControlI[55];
// 1041088: using guessed type wchar_t aErrorStartingR[30];
// 10410C4: using guessed type wchar_t aErrorLoggingOf[26];
// 10410F8: using guessed type wchar_t aSendmessage[12];
// 105E11C: using guessed type struct tagMSGHANDLER CMainWnd::gCmdHandler;
// 106F280: using guessed type int (__stdcall *gpfnProcessIdToSessionId)(_DWORD, _DWORD);
// 106F334: using guessed type int (__stdcall *WTSDisconnectSession)(_DWORD, _DWORD, _DWORD);
// 106F338: using guessed type int (__stdcall *WinStationConnectW)(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 106F33C: using guessed type int (__stdcall *WinStationShadow)(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 106F34C: using guessed type int (__stdcall *WTSLogoffSessio)(_DWORD, _DWORD, _DWORD);

//----- (00FD6470) --------------------------------------------------------
signed int __cdecl CMainWnd::HandleCopyData(HWND hWnd, UINT msg, WPARAM wParam, PCOPYDATASTRUCT lParam)
{
  tagTREEVIEWLISTITEMPARAM *pItemParam; // esi
  signed int ret; // esi
  CHAR *v6; // edi
  CString strData; // [esp+8h] [ebp-34h]
  WINDOWPLACEMENT wndpl; // [esp+Ch] [ebp-30h]

  pItemParam = gpTreeViewListItemParam;
  ATL::CStringT<wchar_t,ATL::StrTraitATL<wchar_t,ATL::ChTraitsCRT<wchar_t>>>::CStringT<wchar_t,ATL::StrTraitATL<wchar_t,ATL::ChTraitsCRT<wchar_t>>>(
    &strData,
    lParam->lpData,
    lParam->cbData);
  if ( pItemParam )
  {
    while ( _wcsicmp(pItemParam->szProcessName2, strData.pszData) )
    {
      pItemParam = pItemParam->m_Prev;
      if ( !pItemParam )
        goto LABEL_4;
    }
    CTreeList::FillTreeViewParam(pItemParam);
    if ( !IsWindowVisible(ghMainWnd) )
    {
      wndpl.length = 44;
      GetWindowPlacement(ghMainWnd, &wndpl);
      ShowWindow(ghMainWnd, 4 * (wndpl.showCmd == 2) + 5);
      SetForegroundWindow(ghMainWnd);
      SetFocus(ghMainWnd);
      gbMainWndMinimized1 = 1;
      gbMainWndMinimized = 0;
    }
    ret = 2;
  }
  else
  {
LABEL_4:
    ret = 1;
  }
  v6 = strData.pszData - 16;
  if ( _InterlockedDecrement(strData.pszData - 1) <= 0 )
    (*(**v6 + 4))(v6);
  return ret;
}
// 106A389: using guessed type char gbMainWndMinimized;
// 106A393: using guessed type char gbMainWndMinimized1;

//----- (00FD6570) --------------------------------------------------------
int __cdecl CMainWnd::HandleMsg7F3(HWND a1, unsigned int a2, unsigned int a3, int a4)
{
  CTreeList *v4; // eax
  HICON v5; // ST08_4
  struct _IMAGELIST *v6; // eax

  v4 = CTreeList::GetTreeList(ghWndTreeListView);
  if ( *(a4 + 52) )
  {
    v5 = *(a4 + 52);
    v6 = CTreeList::GetImageList(v4);
    *(a4 + 64) = ImageList_ReplaceIcon(v6, -1, v5);
  }
  else
  {
    *(a4 + 64) = 0;
  }
  return 0;
}

//----- (00FD65C0) --------------------------------------------------------
int __cdecl CMainWnd::HandleMsg7E8(int a1, int a2, HWND hWnd)
{
  HWND v3; // esi
  LRESULT v4; // edi

  if ( hWnd == 101 )
  {
    v3 = ghWndTreeListView;
  }
  else if ( hWnd == 102 )
  {
    v3 = ghWndHandlesListCtrl;
  }
  else if ( (hWnd - 102) == 2 )
  {
    v3 = ghWndDllsListCtrl;
  }
  else
  {
    v3 = hWnd;
  }
  v4 = -1;
  if ( !gConfig.bShowNewProcesses )
  {
    v4 = SendMessageW(v3, 0x100Cu, 0xFFFFFFFF, 2);
    if ( !SendMessageW(v3, 0x10B6u, v4, 0) )
      v4 = -1;
  }
  if ( hWnd == 101 )
    sub_FF6020(gpTreeViewListItemParam);
  sub_FBFAA0(hWnd);
  if ( v4 != -1 )
    SendMessageW(v3, 0x1013u, v4, 0);
  return 0;
}

//----- (00FD6660) --------------------------------------------------------
int __cdecl CMainWnd::HandleMsg7E9(HWND hWnd, UINT msg, WPARAM wParam, LPARAM lParam)
{
  HMENU v4; // eax
  HMENU v5; // eax
  int v6; // ST14_4
  HMENU v7; // edi
  HMENU v8; // eax
  HMENU v9; // eax
  HMENU v10; // eax
  HMODULE v12; // eax
  void (*EndMenu)(void); // eax
  struct tagPOINT Point; // [esp+4h] [ebp-38h]
  WINDOWPLACEMENT wndpl; // [esp+Ch] [ebp-30h]

  if ( lParam == 123 )
    goto LABEL_4;
  if ( lParam != 513 )
  {
    if ( lParam != 517 )
      return 0;
LABEL_4:
    GetCursorPos(&Point);
    SetForegroundWindow(hWnd);
    v4 = LoadMenuW(ghInstance, L"TRAYMENU");
    v5 = GetSubMenu(v4, 0);
    v6 = gdwMenuItemCountAppendedInRuntime;
    v7 = v5;
    v8 = GetMenu(hWnd);
    v9 = GetSubMenu(v8, 0);
    v10 = GetSubMenu(v9, v6);
    InsertMenuW(v7, 0, 0x410u, v10, L"S&hutdown");
    TrackPopupMenu(v7, 0, Point.x, Point.y, 0, hWnd, 0);
    return 0;
  }
  v12 = GetModuleHandleW(L"user32.dll");
  EndMenu = GetProcAddress(v12, "EndMenu");
  if ( EndMenu )
    EndMenu();
  else
    SendMessageW(hWnd, WM_CANCELMODE, 0, 0);
  wndpl.length = 44;
  GetWindowPlacement(ghMainWnd, &wndpl);
  if ( !IsWindowVisible(ghMainWnd) || wndpl.showCmd == SW_SHOWMINIMIZED )
  {
LABEL_14:
    gbMainWndMinimized1 = 1;
    Command_OpenProcExp();
    return 0;
  }
  if ( sub_FD7A60(ghWndTreeListView) )
  {
    if ( gConfig.bHideWhenMinimized )
    {
      CMainWnd::Hide(ghMainWnd);
      return 0;
    }
    goto LABEL_14;
  }
  SetForegroundWindow(ghMainWnd);
  return 0;
}
// 106A393: using guessed type char gbMainWndMinimized1;

//----- (00FD67F0) --------------------------------------------------------
LRESULT __cdecl CMainWnd::HandleSysCommand(HWND hWnd, UINT Msg, WPARAM wParam, LPARAM lParam)
{
  if ( !gConfig.bHideWhenMinimized || wParam != SC_MINIMIZE )
    return DefWindowProcW(hWnd, Msg, wParam, lParam);
  gbMainWndMinimized = 1;
  CMainWnd::Hide(hWnd);
  return 0;
}
// 106A389: using guessed type char gbMainWndMinimized;

//----- (00FD6830) --------------------------------------------------------
int __cdecl CMainWnd::HandleMsg7EB(int a1, int a2, WPARAM wParam, WPARAM wParam_1)
{
  CTreeList *v4; // eax
  int result; // eax
  RECT Rect; // [esp+0h] [ebp-14h]

  if ( wParam == -2 )
  {
    v4 = CTreeList::GetTreeList(ghWndTreeListView);
    CTreeList::RefreshHeaderItem(v4, wParam_1);
    result = 0;
  }
  else
  {
    if ( wParam_1 == -1 )
    {
      SendMessageW(ghWndTreeListView, 0x1015u, wParam, wParam);
    }
    else
    {
      sub_FBA880(ghWndTreeListView, wParam, wParam_1, &Rect);
      Rect.right += Rect.left;
      Rect.bottom += Rect.top;
      InvalidateRect(ghWndTreeListView, &Rect, 0);
    }
    result = 0;
  }
  return result;
}

//----- (00FD68E0) --------------------------------------------------------
int sub_FD68E0(wchar_t *Dst, wchar_t *Format, ...)
{
  va_list ArgList; // [esp+10h] [ebp+10h]

  va_start(ArgList, Format);
  return vswprintf_s(Dst, 0x410u, Format, ArgList);
}

//----- (00FD6900) --------------------------------------------------------
CString *__thiscall ATL::CStringT<wchar_t,ATL::StrTraitATL<wchar_t,ATL::ChTraitsCRT<wchar_t>>>::CStringT<wchar_t,ATL::StrTraitATL<wchar_t,ATL::ChTraitsCRT<wchar_t>>>(CString *this, LPCSTR lpMultiByteStr, int cbMultiByte)
{
  CString *v3; // esi
  IAtlStringMgr *v4; // ecx
  int v5; // eax
  int v6; // edi

  v3 = this;
  v4 = ATL::StrTraitATL<wchar_t,ATL::ChTraitsCRT<wchar_t>>::GetDefaultManager();
  if ( !v4 )
    ATL::AtlThrowImpl(E_FAIL);
  v3->pszData = ((v4->vtptr->GetNilData)() + 16);
  if ( cbMultiByte > 0 )
  {
    if ( !lpMultiByteStr )
      goto LABEL_15;
    v5 = MultiByteToWideChar(3u, 0, lpMultiByteStr, cbMultiByte, 0, 0);
    v6 = v5;
    if ( v5 < 0 )
      ATL::AtlThrowImpl(E_INVALIDARG);
    if ( ((*(v3->pszData - 2) - v5) | (1 - *(v3->pszData - 1))) < 0 )
      ATL::CSimpleStringT<wchar_t,0>::PrepareWrite2(v3, v5);
    MultiByteToWideChar(3u, 0, lpMultiByteStr, cbMultiByte, v3->pszData, v6);
    if ( v6 > *(v3->pszData - 2) )
LABEL_15:
      ATL::AtlThrowImpl(E_INVALIDARG);
    *(v3->pszData - 3) = v6;
    *&v3->pszData[2 * v6] = 0;
  }
  return v3;
}

//----- (00FD69F0) --------------------------------------------------------
HBRUSH __stdcall DlgSelectColor(HWND hDlg, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
  COLORREF v4; // esi
  HBRUSH result; // eax
  COLORREF v6; // esi
  BOOL v7; // ST08_4
  BOOL v8; // ST08_4
  BOOL v9; // ST08_4
  BOOL v10; // ST08_4
  BOOL v11; // ST08_4
  BOOL v12; // ST08_4
  BOOL v13; // ST08_4
  BOOL v14; // ST08_4
  BOOL v15; // ST08_4
  BOOL v16; // ST08_4
  UINT v17; // eax
  UINT v18; // eax
  UINT v19; // eax
  UINT v20; // eax
  UINT v21; // eax
  UINT v22; // eax
  UINT v23; // eax
  UINT v24; // eax
  UINT v25; // eax
  UINT v26; // eax
  HWND v27; // eax
  HWND v28; // eax
  HWND v29; // eax
  HWND v30; // eax
  HWND v31; // eax
  HWND v32; // eax
  HWND v33; // eax
  HWND v34; // eax
  HWND v35; // eax
  HWND v36; // eax
  HWND v37; // eax
  HWND v38; // eax
  HWND v39; // eax

  if ( uMsg == WM_INITDIALOG )
  {
    gColorOwnProcessStatic = gConfig.ColorOwn;
    gColorServices = gConfig.ColorService;
    gColorRelocatedDlls = gConfig.ColorRelocatedDlls;
    gColorJobs = gConfig.ColorJobs;
    gColorDotNetProcesses = gConfig.ColorNet;
    gColorNewObjectes = gConfig.ColorNewProc;
    gColorDeletedObjects = gConfig.ColorDelProc;
    gColorPackedImages = gConfig.ColorPacked;
    gColorPagingListsStandby = gConfig.ColorGraphBk;
    gColorWSShared = gConfig.ColorImmersive;
    gColorSuspendedProcess = gConfig.ColorSuspend;
    gColorProtectedProcess = gConfig.ColorProtected;
    CheckDlgButton(hDlg, IDD_CHOOSECOLORS_CHECKBOX_DELETED_OBJECTS, gConfig.bHighlightDelProc != 0);
    CheckDlgButton(hDlg, IDD_CHOOSECOLORS_CHECKBOX_NEW_OBJECTS, gConfig.bHighlightNewProc != 0);
    CheckDlgButton(hDlg, IDD_CHOOSECOLORS_CHECKBOX_OWN_PROCESSES, gConfig.bHighlightOwnProcesses != 0);
    CheckDlgButton(hDlg, IDD_CHOOSECOLORS_CHECKBOX_SERVICES, gConfig.bHighlightServices != 0);
    CheckDlgButton(hDlg, IDD_CHOOSECOLORS_CHECKBOX_RELOCATED_DLLS, gConfig.bHighlightRelocatedDlls != 0);
    CheckDlgButton(hDlg, IDD_CHOOSECOLORS_CHECKBOX_PACKED_IMAGES, gConfig.bHighlightPacked != 0);
    CheckDlgButton(hDlg, IDD_CHOOSECOLORS_CHECKBOX_SUSPENDED_PROCESSES, gConfig.bHighlightSuspend != 0);
    CheckDlgButton(hDlg, IDD_CHOOSECOLORS_CHECKBOX_PROTECTED_PROCESS, gConfig.bHighlightProtected != 0);
    v27 = GetDlgItem(hDlg, IDD_CHOOSECOLORS_CHECKBOX_IMMERSIVE_PROCESS);
    EnableWindow(v27, 0);
    if ( gdwVersion >= 1 && IsBuiltinAdministrative() )
    {
      v28 = GetDlgItem(hDlg, IDD_CHOOSECOLORS_CHECKBOX_PROTECTED_PROCESS);
      EnableWindow(v28, 1);
      v29 = GetDlgItem(hDlg, IDD_CHOOSECOLORS_STATIC_PROTECTED_PROCESS);
      EnableWindow(v29, 1);
      v30 = GetDlgItem(hDlg, IDD_CHOOSECOLORS_BUTTON_PROTECTED_PROCESS_CHANGE);
      EnableWindow(v30, 1);
    }
    if ( *IsProcessInJob )
    {
      v31 = GetDlgItem(hDlg, IDD_CHOOSECOLORS_CHECKBOX_JOBS);
      EnableWindow(v31, 1);
      v32 = GetDlgItem(hDlg, IDD_CHOOSECOLORS_BUTTON_JOBS_CHANGE);
      EnableWindow(v32, 1);
      CheckDlgButton(hDlg, IDD_CHOOSECOLORS_CHECKBOX_JOBS, gConfig.bHighlightJobs != 0);
    }
    v33 = GetDlgItem(hDlg, IDD_CHOOSECOLORS_STATIC_JOBS);
    EnableWindow(v33, 1);
    if ( IsImmersiveProcess )
    {
      v34 = GetDlgItem(hDlg, IDD_CHOOSECOLORS_CHECKBOX_IMMERSIVE_PROCESS);
      EnableWindow(v34, 1);
      v35 = GetDlgItem(hDlg, IDD_CHOOSECOLORS_BUTTON_IMMERSIVE_PROCESS_CHANGE);
      EnableWindow(v35, 1);
      CheckDlgButton(hDlg, IDD_CHOOSECOLORS_CHECKBOX_IMMERSIVE_PROCESS, gConfig.bHighlightImmersive != 0);
    }
    v36 = GetDlgItem(hDlg, IDD_CHOOSECOLORS_STATIC_IMMERSIVE_PROCESS);
    EnableWindow(v36, 1);
    if ( gNetClrMemoryPerfInfoLoaded )
    {
      v37 = GetDlgItem(hDlg, IDD_CHOOSECOLORS_CHECKBOX_DOTNET_PROCESSES);
      EnableWindow(v37, 1);
      v38 = GetDlgItem(hDlg, IDD_CHOOSECOLORS_BUTTON_DOTNET_PROCESSES_CHANGE);
      EnableWindow(v38, 1);
      CheckDlgButton(hDlg, IDD_CHOOSECOLORS_CHECKBOX_DOTNET_PROCESSES, gConfig.bHighliteNetProcess != 0);
    }
    v39 = GetDlgItem(hDlg, IDD_CHOOSECOLORS_STATIC_DOTNET_PROCESSES);
    EnableWindow(v39, 1);
    result = 1;
  }
  else
  {
    if ( uMsg != WM_COMMAND )
    {
      if ( uMsg == WM_CTLCOLORSTATIC )
      {
        if ( lParam == GetDlgItem(hDlg, IDD_CHOOSECOLORS_STATIC_OWN_PROCESSES) )
        {
          SetBkColor(wParam, gColorOwnProcessStatic);
          v4 = gColorOwnProcessStatic;
          if ( gBrushOfOwnProcessStatic )
            DeleteObject(gBrushOfOwnProcessStatic);
          result = CreateSolidBrush(v4);
          gBrushOfOwnProcessStatic = result;
          return result;
        }
        if ( lParam == GetDlgItem(hDlg, IDD_CHOOSECOLORS_STATIC_IMMERSIVE_PROCESS) )
        {
          SetBkColor(wParam, gColorWSShared);
          v6 = gColorWSShared;
          if ( gBrushImmsiveProcess )
            DeleteObject(gBrushImmsiveProcess);
          result = CreateSolidBrush(v6);
          gBrushImmsiveProcess = result;
          return result;
        }
        if ( lParam == GetDlgItem(hDlg, IDD_CHOOSECOLORS_STATIC_SERVICES) )
        {
          SetBkColor(wParam, gColorServices);
          return BrushFromColor(gColorServices, &gBrushServices);
        }
        if ( lParam == GetDlgItem(hDlg, IDD_CHOOSECOLORS_STATIC_GRAPH_BACKGROUND) )
        {
          SetTextColor(wParam, 255 - gColorPagingListsStandby);
          SetBkColor(wParam, gColorPagingListsStandby);
          return BrushFromColor(gColorPagingListsStandby, &gBrushPagingListsStandby);
        }
        if ( lParam == GetDlgItem(hDlg, IDD_CHOOSECOLORS_STATIC_RELOCATED_DLLS) )
        {
          SetBkColor(wParam, gColorRelocatedDlls);
          return BrushFromColor(gColorRelocatedDlls, &gBrushRelocatedDlls);
        }
        if ( lParam == GetDlgItem(hDlg, IDD_CHOOSECOLORS_STATIC_PACKED_IMAGES) )
        {
          SetBkColor(wParam, gColorPackedImages);
          return BrushFromColor(gColorPackedImages, &gBrushPackedImages);
        }
        if ( lParam == GetDlgItem(hDlg, IDD_CHOOSECOLORS_STATIC_SUSPENDED_PROCESSES) )
        {
          SetBkColor(wParam, gColorSuspendedProcess);
          return BrushFromColor(gColorSuspendedProcess, &gBrushSuspendedProcess);
        }
        if ( lParam == GetDlgItem(hDlg, IDD_CHOOSECOLORS_STATIC_JOBS) )
        {
          SetBkColor(wParam, gColorJobs);
          return BrushFromColor(gColorJobs, &gBrushJobs);
        }
        if ( lParam == GetDlgItem(hDlg, IDD_CHOOSECOLORS_STATIC_DOTNET_PROCESSES) )
        {
          SetBkColor(wParam, gColorDotNetProcesses);
          return BrushFromColor(gColorDotNetProcesses, &gBrushDotNetProcesses);
        }
        if ( lParam == GetDlgItem(hDlg, IDD_CHOOSECOLORS_STATIC_NEW_OBJECTS) )
        {
          SetBkColor(wParam, gColorNewObjectes);
          return BrushFromColor(gColorNewObjectes, &gBrushNewObjects);
        }
        if ( lParam == GetDlgItem(hDlg, IDD_CHOOSECOLORS_STATIC_DELETED_OBJECTS) )
        {
          SetBkColor(wParam, gColorDeletedObjects);
          return BrushFromColor(gColorDeletedObjects, &gBrushDeletedObjects);
        }
        if ( lParam == GetDlgItem(hDlg, IDD_CHOOSECOLORS_STATIC_PROTECTED_PROCESS) && IsWindowEnabled(lParam) )
        {
          SetBkColor(wParam, gColorProtectedProcess);
          return BrushFromColor(gColorProtectedProcess, &gBrushDeletedObjects);
        }
      }
      return 0;
    }
    if ( !(wParam >> 16) )
    {
      switch ( wParam )
      {
        case IDD_CHOOSECOLORS_STATIC_OWN_PROCESSES:
          v7 = IsDlgButtonChecked(hDlg, IDD_CHOOSECOLORS_CHECKBOX_OWN_PROCESSES) != 1;
          CheckDlgButton(hDlg, IDD_CHOOSECOLORS_CHECKBOX_OWN_PROCESSES, v7);
          break;
        case IDD_CHOOSECOLORS_STATIC_SERVICES:
          v8 = IsDlgButtonChecked(hDlg, IDD_CHOOSECOLORS_CHECKBOX_SERVICES) != 1;
          CheckDlgButton(hDlg, IDD_CHOOSECOLORS_CHECKBOX_SERVICES, v8);
          break;
        case IDD_CHOOSECOLORS_STATIC_RELOCATED_DLLS:
          v10 = IsDlgButtonChecked(hDlg, IDD_CHOOSECOLORS_CHECKBOX_RELOCATED_DLLS) != 1;
          CheckDlgButton(hDlg, IDD_CHOOSECOLORS_CHECKBOX_RELOCATED_DLLS, v10);
          break;
        case IDD_CHOOSECOLORS_STATIC_JOBS:
          v11 = IsDlgButtonChecked(hDlg, IDD_CHOOSECOLORS_CHECKBOX_JOBS) != 1;
          CheckDlgButton(hDlg, IDD_CHOOSECOLORS_CHECKBOX_JOBS, v11);
          break;
        case IDD_CHOOSECOLORS_STATIC_DOTNET_PROCESSES:
          v12 = IsDlgButtonChecked(hDlg, IDD_CHOOSECOLORS_CHECKBOX_DOTNET_PROCESSES) != 1;
          CheckDlgButton(hDlg, IDD_CHOOSECOLORS_CHECKBOX_DOTNET_PROCESSES, v12);
          break;
        case IDD_CHOOSECOLORS_STATIC_DELETED_OBJECTS:
          v15 = IsDlgButtonChecked(hDlg, IDD_CHOOSECOLORS_CHECKBOX_DELETED_OBJECTS) != 1;
          CheckDlgButton(hDlg, IDD_CHOOSECOLORS_CHECKBOX_DELETED_OBJECTS, v15);
          break;
        case IDD_CHOOSECOLORS_STATIC_NEW_OBJECTS:
          v14 = IsDlgButtonChecked(hDlg, IDD_CHOOSECOLORS_CHECKBOX_NEW_OBJECTS) != 1;
          CheckDlgButton(hDlg, IDD_CHOOSECOLORS_CHECKBOX_NEW_OBJECTS, v14);
          break;
        case IDD_CHOOSECOLORS_STATIC_PACKED_IMAGES:
          v9 = IsDlgButtonChecked(hDlg, IDD_CHOOSECOLORS_CHECKBOX_PACKED_IMAGES) != 1;
          CheckDlgButton(hDlg, IDD_CHOOSECOLORS_CHECKBOX_PACKED_IMAGES, v9);
          break;
        case IDS_COMPANY_NAME:
          v13 = IsDlgButtonChecked(hDlg, IDD_CHOOSECOLORS_CHECKBOX_SUSPENDED_PROCESSES) != 1;
          CheckDlgButton(hDlg, IDD_CHOOSECOLORS_CHECKBOX_SUSPENDED_PROCESSES, v13);
          break;
        case IDD_ABOUT_STATIC_ADDRESS:
          v16 = IsDlgButtonChecked(hDlg, IDD_CHOOSECOLORS_CHECKBOX_PROTECTED_PROCESS) != 1;
          CheckDlgButton(hDlg, IDD_CHOOSECOLORS_CHECKBOX_PROTECTED_PROCESS, v16);
          break;
        default:
          break;
      }
    }
    if ( wParam <= IDD_CHOOSECOLORS_BUTTON_OWN_PROCESSES_CHANGE )
    {
      switch ( wParam )
      {
        case IDD_CHOOSECOLORS_BUTTON_OWN_PROCESSES_CHANGE:
          return SelectColor(hDlg, &gColorOwnProcessStatic);
        case 1u:
          gConfig.ColorJobs = gColorJobs;
          DeleteObject(gBrushJobs);
          v17 = IsDlgButtonChecked(hDlg, IDD_CHOOSECOLORS_CHECKBOX_JOBS);
          gConfig.ColorRelocatedDlls = gColorRelocatedDlls;
          gConfig.bHighlightJobs = v17 == 1;
          DeleteObject(gBrushRelocatedDlls);
          v18 = IsDlgButtonChecked(hDlg, IDD_CHOOSECOLORS_CHECKBOX_RELOCATED_DLLS);
          gConfig.ColorOwn = gColorOwnProcessStatic;
          gConfig.bHighlightRelocatedDlls = v18 == 1;
          DeleteObject(gBrushOfOwnProcessStatic);
          v19 = IsDlgButtonChecked(hDlg, IDD_CHOOSECOLORS_CHECKBOX_OWN_PROCESSES);
          gConfig.ColorService = gColorServices;
          gConfig.bHighlightOwnProcesses = v19 == 1;
          DeleteObject(gBrushServices);
          v20 = IsDlgButtonChecked(hDlg, IDD_CHOOSECOLORS_CHECKBOX_SERVICES);
          gConfig.ColorNet = gColorDotNetProcesses;
          gConfig.bHighlightServices = v20 == 1;
          DeleteObject(gBrushDotNetProcesses);
          v21 = IsDlgButtonChecked(hDlg, IDD_CHOOSECOLORS_CHECKBOX_DOTNET_PROCESSES);
          gConfig.ColorSuspend = gColorSuspendedProcess;
          gConfig.bHighliteNetProcess = v21 == 1;
          DeleteObject(gBrushSuspendedProcess);
          v22 = IsDlgButtonChecked(hDlg, IDD_CHOOSECOLORS_CHECKBOX_SUSPENDED_PROCESSES);
          gConfig.ColorNewProc = gColorNewObjectes;
          gConfig.bHighlightSuspend = v22 == 1;
          DeleteObject(gBrushNewObjects);
          v23 = IsDlgButtonChecked(hDlg, IDD_CHOOSECOLORS_CHECKBOX_NEW_OBJECTS);
          gConfig.ColorDelProc = gColorDeletedObjects;
          gConfig.bHighlightNewProc = v23 == 1;
          DeleteObject(gBrushDeletedObjects);
          v24 = IsDlgButtonChecked(hDlg, IDD_CHOOSECOLORS_CHECKBOX_DELETED_OBJECTS);
          gConfig.ColorPacked = gColorPackedImages;
          gConfig.bHighlightDelProc = v24 == 1;
          DeleteObject(gBrushPackedImages);
          gConfig.bHighlightPacked = IsDlgButtonChecked(hDlg, IDD_CHOOSECOLORS_CHECKBOX_PACKED_IMAGES) == 1;
          gConfig.ColorGraphBk = gColorPagingListsStandby;
          DeleteObject(gBrushPagingListsStandby);
          v25 = IsDlgButtonChecked(hDlg, IDD_CHOOSECOLORS_CHECKBOX_IMMERSIVE_PROCESS);
          gConfig.ColorImmersive = gColorWSShared;
          gConfig.bHighlightImmersive = v25 == 1;
          DeleteObject(gBrushImmsiveProcess);
          v26 = IsDlgButtonChecked(hDlg, IDD_CHOOSECOLORS_CHECKBOX_PROTECTED_PROCESS);
          gConfig.ColorProtected = gColorProtectedProcess;
          gConfig.bHighlightProtected = v26 == 1;
          DeleteObject(ho);
          SetEvent(ghTimerRefreshEvent);
          break;
        case IDC_MYICON:
          break;
        default:
          return 0;
      }
      EndDialog(hDlg, 0);
      return 0;
    }
    switch ( wParam )
    {
      case IDD_CHOOSECOLORS_BUTTON_SERVICES_CHANGE:
        result = SelectColor(hDlg, &gColorServices);
        break;
      case IDD_CHOOSECOLORS_BUTTON_RELOCATED_DLLS_CHANGE:
        result = SelectColor(hDlg, &gColorRelocatedDlls);
        break;
      case IDD_CHOOSECOLORS_BUTTON_JOBS_CHANGE:
        result = SelectColor(hDlg, &gColorJobs);
        break;
      case IDD_CHOOSECOLORS_BUTTON_DELETE_OBJECTS_CHANGE:
        result = SelectColor(hDlg, &gColorDeletedObjects);
        break;
      case IDD_CHOOSECOLORS_BUTTON_DOTNET_PROCESSES_CHANGE:
        result = SelectColor(hDlg, &gColorDotNetProcesses);
        break;
      case IDD_CHOOSECOLORS_BUTTON_NEW_OBJECTS_CHANGE:
        result = SelectColor(hDlg, &gColorNewObjectes);
        break;
      case IDD_CHOOSECOLORS_BUTTON_PACKED_IMAGES_CHANGE:
        result = SelectColor(hDlg, &gColorPackedImages);
        break;
      case IDC_SYSINFO_MEMORY_STATIC_PAGING_LISTS_STANDBY_VALUE:
        SelectColor(hDlg, &gColorPagingListsStandby);
        result = 1;
        break;
      case IDS_WS_SHARED:
        result = SelectColor(hDlg, &gColorWSShared);
        break;
      case IDD_CHOOSECOLORS_BUTTON_SUSPENDED_PROCESSES_CHANGE:
        result = SelectColor(hDlg, &gColorSuspendedProcess);
        break;
      case IDD_CHOOSECOLORS_BUTTON_PROTECTED_PROCESS_CHANGE:
        result = SelectColor(hDlg, &gColorProtectedProcess);
        break;
      case IDD_CHOOSECOLORS_BUTTON_DEFAULTS:
        gColorOwnProcessStatic = 0xFFD0D0;
        gColorServices = 0xD0D0FF;
        gColorRelocatedDlls = 0xA0FFFF;
        gColorJobs = 0x6CD0;
        gColorDotNetProcesses = 0xA0FFFF;
        gColorWSShared = 0xEAEA00;
        gColorNewObjectes = 0x46FF46;
        gColorDeletedObjects = 0x4646FF;
        gColorPackedImages = 0xFF0080;
        gColorSuspendedProcess = 0x808080;
        gColorProtectedProcess = 0x8000FF;
        gColorPagingListsStandby = GetSysColor(COLOR_BTNFACE);
        InvalidateRect(hDlg, 0, 0);
        result = 1;
        break;
      default:
        return 0;
    }
  }
  return result;
}
// 1064E54: using guessed type int gdwVersion;
// 106A098: using guessed type char gNetClrMemoryPerfInfoLoaded;
// 107BA4C: using guessed type int (__stdcall *IsImmersiveProcess)(_DWORD);

//----- (00FD74D0) --------------------------------------------------------
int __stdcall PropColumnSetsForStatusBar(HWND hWnd, UINT msg, WPARAM wParam, LPARAM lParam)
{
  double v4; // st6
  double v5; // st7
  __int16 v6; // ax
  char v8; // [esp+8h] [ebp-64h]
  char v9; // [esp+10h] [ebp-5Ch]
  char v10; // [esp+18h] [ebp-54h]

  if ( msg == 78 )
  {
    if ( *(lParam + 8) == -202 )
    {
      gConfig.dwStatusBarColumns = 0;
      if ( IsDlgButtonChecked(hWnd, 1107) == 1 )
        gConfig.dwStatusBarColumns |= 1u;
      if ( IsDlgButtonChecked(hWnd, 1114) == 1 )
        gConfig.dwStatusBarColumns |= 2u;
      if ( IsDlgButtonChecked(hWnd, 1109) == 1 )
        gConfig.dwStatusBarColumns |= 4u;
      if ( IsDlgButtonChecked(hWnd, 1115) == 1 )
        gConfig.dwStatusBarColumns |= 8u;
      if ( IsDlgButtonChecked(hWnd, 1108) == 1 )
        gConfig.dwStatusBarColumns |= 0x10u;
      if ( IsDlgButtonChecked(hWnd, 1111) == 1 )
        gConfig.dwStatusBarColumns |= 0x20u;
      if ( IsDlgButtonChecked(hWnd, 1112) == 1 )
        gConfig.dwStatusBarColumns |= 0x40u;
      if ( IsDlgButtonChecked(hWnd, 1116) == 1 )
        gConfig.dwStatusBarColumns |= 0x80u;
      if ( IsDlgButtonChecked(hWnd, 1110) == 1 )
        gConfig.dwStatusBarColumns |= 0x100u;
      if ( IsDlgButtonChecked(hWnd, 1117) == 1 )
        gConfig.dwStatusBarColumns |= 0x200u;
      if ( IsDlgButtonChecked(hWnd, 1113) == 1 )
        gConfig.dwStatusBarColumns |= 0x400u;
      if ( IsDlgButtonChecked(hWnd, 1118) == 1 )
        gConfig.dwStatusBarColumns |= 0x800u;
      if ( IsDlgButtonChecked(hWnd, 1325) == 1 )
        gConfig.dwStatusBarColumns |= 0x1000u;
      if ( IsDlgButtonChecked(hWnd, 1119) == 1 )
        gConfig.dwStatusBarColumns |= 0x2000u;
      if ( IsDlgButtonChecked(hWnd, 1120) == 1 )
        gConfig.dwStatusBarColumns |= 0x4000u;
      memset(&v10, 0, 0x50u);
      sub_1000410(v5, v4, 0, &v10, &v9, &v8);
      CMainWnd::InitStatusBar(ghWndStatusBar);
      SetEvent(ghRefreshEventHandle);
      return 1;
    }
    return 0;
  }
  if ( msg != 272 )
    return 0;
  v6 = gConfig.dwStatusBarColumns;
  if ( gConfig.dwStatusBarColumns & 1 )
  {
    CheckDlgButton(hWnd, 1107, 1u);
    v6 = gConfig.dwStatusBarColumns;
  }
  if ( v6 & 2 )
  {
    CheckDlgButton(hWnd, 1114, 1u);
    v6 = gConfig.dwStatusBarColumns;
  }
  if ( v6 & 4 )
  {
    CheckDlgButton(hWnd, 1109, 1u);
    v6 = gConfig.dwStatusBarColumns;
  }
  if ( v6 & 8 )
  {
    CheckDlgButton(hWnd, 1115, 1u);
    v6 = gConfig.dwStatusBarColumns;
  }
  if ( v6 & 0x10 )
  {
    CheckDlgButton(hWnd, 1108, 1u);
    v6 = gConfig.dwStatusBarColumns;
  }
  if ( v6 & 0x20 )
  {
    CheckDlgButton(hWnd, 1111, 1u);
    v6 = gConfig.dwStatusBarColumns;
  }
  if ( v6 & 0x40 )
  {
    CheckDlgButton(hWnd, 1112, 1u);
    v6 = gConfig.dwStatusBarColumns;
  }
  if ( (v6 & 0x80u) != 0 )
  {
    CheckDlgButton(hWnd, 1116, 1u);
    v6 = gConfig.dwStatusBarColumns;
  }
  if ( v6 & 0x100 )
  {
    CheckDlgButton(hWnd, 1110, 1u);
    v6 = gConfig.dwStatusBarColumns;
  }
  if ( v6 & 0x200 )
  {
    CheckDlgButton(hWnd, 1117, 1u);
    v6 = gConfig.dwStatusBarColumns;
  }
  if ( v6 & 0x400 )
  {
    CheckDlgButton(hWnd, 1113, 1u);
    v6 = gConfig.dwStatusBarColumns;
  }
  if ( v6 & 0x800 )
  {
    CheckDlgButton(hWnd, 1118, 1u);
    v6 = gConfig.dwStatusBarColumns;
  }
  if ( v6 & 0x1000 )
  {
    CheckDlgButton(hWnd, 1325, 1u);
    v6 = gConfig.dwStatusBarColumns;
  }
  if ( v6 & 0x2000 )
  {
    CheckDlgButton(hWnd, 1119, 1u);
    v6 = gConfig.dwStatusBarColumns;
  }
  if ( v6 & 0x4000 )
    CheckDlgButton(hWnd, 1120, 1u);
  return 1;
}

//----- (00FD7810) --------------------------------------------------------
BOOL __stdcall DialogFunc(HWND hDlg, UINT a2, WPARAM a3, LPARAM a4)
{
  BOOL result; // eax
  HWND v5; // eax
  HWND v6; // eax
  WCHAR String; // [esp+4h] [ebp-204h]
  __int16 v8; // [esp+8h] [ebp-200h]

  if ( a2 == 272 )
  {
    wsprintf(&String, L"%d", gConfig.dwHighlightDuration / 1000);
    SetDlgItemTextW(hDlg, 1105, &String);
    v5 = GetDlgItem(hDlg, 1105);
    SendMessageW(v5, 0xC5u, 1u, 0);
    v6 = GetDlgItem(hDlg, 1022);
    SendMessageW(v6, 0x465u, 0, 9);
    result = 1;
  }
  else
  {
    if ( a2 == 273 )
    {
      if ( a3 == 1 )
      {
        GetDlgItemTextW(hDlg, 1105, &String, 2);
        v8 = 0;
        gConfig.dwHighlightDuration = 1000 * _wtoi(&String);
      }
      else if ( a3 != 2 )
      {
        return 0;
      }
      EndDialog(hDlg, 0);
    }
    result = 0;
  }
  return result;
}

//----- (00FD7930) --------------------------------------------------------
void __cdecl sub_FD7930(int a1)
{
  int v1; // eax
  signed __int16 v2; // ax

  if ( *(a1 + 720) != 3 )
  {
    memmove((a1 + 724), (a1 + 720), 4 * *(a1 + 524));
    v1 = *(a1 + 524);
    *(a1 + 720) = 3;
    memmove((a1 + 530), (a1 + 528), 2 * v1);
    v2 = *(a1 + 520);
    if ( !v2 )
      v2 = 200;
    ++*(a1 + 524);
    *(a1 + 528) = v2;
  }
}

//----- (00FD79B0) --------------------------------------------------------
HBRUSH __cdecl BrushFromColor(COLORREF color, HBRUSH *BrushHandle)
{
  HBRUSH result; // eax

  if ( *BrushHandle )
    DeleteObject(*BrushHandle);
  result = CreateSolidBrush(color);
  *BrushHandle = result;
  return result;
}

//----- (00FD79E0) --------------------------------------------------------
char __cdecl sub_FD79E0(char a1)
{
  if ( a1
    || !gConfig.bHideWhenMinimized
    || gConfig.bShowPhysTray
     + gConfig.bShowIoTray
     + gConfig.bTrayCPUHistory
     + gConfig.bShowCommitTray
     + gConfig.bShowNetTray
     + gConfig.bShowGpuHistory
     + gConfig.bShowDiskTray != 1 )
  {
    return 0;
  }
  MessageBoxW(
    ghWndTreeListView,
    L"Because the Hide When Minimized option is selected, you must maintain at least one tray icon so that you can activat"
     "e Process Explorer when it is minimized.",
    L"Process Explorer Error",
    0x10u);
  return 1;
}

//----- (00FD7A60) --------------------------------------------------------
BOOL __cdecl sub_FD7A60(HWND hWnd)
{
  POINT v1; // ST00_8
  struct tagRECT Rect; // [esp+4h] [ebp-14h]

  if ( !IsWindow(hWnd) )
    return 0;
  GetWindowRect(hWnd, &Rect);
  v1.y = Rect.top + (Rect.bottom - Rect.top) / 2;
  v1.x = Rect.left + (Rect.right - Rect.left) / 2;
  return WindowFromPoint(v1) == hWnd;
}

//----- (00FD7AE0) --------------------------------------------------------
int __cdecl SelectColor(HWND hWnd, COLORREF *ColorReturned)
{
  struct tagCHOOSECOLORW cc; // [esp+8h] [ebp-24h]

  cc.hInstance = ghInstance;
  cc.rgbResult = *ColorReturned;
  cc.lStructSize = 36;
  cc.hwndOwner = hWnd;
  cc.lpCustColors = gColorCustomized;
  cc.lCustData = 0;
  cc.Flags = 1;
  if ( ChooseColorW(&cc) )
  {
    *ColorReturned = cc.rgbResult;
    InvalidateRect(ghWndTreeListView, 0, 1);
    InvalidateRect(ghWndDllsListCtrl, 0, 1);
    InvalidateRect(ghWndHandlesListCtrl, 0, 1);
    InvalidateRect(hWnd, 0, 1);
  }
  return 0;
}

//----- (00FD7B70) --------------------------------------------------------
int __stdcall CMainWnd::BackendRefreshThreadProc(struct VOID *a1)
{
  char v1; // bl
  DWORD dwTimeout; // ecx
  DWORD dwRet; // esi
  DWORD v4; // ebx
  float v5; // xmm1_4
  float v6; // xmm1_4
  float v7; // xmm1_4
  float v8; // xmm1_4
  float v9; // xmm1_4
  __int16 v10; // bx
  DWORD dwTimeoutNew; // ecx
  char v13; // [esp+2h] [ebp-76h]
  char v14; // [esp+3h] [ebp-75h]
  MEMORYSTATUSEX MemoryStatusEx; // [esp+4h] [ebp-74h]
  struct _MEMORYSTATUS MemoryStatus; // [esp+44h] [ebp-34h]
  HANDLE Handles[4]; // [esp+64h] [ebp-14h]

  Handles[0] = ghRefreshEventHandle;
  Handles[1] = ghTimerRefreshEvent;
  Handles[2] = ghEvent2;
  Handles[3] = ghEvent3;
  if ( gNetClrMemoryPerfInfoLoaded )
    CoInitialize(0);
  v1 = gbFlagsInProcPropSheet;
  v13 = gbFlagsInProcPropSheet;
  SetErrorMode(SEM_FAILCRITICALERRORS);
  dwTimeout = -1;
  if ( gConfig.dwRefreshRate )
    dwTimeout = gConfig.dwRefreshRate;
  for ( dwRet = WaitForMultipleObjects(4u, Handles, 0, dwTimeout);
        dwRet != 3;
        dwRet = WaitForMultipleObjects(4u, Handles, 0, dwTimeoutNew) )
  {
    if ( dwRet == 2 )
    {
      gdwValue_4F10B8[0] = -1;
      gdwValue_4F10B8[1] = -1;
      gdwValue_4F10B8[2] = -1;
    }
    if ( gConfig.dwRefreshRate || dwRet != WAIT_TIMEOUT )
    {
      if ( ghWndSysinfoPropSheet )
        PostMessageW(ghWndSysinfoPropSheet, WM_TIMER, 0, 0);
      ++gdwRefreshCount;
      if ( v1 )
        PE_RunTrace(&gProperties, 1);
      if ( dwRet != 2 )
      {
        v4 = GetTickCount();
        if ( (v4 - gdwRefreshTickCountLast) > 10000 )
        {
          GraphInfo_Refresh(&gIOGraphInfo);
          GraphInfo_Refresh(&gNetworkGraphInfo);
          GraphInfo_Refresh(&gDiskGraphInfo);
          gdwRefreshTickCountLast = v4;
        }
        if ( GlobalMemoryStatusEx )
        {
          MemoryStatusEx.dwLength = 64;
          GlobalMemoryStatusEx(&MemoryStatusEx);
          v5 = MemoryStatusEx.ullTotalPageFile;
          v6 = v5 * 0.0009765625;
          if ( v6 > gpGraphInfoOfMemory->m_dbMemorySize )
            gpGraphInfoOfMemory->m_dbMemorySize = v6;
          v7 = MemoryStatusEx.ullTotalPhys;
          v8 = v7 * 0.0009765625;
        }
        else
        {
          MemoryStatus.dwLength = 32;
          GlobalMemoryStatus(&MemoryStatus);
          v9 = MemoryStatus.dwTotalPageFile * 0.0009765625;
          if ( v9 > gpGraphInfoOfMemory->m_dbMemorySize )
            gpGraphInfoOfMemory->m_dbMemorySize = v9;
          v8 = MemoryStatus.dwTotalPhys * 0.0009765625;
        }
        if ( v8 > gpGraphInfoOfPhysicalMemory->m_dbMemorySize )
          gpGraphInfoOfPhysicalMemory->m_dbMemorySize = v8;
      }
      v10 = 0;
      v14 = 0;
      if ( dwRet != 2 )
      {
        v14 = CTreeList::InitTreeList(ghWndTreeListView, dwRet == 1);
        PulseEvent(ghTimerRefreshProcPageEventHandle);
        PostMessageW(ghWndCPUGraph, WM_USER, 0, 0);
        PostMessageW(ghWndMemoryGraph, WM_USER, 0, 0);
        PostMessageW(ghWndPhysicalMemoryGraph, WM_USER, 0, 0);
        if ( ghWndIOGraphCtrl )
          PostMessageW(ghWndIOGraphCtrl, WM_USER, 0, 0);
        if ( ghWndNetworkGraph )
          PostMessageW(ghWndNetworkGraph, WM_USER, 0, 0);
        if ( ghWndDiskGraph )
          PostMessageW(ghWndDiskGraph, WM_USER, 0, 0);
        if ( ghWndGPUGraph )
          PostMessageW(ghWndGPUGraph, WM_USER, 0, 0);
      }
      if ( !gbMainWndMinimized )
      {
        if ( gdwProcessIdSelected == -1 )
        {
          gdwValue_4F10B8[0] = -2;
          gdwValue_4F10B8[2] = -1;
          gdwValue_4F10B8[1] = -2;
          if ( gConfig.bShowDllView )
            SendMessageW(ghWndDllsListCtrl, LVM_DELETEALLITEMS, 0, 0);
          else
            SendMessageW(ghWndHandlesListCtrl, LVM_DELETEALLITEMS, 0, 0);
        }
        else if ( gConfig.bShowDllView )
        {
          HIBYTE(v10) = CMainWnd::RefreshDllsView(0, ghWndDllsListCtrl, gdwProcessIdSelected, 0);
        }
        else
        {
          LOBYTE(v10) = CMainWnd::RefreshHandlesView(0, ghWndHandlesListCtrl, gdwProcessIdSelected, 0);
        }
      }
      ++gdwRefreshCount;
      if ( v14 )
        PostMessageW(ghMainWnd, WM_TREEVIEW_SORT, IDC_TREEVIEW_LIST, gConfig.bShowProcessTree);
      if ( v10 )
        PostMessageW(ghMainWnd, WM_TREEVIEW_SORT, IDC_LISTCTRL_HANDLES, 0);
      if ( HIBYTE(v10) )
        PostMessageW(ghMainWnd, WM_TREEVIEW_SORT, IDC_LISTCTRL_DLLS, 0);
      v1 = v13;
    }
    dwTimeoutNew = -1;
    if ( gConfig.dwRefreshRate )
      dwTimeoutNew = gConfig.dwRefreshRate;
  }
  return 0;
}
// 10610B8: using guessed type int gdwValue_4F10B8[3];
// 1065390: using guessed type char gbFlagsInProcPropSheet;
// 106A098: using guessed type char gNetClrMemoryPerfInfoLoaded;
// 106A11C: using guessed type int gdwRefreshCount;
// 106A389: using guessed type char gbMainWndMinimized;
// 106A90C: using guessed type int gdwRefreshTickCountLast;
// 106F2E8: using guessed type int (__stdcall *GlobalMemoryStatusEx)(_DWORD);

//----- (00FD7F60) --------------------------------------------------------
BOOL __stdcall sub_FD7F60(HWND hDlg, UINT a2, WPARAM a3, LPARAM hData)
{
  wchar_t *v4; // eax
  int v6; // eax
  int v7; // eax
  HANDLE v8; // eax
  HANDLE v9; // esi
  HANDLE v10; // ST28_4
  DWORD v11; // ecx
  HINSTANCE v12; // eax
  HWND v13; // eax
  LONG v14; // eax
  unsigned int v15; // esi
  struct HWND__ *v16; // eax
  struct _STARTUPINFOW StartupInfo; // [esp+Ch] [ebp-6F8h]
  struct _PROCESS_INFORMATION ProcessInformation; // [esp+50h] [ebp-6B4h]
  struct tagOFNW v19; // [esp+60h] [ebp-6A4h]
  LPARAM lParam; // [esp+B8h] [ebp-64Ch]
  int v21; // [esp+BCh] [ebp-648h]
  wchar_t *v22; // [esp+C0h] [ebp-644h]
  HANDLE TokenHandle; // [esp+E0h] [ebp-624h]
  HKEY phkResult; // [esp+E4h] [ebp-620h]
  DWORD cbData; // [esp+E8h] [ebp-61Ch]
  DWORD dwErrCode; // [esp+ECh] [ebp-618h]
  wchar_t v27[260]; // [esp+F0h] [ebp-614h]
  wchar_t Dst; // [esp+2F8h] [ebp-40Ch]
  BYTE Data[2]; // [esp+500h] [ebp-204h]
  char v30; // [esp+502h] [ebp-202h]

  *Data = 0;
  memset(&v30, 0, 0x1FEu);
  dwErrCode = 65;
  if ( a2 == 272 )
  {
    SetPropW(hDlg, L"Runas", hData);
    if ( hData == 40121 )
    {
      SetWindowTextW(hDlg, L"Runas");
      SetDlgItemTextW(hDlg, 1318, L"Runas:");
      SetDlgItemTextW(hDlg, 1319, L"Select the program to run and then you will be prompted for alternate credentials.");
    }
    else if ( hData == 40122 )
    {
      SetWindowTextW(hDlg, L"Run as Limited User");
      SetDlgItemTextW(hDlg, 1319, L"Select the program to run with standard user privileges.");
    }
    v13 = GetDlgItem(hDlg, 1097);
    hWnd = v13;
    v14 = GetWindowLongW(v13, -16);
    SetWindowLongW(hWnd, -16, v14 | 0x40);
    v21 = -1;
    lParam = 1;
    if ( CommandLine )
    {
      v22 = &CommandLine;
      SendMessageW(hWnd, 0x40Bu, 0, &lParam);
    }
    SendMessageW(hWnd, 0x141u, 0x104u, 0);
    if ( !RegOpenKeyW(HKEY_CURRENT_USER, L"Software\\Microsoft\\Windows\\CurrentVersion\\Explorer\\RunMRU", &phkResult) )
    {
      cbData = 512;
      RegQueryValueExW(phkResult, L"MRUList", 0, 0, Data, &cbData);
      v15 = 0;
      if ( wcslen(Data) )
      {
        do
        {
          LOWORD(dwErrCode) = *&Data[2 * v15];
          cbData = 520;
          if ( !RegQueryValueExW(phkResult, &dwErrCode, 0, 0, v27, &cbData) )
          {
            if ( wcsrchr(v27, 0x5Cu) )
              *wcsrchr(v27, 0x5Cu) = 0;
            v22 = v27;
            SendMessageW(hWnd, 0x40Bu, 0, &lParam);
          }
          ++v15;
        }
        while ( v15 < wcslen(Data) );
      }
      RegCloseKey(phkResult);
    }
    SetFocus(hWnd);
    if ( gpfnSHAutoComplete )
    {
      v16 = SendMessageW(hWnd, 0x407u, 0, 0);
      gpfnSHAutoComplete(v16, 1u);
    }
    SendMessageW(hWnd, 0x14Eu, 0, 0);
    SendMessageW(hWnd, 0x142u, 0, -1);
    SetFocus(hWnd);
    return 1;
  }
  if ( a2 != 273 )
    return 0;
  if ( a3 == 1 )
  {
    GetDlgItemTextW(hDlg, 1097, &CommandLine, 260);
    v6 = GetPropW(hDlg, L"Runas") - 40061;
    if ( v6 )
    {
      v7 = v6 - 60;
      if ( v7 )
      {
        if ( v7 == 1 )
        {
          v8 = GetCurrentProcess();
          OpenProcessToken(v8, 0xF01FFu, &TokenHandle);
          v9 = sub_FC6DB0(TokenHandle);
          if ( !v9 )
          {
            ReportMsg(L"Unable to execute process", ghMainWnd);
            return 0;
          }
          memset(&StartupInfo, 0, 0x44u);
          StartupInfo.cb = 68;
          StartupInfo.dwFlags = 1;
          StartupInfo.wShowWindow = 5;
          v10 = TokenHandle;
          _mm_storeu_si128(&ProcessInformation, 0i64);
          CloseHandle(v10);
          if ( !CreateProcessAsUserW(v9, 0, &CommandLine, 0, 0, 0, 0x10u, 0, 0, &StartupInfo, &ProcessInformation) )
          {
            ReportMsg(L"Unable to execute process", ghMainWnd);
            CloseHandle(v9);
            return 0;
          }
          sub_FC3300(&CommandLine);
          EndDialog(hDlg, 0);
          CloseHandle(v9);
          return 0;
        }
        v11 = dwErrCode;
        goto LABEL_23;
      }
      v12 = ShellExecuteW(hDlg, L"runas", &CommandLine, 0, 0, 1);
    }
    else
    {
      v12 = ShellExecuteW(hDlg, L"open", &CommandLine, 0, 0, 1);
    }
    v11 = v12;
LABEL_23:
    switch ( v11 )
    {
      case 0u:
      case 8u:
        v11 = 8;
        break;
      case 1u:
      case 2u:
      case 3u:
      case 4u:
      case 6u:
      case 7u:
      case 9u:
      case 0xAu:
      case 0xBu:
      case 0xCu:
      case 0xDu:
      case 0xEu:
      case 0xFu:
      case 0x10u:
      case 0x11u:
      case 0x12u:
      case 0x13u:
      case 0x14u:
      case 0x15u:
      case 0x16u:
      case 0x17u:
      case 0x18u:
      case 0x19u:
      case 0x1Bu:
      case 0x1Cu:
      case 0x1Du:
      case 0x1Eu:
      case 0x1Fu:
        break;
      case 5u:
        v11 = 5;
        break;
      case 0x1Au:
        v11 = 32;
        break;
      case 0x20u:
        v11 = 2;
        break;
      default:
        sub_FC3300(&CommandLine);
        goto LABEL_30;
    }
    SetLastError(v11);
    ReportMsg(L"Unable to execute process", ghMainWnd);
    SetFocus(hWnd);
    return 0;
  }
  if ( a3 != 2 )
  {
    if ( a3 == 4 )
    {
      memset(&v19, 0, 0x58u);
      v19.lStructSize = 76;
      v19.hwndOwner = hDlg;
      v19.hInstance = ghInstance;
      v19.nMaxFile = 256;
      v19.Flags = 2097156;
      v19.lpstrTitle = L"Specify executable...";
      v19.lpstrDefExt = L"*.exe";
      v19.nFilterIndex = 1;
      v19.lpstrFilter = L"Executables";
      GetDlgItemTextW(hDlg, 1097, &CommandLine, 260);
      if ( wcschr(&CommandLine, 0x5Cu) )
      {
        wcscpy_s(&Dst, 0x104u, &CommandLine);
        v4 = wcschr(&Dst, 0x5Cu);
        wcscpy_s(&CommandLine, 0x104u, v4 + 1);
        wcschr(&Dst, 0x5Cu)[1] = 0;
        v19.lpstrInitialDir = &Dst;
      }
      v19.lpstrFile = &CommandLine;
      if ( GetOpenFileNameW(&v19) )
      {
        SetDlgItemTextW(hDlg, 1097, &CommandLine);
        return 0;
      }
    }
    return 0;
  }
LABEL_30:
  EndDialog(hDlg, 0);
  return 0;
}
// 10419EC: using guessed type wchar_t aSpecifyExecuta[22];
// 1041A18: using guessed type wchar_t aExe_0[6];
// 1041A28: using guessed type wchar_t aExecutables[12];
// 1041A6C: using guessed type wchar_t aRunas_0[6];
// 1041A78: using guessed type wchar_t aUnableToExecut[26];
// 106A8F4: using guessed type int (__stdcall *gpfnSHAutoComplete)(struct HWND__ *, unsigned int);

//----- (00FD85F0) --------------------------------------------------------
int __stdcall sub_FD85F0(HWND hDlg, int a2, int a3, int a4)
{
  HWND v4; // eax
  HWND v5; // eax
  unsigned int v6; // kr00_4
  WCHAR *v7; // edx
  WCHAR v8; // ax
  HWND v9; // eax
  HWND v10; // eax
  HWND v11; // eax
  HWND v13; // eax
  DWORD v14; // ST14_4
  HANDLE v15; // eax
  HWND v16; // eax
  HWND v17; // eax
  HWND v18; // eax
  int v19; // [esp+Ch] [ebp-82Ch]
  __int16 *v20; // [esp+10h] [ebp-828h]
  char ArgList; // [esp+14h] [ebp-824h]
  wchar_t Dst; // [esp+21Ch] [ebp-61Ch]
  WCHAR v23; // [esp+424h] [ebp-414h]
  __int16 v24; // [esp+426h] [ebp-412h]
  WCHAR String; // [esp+62Ch] [ebp-20Ch]

  if ( a2 != 272 )
  {
    if ( a2 != 273 )
      return 0;
    if ( a3 == 1 )
    {
      v4 = GetDlgItem(hDlg, 1302);
      GetWindowTextW(v4, &String, 260);
      v5 = GetDlgItem(hDlg, 1303);
      GetWindowTextW(v5, &v23, 260);
      v6 = wcslen(&String);
      v7 = &v23;
      v20 = &v24;
      do
      {
        v8 = *v7;
        ++v7;
      }
      while ( v8 );
      if ( !WTSSendMessageW(0, dword_106A914, &v23, 2 * ((v7 - v20) >> 1), &String, 2 * v6, 0, 0, &v19, 0) )
        ReportMsg(L"Error sending message", ghMainWnd);
    }
    else if ( a3 != 2 )
    {
LABEL_11:
      if ( a3 >> 16 == 768 )
      {
        v9 = GetDlgItem(hDlg, 1302);
        GetWindowTextW(v9, &String, 260);
        v10 = GetDlgItem(hDlg, 1303);
        GetWindowTextW(v10, &v23, 260);
        if ( String && v23 )
        {
          v11 = GetDlgItem(hDlg, 1);
          EnableWindow(v11, 1);
          return 0;
        }
        v13 = GetDlgItem(hDlg, 1);
        EnableWindow(v13, 0);
      }
      return 0;
    }
    EndDialog(hDlg, 0);
    goto LABEL_11;
  }
  dword_106A914 = a4;
  v14 = GetCurrentProcessId();
  v15 = GetCurrentProcess();
  QueryProcessUsers(v15, v14, 0, &Dst, 0x104u, &ArgList, 0x104u, 0, 0, 0, 0);
  swprintf(&String, L"Message from %s\\%s", &ArgList, &Dst);
  v16 = GetDlgItem(hDlg, 1303);
  SetWindowTextW(v16, &String);
  v17 = GetDlgItem(hDlg, 1302);
  SetWindowTextW(v17, &gszNullString);
  v18 = GetDlgItem(hDlg, 1303);
  SetFocus(v18);
  return 1;
}
// 1040EE8: using guessed type wchar_t aErrorSendingMe[22];
// 106F350: using guessed type int (__stdcall *WTSSendMessageW)(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);

//----- (00FD8860) --------------------------------------------------------
BOOL __stdcall DlgSymbolConfig(HWND hDlg, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
  HANDLE v4; // esi
  BOOL v5; // eax
  BOOL v6; // ST0C_4
  HWND v7; // eax
  BOOL result; // eax
  HWND v9; // eax
  HWND v10; // eax
  struct tagOFNW OpenFileName; // [esp+8h] [ebp-4B4h]
  struct _WIN32_FIND_DATAW FindFileData; // [esp+60h] [ebp-45Ch]
  WCHAR szText[260]; // [esp+2B0h] [ebp-20Ch]

  if ( uMsg == WM_INITDIALOG )
  {
    SetDlgItemTextW(hDlg, IDC_DLG_SYMBOLCONFIG_EDIT_DBGHELPDLL_PATH, gConfig.strDbgHelpModuleName);
    SetDlgItemTextW(hDlg, IDC_DLG_SYMBOLCONFIG_EDIT_SYMBOLS_PATH, gConfig.strNtSymbolPath);
    if ( gpfnSHAutoComplete )
    {
      v9 = GetDlgItem(hDlg, IDC_DLG_SYMBOLCONFIG_EDIT_DBGHELPDLL_PATH);
      gpfnSHAutoComplete(v9, 1u);
    }
    v10 = GetDlgItem(hDlg, IDC_DLG_SYMBOLCONFIG_EDIT_DBGHELPDLL_PATH);
    SetFocus(v10);
    result = 1;
  }
  else
  {
    if ( uMsg == WM_COMMAND )
    {
      if ( wParam > IDC_DLG_SYMBOLCONFIG_BUTTON_BROWSE_DBGHELPDLL_PATH )
      {
        if ( wParam == IDC_DLG_SYMBOLCONFIG_BUTTON_BROWSE_SYMBOLS_PATH )
        {
          GetDlgItemTextW(hDlg, IDC_DLG_SYMBOLCONFIG_EDIT_SYMBOLS_PATH, szText, MAX_PATH);
          if ( BrowseSymbolPath(hDlg, szText) )
            SetDlgItemTextW(hDlg, IDC_DLG_SYMBOLCONFIG_EDIT_SYMBOLS_PATH, szText);
        }
      }
      else
      {
        switch ( wParam )
        {
          case IDC_DLG_SYMBOLCONFIG_BUTTON_BROWSE_DBGHELPDLL_PATH:
            GetDlgItemTextW(hDlg, IDC_DLG_SYMBOLCONFIG_EDIT_DBGHELPDLL_PATH, szText, MAX_PATH);
            memset(&OpenFileName, 0, 0x58u);
            OpenFileName.hInstance = ghInstance;
            OpenFileName.lpstrFile = szText;
            *&OpenFileName.nFileOffset = 0;
            OpenFileName.lpfnHook = 0;
            OpenFileName.lStructSize = 76;
            OpenFileName.hwndOwner = hDlg;
            OpenFileName.lpstrCustomFilter = 0;
            OpenFileName.nMaxCustFilter = 0;
            OpenFileName.nFilterIndex = 1;
            OpenFileName.nMaxFile = 256;
            OpenFileName.lpstrFileTitle = 0;
            OpenFileName.nMaxFileTitle = 0;
            OpenFileName.lpstrInitialDir = 0;
            OpenFileName.Flags = 0x200000;
            OpenFileName.lpstrTitle = L"Specify dbghelp.dll...";
            OpenFileName.lpstrDefExt = L"*.dll";
            OpenFileName.lpstrFilter = L"Dbghelp DLL (dbghelp.dll)";
            if ( GetOpenFileNameW(&OpenFileName) )
              SetDlgItemTextW(hDlg, 1088, szText);
            break;
          case 1u:
            GetDlgItemTextW(hDlg, 1088, szText, 260);
            if ( LoadDbgHelp(szText) )
            {
              GetDlgItemTextW(hDlg, 1089, gConfig.strNtSymbolPath, 260);
              wcscpy_s(gConfig.strDbgHelpModuleName, 0x104u, szText);
              SetEnvironmentVariableW(L"_NT_SYMBOL_PATH", gConfig.strNtSymbolPath);
              dword_105E0DC = 1;
              ShowSymbolConfigWarning(hDlg);
              EndDialog(hDlg, 0);
            }
            else
            {
              MessageBoxW(
                hDlg,
                L"The DLL you specified is not a valid version of the Debugging Tools Help File.",
                L"Process Explorer Error",
                0x10u);
            }
            break;
          case IDC_MYICON:
            EndDialog(hDlg, 0);
            break;
        }
      }
      if ( wParam >> 16 == 768 )
      {
        GetDlgItemTextW(hDlg, 1088, szText, 260);
        v4 = FindFirstFileW(szText, &FindFileData);
        v5 = v4 != -1 && !(FindFileData.dwFileAttributes & 0x10);
        v6 = v5;
        v7 = GetDlgItem(hDlg, 1);
        EnableWindow(v7, v6);
        if ( v4 )
          FindClose(v4);
      }
    }
    result = 0;
  }
  return result;
}
// 1041578: using guessed type wchar_t aSpecifyDbghelp[23];
// 10415A8: using guessed type wchar_t aDll_2[6];
// 10415B4: using guessed type wchar_t aDbghelpDllDbgh[26];
// 105E0DC: using guessed type int dword_105E0DC;
// 106A8F4: using guessed type int (__stdcall *gpfnSHAutoComplete)(struct HWND__ *, unsigned int);

//----- (00FD8B70) --------------------------------------------------------
char __cdecl BrowseSymbolPath(HWND hWnd, LPWSTR pszPath)
{
  void *pBuffer; // esi
  char result; // al
  const ITEMIDLIST *pItemList; // eax
  ITEMIDLIST *pItemList_1; // edi
  struct _browseinfoW bi; // [esp+4h] [ebp-28h]
  LPITEMIDLIST pidl; // [esp+24h] [ebp-8h]
  IMalloc *pMalloc; // [esp+28h] [ebp-4h]

  SHGetMalloc(&pMalloc);
  pBuffer = pMalloc->lpVtbl->Alloc(pMalloc, MAX_PATH);
  if ( !pBuffer )
    return 0;
  if ( SHGetSpecialFolderLocation(hWnd, 0, &pidl) >= 0 )
  {
    bi.pidlRoot = pidl;
    bi.hwndOwner = hWnd;
    bi.pszDisplayName = pszPath;
    bi.lpszTitle = L"Browse for Symbols Directory";
    bi.ulFlags = 0x11;
    bi.lpfn = 0;
    bi.lParam = 0;
    pItemList = SHBrowseForFolderW(&bi);
    pItemList_1 = pItemList;
    if ( pItemList )
    {
      SHGetPathFromIDListW(pItemList, pszPath);
      pMalloc->lpVtbl->Free(pMalloc, pItemList_1);
      pMalloc->lpVtbl->Free(pMalloc, pidl);
      pMalloc->lpVtbl->Free(pMalloc, pBuffer);
      result = 1;
    }
    else
    {
      pMalloc->lpVtbl->Free(pMalloc, pidl);
      pMalloc->lpVtbl->Free(pMalloc, pBuffer);
      result = 0;
    }
  }
  else
  {
    pMalloc->lpVtbl->Free(pMalloc, pBuffer);
    result = 0;
  }
  return result;
}
// 10414DC: using guessed type wchar_t aBrowseForSymbo[29];

//----- (00FD8C50) --------------------------------------------------------
BOOL BackendSysInfoPropSheetThreadProc()
{
  HICON v0; // edi
  BOOL result; // eax
  struct tagMSG msg; // [esp+8h] [ebp-20h]
  HACCEL hAccel; // [esp+24h] [ebp-4h]

  ghWndSysinfoPropSheet = CreateDialogParamW(ghInstance, L"SYSINFOPROPSHEET", 0, SysinfoPropSheet, 0);
  v0 = LoadIconW(ghInstance, 101);
  SendMessageW(ghWndSysinfoPropSheet, WM_SETICON, 0, v0);
  SendMessageW(ghWndSysinfoPropSheet, WM_SETICON, 1u, v0);
  SetEvent(ghSystemInfoSheetThreadEvent);
  hAccel = LoadAcceleratorsW(ghInstance, L"PROCPROPERTIES");
  for ( result = GetMessageW(&msg, 0, 0, 0); result; result = GetMessageW(&msg, 0, 0, 0) )
  {
    if ( !TranslateAcceleratorW(ghWndSysinfoPropSheet, hAccel, &msg) && !IsDialogMessageW(ghWndSysinfoPropSheet, &msg) )
    {
      TranslateMessage(&msg);
      DispatchMessageW(&msg);
    }
  }
  return result;
}

//----- (00FD8D50) --------------------------------------------------------
const wchar_t *__cdecl sub_FD8D50(int a1)
{
  const wchar_t *result; // eax

  switch ( a1 )
  {
    case 1:
      result = L"16";
      break;
    case 2:
      result = L"256";
      break;
    case 4:
      result = L"65536";
      break;
    case 8:
    case 24:
      result = L"2^24";
      break;
    case 16:
      result = L"2^15";
      break;
    case 32:
      result = L"2^32";
      break;
    default:
      result = L"<?>";
      break;
  }
  return result;
}
// 1040E34: using guessed type wchar_t a16[3];
// 1040E3C: using guessed type wchar_t a256[4];
// 1040E44: using guessed type wchar_t a65536[6];
// 1040E50: using guessed type wchar_t a224[5];
// 1040E5C: using guessed type wchar_t a215[5];
// 1040E68: using guessed type wchar_t a232[5];
// 1040E74: using guessed type wchar_t asc_1040E74[4];

//----- (00FD8DE0) --------------------------------------------------------
BOOL __stdcall sub_FD8DE0(HWND hDlg, UINT a2, WPARAM a3, LPARAM a4)
{
  WCHAR *v5; // eax
  struct _WTS_SESSION_INFOW *v6; // eax
  const wchar_t *v7; // eax
  _DWORD *v8; // ecx
  PWTS_SESSION_INFOW SessionInfo; // [esp+4h] [ebp-22Ch]
  LPCWSTR lpString; // [esp+8h] [ebp-228h]
  PWTS_SESSION_INFOW v11; // [esp+Ch] [ebp-224h]
  char ArgList[4]; // [esp+10h] [ebp-220h]
  PWTS_SESSION_INFOW v13; // [esp+14h] [ebp-21Ch]
  PWTS_SESSION_INFOW v14; // [esp+18h] [ebp-218h]
  PWTS_SESSION_INFOW v15; // [esp+1Ch] [ebp-214h]
  DWORD pBytesReturned; // [esp+20h] [ebp-210h]
  WCHAR String; // [esp+24h] [ebp-20Ch]

  if ( a2 == 43 )
  {
    CMainWnd::DrawList(a4);
    return 0;
  }
  if ( a2 != 272 )
  {
    if ( a2 == 273 && a3 - 1 <= 1 )
    {
      EndDialog(hDlg, 0);
      return 0;
    }
    return 0;
  }
  SessionId = a4;
  swprintf(&String, L"%d", a4);
  SetDlgItemTextW(hDlg, 108, &String);
  v15 = 0;
  WTSQuerySessionInformationW(0, SessionId, WTSClientProtocolType, &v15, &pBytesReturned);
  if ( WTSQuerySessionInformationW(0, SessionId, WTSUserName, &SessionInfo, &pBytesReturned) )
  {
    if ( WTSQuerySessionInformationW(0, SessionId, WTSDomainName, ArgList, &pBytesReturned) )
    {
      swprintf(&String, L"%s\\%s", *ArgList, SessionInfo);
      SetDlgItemTextW(hDlg, 106, &String);
      WTSFreeMemory(*ArgList);
    }
    WTSFreeMemory(SessionInfo);
  }
  if ( WTSQuerySessionInformationW(0, SessionId, WTSConnectState, &v14, &pBytesReturned) )
  {
    if ( v14->SessionId >= 0xA )
    {
      swprintf(&String, L"Unknown (%d)", v14->SessionId);
      v5 = &String;
    }
    else
    {
      v5 = &aActive[32 * v14->SessionId];
    }
    SetDlgItemTextW(hDlg, 1083, v5);
    WTSFreeMemory(v14);
  }
  v6 = v15;
  if ( v15 )
  {
    if ( LOWORD(v15->SessionId) )
    {
      if ( WTSQuerySessionInformationW(0, SessionId, WTSClientName, &lpString, &pBytesReturned) )
      {
        SetDlgItemTextW(hDlg, 110, lpString);
        WTSFreeMemory(lpString);
      }
      if ( WTSQuerySessionInformationW(0, SessionId, WTSClientAddress, &v13, &pBytesReturned) && v13->pWinStationName )
      {
        swprintf(
          &String,
          L"%d.%d.%d.%d",
          BYTE2(v13->pWinStationName),
          HIBYTE(v13->pWinStationName),
          LOBYTE(v13->State),
          BYTE1(v13->State));
        SetDlgItemTextW(hDlg, 111, &String);
        WTSFreeMemory(v13);
      }
      if ( WTSQuerySessionInformationW(0, SessionId, WTSClientDisplay, &v11, &pBytesReturned) )
      {
        v7 = sub_FD8D50(v11->State);
        swprintf(&String, L"%dx%d by %s colors", *v8, v8[1], v7);
        SetDlgItemTextW(hDlg, 112, &String);
        WTSFreeMemory(v11);
      }
      v6 = v15;
    }
    if ( v6 )
      WTSFreeMemory(v6);
  }
  return 1;
}
// 105E130: using guessed type wchar_t aActive[7];

//----- (00FD90F0) --------------------------------------------------------
CGraphData *HandleTaskbarCreated()
{
  signed int v0; // esi
  CGraphData *result; // eax
  int v2; // esi

  v0 = 1;
  do
    result = TrayIcon_Delete(ghMainWnd, v0++);
  while ( v0 < 5 );
  v2 = 1;
  if ( gConfig.bShowPhysTray )
  {
    dword_106A3F0 = 1;
    result = TrayIcon_Add(ghMainWnd, 1u, gpGraphInfoOfPhysicalMemory, &gszNullString);
    v2 = 2;
  }
  else
  {
    dword_106A3F0 = 0;
  }
  if ( gConfig.bShowIoTray )
  {
    dword_106A3C8 = v2;
    result = TrayIcon_Add(ghMainWnd, v2++, gIOGraphInfo.pGraphData, &gszNullString);
  }
  else
  {
    dword_106A3C8 = 0;
  }
  if ( gConfig.bShowDiskTray )
  {
    dword_106A3F4 = v2;
    result = TrayIcon_Add(ghMainWnd, v2++, gDiskGraphInfo.pGraphData, &gszNullString);
  }
  else
  {
    dword_106A3F4 = 0;
  }
  if ( gConfig.bShowGpuHistory && (result = gpGraphInfoOfGPU) != 0 )
  {
    dword_106A3C0 = v2;
    result = TrayIcon_Add(ghMainWnd, v2++, gpGraphInfoOfGPU, &gszNullString);
  }
  else
  {
    dword_106A3C0 = 0;
  }
  if ( gConfig.bShowNetTray )
  {
    dword_106A600 = v2;
    result = TrayIcon_Add(ghMainWnd, v2++, gNetworkGraphInfo.pGraphData, &gszNullString);
  }
  else
  {
    dword_106A600 = 0;
  }
  if ( gConfig.bShowCommitTray )
  {
    dword_106A3C4 = v2;
    result = TrayIcon_Add(ghMainWnd, v2++, gpGraphInfoOfMemory, &gszNullString);
  }
  else
  {
    dword_106A3C4 = 0;
  }
  if ( gConfig.bTrayCPUHistory )
  {
    dword_106A3BC = v2;
    result = TrayIcon_Add(ghMainWnd, v2, gpGraphInfoOfCPU, &gszNullString);
  }
  else
  {
    dword_106A3BC = 0;
  }
  return result;
}
// 106A3BC: using guessed type int dword_106A3BC;

//----- (00FD92A0) --------------------------------------------------------
void __cdecl ShowSymbolConfigWarning(HWND hWnd)
{
  DWORD cbLength; // esi
  _DWORD *pVersionInfo; // ebx
  DWORD dwHandle; // [esp+4h] [ebp-4h]

  dwHandle = 0;
  if ( !_wcsnicmp(L"srv*", gConfig.strNtSymbolPath, 4u) )
  {
    cbLength = GetFileVersionInfoSizeW(gConfig.strDbgHelpModuleName, &dwHandle);
    pVersionInfo = malloc(cbLength);
    if ( GetFileVersionInfoW(gConfig.strDbgHelpModuleName, 0, cbLength, pVersionInfo) && pVersionInfo[12] < 0x60000u )
    {
      if ( hWnd )
        DialogBoxParamW(ghInstance, L"SYMBOLDBGHELPGWARNING", 0, DlgAbout, 0);
      else
        DialogBoxParamW(ghInstance, L"SYMBOLCONFIGWARNING", 0, DlgAbout, 0);
    }
    free(pVersionInfo);
  }
  if ( !LOBYTE(gConfig.bSymbolWarningShown) && (!SymInitialize || !gConfig.strNtSymbolPath[0]) )
  {
    DialogBoxParamW(ghInstance, L"SYMBOLCONFIGWARNING", 0, DlgAbout, 0);
    LOBYTE(gConfig.bSymbolWarningShown) = 1;
    UpdateWindowPlacement(ghMainWnd, 1);
  }
}

//----- (00FD9380) --------------------------------------------------------
int __cdecl SearchWindow(HWND hWnd)
{
  int result; // eax
  HWND v2; // eax
  unsigned int nCount; // edi
  WPARAM nIndex; // esi
  DWORD dwProcessId_1; // ecx
  tagTREEVIEWLISTITEMPARAM *pTreeViewListItemParam; // eax
  LVITEMW Item; // [esp+8h] [ebp-244h]
  DWORD dwProcessId; // [esp+3Ch] [ebp-210h]
  WCHAR szBuffer[260]; // [esp+40h] [ebp-20Ch]

  if ( gbWindowFinding )
  {
    SetCursor(ghFindCursor);
    ReleaseCapture();
    gbWindowFinding = 0;
    SendMessageW(ghWndToolbar, TB_PRESSBUTTON, IDM_FIND_PROCESS_BY_WINDOW, 0);
    SetWindowPos(hWnd, -(gConfig.bAlwaysOntop != 0), 0, 0, 0, 0, SWP_NOMOVE|SWP_NOSIZE);
    if ( ghWndHungWindow )
    {
      DrawHungWindow(ghWndHungWindow);
      if ( !HungWindowFromGhostWindow || (v2 = HungWindowFromGhostWindow(ghWndHungWindow)) == 0 )
        v2 = ghWndHungWindow;
      GetWindowThreadProcessId(v2, &dwProcessId);
      nCount = SendMessageW(ghWndTreeListView, LVM_GETITEMCOUNT, 0, 0);
      nIndex = 0;
      if ( nCount )
      {
        while ( 1 )
        {
          Item.mask = LVIF_PARAM;
          Item.iItem = nIndex;
          Item.iSubItem = 0;
          SendMessageW(ghWndTreeListView, LVM_GETITEMW, 0, &Item);
          dwProcessId_1 = dwProcessId;
          if ( Item.lParam->dwProcessId == dwProcessId )
            break;
          if ( ++nIndex >= nCount )
            goto __BREAK;
        }
        Item.mask = LVIF_STATE;
        Item.stateMask = LVIS_SELECTED;
        Item.state = LVIS_SELECTED;
        SendMessageW(ghWndTreeListView, LVM_SETITEMW, 0, &Item);
        SendMessageW(ghWndTreeListView, LVM_ENSUREVISIBLE, nIndex, 0);
        SetFocus(ghWndTreeListView);
      }
      dwProcessId_1 = dwProcessId;
__BREAK:
      if ( nIndex == nCount )
      {
        pTreeViewListItemParam = gpTreeViewListItemParam;
        if ( gpTreeViewListItemParam )
        {
          while ( pTreeViewListItemParam->dwProcessId != dwProcessId_1 )
          {
            pTreeViewListItemParam = pTreeViewListItemParam->m_Prev;
            if ( !pTreeViewListItemParam )
              goto __ReportError;
          }
          swprintf(
            szBuffer,
            L"The owning process is %s (process ID %d), which is not currently visible in the process list.",
            pTreeViewListItemParam->szProcessName2,
            pTreeViewListItemParam->dwProcessId);
          MessageBoxW(ghWndTreeListView, szBuffer, L"Process Explorer Error", MB_ICONASTERISK);
        }
        else
        {
__ReportError:
          MessageBoxW(
            ghWndTreeListView,
            L"Unable to find the window's owning process in the current process list",
            L"Process Explorer Error",
            MB_ICONERROR);
        }
      }
    }
    result = 0;
  }
  else
  {
    SetWindowPos(hWnd, HWND_BOTTOM, 0, 0, 0, 0, SWP_NOMOVE|SWP_NOSIZE);
    SetWindowPos(hWnd, HWND_BOTTOM, 0, 0, 0, 0, SWP_NOMOVE|SWP_NOSIZE);
    ghFindCursor = SetCursor(ghFindCursor);
    SetCapture(hWnd);
    gbWindowFinding = 1;
    result = 0;
    ghWndHungWindow = 0;
  }
  return result;
}
// 106A38B: using guessed type char gbWindowFinding;

//----- (00FD95D0) --------------------------------------------------------
LRESULT __stdcall CMainWnd::MainWndProc(HWND hWnd, UINT Msg, WPARAM wParam, LPARAM lParam)
{
  if ( Msg == gShellIconMsg )
    HandleTaskbarCreated();
  return HandleMsgHandler(&CMainWnd::gMsgHandler, hWnd, Msg, wParam, lParam);
}
// 106A884: using guessed type int gShellIconMsg;

//----- (00FD9600) --------------------------------------------------------
int __cdecl DumpFileProcess(int hFile, HANDLE Process, char a3)
{
  HMODULE v3; // eax
  signed int v4; // eax
  MINIDUMP_TYPE v5; // ST0C_4
  DWORD v6; // eax

  v3 = LoadLibraryW(L"Dbghelp.dll");
  if ( GetProcAddress(v3, "EnumDirTreeW") )
  {
    v4 = 4357;
    if ( a3 )
      v4 = 6407;
  }
  else
  {
    v4 = 261;
    if ( a3 )
      v4 = 263;
  }
  v5 = v4;
  v6 = GetProcessId(Process);
  return MiniDumpWriteDump(Process, v6, hFile, v5, 0, 0, 0);
}

//----- (00FD9660) --------------------------------------------------------
int __cdecl sub_FD9660(int a1, int a2, wchar_t *Dst)
{
  return swprintf_s(Dst, 0x400u, L"%d.%d.%d.%d", a2 >> 16, a2, a1 >> 16, a1);
}

//----- (00FD9690) --------------------------------------------------------
_DWORD *__thiscall sub_FD9690(_DWORD *this, int a2)
{
  _DWORD *result; // eax

  result = sub_FF5470(this);
  *(result + 6) = 0;
  if ( result != -16 )
  {
    result[4] = *a2;
    _mm_storeu_si128((result + 6), _mm_loadu_si128((a2 + 8)));
    _mm_storeu_si128((result + 10), _mm_loadu_si128((a2 + 24)));
    _mm_storeu_si128((result + 14), _mm_loadu_si128((a2 + 40)));
  }
  return result;
}

//----- (00FD96D0) --------------------------------------------------------
int __thiscall std::_Tree<std::_Tmap_traits<unsigned long,_SYSTEM_PROCESSOR_IDLE_CYCLE_TIME_INFORMATION *,std::less<unsigned long>,std::allocator<std::pair<unsigned long const,_SYSTEM_PROCESSOR_IDLE_CYCLE_TIME_INFORMATION *>>,0>>::_Insert_at<std::pair<unsigned long const,_SYSTEM_PROCESSOR_IDLE_CYCLE_TIME_INFORMATION *> &,std::_Tree_node<std::pair<unsigned long const,_SYSTEM_PROCESSOR_IDLE_CYCLE_TIME_INFORMATION *>,void *> *>(CSystemProcessInfoMap *this, int a2, char a3, int a4, int a5, CSystemProcessInfoMapNode *_Node)
{
  CSystemProcessInfoMap *v6; // edi
  unsigned int v7; // eax
  CSystemProcessInfoMapNode *v8; // eax
  std__Tree_node *v9; // ecx
  std__Tree_node *v10; // esi
  std__Tree_node *v11; // edx
  CSystemProcessInfoMapNode **v12; // edx
  CSystemProcessInfoMapNode **v13; // ecx
  CSystemProcessInfoMapNode *v14; // edx
  std__Tree_node *v15; // esi
  std__Tree_node_For__bstr_t *v16; // ecx
  _DWORD *v17; // ecx
  std__Tree_node *v18; // edx
  std__Tree_node_For__bstr_t *v19; // ecx
  CSystemProcessInfoMapNode *v20; // ecx
  CSystemProcessInfoMapNode **v21; // ecx
  int result; // eax

  v6 = this;
  v7 = this->_Size;
  if ( v7 >= 0xAAAAAA9 )
  {
    j__free(_Node);
    std::_Xlength_error("map/set<T> too long");
  }
  this->_Size = v7 + 1;
  _Node->baseclass._Parent = a4;
  if ( a4 == this->_Header )
  {
    this->_Header->_Parent = _Node;
    this->_Header->_Left = _Node;
    this->_Header->_Right = _Node;
  }
  else if ( a3 )
  {
    *a4 = _Node;
    if ( a4 == this->_Header->_Left )
      this->_Header->_Left = _Node;
  }
  else
  {
    *(a4 + 8) = _Node;
    if ( a4 == this->_Header->_Right )
      this->_Header->_Right = _Node;
  }
  v8 = _Node;
  while ( !v8->baseclass._Parent->baseclass._Color )
  {
    v9 = v8->baseclass._Parent;
    v10 = v9->_Parent;
    v11 = v10->_Left;
    if ( v9 == v10->_Left )
    {
      v11 = v10->_Right;
      if ( v11->_Color )
      {
        if ( v8 == v9->_Right )
        {
          v8 = v8->baseclass._Parent;
          v12 = v9->_Right;
          v9->_Right = *v12;
          if ( !(*v12)->baseclass._isnil )
            (*v12)->baseclass._Parent = v9;
          v12[1] = v9->_Parent;
          if ( v9 == v6->_Header->_Parent )
          {
            v6->_Header->_Parent = v12;
          }
          else
          {
            v13 = v9->_Parent;
            if ( v8 == *v13 )
              *v13 = v12;
            else
              v13[2] = v12;
          }
          *v12 = v8;
          v8->baseclass._Parent = v12;
        }
        v8->baseclass._Parent->baseclass._Color = 1;
        v8->baseclass._Parent->baseclass._Parent->baseclass._Color = 0;
        v14 = v8->baseclass._Parent->baseclass._Parent;
        v15 = v14->baseclass._Left;
        v14->baseclass._Left = v14->baseclass._Left->baseclass._Right;
        v16 = v15->_Right;
        if ( !v16->_IsNil )
          v16->_Parent = v14;
        v15->_Parent = v14->baseclass._Parent;
        if ( v14 == v6->_Header->_Parent )
        {
          v6->_Header->_Parent = v15;
          v15->_Right = v14;
        }
        else
        {
          v17 = &v14->baseclass._Parent->baseclass._Left;
          if ( v14 == v17[2] )
            v17[2] = v15;
          else
            *v17 = v15;
          v15->_Right = v14;
        }
LABEL_48:
        v14->baseclass._Parent = v15;
        continue;
      }
    }
    else if ( v11->_Color )
    {
      if ( v8 == v9->_Left )
      {
        v8 = v8->baseclass._Parent;
        v18 = v9->_Left;
        v9->_Left = v9->_Left->_Right;
        v19 = v18->_Right;
        if ( !v19->_IsNil )
          v19->_Parent = v8;
        v18->_Parent = v8->baseclass._Parent;
        if ( v8 == v6->_Header->_Parent )
        {
          v6->_Header->_Parent = v18;
        }
        else
        {
          v20 = v8->baseclass._Parent;
          if ( v8 == v20->baseclass._Right )
            v20->baseclass._Right = v18;
          else
            v20->baseclass._Left = v18;
        }
        v18->_Right = v8;
        v8->baseclass._Parent = v18;
      }
      v8->baseclass._Parent->baseclass._Color = 1;
      v8->baseclass._Parent->baseclass._Parent->baseclass._Color = 0;
      v14 = v8->baseclass._Parent->baseclass._Parent;
      v15 = v14->baseclass._Right;
      v14->baseclass._Right = v15->_Left;
      if ( !v15->_Left->_IsNil )
        v15->_Left->_Parent = v14;
      v15->_Parent = v14->baseclass._Parent;
      if ( v14 == v6->_Header->_Parent )
      {
        v6->_Header->_Parent = v15;
      }
      else
      {
        v21 = &v14->baseclass._Parent->baseclass._Left;
        if ( v14 == *v21 )
          *v21 = v15;
        else
          v21[2] = v15;
      }
      v15->_Left = v14;
      goto LABEL_48;
    }
    v9->_Color = 1;
    v11->_Color = 1;
    v8->baseclass._Parent->baseclass._Parent->baseclass._Color = 0;
    v8 = v8->baseclass._Parent->baseclass._Parent;
  }
  v6->_Header->_Parent->_Color = 1;
  result = a2;
  *a2 = _Node;
  return result;
}

//----- (00FD98E0) --------------------------------------------------------
_DWORD *__thiscall sub_FD98E0(_DWORD *this, _DWORD *a2, char a3, _DWORD *a4, int a5, int a6)
{
  _DWORD *v6; // edi
  _DWORD *v7; // eax
  _DWORD *v8; // ebx
  int v9; // eax
  _DWORD *v10; // eax
  int *v11; // ecx
  int *v12; // esi
  int *v13; // edx
  _DWORD *v14; // edx
  _DWORD *v15; // ecx
  _DWORD *v16; // edx
  _DWORD *v17; // esi
  int v18; // ecx
  _DWORD *v19; // ecx
  int v20; // edx
  int v21; // ecx
  _DWORD *v22; // ecx
  _DWORD *v23; // ecx
  _DWORD *result; // eax

  v6 = this;
  if ( this[1] >= 0x38E38E2u )
    std::_Xlength_error("map/set<T> too long");
  v7 = sub_FD9690(this, a5);
  ++v6[1];
  v8 = v7;
  v7[1] = a4;
  if ( a4 == *v6 )
  {
    *(*v6 + 4) = v7;
    **v6 = v7;
    v9 = *v6;
LABEL_8:
    *(v9 + 8) = v8;
    goto LABEL_9;
  }
  if ( !a3 )
  {
    a4[2] = v7;
    v9 = *v6;
    if ( a4 != *(*v6 + 8) )
      goto LABEL_9;
    goto LABEL_8;
  }
  *a4 = v7;
  if ( a4 == **v6 )
    **v6 = v7;
LABEL_9:
  v10 = v8;
  while ( !*(v10[1] + 12) )
  {
    v11 = v10[1];
    v12 = v11[1];
    v13 = *v12;
    if ( v11 == *v12 )
    {
      v13 = v12[2];
      if ( *(v13 + 12) )
      {
        if ( v10 == v11[2] )
        {
          v10 = v10[1];
          v14 = v11[2];
          v11[2] = *v14;
          if ( !*(*v14 + 13) )
            *(*v14 + 4) = v11;
          v14[1] = v11[1];
          if ( v11 == *(*v6 + 4) )
          {
            *(*v6 + 4) = v14;
          }
          else
          {
            v15 = v11[1];
            if ( v10 == *v15 )
              *v15 = v14;
            else
              v15[2] = v14;
          }
          *v14 = v10;
          v10[1] = v14;
        }
        *(v10[1] + 12) = 1;
        *(*(v10[1] + 4) + 12) = 0;
        v16 = *(v10[1] + 4);
        v17 = *v16;
        *v16 = *(*v16 + 8);
        v18 = v17[2];
        if ( !*(v18 + 13) )
          *(v18 + 4) = v16;
        v17[1] = v16[1];
        if ( v16 == *(*v6 + 4) )
        {
          *(*v6 + 4) = v17;
          v17[2] = v16;
        }
        else
        {
          v19 = v16[1];
          if ( v16 == v19[2] )
            v19[2] = v17;
          else
            *v19 = v17;
          v17[2] = v16;
        }
LABEL_48:
        v16[1] = v17;
        continue;
      }
    }
    else if ( *(v13 + 12) )
    {
      if ( v10 == *v11 )
      {
        v10 = v10[1];
        v20 = *v11;
        *v11 = *(*v11 + 8);
        v21 = *(v20 + 8);
        if ( !*(v21 + 13) )
          *(v21 + 4) = v10;
        *(v20 + 4) = v10[1];
        if ( v10 == *(*v6 + 4) )
        {
          *(*v6 + 4) = v20;
        }
        else
        {
          v22 = v10[1];
          if ( v10 == v22[2] )
            v22[2] = v20;
          else
            *v22 = v20;
        }
        *(v20 + 8) = v10;
        v10[1] = v20;
      }
      *(v10[1] + 12) = 1;
      *(*(v10[1] + 4) + 12) = 0;
      v16 = *(v10[1] + 4);
      v17 = v16[2];
      v16[2] = *v17;
      if ( !*(*v17 + 13) )
        *(*v17 + 4) = v16;
      v17[1] = v16[1];
      if ( v16 == *(*v6 + 4) )
      {
        *(*v6 + 4) = v17;
      }
      else
      {
        v23 = v16[1];
        if ( v16 == *v23 )
          *v23 = v17;
        else
          v23[2] = v17;
      }
      *v17 = v16;
      goto LABEL_48;
    }
    *(v11 + 12) = 1;
    *(v13 + 12) = 1;
    *(*(v10[1] + 4) + 12) = 0;
    v10 = *(v10[1] + 4);
  }
  *(*(*v6 + 4) + 12) = 1;
  result = a2;
  *a2 = v8;
  return result;
}

//----- (00FD9AF0) --------------------------------------------------------
int __thiscall std::_Tree<std::_Tmap_traits<unsigned long,_SYSTEM_PROCESSOR_IDLE_CYCLE_TIME_INFORMATION *,std::less<unsigned long>,std::allocator<std::pair<unsigned long const,_SYSTEM_PROCESSOR_IDLE_CYCLE_TIME_INFORMATION *>>,0>>::_Insert_hint<std::pair<unsigned long const,_SYSTEM_PROCESSOR_IDLE_CYCLE_TIME_INFORMATION *> &,std::_Tree_node<std::pair<unsigned long const,_SYSTEM_PROCESSOR_IDLE_CYCLE_TIME_INFORMATION *>,void *> *>(CSystemProcessInfoMap *this, int a2, int _Where, int _Val, CSystemProcessInfoMapNode *_Newnode)
{
  std__Tree_node *v5; // ecx
  bool v6; // dl
  _DWORD *v7; // ebx
  int v8; // edi
  std__Tree_node *v9; // eax
  std__Tree_node *v10; // ecx
  int v11; // esi
  int *v12; // eax
  int v13; // ecx
  int result; // eax
  int v15; // [esp+0h] [ebp-2Ch]
  std__Tree_node *v16; // [esp+10h] [ebp-1Ch]
  CSystemProcessInfoMap *v17; // [esp+14h] [ebp-18h]
  int v18; // [esp+18h] [ebp-14h]
  int *v19; // [esp+1Ch] [ebp-10h]
  int v20; // [esp+28h] [ebp-4h]

  v19 = &v15;
  v17 = this;
  v5 = this->_Header;
  v6 = 1;
  v7 = _Val;
  v8 = v5;
  v20 = 0;
  v16 = v5;
  v9 = v5->_Parent;
  LOBYTE(v18) = 1;
  if ( !v9->_IsNil )
  {
    v10 = *_Val;
    do
    {
      v8 = v9;
      if ( _Where )
        v6 = v9[1]._Left >= v10;
      else
        v6 = v10 < v9[1]._Left;
      LOBYTE(v18) = v6;
      if ( v6 )
        v9 = v9->_Left;
      else
        v9 = v9->_Right;
    }
    while ( !v9->_IsNil );
    v5 = v16;
  }
  v11 = v8;
  _Where = v8;
  if ( v6 )
  {
    if ( v8 == v5->_Left )
    {
      v12 = std::_Tree<std::_Tmap_traits<unsigned long,_SYSTEM_PROCESSOR_IDLE_CYCLE_TIME_INFORMATION *,std::less<unsigned long>,std::allocator<std::pair<unsigned long const,_SYSTEM_PROCESSOR_IDLE_CYCLE_TIME_INFORMATION *>>,0>>::_Insert_at<std::pair<unsigned long const,_SYSTEM_PROCESSOR_IDLE_CYCLE_TIME_INFORMATION *> &,std::_Tree_node<std::pair<unsigned long const,_SYSTEM_PROCESSOR_IDLE_CYCLE_TIME_INFORMATION *>,void *> *>(
              v17,
              &_Where,
              1,
              v8,
              _Val,
              _Newnode);
LABEL_14:
      v13 = *v12;
      result = a2;
      *a2 = v13;
      *(a2 + 4) = 1;
      return result;
    }
    std::_Tree_unchecked_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<unsigned long const,_SYSTEM_PROCESSOR_IDLE_CYCLE_TIME_INFORMATION *>>>,std::_Iterator_base0>::operator--(&_Where);
    v11 = _Where;
  }
  if ( *(v11 + 16) < *v7 )
  {
    v12 = std::_Tree<std::_Tmap_traits<unsigned long,_SYSTEM_PROCESSOR_IDLE_CYCLE_TIME_INFORMATION *,std::less<unsigned long>,std::allocator<std::pair<unsigned long const,_SYSTEM_PROCESSOR_IDLE_CYCLE_TIME_INFORMATION *>>,0>>::_Insert_at<std::pair<unsigned long const,_SYSTEM_PROCESSOR_IDLE_CYCLE_TIME_INFORMATION *> &,std::_Tree_node<std::pair<unsigned long const,_SYSTEM_PROCESSOR_IDLE_CYCLE_TIME_INFORMATION *>,void *> *>(
            v17,
            &_Where,
            v18,
            v8,
            v7,
            _Newnode);
    goto LABEL_14;
  }
  j__free(_Newnode);
  result = a2;
  *a2 = v11;
  *(a2 + 4) = 0;
  return result;
}
// 10081AA: using guessed type void __stdcall __noreturn _CxxThrowException(_DWORD, _DWORD);

//----- (00FD9C10) --------------------------------------------------------
int __thiscall sub_FD9C10(_DWORD *this, int a2, _DWORD *a3, _DWORD *a4, int a5)
{
  _DWORD *v5; // ebx
  _DWORD *v6; // ecx
  bool v7; // dl
  _DWORD *v8; // edi
  _DWORD *v9; // esi
  int *v10; // eax
  unsigned int v11; // ecx
  _DWORD *v12; // eax
  int *v13; // eax
  int v14; // ecx
  int result; // eax
  int v16; // [esp+0h] [ebp-2Ch]
  _DWORD *v17; // [esp+10h] [ebp-1Ch]
  _DWORD *v18; // [esp+14h] [ebp-18h]
  int v19; // [esp+18h] [ebp-14h]
  int *v20; // [esp+1Ch] [ebp-10h]
  int v21; // [esp+28h] [ebp-4h]

  v20 = &v16;
  v5 = this;
  v17 = this;
  v6 = *this;
  v7 = 1;
  v8 = a4;
  v9 = v6;
  v21 = 0;
  v18 = v6;
  v10 = v6[1];
  LOBYTE(v19) = 1;
  if ( !*(v10 + 13) )
  {
    v11 = *a4;
    do
    {
      v9 = v10;
      if ( a3 )
        v7 = v10[4] >= v11;
      else
        v7 = v11 < v10[4];
      LOBYTE(v19) = v7;
      if ( v7 )
        v10 = *v10;
      else
        v10 = v10[2];
    }
    while ( !*(v10 + 13) );
    v6 = v18;
    v5 = v17;
  }
  v12 = v9;
  a3 = v9;
  if ( v7 )
  {
    if ( v9 == *v6 )
    {
      v13 = sub_FD98E0(v5, &a3, 1, v9, a4, a5);
LABEL_14:
      v14 = *v13;
      result = a2;
      *a2 = v14;
      *(a2 + 4) = 1;
      return result;
    }
    std::_Tree_unchecked_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<unsigned long const,_SYSTEM_PROCESSOR_IDLE_CYCLE_TIME_INFORMATION *>>>,std::_Iterator_base0>::operator--(&a3);
    v12 = a3;
  }
  if ( v12[4] < *v8 )
  {
    v13 = sub_FD98E0(v5, &a4, v19, v9, v8, a5);
    goto LABEL_14;
  }
  *a2 = v12;
  result = a2;
  *(a2 + 4) = 0;
  return result;
}
// 10081AA: using guessed type void __stdcall __noreturn _CxxThrowException(_DWORD, _DWORD);

//----- (00FD9D20) --------------------------------------------------------
int MakeDriverName(wchar_t *pszText, wchar_t *lpszFormat, ...)
{
  va_list ArgList; // [esp+10h] [ebp+10h]

  va_start(ArgList, lpszFormat);
  return vswprintf_s(pszText, 10u, lpszFormat, ArgList);
}

//----- (00FD9D40) --------------------------------------------------------
int wsprintfW(wchar_t *Dst, wchar_t *Format, ...)
{
  va_list ArgList; // [esp+10h] [ebp+10h]

  va_start(ArgList, Format);
  return vswprintf_s(Dst, 0x1000u, Format, ArgList);
}

//----- (00FD9D60) --------------------------------------------------------
int sub_FD9D60(wchar_t *Dst, wchar_t *Format, ...)
{
  va_list ArgList; // [esp+10h] [ebp+10h]

  va_start(ArgList, Format);
  return vswprintf_s(Dst, 0x105u, Format, ArgList);
}

//----- (00FD9D80) --------------------------------------------------------
int wsprintf_s(wchar_t *Dst, wchar_t *Format, ...)
{
  va_list ArgList; // [esp+10h] [ebp+10h]

  va_start(ArgList, Format);
  return vswprintf_s(Dst, 0x20u, Format, ArgList);
}

//----- (00FD9DA0) --------------------------------------------------------
int sub_FD9DA0(wchar_t *Dst, wchar_t *Format, ...)
{
  va_list ArgList; // [esp+10h] [ebp+10h]

  va_start(ArgList, Format);
  return vswprintf_s(Dst, 0x32u, Format, ArgList);
}

//----- (00FD9DC0) --------------------------------------------------------
int MakeDeviceName(wchar_t *Dst, wchar_t *Format, ...)
{
  va_list ArgList; // [esp+10h] [ebp+10h]

  va_start(ArgList, Format);
  return vswprintf_s(Dst, 0x40u, Format, ArgList);
}

//----- (00FD9DE0) --------------------------------------------------------
int sub_FD9DE0(wchar_t *Dst, wchar_t *Format, ...)
{
  va_list ArgList; // [esp+10h] [ebp+10h]

  va_start(ArgList, Format);
  return vswprintf_s(Dst, 0x41u, Format, ArgList);
}

//----- (00FD9E00) --------------------------------------------------------
int *__thiscall sub_FD9E00(_DWORD *this, LPCWSTR lpWideCharStr)
{
  int *v2; // esi
  IAtlStringMgr *v3; // ecx
  CHAR *v4; // eax

  v2 = this;
  v3 = ATL::StrTraitATL<wchar_t,ATL::ChTraitsCRT<wchar_t>>::GetDefaultManager();
  if ( !v3 )
    ATL::AtlThrowImpl(E_FAIL);
  *v2 = (v3->vtptr->GetNilData)() + 16;
  if ( !lpWideCharStr || lpWideCharStr & 0xFFFF0000 )
  {
    sub_FD9FE0(v2, lpWideCharStr);
  }
  else
  {
    v4 = ATL::StrTraitATL<wchar_t,ATL::ChTraitsCRT<wchar_t>>::FindStringResourceInstance(lpWideCharStr, 0);
    if ( v4 )
      sub_FDF660(v2, v4, lpWideCharStr);
  }
  return v2;
}

//----- (00FD9EA0) --------------------------------------------------------
CString *__thiscall ATL::CStringT<wchar_t,ATL::StrTraitATL<wchar_t,ATL::ChTraitsCRT<wchar_t>>>::CStringT<wchar_t,ATL::StrTraitATL<wchar_t,ATL::ChTraitsCRT<wchar_t>>>(CString *this, LPCSTR lpMultiByteStr)
{
  CString *v2; // esi
  IAtlStringMgr *v3; // ecx

  v2 = this;
  v3 = ATL::StrTraitATL<wchar_t,ATL::ChTraitsCRT<wchar_t>>::GetDefaultManager();
  if ( !v3 )
    ATL::AtlThrowImpl(0x80004005);
  v2->pszData = ((v3->vtptr->GetNilData)() + 16);
  ATL::CStringT<wchar_t,ATL::StrTraitATL<wchar_t,ATL::ChTraitsCRT<wchar_t>>>::operator=(v2, lpMultiByteStr);
  return v2;
}

//----- (00FD9F20) --------------------------------------------------------
void __thiscall sub_FD9F20(void **this)
{
  void **v1; // eax
  _DWORD *v2; // ebx
  void *v3; // edi
  unsigned int v4; // esi
  int v5; // ecx
  void **v6; // [esp+4h] [ebp-4h]

  v1 = this;
  v6 = this;
  v2 = *this;
  if ( *this )
  {
    v3 = this[1];
    v4 = 0;
    if ( v3 )
    {
      do
      {
        v5 = v2[v4];
        if ( v5 )
          (*(*v5 + 8))(v2[v4]);
        ++v4;
      }
      while ( v4 < v3 );
      v1 = v6;
    }
    free(*v1);
  }
}

//----- (00FD9F70) --------------------------------------------------------
void __thiscall PerformanceInfoInMemory::~PerformanceInfoInMemory(PerformanceInfoInMemory *this)
{
  PerformanceInfoInMemory *v1; // esi

  v1 = this;
  j__free(this->m_pBuffer);
  v1->m_pBuffer = 0;
}

//----- (00FD9FB0) --------------------------------------------------------
void __thiscall sub_FD9FB0(CSystemProcessInfoMap *this)
{
  CSystemProcessInfoMap *v1; // esi
  int *a2; // [esp+4h] [ebp-4h]

  v1 = this;
  sub_FF5510(this, &a2, this->_Header->_Left, this->_Header);
  j__free(v1->_Header);
}

//----- (00FD9FE0) --------------------------------------------------------
int *__thiscall sub_FD9FE0(int *this, LPCWSTR lpWideCharStr)
{
  int *v2; // edi
  int v3; // esi
  int *result; // eax

  v2 = this;
  if ( lpWideCharStr && (v3 = WideCharToMultiByte(3u, 0, lpWideCharStr, -1, 0, 0, 0, 0) - 1, v3 > 0) )
  {
    if ( ((*(*v2 - 8) - v3) | (1 - *(*v2 - 4))) < 0 )
      sub_FE2330(v2, v3);
    WideCharToMultiByte(3u, 0, lpWideCharStr, -1, *v2, v3, 0, 0);
    if ( v3 > *(*v2 - 8) )
      ATL::AtlThrowImpl(-2147024809);
    *(*v2 - 12) = v3;
    *(v3 + *v2) = 0;
    result = v2;
  }
  else
  {
    sub_FDB8D0(v2);
    result = v2;
  }
  return result;
}

//----- (00FDA070) --------------------------------------------------------
char *__cdecl sub_FDA070(HWND hWnd, char a2, int a3, int a4, int a5, int a6, int a7, u_long hostlong, int a9, int port, int a11, int a12, int a13, int a14)
{
  const __m128i *v14; // esi
  const __m128i *v15; // edi
  int v16; // esi
  __int32 *v17; // edx
  _DWORD *v18; // ecx
  unsigned int v19; // edi
  bool v20; // cf
  LRESULT v21; // eax
  signed int v22; // eax
  int *v23; // edi
  const wchar_t *v24; // eax
  char *result; // eax
  int v26; // eax
  int v27; // edi
  _BYTE *v28; // edi
  char v29; // dl
  char v30; // al
  signed int v31; // ecx
  _DWORD *v32; // edx
  _DWORD *v33; // ecx
  unsigned int v34; // edi
  unsigned int v35; // kr00_4
  HWND v36; // ebx
  char v37; // [esp-890h] [ebp-13B0h]
  char v38; // [esp+Ch] [ebp-B14h]
  int v39; // [esp+10h] [ebp-B10h]
  int v40; // [esp+1Ch] [ebp-B04h]
  char v41; // [esp+30h] [ebp-AF0h]
  int v42; // [esp+34h] [ebp-AECh]
  int v43; // [esp+38h] [ebp-AE8h]
  __int128 v44; // [esp+3Ch] [ebp-AE4h]
  int v45; // [esp+254h] [ebp-8CCh]
  u_long v46; // [esp+460h] [ebp-6C0h]
  __int128 v47; // [esp+464h] [ebp-6BCh]
  int v48; // [esp+67Ch] [ebp-4A4h]
  int v49; // [esp+888h] [ebp-298h]
  int *v50; // [esp+88Ch] [ebp-294h]
  int v51; // [esp+890h] [ebp-290h]
  wchar_t *v52; // [esp+894h] [ebp-28Ch]
  LPARAM v53; // [esp+89Ch] [ebp-284h]
  int v54; // [esp+8A4h] [ebp-27Ch]
  const wchar_t *v55; // [esp+8B0h] [ebp-270h]
  LPARAM lParam; // [esp+8D0h] [ebp-250h]
  WPARAM wParam; // [esp+8D4h] [ebp-24Ch]
  int v58; // [esp+8D8h] [ebp-248h]
  int v59; // [esp+8F0h] [ebp-230h]
  const __m128i *v60; // [esp+904h] [ebp-21Ch]
  _BYTE *v61; // [esp+908h] [ebp-218h]
  int *v62; // [esp+90Ch] [ebp-214h]
  int v63; // [esp+910h] [ebp-210h]
  HWND v64; // [esp+914h] [ebp-20Ch]
  int v65; // [esp+918h] [ebp-208h]
  __int16 Dst[256]; // [esp+91Ch] [ebp-204h]

  v14 = a9;
  v65 = a4;
  v15 = a6;
  v62 = a12;
  v61 = a14;
  v64 = hWnd;
  v60 = a6;
  v63 = a9;
  lParam = 4;
  wParam = 0;
  v58 = 0;
  if ( !SendMessageW(hWnd, 0x104Bu, 0, &lParam) )
  {
LABEL_15:
    memset(&v38, 0, 0x890u);
    v39 = 5;
    v41 = 1;
    v22 = 2;
    v42 = a3;
    if ( a2 )
      v22 = 0;
    v40 = v22;
    v49 = v65;
    v43 = a5;
    if ( v15 )
      _mm_storeu_si128(&v44, _mm_loadu_si128(v15));
    v45 = a7;
    v46 = hostlong;
    if ( v14 )
      _mm_storeu_si128(&v47, _mm_loadu_si128(v14));
    v23 = v62;
    v48 = port;
    if ( gdwVersion >= 1 && !a13 && v62 )
    {
      if ( *v62 )
      {
        v24 = sub_FFEFB0(*v62);
        v52 = _wcsdup(v24);
      }
    }
    v50 = v23;
    v51 = a13;
    qmemcpy(&v37, &v38, 0x890u);
    return sub_FB7DD0(v64, v37);
  }
  while ( 1 )
  {
    if ( (v16 = v59, a3) && a3 != 1 || *(v59 + 44) == a5 )
    {
      if ( a3 == 2 || a3 == 3 )
      {
        v17 = v15;
        v18 = (v59 + 48);
        v19 = 12;
        while ( *v18 == *v17 )
        {
          ++v18;
          ++v17;
          v20 = v19 < 4;
          v19 -= 4;
          if ( v20 )
            goto LABEL_10;
        }
        goto LABEL_13;
      }
LABEL_10:
      if ( !*(v59 + 36) && *(v59 + 40) == a3 && *(v59 + 584) == a7 )
        break;
    }
LABEL_13:
    ++wParam;
    v21 = SendMessageW(v64, 0x104Bu, 0, &lParam);
    v15 = v60;
    if ( !v21 )
    {
      v14 = v63;
      goto LABEL_15;
    }
  }
  if ( a3 == 1 || a3 == 3 )
  {
LABEL_31:
    v26 = v65;
    goto LABEL_32;
  }
  if ( a3 )
  {
    if ( a3 != 2 )
      goto LABEL_41;
    v32 = v63;
    v33 = (v59 + 1112);
    v34 = 12;
    while ( *v33 == *v32 )
    {
      ++v33;
      ++v32;
      v20 = v34 < 4;
      v34 -= 4;
      if ( v20 )
        goto LABEL_41;
    }
    goto LABEL_31;
  }
  if ( *(v59 + 1108) != hostlong )
    goto LABEL_31;
LABEL_41:
  v26 = v65;
  if ( *(v59 + 2172) != v65 )
  {
    v27 = port;
LABEL_43:
    *(v59 + 2172) = v26;
    *(v16 + 1108) = hostlong;
    *(v16 + 1648) = v27;
    if ( a3 )
    {
      v54 = 2;
      v55 = L"*:*";
      SendMessageW(v64, 0x1074u, wParam, &v53);
    }
    else
    {
      sub_FC44B0(0, 1, 0, hostlong, v63, Dst, 0x100u);
      v35 = wcslen(Dst);
      sub_FC4670(1, v27, gszProtocolNames[0], &Dst[v35], 256 - v35);
      v36 = v64;
      v55 = Dst;
      v54 = 2;
      SendMessageW(v64, 0x1074u, wParam, &v53);
      v54 = 3;
      v55 = gszNetStatus[v65];
      SendMessageW(v36, 0x1074u, wParam, &v53);
    }
    v28 = v61;
    *v61 = 1;
    goto LABEL_34;
  }
LABEL_32:
  v27 = port;
  if ( *(v59 + 1648) != port )
    goto LABEL_43;
  v28 = v61;
LABEL_34:
  v29 = *(v16 + 24);
  v30 = 0;
  if ( v29 )
  {
    v31 = *(v16 + 28);
    if ( v31 < gConfig.dwHighlightDuration )
    {
      *(v16 + 16) = 2;
      result = 0;
      *(v16 + 20) = v31;
      *(v16 + 36) = 1;
      return result;
    }
    if ( v29 )
    {
      v30 = 1;
      *(v16 + 24) = 0;
    }
  }
  *(v16 + 16) = 0;
  if ( v30 )
    *v28 = 1;
  result = 0;
  *(v16 + 36) = 1;
  return result;
}
// 103E250: using guessed type wchar_t asc_103E250[4];
// 105D238: using guessed type wchar_t *gszNetStatus[13];
// 1064E54: using guessed type int gdwVersion;
// FDA070: using guessed type wchar_t Dst[256];

//----- (00FDA4A0) --------------------------------------------------------
CHAR *__thiscall sub_FDA4A0(CString *this, __int16 a2)
{
  CString *v2; // edi
  int v3; // ebx
  int v4; // esi
  CHAR *result; // eax

  v2 = this;
  v3 = *(this->pszData - 3);
  v4 = v3 + 1;
  if ( v3 + 1 < 0 )
    goto LABEL_9;
  if ( ((*(this->pszData - 2) - v4) | (1 - *(this->pszData - 1))) < 0 )
    ATL::CSimpleStringT<wchar_t,0>::PrepareWrite2(this, v3 + 1);
  *&v2->pszData[2 * v3] = a2;
  if ( v4 > *(v2->pszData - 2) )
LABEL_9:
    ATL::AtlThrowImpl(-2147024809);
  *(v2->pszData - 3) = v4;
  result = v2->pszData;
  *&v2->pszData[2 * v4] = 0;
  return result;
}

//----- (00FDA500) --------------------------------------------------------
int __cdecl sub_FDA500(SYSTEM_PROCESS_INFORMATION *pSystemProcessInfo)
{
  SYSTEM_PROCESS_INFORMATION *pNext; // eax
  ULONG NumberOfThreads; // ecx
  signed int v3; // edx
  PUCHAR pKernelTime; // eax
  unsigned int v5; // esi
  int v6; // kr00_4
  int result; // eax

  if ( GetVersion() <= 4u )
    pNext = (pSystemProcessInfo + 0x88);
  else
    pNext = pSystemProcessInfo + 1;
  NumberOfThreads = pSystemProcessInfo->NumberOfThreads;
  if ( !NumberOfThreads )
    goto __quit;
  v3 = 0;
  pKernelTime = &pNext->KernelTime;
  v5 = 0;
  do
  {
    v6 = *pKernelTime + v5;
    v3 = (*pKernelTime + __PAIR__(v3, v5)) >> 32;
    v5 += *pKernelTime;
    pKernelTime += 0x40;
    --NumberOfThreads;
  }
  while ( NumberOfThreads );
  if ( v3 >= 0 && (v3 > 0 || v6) )
    result = v6;
  else
__quit:
    result = 0;
  return result;
}

//----- (00FDA580) --------------------------------------------------------
int __stdcall pfnAclChangeCallback(HWND Owner, HANDLE Instance, PVOID CallbackContext, PSECURITY_DESCRIPTOR NewSD, PSECURITY_DESCRIPTOR NewObjectSD, BOOLEAN ApplyToSubContainers, BOOLEAN ApplyToSubObjects, PDWORD ChangeContextStatus)
{
  PVOID v8; // esi
  int v9; // eax
  int v10; // eax
  PDWORD v11; // eax
  void *v12; // edi
  int result; // eax
  unsigned int v14; // eax
  bool v15; // zf
  DWORD nLengthNeeded; // [esp+8h] [ebp-4h]

  v8 = CallbackContext;
  v9 = *(CallbackContext + 2);
  if ( v9 )
  {
    v10 = v9 - 1;
    if ( v10 )
    {
      if ( v10 == 1 )
      {
        CallbackContext = 1;
        v11 = 0x80000;
      }
      else
      {
        v11 = ChangeContextStatus;
      }
    }
    else
    {
      CallbackContext = 8;
      v11 = (&loc_FFFFFE + 2);
    }
  }
  else
  {
    CallbackContext = 4;
    v11 = 0x40000;
  }
  v12 = PE_DuplicateProcessHandle(*v8, *(v8 + 1), v11);
  if ( v12 )
  {
    if ( SetUserObjectSecurity(v12, &CallbackContext, NewSD) )
    {
      v14 = CallbackContext | 3;
      v15 = *(v8 + 2) == 2;
      CallbackContext = (CallbackContext | 3);
      if ( v15 )
        CallbackContext = (v14 | 4);
      **(v8 + 5) = GetUserObjectSecurity(v12, &CallbackContext, *(v8 + 4), 0x2000u, &nLengthNeeded);
    }
    else
    {
      MessageBoxW(0, L"Unable to modify the object's Security Information.", L"WinObj", 0x10u);
    }
    CloseHandle(v12);
    *ChangeContextStatus = 1;
    result = 0;
  }
  else
  {
    MessageBoxW(0, L"Unable to modify the object's Security Information.", L"WinObj", 0x10u);
    *ChangeContextStatus = 1;
    result = 0;
  }
  return result;
}

//----- (00FDA670) --------------------------------------------------------
HBRUSH __stdcall DlgDllInfo(HWND hWnd, UINT msg, WPARAM uID, DLLINFOLISTITEMPARAM *pListItem)
{
  DLLLISTITEMPARAM *pItemParam; // edi
  CResizer *v5; // eax
  CResizer *pResizer; // eax
  HWND v7; // eax
  struct tagResizerItem *v8; // eax
  HWND v9; // eax
  struct tagResizerItem *v10; // eax
  CHAR *psz; // eax
  const WCHAR *v12; // eax
  const WCHAR *v13; // ecx
  BOOL v14; // ST10_4
  HWND v15; // eax
  BOOL v16; // ST10_4
  HWND v17; // eax
  HICON v18; // ST10_4
  HWND v19; // eax
  HICON v20; // ST10_4
  HWND hWndParent; // eax
  const WCHAR *pszCompanyInfo; // ST10_4
  HWND v23; // eax
  HWND v24; // eax
  _WORD *v25; // eax
  HWND v26; // eax
  HWND v27; // eax
  CHAR *v28; // eax
  int v29; // ST10_4
  HWND v30; // eax
  const WCHAR *v31; // ecx
  wchar_t *v32; // eax
  int v34; // eax
  HWND v35; // eax
  const WCHAR *v36; // eax
  int v37; // eax
  char v38; // cl
  HWND v39; // eax
  int v40; // ST10_4
  HWND v41; // eax
  HWND v42; // eax
  WPARAM v43; // [esp-8h] [ebp-E38h]
  int v44; // [esp-4h] [ebp-E34h]
  CResizer *pResizer_1; // [esp+1Ch] [ebp-E14h]
  WCHAR szTitle[1024]; // [esp+20h] [ebp-E10h]
  WCHAR String[256]; // [esp+820h] [ebp-610h]
  WCHAR v48[256]; // [esp+A20h] [ebp-410h]
  WCHAR Dest[256]; // [esp+C20h] [ebp-210h]
  int v50; // [esp+E2Ch] [ebp-4h]

  pItemParam = GetWindowLongW(hWnd, GWLP_USERDATA);
  switch ( msg )
  {
    case WM_INITDIALOG:
      v5 = operator new(0x40u);
      v50 = 0;
      if ( v5 )
        pResizer = CResizer::CResizer(v5, hWnd);
      else
        pResizer = 0;
      pResizer_1 = pResizer;
      v50 = -1;
      pResizer->m_nXRatio = 85;
      pResizer->m_nYRatio = 100;
      v7 = GetDlgItem(hWnd, IDC_DLG_DLLINFO_EDIT_PATH);
      if ( v7 )
      {
        v8 = CResizer::AddItem(pResizer_1, v7, 1);
        *&v8->m_rect1.left = 0i64;
        *&v8->m_rect1.right = db_one;
      }
      v9 = GetDlgItem(hWnd, IDC_DLG_DLLINFO_EDIT_AUTOSTART_LOCATION);
      if ( v9 )
      {
        v10 = CResizer::AddItem(pResizer_1, v9, 1);
        *&v10->m_rect1.left = 0i64;
        *&v10->m_rect1.right = db_one;
      }
      SetWindowLongW(hWnd, GWLP_USERDATA, pListItem);
      if ( wcsrchr(pListItem->m_strPath.pszData, '\\') )
        psz = (wcsrchr(pListItem->m_strPath.pszData, '\\') + 1);
      else
        psz = pListItem->m_strPath.pszData;
      wsprintfW(szTitle, L"%s Properties", psz);
      SetWindowTextW(hWnd, szTitle);
      if ( pListItem->m_dwStyle & 4 )
        SetDlgItemTextW(hWnd, IDC_DLG_DLLINFO_STATIC_PATH, L"Path (Image is probably packed):");
      v12 = L"Data";
      if ( !(pListItem->m_dwStyle & 2) )
        v12 = L"Image";
      SetDlgItemTextW(hWnd, IDC_DLG_DLLINFO_STATIC_MAPPING_TYPE_VALUE, v12);
      SetDlgItemTextW(hWnd, IDC_DLG_DLLINFO_EDIT_PATH, pListItem->m_strPath.pszData);
      v13 = L"n/a";
      if ( pListItem->m_strLocation )
        v13 = pListItem->m_strLocation;
      SetDlgItemTextW(hWnd, IDC_DLG_DLLINFO_EDIT_AUTOSTART_LOCATION, v13);
      v14 = pListItem->m_strPath.pszData != 0;
      v15 = GetDlgItem(hWnd, IDC_DLG_DLLINFO_BUTTON_EXPLORE_PATH);
      EnableWindow(v15, v14);
      v16 = pListItem->m_strLocation != 0;
      v17 = GetDlgItem(hWnd, IDC_DLG_DLLINFO_BUTTON_EXPLORE_LOCATION);
      EnableWindow(v17, v16);
      v18 = LoadIconW(ghInstance, 154);
      v19 = GetParent(hWnd);
      SendMessageW(v19, WM_SETICON, 1u, v18);
      v20 = LoadIconW(ghInstance, 154);
      hWndParent = GetParent(hWnd);
      SendMessageW(hWndParent, WM_SETICON, 0, v20);
      if ( pListItem->m_strDescription )
        SetDlgItemTextW(hWnd, IDC_DLG_DLLINFO_EDIT_DESCRIPTION, pListItem->m_strDescription);
      else
        SetDlgItemTextW(hWnd, IDC_DLG_DLLINFO_EDIT_DESCRIPTION, L"n/a");
      if ( pListItem->m_strCompanyInfo )
      {
        pszCompanyInfo = VerifyImage(pListItem, gConfig.bVerifySignatures);
        SetDlgItemTextW(hWnd, IDC_DLG_DLLINFO_EDIT_COMPANY, pszCompanyInfo);
      }
      else
      {
        SetDlgItemTextW(hWnd, IDC_DLG_DLLINFO_EDIT_COMPANY, L"n/a");
      }
      v23 = GetDlgItem(hWnd, IDC_DLG_DLLINFO_STATIC_IMAGE_TYPE);
      ShowWindow(v23, 0);
      if ( gbWintrustInited )
      {
        if ( pListItem->field_160 || (v25 = pListItem->m_strCompanyInfo) == 0 || *v25 == '[' )
        {
          v26 = GetDlgItem(hWnd, IDC_DLG_DLLINFO_BUTTON_VERIFY);
          EnableWindow(v26, 0);
        }
      }
      else
      {
        v24 = GetDlgItem(hWnd, IDC_DLG_DLLINFO_BUTTON_VERIFY);
        ShowWindow(v24, 0);
      }
      v27 = GetDlgItem(hWnd, IDC_DLG_DLLINFO_EDIT_VIRUSTOTAL);
      SetWindowSubclass(v27, EditVTClassCallback, 0, 0);
      sub_1001A50(pListItem->m_ItemData1, Dest);
      SetDlgItemTextW(hWnd, IDC_DLG_DLLINFO_EDIT_VIRUSTOTAL, Dest);
      v28 = pListItem->m_strPath.pszData;
      if ( v28 && *v28 != '[' )
      {
        v29 = sub_1001C10(pListItem->m_ItemData1);
        v30 = GetDlgItem(hWnd, IDC_DLG_DLLINFO_BUTTON_SUBMIT);
        EnableWindow(v30, v29);
      }
      v31 = L"n/a";
      if ( pListItem->m_szVersion[0] )
        v31 = pListItem->m_szVersion;
      SetDlgItemTextW(hWnd, IDC_DLG_DLLINFO_EDIT_VERSION, v31);
      wsprintfW(szTitle, L"0x%X", pListItem->m_LoadAddress);
      SetDlgItemTextW(hWnd, IDC_DLG_DLLINFO_STATIC_LOAD_ADDRESS_VALUE, szTitle);
      wsprintfW(szTitle, L"0x%X bytes", pListItem->m_MappedSize);
      SetDlgItemTextW(hWnd, IDC_DLG_DLLINFO_STATIC_MAPED_SIZE_VALUE, szTitle);
      if ( pListItem->m_BuildTime )
        v32 = _wctime32(&pListItem->m_BuildTime);
      else
        v32 = L"n/a";
      SetDlgItemTextW(hWnd, IDC_DLG_DLLINFO_EDIT_BUILD_TIME, v32);
      SetTimer(hWnd, 0, 0x3E8u, 0);
      PropSheet_UpdateTab(hWnd);
      ShowWindow(hWnd, 1);
      return 1;
    case WM_COMMAND:
      if ( uID > IDC_DLG_DLLINFO_BUTTON_EXPLORE_PATH )
      {
        if ( uID > IDM_FILE_EXIT )
        {
          if ( uID - 40092 > 1 )
            return 0;
          v43 = uID;
        }
        else
        {
          if ( uID != IDM_FILE_EXIT )
          {
            if ( uID == IDC_DLG_DLLINFO_BUTTON_SUBMIT )
            {
              if ( !SubmitExeToVirusTotalDotCom() )
                return 1;
              v37 = pItemParam->m_HashData;
              v38 = 0;
              if ( v37 )
              {
                v38 = 1;
                *(v37 + 4) = 6;
              }
              sub_1001C30(pItemParam, ~(pItemParam->field_2C >> 1) & 1, v38 != 0);
              v39 = GetDlgItem(hWnd, IDC_DLG_DLLINFO_BUTTON_SUBMIT);
              EnableWindow(v39, 0);
              sub_1001A50(pItemParam->m_HashData, v48);
              v40 = sub_1001C10(pItemParam->m_HashData);
              v41 = GetDlgItem(hWnd, IDC_DLG_DLLINFO_BUTTON_SUBMIT);
              EnableWindow(v41, v40);
              SetDlgItemTextW(hWnd, IDC_DLG_DLLINFO_EDIT_VIRUSTOTAL, v48);
              PostMessageW(ghMainWnd, 0x7F9u, 0, pItemParam->m_HashData);
              return 1;
            }
            return 0;
          }
          v43 = 40014;
        }
        v42 = GetParent(hWnd);
        PostMessageW(v42, WM_COMMAND, v43, 0);
        return 0;
      }
      if ( uID == IDC_DLG_DLLINFO_BUTTON_EXPLORE_PATH )
      {
        sub_FAB780(hWnd, pItemParam->m_strPath);
        return 1;
      }
      if ( uID > 1005 )
      {
        if ( uID == IDC_DLG_DLLINFO_BUTTON_EXPLORE_LOCATION )
        {
          sub_FAB780(hWnd, pItemParam->m_strLocation);
          return 1;
        }
        return 0;
      }
      if ( uID != 1005 )
      {
        if ( uID != 1 )
        {
          if ( uID == 2 )
            return 1;
          return 0;
        }
        return 1;
      }
      v36 = VerifyImage(pItemParam, 1);
      SetDlgItemTextW(hWnd, 3, v36);
      v44 = 0;
      v35 = GetDlgItem(hWnd, IDC_DLG_DLLINFO_BUTTON_VERIFY);
LABEL_44:
      EnableWindow(v35, v44);
      return 1;
    case WM_TIMER:
      GetDlgItemTextW(hWnd, IDC_DLG_DLLINFO_EDIT_VIRUSTOTAL, String, 256);
      sub_1001A50(pItemParam->m_HashData, Dest);
      v34 = wcscmp(String, Dest);
      if ( v34 )
        v34 = -(v34 < 0) | 1;
      if ( !v34 )
        return 1;
      SetDlgItemTextW(hWnd, IDC_DLG_DLLINFO_EDIT_VIRUSTOTAL, Dest);
      v44 = sub_1001C10(pItemParam->m_HashData);
      v35 = GetDlgItem(hWnd, IDC_DLG_DLLINFO_BUTTON_SUBMIT);
      goto LABEL_44;
    case WM_CTLCOLORSTATIC:
      if ( pListItem != GetDlgItem(hWnd, IDC_DLG_DLLINFO_EDIT_VIRUSTOTAL) || !sub_1001820(pItemParam->m_HashData) )
        return 0;
      if ( sub_1002910(pItemParam->m_HashData) )
        SetTextColor(uID, 0xFFu);
      else
        SetTextColor(uID, 0xFF0000u);
      SelectObject(uID, ghDefaultUnderlineFontHandle);
      return GetSysColorBrush(COLOR_BTNHILIGHT);
    default:
      return 0;
  }
}
// 103E220: using guessed type wchar_t aData_0[5];
// 106A391: using guessed type char gbWintrustInited;

//----- (00FDADD0) --------------------------------------------------------
BOOL __stdcall ProcPropSheet(HWND hDlg, UINT uMsg, WPARAM wParam, PROPITEM *PropItem)
{
  LONG v4; // eax
  tagTREEVIEWLISTITEMPARAM **v5; // ebx
  HWND *v7; // esi
  signed int v8; // ebx
  LRESULT v9; // eax
  tagTREEVIEWLISTITEMPARAM *v10; // esi
  HWND v11; // eax
  int v12; // ecx
  HWND v13; // esi
  HWND *v14; // esi
  HWND v15; // ecx
  void (__stdcall *SendMessageW)(HWND, UINT, WPARAM, LPARAM); // esi
  WPARAM v17; // eax
  LRESULT v18; // eax
  WPARAM v19; // ecx
  _DWORD *i; // eax
  CResizer *pResizer; // eax
  HWND v22; // ebx
  bool v23; // zf
  void *v24; // eax
  wchar_t *v25; // eax
  HWND hDlgDllInfo; // eax
  UINT v27; // eax
  WPARAM v28; // ecx
  POINT v29; // ST10_8
  HCURSOR v30; // eax
  tagTCITEMW tcitem; // [esp+10h] [ebp-260h]
  struct tagPOINT Point; // [esp+2Ch] [ebp-244h]
  CResizer *hWnd; // [esp+34h] [ebp-23Ch]
  NMHDR lParam; // [esp+38h] [ebp-238h]
  HWND hWndTab; // [esp+44h] [ebp-22Ch]
  struct tagRECT Rect; // [esp+48h] [ebp-228h]
  WCHAR String; // [esp+58h] [ebp-218h]
  int v38; // [esp+26Ch] [ebp-4h]

  hWnd = hDlg;
  hWndTab = GetDlgItem(hDlg, IDS_PROCPROPSHEET_TABCTRL);
  v4 = GetWindowLongW(hDlg, GWLP_USERDATA);
  v5 = v4;
  if ( uMsg > WM_NOTIFY )
  {
    if ( uMsg == WM_INITDIALOG )
    {
      pResizer = operator new(0x40u);
      hWnd = pResizer;
      v38 = 0;
      if ( pResizer )
        CResizer::CResizer(pResizer, hDlg);
      SetWindowLongW(hDlg, GWLP_USERDATA, PropItem);
      v22 = hWndTab;
      tcitem.mask = 3;
      tcitem.iImage = -1;
      tcitem.pszText = L"Image";
      ::SendMessageW(hWndTab, TCM_INSERTITEMW, 0, &tcitem);
      wcscpy_s(PropItem->PageData[1].szTemplateName, 0x100u, L"PROCSTRINGS");
      PropItem->PageData[1].nTabId = 13;
      PropItem->PageData[1].PageWndProc = PageProcStrings;
      tcitem.pszText = L"Strings";
      ::SendMessageW(v22, TCM_INSERTITEMW, 1u, &tcitem);
      v23 = wcsrchr(*(PropItem->pListItem + 86), '\\') == 0;
      v24 = PropItem->pListItem;
      if ( v23 )
        v25 = *(v24 + 86);
      else
        v25 = wcsrchr(*(v24 + 86), '\\') + 1;
      swprintf(&String, L"%s Properties", v25);
      SetWindowTextW(hDlg, &String);
      hDlgDllInfo = CreateDialogParamW(ghMainInstance, L"DLLINFO", hDlg, DlgDllInfo, PropItem->pListItem);
      PropItem->PageData[0].hWnd = hDlgDllInfo;
      PropItem->PageData[0].nTabId = 1;
      ShowWindow(hDlgDllInfo, 5);
      SetForegroundWindow(hDlg);
      v27 = PropItem->PageData[0].nTabId;
      v28 = 0;
      if ( v27 )
      {
        while ( gConfig.dwDefaultDllPropPage != v27 )
        {
          v27 = *(&PropItem->nTabIndex + 131 * (++v28 + 1));
          if ( !v27 )
            goto LABEL_47;
        }
      }
      else
      {
LABEL_47:
        v28 = 0;
      }
      ::SendMessageW(v22, TCM_SETCURSEL, v28, 0);
      lParam.idFrom = 1110;
      lParam.code = TCN_SELCHANGE;
      ::SendMessageW(hDlg, WM_NOTIFY, 0, &lParam);
      if ( gConfig.WindowPlacement[3].rcNormalPosition.right == gConfig.WindowPlacement[3].rcNormalPosition.left )
      {
        GetCursorPos(&Point);
        v29.y = Point.y - 408;
        v29.x = Point.x - 385;
        PE_SetWindowPlacement(hDlg, v29);
      }
      else
      {
        sub_FEDC50(hDlg, PropItem->pListItem);
      }
      ShowWindow(hDlg, 5);
      InterlockedDecrement(&gnRefCount);
      v30 = LoadCursorW(0, 0x7F00);
      SetCursor(v30);
      return 1;
    }
    if ( uMsg == 273 )
    {
      if ( wParam > 40092 )
      {
        if ( wParam != 40093 )
          return 0;
        v18 = ::SendMessageW(hWndTab, TCM_GETCURSEL, 0, 0);
        v19 = v18 - 1;
        if ( !v18 )
        {
          v19 = 0;
          for ( i = v5 + 263; *i; ++v19 )
            i += 131;
        }
        SendMessageW = ::SendMessageW;
        ::SendMessageW(hWndTab, TCM_SETCURSEL, v19, 0);
      }
      else
      {
        if ( wParam != 40092 )
        {
          if ( wParam > 0 && (wParam <= 2 || wParam == 40014) )
          {
            v14 = (v4 + 8);
            v15 = 32;
            hWndTab = 32;
            while ( 1 )
            {
              if ( *v14 )
              {
                ::SendMessageW(*v14, WM_COMMAND, wParam, 0);
                DestroyWindow(*v14);
                v15 = hWndTab;
              }
              v14 += 131;
              v15 = (v15 - 1);
              hWndTab = v15;
              if ( !v15 )
              {
                DLLLISTITEMPARAM_Release(v5[1]);
                free(v5);
                GetWindowPlacement(hWnd, &gConfig.WindowPlacement[3]);
                DestroyWindow(hWnd);
                _endthread();
              }
            }
          }
          return 0;
        }
        SendMessageW = ::SendMessageW;
        v17 = ::SendMessageW(hWndTab, TCM_GETCURSEL, 0, 0) + 1;
        if ( !v5[131 * v17 + 132] )
          v17 = 0;
        ::SendMessageW(hWndTab, TCM_SETCURSEL, v17, 0);
      }
      lParam.idFrom = IDS_PROCPROPSHEET_TABCTRL;
      lParam.code = TCN_SELCHANGE;
      SendMessageW(hDlg, WM_NOTIFY, 0, &lParam);
    }
    return 0;
  }
  if ( uMsg == WM_NOTIFY )
  {
    if ( PropItem->pListItem == IDS_PROCPROPSHEET_TABCTRL && PropItem->PageData[0].hWnd == -0x227 )
    {
      v9 = ::SendMessageW(hWndTab, TCM_GETCURSEL, 0, 0);
      v10 = v9;
      v11 = &v5[131 * v9];
      gConfig.dwDefaultDllPropPage = *(v11 + 524);
      v12 = 131 * *v5;
      hWndTab = v11;
      ShowWindow(v5[v12 + 2], 0);
      *v5 = v10;
      v13 = hWndTab;
      if ( !*(hWndTab + 2) )
        *(hWndTab + 2) = CreateDialogParamW(ghMainInstance, hWndTab + 6, hDlg, *(hWndTab + 132), v5[1]);
      ShowWindow(*(v13 + 2), 5);
      return 0;
    }
    return 0;
  }
  if ( uMsg != WM_SIZE )
  {
    if ( uMsg == WM_GETMINMAXINFO )
    {
      PropItem->PageData[0].hWnd = (2 * gdwVirtualScreenWidth);
      return 0;
    }
    return 0;
  }
  v7 = (v4 + 8);
  v8 = 32;
  do
  {
    if ( *v7 )
    {
      GetWindowRect(hWndTab, &Rect);
      ::SendMessageW(hWndTab, TCM_ADJUSTRECT, 0, &Rect);
      MapWindowPoints(0, hDlg, &Rect, 2u);
      MoveWindow(*v7, Rect.left, Rect.top, Rect.right - Rect.left, Rect.bottom - Rect.top, 1);
    }
    v7 += 131;
    --v8;
  }
  while ( v8 );
  return 0;
}
// 100A009: using guessed type int _endthread(void);
// 10465E8: using guessed type wchar_t aStrings[8];
// 1064E28: using guessed type int gdwVirtualScreenWidth;

//----- (00FDB330) --------------------------------------------------------
signed int CDriver::Load()
{
  WCHAR szDirName[260]; // [esp+0h] [ebp-414h]
  WCHAR szPathName[260]; // [esp+208h] [ebp-20Ch]

  if ( !CDriver::Open(L"PROCEXP152", &ghDriverHandle) )
  {
    GetSystemDirectoryW(szDirName, MAX_PATH);
    swprintf(szPathName, L"%s\\Drivers\\%s", szDirName, L"PROCEXP152.SYS");
    if ( !CDriver::SaveDriverFromResource(0x96, szPathName) )
    {
      swprintf(szDirName, L"%%TEMP%%\\%s", L"PROCEXP152.SYS");
      ExpandEnvironmentStringsW(szDirName, szPathName, MAX_PATH);
      if ( !CDriver::SaveDriverFromResource(0x96, szPathName) )
      {
        GetCurrentDirectoryW(MAX_PATH, szDirName);
        swprintf(szPathName, L"%s\\s", szDirName, L"PROCEXP152.SYS");
        if ( !CDriver::SaveDriverFromResource(0x96, szPathName) )
          return 0;
      }
    }
    if ( !CDriver::OpenEx(L"PROCEXP152", szPathName, &ghDriverHandle) )
    {
      DeleteFileW(szPathName);
      return 0;
    }
    DeleteFileW(szPathName);
  }
  return 1;
}
// 1042E08: using guessed type wchar_t aProcexp152Sys[15];

//----- (00FDB490) --------------------------------------------------------
HCURSOR __cdecl sub_FDB490(HWND hWnd, int a2)
{
  HWND v2; // ST14_4
  HCURSOR result; // eax
  HCURSOR v4; // edi
  int v5; // ecx
  HCURSOR v6; // eax
  void *v7; // eax
  HANDLE v8; // eax
  void *v9; // eax
  ULONG v10; // esi
  void *v11; // eax
  int v12; // eax
  PRTL_DEBUG_BUFFER v13; // eax
  int v14; // ecx
  void *v15; // esi
  HWND v16; // ST10_4
  int v17; // edi
  HCURSOR v18; // eax
  unsigned int v19; // esi
  unsigned int v20; // eax
  int v21; // eax
  int v22; // eax
  DWORD ThreadId; // [esp+8h] [ebp-4ECh]
  LPARAM lParam; // [esp+Ch] [ebp-4E8h]
  HCURSOR v25; // [esp+10h] [ebp-4E4h]
  int v26; // [esp+14h] [ebp-4E0h]
  int v27; // [esp+18h] [ebp-4DCh]
  int v28; // [esp+1Ch] [ebp-4D8h]
  wchar_t *v29; // [esp+20h] [ebp-4D4h]
  int v30; // [esp+28h] [ebp-4CCh]
  int v31; // [esp+2Ch] [ebp-4C8h]
  int v32; // [esp+40h] [ebp-4B4h]
  PRTL_DEBUG_BUFFER v33; // [esp+44h] [ebp-4B0h]
  DWORD ExitCode; // [esp+48h] [ebp-4ACh]
  HWND v35; // [esp+4Ch] [ebp-4A8h]
  char ArgList[4]; // [esp+50h] [ebp-4A4h]
  ULONG ReturnLength; // [esp+54h] [ebp-4A0h]
  HCURSOR hCursor; // [esp+58h] [ebp-49Ch]
  char v39; // [esp+5Fh] [ebp-495h]
  char v40; // [esp+60h] [ebp-494h]
  int v41; // [esp+8Ch] [ebp-468h]
  char v42; // [esp+94h] [ebp-460h]
  wchar_t Dst; // [esp+2F0h] [ebp-204h]

  v35 = hWnd;
  *ArgList = 0;
  hCursor = 0;
  v39 = 0;
  SendMessageW(hWnd, 0x1009u, 0, 0);
  v2 = *(a2 + 4);
  v41 = 0;
  result = SendMessageW(v2, 0x100Cu, 0xFFFFFFFF, 2);
  v25 = result;
  if ( result != -1 )
  {
    if ( !*(a2 + 20) )
    {
      GetSystemProcessInfo(&hCursor, 0);
      v4 = hCursor;
      v5 = *(*a2 + 68);
      if ( *(hCursor + 17) != v5 )
      {
        while ( *v4 )
        {
          v4 = (v4 + *v4);
          if ( *(v4 + 17) == v5 )
            goto LABEL_8;
        }
        v4 = 0;
      }
LABEL_8:
      v6 = LoadCursorW(0, 0x7F02);
      SetCursor(v6);
      *(a2 + 12) = OpenProcess(0x80000000, 0, *(*a2 + 68));
      if ( SymInitialize )
      {
        EnterCriticalSection(&gProcThreadsLock);
        v39 = 1;
        SymSetOptions(0x10027u);
        v7 = *(a2 + 12);
        if ( v7 )
          *(a2 + 20) = SymInitialize(v7, 0, 1);
        if ( !*(a2 + 20) )
        {
          if ( *(a2 + 12) )
            CloseHandle(*(a2 + 12));
          v8 = GetCurrentProcess();
          *(a2 + 12) = v8;
          *(a2 + 20) = SymInitialize(v8, 0, 1);
        }
      }
      ReturnLength = 1000;
      v9 = malloc(0x3E8u);
      *(a2 + 8) = v9;
      if ( NtQuerySystemInformation(SystemModuleInformation, v9, 0x3E8u, &ReturnLength) )
      {
        do
        {
          free(*(a2 + 8));
          ReturnLength += 1000;
          v10 = ReturnLength;
          v11 = malloc(ReturnLength);
          *(a2 + 8) = v11;
        }
        while ( NtQuerySystemInformation(SystemModuleInformation, v11, v10, &ReturnLength) );
      }
      v12 = *a2;
      *(a2 + 16) = 0;
      if ( !(*(v12 + 40) & 0x10) )
      {
        v13 = RtlCreateQueryDebugBuffer(0, 0);
        *(a2 + 16) = v13;
        if ( v13 )
        {
          v14 = *(v4 + 17);
          v33 = v13;
          v32 = v14;
          v15 = _beginthreadex(0, 0, QueryProcessDebugInforThreadProc, &v32, 0, &ThreadId);
          if ( WaitForSingleObject(v15, 0xFA0u) == 258 )
            TerminateThread(v15, 1u);
          GetExitCodeThread(v15, &ExitCode);
          if ( ExitCode )
          {
            RtlDestroyQueryDebugBuffer(*(a2 + 16));
            *(a2 + 16) = 0;
          }
          CloseHandle(v15);
        }
      }
    }
    v26 = 0;
    v16 = *(a2 + 4);
    lParam = 4;
    SendMessageW(v16, 0x104Bu, 0, &lParam);
    v17 = v31;
    v18 = LoadCursorW(0, 0x7F02);
    v19 = 0;
    hCursor = SetCursor(v18);
    if ( *(v17 + 2180) & 0xFFFFFFFC )
    {
      do
      {
        v20 = *(*(v17 + 2176) + 4 * v19);
        if ( v20 && v20 != -1 )
        {
          sub_FDDD60(1, v20, &v40, *(a2 + 12), 0, 0, *(a2 + 16), *(a2 + 8));
          v21 = wcscmp(&v42, L"0x0");
          if ( v21 )
            v21 = -(v21 < 0) | 1;
          if ( v21 )
          {
            lParam = 5;
            v25 = 0x7FFFFFFF;
            v26 = 0;
            v28 = 0;
            v27 = 0;
            wsprintf(&Dst, L"%d", ArgList[0]);
            v30 = 0;
            v29 = &Dst;
            v22 = *ArgList + 1;
            *ArgList = v22;
            v31 = v22;
            result = SendMessageW(v35, 0x104Du, 0, &lParam);
            if ( result == -1 )
              return result;
            v25 = result;
            v29 = &v42;
            lParam = 1;
            v26 = 1;
            SendMessageW(v35, 0x104Cu, 0, &lParam);
          }
        }
        ++v19;
      }
      while ( v19 < *(v17 + 2180) >> 2 );
    }
    if ( v39 )
      LeaveCriticalSection(&gProcThreadsLock);
    result = SetCursor(hCursor);
  }
  return result;
}
// 1045208: using guessed type wchar_t a0x0[4];
// 106F264: using guessed type int (__stdcall *RtlDestroyQueryDebugBuffer)(_DWORD);

//----- (00FDB8D0) --------------------------------------------------------
_BYTE *__thiscall sub_FDB8D0(_DWORD *this)
{
  _DWORD *v1; // esi
  _BYTE *result; // eax
  volatile signed __int32 *v3; // edx
  volatile signed __int32 v4; // edi

  v1 = this;
  result = *this;
  v3 = (*this - 16);
  v4 = *v3;
  if ( *(*this - 12) )
  {
    if ( *(v3 + 3) >= 0 )
    {
      if ( _InterlockedDecrement(v3 + 3) <= 0 )
        (*(**v3 + 4))(v3);
      result = ((*(*v4 + 12))(v4) + 16);
      *v1 = result;
    }
    else
    {
      if ( *(result - 2) < 0 )
        ATL::AtlThrowImpl(-2147024809);
      *(result - 3) = 0;
      result = *this;
      **this = 0;
    }
  }
  return result;
}

//----- (00FDB930) --------------------------------------------------------
void __cdecl QueryProcessCommandLineArgs(HANDLE hProcess, LPCVOID lpBaseAddress, WCHAR **ppCommandBuffer, WCHAR **ppszCurrentDirectory, WCHAR **ppszEnvBlock)
{
  BOOL (__stdcall *ReadProcessMemory)(HANDLE, LPCVOID, LPVOID, SIZE_T, SIZE_T *); // edi
  SIZE_T v6; // edi
  void *CommandBuffer; // esi
  SIZE_T BufLen; // ST0C_4
  SIZE_T v9; // edi
  SIZE_T v10; // ST0C_4
  signed int dwEnvironmentBufLen; // esi
  unsigned __int16 *v12; // esi
  size_t v13; // edi
  CHAR *v14; // esi
  size_t v15; // edi
  WCHAR *v16; // eax
  CStringData *v17; // esi
  SIZE_T dwRet; // [esp+18h] [ebp-80514h]
  CString strText; // [esp+1Ch] [ebp-80510h]
  _PEB Peb; // [esp+20h] [ebp-8050Ch]
  _RTL_USER_PROCESS_PARAMETERS ProcessParameters; // [esp+270h] [ebp-802BCh]
  __int16 szEnvironmentBuffer[262144]; // [esp+518h] [ebp-80014h]
  int v23; // [esp+80518h] [ebp-14h]
  int v24; // [esp+80528h] [ebp-4h]

  ReadProcessMemory = ::ReadProcessMemory;
  strText.pszData = ppszCurrentDirectory;
  if ( ::ReadProcessMemory(hProcess, lpBaseAddress, &Peb, 592u, &dwRet)
    && ::ReadProcessMemory(hProcess, Peb.ProcessParameters, &ProcessParameters, 680u, &dwRet)
    && ProcessParameters.CommandLine.Buffer )
  {
    if ( ppCommandBuffer )
    {
      v6 = ProcessParameters.CommandLine.Length;
      CommandBuffer = malloc(ProcessParameters.CommandLine.Length + 2);
      BufLen = v6;
      ReadProcessMemory = ::ReadProcessMemory;
      if ( !::ReadProcessMemory(hProcess, ProcessParameters.CommandLine.Buffer, CommandBuffer, BufLen, &dwRet) )
      {
LABEL_6:
        j__free(CommandBuffer);
        return;
      }
      *(CommandBuffer + (ProcessParameters.CommandLine.Length >> 1)) = 0;
      *ppCommandBuffer = CommandBuffer;
      j__free(0);
    }
    if ( strText.pszData )
    {
      v9 = ProcessParameters.CurrentDirectory.DosPath.Length;
      CommandBuffer = malloc(ProcessParameters.CurrentDirectory.DosPath.Length + 2);
      v10 = v9;
      ReadProcessMemory = ::ReadProcessMemory;
      if ( !::ReadProcessMemory(hProcess, ProcessParameters.CurrentDirectory.DosPath.Buffer, CommandBuffer, v10, &dwRet) )
        goto LABEL_6;
      *(CommandBuffer + (ProcessParameters.CurrentDirectory.DosPath.Length >> 1)) = 0;
      *strText.pszData = CommandBuffer;
      j__free(0);
    }
    if ( ppszEnvBlock )
    {
      dwEnvironmentBufLen = 0x80000;
      while ( !ReadProcessMemory(
                 hProcess,
                 ProcessParameters.Environment,
                 szEnvironmentBuffer,
                 dwEnvironmentBufLen,
                 &dwRet) )
      {
        dwEnvironmentBufLen -= 4096;
        if ( dwEnvironmentBufLen <= 0 )
          return;
      }
      if ( dwEnvironmentBufLen > 0 )
      {
        v23 = 0;
        ATL::CSimpleStringT<wchar_t,0>::CSimpleStringT<wchar_t,0>(&strText);
        v12 = szEnvironmentBuffer;
        v24 = 0;
        if ( szEnvironmentBuffer[0] )
        {
          do
          {
            if ( *v12 == 61 )
            {
              do
                ++v12;
              while ( *v12 );
            }
            else
            {
              v13 = wcslen(v12);
              sub_FADB80(&strText, v12, v13);
              sub_FDA4A0(&strText, 0);
              v12 += v13;
            }
            ++v12;
          }
          while ( *v12 );
        }
        v14 = strText.pszData;
        v15 = 2 * *(strText.pszData - 3) + 2;
        v16 = malloc(v15);
        *ppszEnvBlock = v16;
        memmove_0(v16, v14, v15);
        v17 = (v14 - 16);
        v24 = -1;
        if ( _InterlockedDecrement(&v17->nRefs) <= 0 )
          (v17->pStringMgr->vtptr->Free)(v17);
      }
    }
  }
}

//----- (00FDBBC0) --------------------------------------------------------
int __stdcall FindDlg_SortCallback(int a1, int a2, int a3)
{
  int v3; // eax
  int v4; // ecx

  if ( a3 )
  {
    if ( a3 == 1 )
    {
      v4 = *(a1 + 168) - *(a2 + 168);
      goto LABEL_9;
    }
    if ( a3 == 2 )
      v3 = _wcsicmp((a1 + 40), (a2 + 40));
    else
      v3 = _wcsicmp(*(a1 + 180), *(a2 + 180));
  }
  else
  {
    v3 = _wcsicmp(*(a1 + 36), *(a2 + 36));
  }
  v4 = v3;
LABEL_9:
  if ( !byte_105E8B0 )
    v4 = -v4;
  return v4;
}
// FDBBC0: using guessed type int __stdcall FindDlg_SortCallback(int, int, int);
// 105E8B0: using guessed type char byte_105E8B0;

//----- (00FDBC30) --------------------------------------------------------
HANDLE __stdcall FindExecutableImageExW_1(PCWSTR FileName, PCWSTR SymbolPath, PWSTR ImageFilePath, PFIND_EXE_FILE_CALLBACKW Callback, PVOID CallerData)
{
  return FindExecutableImageExW(FileName, SymbolPath, ImageFilePath, 0, 0);
}

//----- (00FDBC50) --------------------------------------------------------
int __stdcall sub_FDBC50(LPCWSTR a1, LPCWSTR a2, int a3)
{
  int *SymbolPath; // esi
  int *FileName; // eax
  int v5; // eax
  int v6; // edi
  int v7; // ebx
  int v8; // edx
  int v10; // [esp+10h] [ebp-124h]
  int v11; // [esp+14h] [ebp-120h]
  CHAR MultiByteStr; // [esp+18h] [ebp-11Ch]
  LPWSTR lpWideCharStr; // [esp+120h] [ebp-14h]
  int v14; // [esp+130h] [ebp-4h]

  lpWideCharStr = a3;
  v14 = 0;
  SymbolPath = sub_FD9E00(&v11, a2);
  LOBYTE(v14) = 1;
  FileName = sub_FD9E00(&v10, a1);
  LOBYTE(v14) = 2;
  v5 = FindExecutableImage(*FileName, *SymbolPath, &MultiByteStr);
  v6 = v10 - 16;
  LOBYTE(v14) = 1;
  v7 = v5;
  if ( _InterlockedDecrement((v10 - 16 + 12)) <= 0 )
    (*(**v6 + 4))(v6);
  v8 = v11 - 16;
  LOBYTE(v14) = 0;
  if ( _InterlockedDecrement((v11 - 16 + 12)) <= 0 )
    (*(**v8 + 4))(v8);
  MultiByteToWideChar(0, 0, &MultiByteStr, 261, lpWideCharStr, 261);
  return v7;
}

//----- (00FDBD50) --------------------------------------------------------
int __userpurge FindDlg_SearchThreadProc@<eax>(signed int a1@<ebx>, _BYTE *wParam)
{
  HWND v2; // eax

  CMainWnd::RefreshDllsView(a1, ghWndListInFindDlg, 0, wParam);
  CMainWnd::RefreshHandlesView(a1, ghWndListInFindDlg, 0, wParam);
  v2 = GetParent(ghWndListInFindDlg);
  PostMessageW(v2, 0x464u, 0, 0);
  return 0;
}

//----- (00FDBDA0) --------------------------------------------------------
HWND __cdecl sub_FDBDA0(HWND hWndParent)
{
  HWND v1; // eax
  HWND result; // eax

  v1 = FindWindowExW(hWndParent, 0, 0, L"OK");
  if ( v1 )
    ShowWindow(v1, 0);
  result = FindWindowExW(hWndParent, 0, 0, L"Cancel");
  if ( result )
    result = SetWindowTextW(result, L"&OK");
  return result;
}

//----- (00FDBDF0) --------------------------------------------------------
int *__thiscall sub_FDBDF0(int *this, int a2)
{
  volatile signed __int32 *v2; // esi
  int v3; // ebx
  int (__thiscall ***v4)(_DWORD, int, signed int); // eax
  int v5; // edi
  int v6; // eax
  int v7; // ebx
  int *result; // eax
  int *v9; // [esp+Ch] [ebp-8h]
  int v10; // [esp+10h] [ebp-4h]
  int v11; // [esp+1Ch] [ebp+8h]

  v9 = this;
  v2 = (*this - 16);
  v3 = *(v2 + 1);
  v10 = *(v2 + 1);
  v4 = (*(**v2 + 16))();
  v5 = a2;
  v6 = (**v4)(v4, a2, 1);
  v11 = v6;
  if ( !v6 )
    ATL::CSimpleStringT<wchar_t,0>::ThrowMemoryException();
  if ( v3 < v5 )
    v5 = v3;
  v7 = v6 + 16;
  memcpy_s((v6 + 16), v5 + 1, (v2 + 4), v5 + 1);
  *(v11 + 4) = v10;
  if ( _InterlockedDecrement(v2 + 3) <= 0 )
    (*(**v2 + 4))(v2);
  result = v9;
  *v9 = v7;
  return result;
}

//----- (00FDBE70) --------------------------------------------------------
HLOCAL __cdecl sub_FDBE70(wchar_t *Dst, size_t SizeInWords)
{
  int v2; // ecx
  DWORD v3; // eax
  WCHAR Buffer[2]; // [esp+0h] [ebp-4h]

  *Buffer = v2;
  v3 = GetLastError();
  FormatMessageW(0x1100u, 0, v3, 0x400u, Buffer, 0, 0);
  swprintf_s(Dst, SizeInWords, L"%s", *Buffer);
  return LocalFree(*Buffer);
}

//----- (00FDBEC0) --------------------------------------------------------
int __cdecl sub_FDBEC0(int a1, int a2, wchar_t *Dst, size_t SizeInWords)
{
  return swprintf_s(Dst, SizeInWords, L"%d.%d.%d.%d", a2 >> 16, a2, a1 >> 16, a1);
}

//----- (00FDBEF0) --------------------------------------------------------
unsigned int __cdecl Fake_GetProcessMitigationPolicy(tagTREEVIEWLISTITEMPARAM *pItem, HANDLE ProcessHandle)
{
  HANDLE v2; // esi
  int (__stdcall *pfnGetProcessMitigationPolicy)(HANDLE, _PROCESS_MITIGATION_POLICY, PVOID, SIZE_T); // eax
  HMODULE v4; // eax
  unsigned int result; // eax
  _PROCESS_MITIGATION_DEP_POLICY Policy; // [esp+4h] [ebp-10h]
  DWORD Flags; // [esp+Ch] [ebp-8h]
  unsigned int ret; // [esp+10h] [ebp-4h]

  v2 = ProcessHandle;
  LOBYTE(ret) = -1;
  if ( !ProcessHandle )
    return ret;
  if ( gdwVersion >= WINDOWS_8 )
  {
    pfnGetProcessMitigationPolicy = GetProcessMitigationPolicy;
    if ( !GetProcessMitigationPolicy )
    {
      v4 = GetModuleHandleW(L"KERNEL32.DLL");
      pfnGetProcessMitigationPolicy = GetProcAddress(v4, "GetProcessMitigationPolicy");
      GetProcessMitigationPolicy = pfnGetProcessMitigationPolicy;
      if ( !pfnGetProcessMitigationPolicy )
      {
        SetLastError(ERROR_CALL_NOT_IMPLEMENTED);
        return ret;
      }
    }
    if ( pfnGetProcessMitigationPolicy(v2, ProcessDEPPolicy, &Policy, 8) )
    {
      result = 0;
      if ( Policy.DUMMYUNIONNAME.Flags & 1 )
        result = 1;
      if ( Policy.DUMMYUNIONNAME.Flags & 2 )
        result |= 4u;
      if ( Policy.Permanent )
        result |= 8u;
      return result;
    }
    return ret;
  }
  if ( gdwVersion < 2 )
  {
    if ( gdwVersion < 1 )
    {
      DeviceIoControl(
        ghDriverHandle,
        CTRLCODE_QUERY_PROCESS_DEPPOLICY,
        &ProcessHandle,
        4u,
        &ret,
        4u,
        &Policy.Permanent,
        0);
      return ret;
    }
    if ( NtQueryInformationProcess(ProcessHandle, ProcessExecuteFlags, &ret, 4u, 0) )
      return ret;
    result = ret & 0xFFFFFF0B;
    ret &= 0xFFFFFF0B;
    if ( ret & 2 )
      result &= 0xFFFFFFF6;
  }
  else
  {
    if ( !Fake_GetProcessDEPPolicy(ProcessHandle, &Flags, &Policy.Permanent) )
      return ret;
    result = 0;
    if ( Flags & 1 )
      result = 1;
    if ( Flags & 2 )
      result |= 4u;
    if ( *&Policy.Permanent )
      result |= 8u;
  }
  return result;
}
// 1064E54: using guessed type int gdwVersion;

//----- (00FDC020) --------------------------------------------------------
int __stdcall BackendQueryObjectThreadProc(void *a1)
{
  ULONG ReturnedLength; // [esp+4h] [ebp-4h]

  while ( !WaitForSingleObject(lpName, 0xFFFFFFFF) )
  {
    ReturnedLength = gObjectNameInformation->Name.Length + 8;
    gulQueryObjectResult = NtQueryObject(
                             Handle,
                             ObjectNameInformation,
                             gObjectNameInformation,
                             ReturnedLength,
                             &ReturnedLength);
    SetEvent(hHandle);
  }
  return 0;
}
// 106ABA0: using guessed type int gulQueryObjectResult;

//----- (00FDC090) --------------------------------------------------------
int __stdcall sub_FDC090(DWORD nLengthNeeded)
{
  DWORD v1; // edi
  DWORD v2; // edx
  signed int v3; // eax
  signed int v4; // esi
  void *v5; // ebx
  BOOL v6; // esi
  int result; // eax

  v1 = nLengthNeeded;
  v2 = 0;
  v3 = 1;
  v4 = 32;
  do
  {
    if ( *(nLengthNeeded + 4) & v3 )
    {
      switch ( v3 )
      {
        case 1:
          v2 |= 0xE0000u;
          break;
        case 4:
        case 16:
          v2 |= 0x60000u;
          break;
        case 8:
          v2 |= 0x1000000u;
          break;
        default:
          break;
      }
    }
    v3 = __ROL4__(v3, 1);
    --v4;
  }
  while ( v4 );
  v5 = PE_DuplicateProcessHandle(*(*nLengthNeeded + 36), *(*nLengthNeeded + 44), v2);
  if ( v5 )
  {
    GetKernelObjectSecurity(v5, *(v1 + 4), 0, 0, &nLengthNeeded);
    **(v1 + 8) = LocalAlloc(0x40u, nLengthNeeded);
    v6 = GetKernelObjectSecurity(v5, *(v1 + 4), **(v1 + 8), nLengthNeeded, &nLengthNeeded);
    CloseHandle(v5);
    if ( v6 )
    {
      result = 0;
      *(v1 + 12) = 0;
    }
    else
    {
      *(v1 + 12) = GetLastError();
      result = 0;
    }
  }
  else
  {
    *(v1 + 12) = 6;
    result = 0;
  }
  return result;
}

//----- (00FDC190) --------------------------------------------------------
LPVOID __cdecl sub_FDC190(LPCVOID pBlock, int a2, unsigned __int16 a3, int a4)
{
  BOOL v4; // eax
  BOOL v5; // ecx
  LPVOID result; // eax
  unsigned int puLen; // [esp+10h] [ebp-228h]
  LPVOID lpBuffer; // [esp+14h] [ebp-224h]
  BOOL v9; // [esp+18h] [ebp-220h]
  WCHAR SubBlock; // [esp+1Ch] [ebp-21Ch]
  CPPEH_RECORD ms_exc; // [esp+220h] [ebp-18h]

  v9 = 0;
  wsprintf(&SubBlock, L"\\StringFileInfo\\%04X%04X\\%s", a2, a3, a4);
  ms_exc.registration.TryLevel = 0;
  v4 = VerQueryValueW(pBlock, &SubBlock, &lpBuffer, &puLen);
  v5 = v4;
  v9 = v4;
  ms_exc.registration.TryLevel = -2;
  result = lpBuffer;
  if ( !v5 )
    result = 0;
  return result;
}

//----- (00FDC270) --------------------------------------------------------
__int16 *__cdecl sub_FDC270(int a1, rsize_t SizeInWords)
{
  __int16 *v2; // ecx
  __int16 v3; // ax
  int v4; // edi
  __int16 *v5; // ecx
  __int16 v6; // ax
  wchar_t *v7; // esi

  if ( !*GetLongPathNameW )
    return *a1;
  v2 = *a1;
  do
  {
    v3 = *v2;
    ++v2;
  }
  while ( v3 );
  if ( SizeInWords <= ((v2 - *a1 - 2) >> 1) + 1 )
  {
    v5 = *a1;
    do
    {
      v6 = *v5;
      ++v5;
    }
    while ( v6 );
    v4 = ((v5 - *a1 - 2) >> 1) + 1;
  }
  else
  {
    v4 = SizeInWords;
  }
  v7 = malloc(2 * v4);
  wcscpy_s(v7, v4, *a1);
  GetLongPathNameW(v7, *a1, SizeInWords);
  j__free(v7);
  return *a1;
}

//----- (00FDC350) --------------------------------------------------------
void __cdecl PE_GetFullPathName(LPCWSTR *ppszShortPath)
{
  DWORD v1; // eax
  DWORD cbSize; // ebx
  WCHAR *pszLongPathName; // ST1C_4

  if ( *GetLongPathNameW )
  {
    v1 = GetLongPathNameW(*ppszShortPath, 0, 0);
    cbSize = v1;
    if ( v1 )
    {
      pszLongPathName = malloc(2 * v1 + 2);
      GetLongPathNameW(*ppszShortPath, pszLongPathName, cbSize + 1);
      free(*ppszShortPath);
      *ppszShortPath = pszLongPathName;
      j__free(0);
    }
  }
}

//----- (00FDC3E0) --------------------------------------------------------
int __stdcall QueryProcessDebugInforThreadProc(_DWORD *a1)
{
  return RtlQueryProcessDebugInformation(*a1, 1, a1[1]);
}
// 106F260: using guessed type int (__stdcall *RtlQueryProcessDebugInformation)(_DWORD, _DWORD, _DWORD);

//----- (00FDC400) --------------------------------------------------------
char __cdecl sub_FDC400(int *a1, _DWORD *a2)
{
  int v2; // ecx
  int v3; // edx
  int v4; // ebx
  int v6; // edi
  int *v7; // esi
  int v8; // eax
  unsigned int v9; // ecx
  bool v10; // cf
  bool v11; // zf
  DWORD v12; // eax
  DWORD v13; // esi
  DWORD v14; // edi
  DWORD v15; // ecx
  bool v16; // bl
  bool v17; // dl
  int v18; // [esp+8h] [ebp-Ch]
  int v19; // [esp+Ch] [ebp-8h]
  int v20; // [esp+10h] [ebp-4h]
  unsigned int v21; // [esp+1Ch] [ebp+8h]

  v2 = 0;
  v3 = 0;
  v4 = 0;
  v20 = 0;
  v18 = 0;
  v19 = 0;
  if ( !a1 )
    return 0;
  v6 = *a1;
  if ( *a1 )
  {
    v7 = a1 + 1;
    do
    {
      v8 = *v7;
      v21 = *v7 & 0xFFFFF000;
      v2 = v20;
      if ( v21 >= a2[9] )
      {
        v9 = a2[9] + a2[14];
        v10 = v21 < v9;
        v11 = v21 == v9;
        v2 = v20;
        if ( v10 || v11 )
        {
          v2 = v20++ + 1;
          if ( v8 & 0x100 )
          {
            ++v18;
            if ( (*v7 & 0xE0u) > 0x20 )
              ++v19;
          }
          else
          {
            ++v4;
          }
        }
      }
      ++v7;
      --v6;
    }
    while ( v6 );
    v3 = v19;
  }
  v12 = v2 * gSystemInfo.dwPageSize;
  v13 = v18 * gSystemInfo.dwPageSize;
  v14 = v3 * gSystemInfo.dwPageSize;
  v15 = v4 * gSystemInfo.dwPageSize;
  v11 = v12 == a2[92];
  a2[92] = v12;
  v16 = !v11;
  v11 = v15 == a2[93];
  a2[93] = v15;
  v17 = !v11;
  v11 = v13 == a2[94];
  a2[94] = v13;
  LOBYTE(v12) = v14 != a2[95];
  a2[95] = v14;
  return v16 | v17 | !v11 | v12;
}

//----- (00FDC4F0) --------------------------------------------------------
char __cdecl sub_FDC4F0(LPVOID lpInBuffer, int a2, int a3, int a4)
{
  char v4; // bl
  HANDLE v6; // eax
  BOOL (__stdcall *DeviceIoControl)(HANDLE, DWORD, LPVOID, DWORD, LPVOID, DWORD, LPDWORD, LPOVERLAPPED); // esi
  int v8; // eax
  char v9; // [esp+8h] [ebp-78h]
  int v10; // [esp+18h] [ebp-68h]
  struct _OVERLAPPED Overlapped; // [esp+20h] [ebp-60h]
  DWORD InBuffer; // [esp+34h] [ebp-4Ch]
  int v13; // [esp+38h] [ebp-48h]
  char v14; // [esp+3Ch] [ebp-44h]
  HANDLE v15; // [esp+40h] [ebp-40h]
  _DWORD *v16; // [esp+44h] [ebp-3Ch]
  _DWORD *v17; // [esp+48h] [ebp-38h]
  DWORD BytesReturned; // [esp+4Ch] [ebp-34h]
  int OutBuffer; // [esp+50h] [ebp-30h]
  _DWORD *v20; // [esp+54h] [ebp-2Ch]
  HANDLE TargetHandle; // [esp+58h] [ebp-28h]
  LPVOID lpOutBuffer; // [esp+5Ch] [ebp-24h]
  char v23; // [esp+60h] [ebp-20h]
  unsigned __int16 v24; // [esp+6Ch] [ebp-14h]
  int v25; // [esp+6Eh] [ebp-12h]

  v17 = a2;
  v4 = 0;
  v20 = a3;
  v16 = a4;
  if ( !lpInBuffer )
  {
    if ( dword_10610D4 != -1 )
    {
      CloseHandle(ghSourceProcessHandle);
      dword_10610D4 = -1;
    }
    return 0;
  }
  if ( dword_10610D4 != *(lpInBuffer + 1) )
  {
    if ( dword_10610D4 != -1 )
    {
      dword_10610D4 = -1;
      CloseHandle(ghSourceProcessHandle);
    }
    ghSourceProcessHandle = OpenProcess(PROCESS_DUP_HANDLE, 0, *(lpInBuffer + 1));
    if ( !ghSourceProcessHandle )
      return 0;
    dword_10610D4 = *(lpInBuffer + 1);
  }
  v6 = GetCurrentProcess();
  if ( !DuplicateHandle(ghSourceProcessHandle, *(lpInBuffer + 2), v6, &TargetHandle, 0, 0, 0) )
    return 0;
  lpOutBuffer = malloc(0x408u);
  InBuffer = GetCurrentProcessId();
  v13 = *lpInBuffer;
  v15 = TargetHandle;
  v14 = 0;
  if ( ::DeviceIoControl(ghDriverHandle, 0x83350048, &InBuffer, 0x10u, lpOutBuffer, 0x408u, &BytesReturned, 0)
    && (!_wcsicmp(lpOutBuffer + 2, L"\\Device\\Tcp") || !_wcsicmp(lpOutBuffer + 2, L"\\Device\\Udp")) )
  {
    if ( GetVersion() >= 5u )
    {
      DeviceIoControl = ::DeviceIoControl;
    }
    else
    {
      DeviceIoControl = ::DeviceIoControl;
      ::DeviceIoControl(ghDriverHandle, 0x83350020, lpInBuffer, 4u, &OutBuffer, 4u, &BytesReturned, 0);
    }
    if ( GetVersion() >= 5u || OutBuffer == 1 || OutBuffer == 2 )
    {
      Overlapped.hEvent = 0;
      _mm_storeu_si128(&Overlapped, 0i64);
      Overlapped.hEvent = CreateEventW(0, 0, 0, 0);
      v10 = 3;
      if ( DeviceIoControl(TargetHandle, 0x210012u, &v9, 0x18u, &v23, 0x1Au, 0, &Overlapped) )
      {
        v8 = _wcsicmp(lpOutBuffer + 2, L"\\Device\\Tcp");
        v4 = 1;
        *v17 = v8 != 0;
        *v16 = v24;
        *v20 = v25;
      }
      else
      {
        v4 = 0;
      }
      CloseHandle(Overlapped.hEvent);
    }
  }
  free(lpOutBuffer);
  CloseHandle(TargetHandle);
  return v4;
}
// 10610D4: using guessed type int dword_10610D4;

//----- (00FDC750) --------------------------------------------------------
void __cdecl sub_FDC750(wchar_t *a1, int a2, wchar_t *Dst, rsize_t SizeInWords, _DWORD *a5)
{
  rsize_t v5; // esi
  int v6; // eax
  void *v7; // eax
  size_t v8; // esi
  void *v9; // eax
  BOOL v10; // eax
  HANDLE v11; // esi
  size_t v12; // esi
  const wchar_t **v13; // eax
  ULONG v14; // ST20_4
  const wchar_t **v15; // esi
  int v16; // eax
  void *v17; // edi
  int v18; // ebx
  void *v19; // eax
  void *v20; // ebx
  size_t v21; // esi
  void *v22; // eax
  int v23; // ecx
  bool v24; // zf
  wchar_t *v25; // ebx
  void *v26; // ebx
  __m128i *v27; // edi
  HANDLE v28; // eax
  int v29; // eax
  void *v30; // ebx
  PROCESS_BASIC_INFORMATION ProcessInfo; // [esp+Ch] [ebp-10C0h]
  THREAD_BASIC_INFORMATION ThreadInfo; // [esp+24h] [ebp-10A8h]
  enum _SID_NAME_USE peUse; // [esp+40h] [ebp-108Ch]
  DWORD ThreadId; // [esp+44h] [ebp-1088h]
  DWORD cchReferencedDomainName; // [esp+48h] [ebp-1084h]
  DWORD cchName; // [esp+4Ch] [ebp-1080h]
  int InBuffer; // [esp+50h] [ebp-107Ch]
  int v38; // [esp+54h] [ebp-1078h]
  bool v39; // [esp+58h] [ebp-1074h]
  int v40; // [esp+5Ch] [ebp-1070h]
  _DWORD *v41; // [esp+60h] [ebp-106Ch]
  DWORD ReturnLength; // [esp+64h] [ebp-1068h]
  HANDLE hObject; // [esp+68h] [ebp-1064h]
  size_t cbRet; // [esp+6Ch] [ebp-1060h]
  wchar_t *v45; // [esp+70h] [ebp-105Ch]
  DWORD BytesReturned; // [esp+74h] [ebp-1058h]
  char TokenInformation; // [esp+78h] [ebp-1054h]
  int v48; // [esp+80h] [ebp-104Ch]
  DWORD v49; // [esp+84h] [ebp-1048h]
  PSID Sid; // [esp+B0h] [ebp-101Ch]
  WCHAR Name; // [esp+8B0h] [ebp-81Ch]
  WCHAR ReferencedDomainName; // [esp+AB8h] [ebp-614h]
  wchar_t v53; // [esp+CC0h] [ebp-40Ch]
  wchar_t pszText; // [esp+EC8h] [ebp-204h]

  v5 = SizeInWords;
  v45 = Dst;
  v41 = a5;
  wcscpy_s(Dst, SizeInWords, &gszNullString);
  if ( a5 )
    *v41 = 0;
  if ( !*a1 )
    goto LABEL_55;
  v6 = wcscmp(a1, L"<Unknown type>");
  if ( v6 )
    v6 = -(v6 < 0) | 1;
  if ( !v6 )
  {
LABEL_55:
    v7 = PE_DuplicateProcessHandle(*(a2 + 4), *(a2 + 8), 0);
    hObject = v7;
    if ( v7 )
    {
      NtQueryObject(v7, ObjectTypeInformation, 0, 0, &cbRet);
      v12 = cbRet;
      v13 = malloc(cbRet);
      v14 = v12;
      v15 = v13;
      v16 = NtQueryObject(hObject, ObjectTypeInformation, v13, v14, 0);
      if ( v16 )
        MakeDeviceName(a1, L"<Unknown type: %X>", v16);
      else
        wcsncpy_s(a1, 0x40u, v15[1], *v15 >> 1);
      free(v15);
      CloseHandle(hObject);
LABEL_17:
      v5 = SizeInWords;
      goto LABEL_18;
    }
    if ( ghDriverHandle != -1 )
    {
      v8 = 2 * SizeInWords + 8;
      v9 = malloc(v8);
      InBuffer = *(a2 + 4);
      v38 = *a2;
      v40 = *(a2 + 8);
      hObject = v9;
      v10 = DeviceIoControl(ghDriverHandle, 0x8335004C, &InBuffer, 0x10u, v9, v8, &BytesReturned, 0);
      v11 = hObject;
      if ( v10 )
        wcscpy_s(a1, 0x40u, hObject + 2);
      free(v11);
      goto LABEL_17;
    }
    MakeDeviceName(a1, L"<Unknown type>");
  }
LABEL_18:
  if ( _wcsicmp(a1, L"process") && _wcsicmp(a1, L"thread") )
  {
    if ( _wcsicmp(a1, L"token") )
    {
      if ( _wcsicmp(a1, L"EtwRegistration") )
      {
        if ( ghDriverHandle == -1 )
        {
          v26 = PE_DuplicateProcessHandle(*(a2 + 4), *(a2 + 8), 0);
          if ( v26 )
          {
            cbRet = 1024;
            v27 = malloc(0x400u);
            _mm_storel_epi64(v27, 0i64);
            LOWORD(v27->m128i_i32[0]) = cbRet - 8;
            if ( !ghBackendQueryObjectThreadHandle )
              ghBackendQueryObjectThreadHandle = _beginthreadex(0, 0, BackendQueryObjectThreadProc, 0, 0, &ThreadId);
            v28 = lpName;
            if ( !lpName )
            {
              lpName = CreateEventW(lpName, lpName, lpName, lpName);
              hHandle = CreateEventW(0, 0, 0, 0);
              v28 = lpName;
            }
            gObjectNameInformation = v27;
            Handle = v26;
            SetEvent(v28);
            if ( WaitForSingleObject(hHandle, 0x3E8u) == 258 )
            {
              TerminateThread(ghBackendQueryObjectThreadHandle, 1u);
              CloseHandle(ghBackendQueryObjectThreadHandle);
              ghBackendQueryObjectThreadHandle = 0;
              free(v27);
              CloseHandle(v26);
            }
            else
            {
              if ( !gulQueryObjectResult )
                sub_FF5230(v45, SizeInWords, v27);
              free(v27);
              CloseHandle(v26);
            }
          }
        }
        else
        {
          v21 = 2 * v5 + 8;
          v22 = malloc(v21);
          InBuffer = *(a2 + 4);
          v23 = *a2;
          BytesReturned = v22;
          v38 = v23;
          v24 = _wcsicmp(a1, L"file") == 0;
          v25 = BytesReturned;
          v40 = *(a2 + 8);
          v39 = v24;
          if ( CDriver::Control(0x83350048, &InBuffer, 0x10u, BytesReturned, v21) )
          {
            wcscpy_s(v45, SizeInWords, v25 + 2);
            if ( v41 )
              *v41 = *v25;
          }
          free(v25);
        }
      }
      else
      {
        v19 = PE_DuplicateProcessHandle(*(a2 + 4), *(a2 + 8), 0);
        v20 = v19;
        if ( v19 )
        {
          CloseHandle(v19);
          CloseHandle(v20);
        }
      }
    }
    else
    {
      v17 = PE_DuplicateProcessHandle(*(a2 + 4), *(a2 + 8), 8u);
      if ( v17 )
      {
        v49 = 0;
        v48 = 0;
        ReturnLength = 56;
        GetTokenInformation(v17, TokenStatistics, &TokenInformation, 0x38u, &ReturnLength);
        v18 = v48;
        BytesReturned = v49;
        ReturnLength = 2048;
        if ( GetTokenInformation(v17, TokenUser, &Sid, 0x800u, &ReturnLength) )
        {
          cchName = 260;
          cchReferencedDomainName = 260;
          if ( LookupAccountSidW(
                 &gszNullString,
                 Sid,
                 &Name,
                 &cchName,
                 &ReferencedDomainName,
                 &cchReferencedDomainName,
                 &peUse) )
          {
            swprintf_s(v45, SizeInWords, L"%s\\%s:%x", &ReferencedDomainName, &Name, v18, BytesReturned);
          }
        }
        CloseHandle(v17);
      }
    }
  }
  else
  {
    v29 = _wcsicmp(a1, L"process");
    v30 = PE_DuplicateProcessHandle(*(a2 + 4), *(a2 + 8), v29 != 0 ? 64 : 1024);
    if ( v30 )
    {
      if ( _wcsicmp(a1, L"Process") )
      {
        if ( !NtQueryInformationThread(
                v30,
                ThreadBasicInformation,
                &ThreadInfo,
                sizeof(_THREAD_BASIC_INFORMATION),
                &cbRet) )
        {
          SystemProcessInfo_GetSystemProcessName(ThreadInfo.ClientId.UniqueProcess, 0, &pszText, 0x100u);
          swprintf_s(
            v45,
            v5,
            L"%s(%d): %d",
            &pszText,
            ThreadInfo.ClientId.UniqueProcess,
            ThreadInfo.ClientId.UniqueThread);
        }
      }
      else if ( !NtQueryInformationProcess(
                   v30,
                   ProcessBasicInformation,
                   &ProcessInfo,
                   sizeof(PROCESS_BASIC_INFORMATION),
                   &cbRet) )
      {
        SystemProcessInfo_GetSystemProcessName(ProcessInfo.UniqueProcessId, 0, &pszText, 0x100u);
        swprintf_s(v45, v5, L"%s(%d)", &pszText, ProcessInfo.UniqueProcessId);
        CloseHandle(v30);
        return;
      }
      CloseHandle(v30);
    }
    else if ( ghDriverHandle != -1 )
    {
      sub_FDBE70(&v53, 0x104u);
      swprintf_s(v45, v5, L"<%s>", &v53);
    }
  }
}
// 106ABA0: using guessed type int gulQueryObjectResult;

//----- (00FDCE20) --------------------------------------------------------
int __cdecl sub_FDCE20(DWORD BytesReturned, LPVOID lpOutBuffer)
{
  _DWORD *v2; // esi
  _DWORD *v3; // edi
  DWORD dwSymbolAddress; // eax
  unsigned __int64 v5; // rax
  double v6; // xmm0_8

  v2 = BytesReturned;
  v3 = lpOutBuffer;
  *BytesReturned = 0;
  v2[1] = 0;
  *v3 = 0;
  v3[1] = 0;
  if ( gdwSymbolAddressOfMmMaximumNonPagedPoolInBytes || !dword_105E0DC )
  {
    dwSymbolAddress = gdwSymbolAddressOfMmSizeOfPagedPoolInBytes;
  }
  else
  {
    gdwSymbolAddressOfMmMaximumNonPagedPoolInBytes = LoadSystemModulesSymbolAddress("MmMaximumNonPagedPoolInBytes");
    dwSymbolAddress = LoadSystemModulesSymbolAddress("MmSizeOfPagedPoolInBytes");
    gdwSymbolAddressOfMmSizeOfPagedPoolInBytes = dwSymbolAddress;
    dword_105E0DC = 0;
  }
  if ( dwSymbolAddress )
    DeviceIoControl(
      ghDriverHandle,
      0x83350044,
      &gdwSymbolAddressOfMmSizeOfPagedPoolInBytes,
      4u,
      v3,
      8u,
      &BytesReturned,
      0);
  if ( gdwSymbolAddressOfMmMaximumNonPagedPoolInBytes )
  {
    LODWORD(v5) = DeviceIoControl(
                    ghDriverHandle,
                    0x83350044,
                    &gdwSymbolAddressOfMmMaximumNonPagedPoolInBytes,
                    4u,
                    v2,
                    8u,
                    &BytesReturned,
                    0);
    v2[1] = 0;
    v3[1] = 0;
  }
  else
  {
    *v2 = 0x200000;
    v2[1] = 0;
    v6 = gpGraphInfoOfPhysicalMemory->m_dbMemorySize;
    v5 = v6 << 10;
    if ( is_mul_ok(0x400u, v6) && v5 < 0x200000 )
      *v2 = v5;
    v2[1] = 0;
    v3[1] = 0;
  }
  return v5;
}
// 105E0DC: using guessed type int dword_105E0DC;
// 10850E8: using guessed type int gdwSymbolAddressOfMmMaximumNonPagedPoolInBytes;
// 10850EC: using guessed type int gdwSymbolAddressOfMmSizeOfPagedPoolInBytes;

//----- (00FDCF30) --------------------------------------------------------
char __cdecl sub_FDCF30(HANDLE hProcess, WCHAR **ppszFileName)
{
  SIZE_T v3; // ebx
  wchar_t *v4; // esi
  char v5; // bl
  wchar_t *v6; // eax
  PROCESS_BASIC_INFORMATION ProcessInformation; // [esp+4h] [ebp-520h]
  ULONG ReturnLength; // [esp+1Ch] [ebp-508h]
  WCHAR **v9; // [esp+20h] [ebp-504h]
  SIZE_T dwRet; // [esp+24h] [ebp-500h]
  char Buffer; // [esp+28h] [ebp-4FCh]
  LPCVOID lpBaseAddress; // [esp+38h] [ebp-4ECh]
  PEB Peb; // [esp+278h] [ebp-2ACh]

  v9 = ppszFileName;
  if ( NtQueryInformationProcess(hProcess, 0, &ProcessInformation, 0x18u, &ReturnLength)
    || !ProcessInformation.PebBaseAddress )
  {
    return 0;
  }
  if ( !ReadProcessMemory(hProcess, ProcessInformation.PebBaseAddress, &Buffer, 0x250u, &dwRet)
    || !ReadProcessMemory(hProcess, lpBaseAddress, &Peb, 0x2A8u, &dwRet)
    || !Peb.TlsExpansionCounter )
  {
    return 0;
  }
  v3 = LOWORD(Peb.FreeList);
  v4 = malloc(LOWORD(Peb.FreeList) + 2);
  if ( ReadProcessMemory(hProcess, Peb.TlsExpansionCounter, v4, v3, &dwRet) )
  {
    v4[v3 >> 1] = 0;
    v6 = _wcsdup(v4);
    v5 = 1;
    *v9 = v6;
  }
  else
  {
    v5 = 0;
  }
  j__free(v4);
  return v5;
}

//----- (00FDD050) --------------------------------------------------------
HICON __cdecl ExtractApplicationIcon(LPCWSTR pszPath, int uFlags)
{
  SHFILEINFOW FileInfo; // [esp+0h] [ebp-2B8h]

  FileInfo.hIcon = 0;
  if ( !pszPath )
    return 0;
  SHGetFileInfoW(pszPath, 0, &FileInfo, sizeof(SHFILEINFOW), uFlags | SHGFI_ICON);
  return FileInfo.hIcon;
}

//----- (00FDD0C0) --------------------------------------------------------
char __cdecl sub_FDD0C0(HANDLE hProcess, tagTREEVIEWLISTITEMPARAM *pItem)
{
  wchar_t *v2; // ebx
  unsigned int v3; // kr00_4
  wchar_t *v4; // esi
  const WCHAR *v5; // ecx
  const wchar_t *v6; // eax
  wchar_t *v7; // eax
  wchar_t *v8; // ebx
  int v9; // edx
  wchar_t v10; // cx
  wchar_t *v11; // eax
  wchar_t *v12; // eax
  wchar_t *v13; // esi
  wchar_t i; // ax
  char v15; // cl
  int v16; // eax
  DWORD v17; // eax
  WCHAR *v18; // eax
  wchar_t *v19; // ecx
  wchar_t *v20; // ecx
  HWND v21; // eax
  HWND v22; // esi
  char v23; // al
  wchar_t *v24; // ebx
  wchar_t *v26; // eax
  wchar_t *v27; // esi
  LPWSTR FilePart; // [esp+Ch] [ebp-2A0h]
  char hObject; // [esp+13h] [ebp-299h]
  wchar_t *pszFileName; // [esp+14h] [ebp-298h]
  DWORD nBufferLength; // [esp+18h] [ebp-294h]
  char v32; // [esp+1Fh] [ebp-28Dh]
  __int16 ClassName[260]; // [esp+20h] [ebp-28Ch]
  __int16 Dst[64]; // [esp+228h] [ebp-84h]

  pszFileName = 0;
  v32 = 0;
  if ( pItem->szProcessName )
    return 0;
  if ( !sub_FE0A90(hProcess, pItem->dwProcessId, &pszFileName, pItem) )
  {
    if ( pItem->dwProcessId <= 8u )
    {
      v27 = pszFileName;
    }
    else
    {
      v26 = malloc(0x208u);
      v27 = v26;
      if ( hProcess )
      {
        sub_FDBE70(v26 + 1, 0x103u);
        *v27 = 91;
        if ( wcschr(v27, 0xDu) )
          *wcschr(v27, 0xDu) = 0;
        wcscat_s(v27, 0x104u, L"]");
      }
      else
      {
        swprintf_s(v26, 0x104u, L"[Error opening process]");
      }
      pItem->szProcessName = _wcsdup(v27);
    }
    if ( v27 )
      free(v27);
    return 0;
  }
  v2 = pszFileName;
  if ( sub_FC43C0(pszFileName, &pItem->field_28C + 1, 0x41u, &pItem->pszTitle, &pItem->field_314)
    && GetLastError() != ERROR_RESOURCE_TYPE_NOT_FOUND )
  {
    v3 = wcslen(v2);
    v4 = malloc(2 * (v3 + 260));
    wcscpy_s(v4, v3 + 260, pszFileName);
    sub_FDBE70(v4 + 1, v3 + 259);
    *v4 = 91;
    if ( wcschr(v4, 0xDu) )
      *wcschr(v4, 0xDu) = 0;
    wcscat_s(v4, v3 + 260, L"]");
    pItem->szProcessName = v4;
  }
  else
  {
    nBufferLength = _wcsdup(v2);
    PE_GetFullPathName(&nBufferLength);
    v5 = nBufferLength;
    pItem->szProcessName = nBufferLength;
    if ( sub_FCE970(v5, &pItem->field_280, &hObject, &pItem->field_288 + 2) )
      pItem->dwStyle |= 0x100u;
    else
      pItem->dwStyle &= 0xFFFFFEFF;
    if ( !_wcsicmp(pItem->szProcessName2, L"rundll32.exe") && (v6 = pItem->pszCommandLine) != 0 && wcschr(v6, 0x2Cu) )
    {
      v7 = _wcsdup(pItem->pszCommandLine);
      v8 = v7;
      v9 = (v7 + 1);
      do
      {
        v10 = *v7;
        ++v7;
      }
      while ( v10 );
      _wcsupr_s(v8, ((v7 - v9) >> 1) + 1);
      if ( wcsstr(v8, L"SHELL32.DLL") && wcsstr(v8, L"CONTROL_RUNDLL ") )
      {
        v11 = wcsstr(v8, L"CONTROL_RUNDLL");
        v12 = wcschr(v11, 0x20u);
        v13 = v12;
        for ( i = *v12; i; ++v13 )
        {
          if ( i != 32 )
            break;
          i = v13[1];
        }
        if ( *v13 == 34 )
        {
          ++v13;
          if ( wcschr(v13, 0x22u) )
            *wcschr(v13, 0x22u) = 0;
        }
      }
      else
      {
        v13 = wcschr(v8, 0x2Cu);
        v15 = 0;
        for ( *v13 = 0; v13 != v8; --v13 )
        {
          if ( v15 )
          {
            if ( *v13 == 34 )
              break;
          }
          else
          {
            v16 = *v13;
            if ( v16 == 32 )
              goto LABEL_33;
            if ( v16 == 34 )
            {
              v15 = 1;
              *v13 = 0;
            }
          }
        }
        if ( *v13 == 32 )
LABEL_33:
          ++v13;
        if ( *v13 == 34 )
          ++v13;
        if ( !*v13 )
          ++v13;
      }
      v17 = SearchPathW(0, v13, 0, 0, 0, 0);
      nBufferLength = v17;
      if ( v17 )
      {
        v18 = malloc(2 * v17);
        pItem->m_ExtensionName = v18;
        SearchPathW(0, v13, 0, nBufferLength, v18, &FilePart);
        _wcslwr_s(pItem->m_ExtensionName, nBufferLength);
        sub_FC43C0(pItem->m_ExtensionName, Dst, 0x40u, &pItem->field_358, &pItem->field_354);
      }
      free(v8);
    }
    else if ( _wcsicmp(pItem->szProcessName2, L"svchost.exe") || (v19 = pItem->pszCommandLine) == 0 )
    {
      if ( !_wcsicmp(pItem->szProcessName2, L"dllhost.exe") )
      {
        v20 = pItem->pszCommandLine;
        if ( v20 )
          sub_FC3F80(v20, &pItem->field_350, &pItem->m_ExtensionName, &pItem->field_358, &pItem->field_354);
      }
    }
    else
    {
      sub_FC4730(v19, &pItem->szServiceName);
    }
    if ( !_wcsicmp(pItem->szProcessName2, L"mmc.exe") && SLOBYTE(pItem->dwStyle) >= 0 )
    {
      v21 = GetDesktopWindow();
      v22 = GetWindow(v21, 5u);
      nBufferLength = 0;
      while ( 1 )
      {
        GetWindowThreadProcessId(v22, &nBufferLength);
        ClassName[0] = 0;
        GetClassNameW(v22, ClassName, 260);
        if ( nBufferLength == pItem->dwProcessId && !wcsncmp(ClassName, &off_104421C, 0x104u) )
        {
          SendMessageTimeoutW(v22, 0x7Fu, 0, 0, 0, 0xC8u, &pItem->hIcon);
          SendMessageTimeoutW(v22, 0x7Fu, 1u, 0, 0, 0xC8u, &pItem->hFileIcon);
          v23 = 1;
          v32 = 1;
        }
        else
        {
          v22 = GetWindow(v22, 2u);
          v23 = v32;
        }
        if ( !v22 )
          break;
        if ( v23 )
          goto LABEL_59;
      }
      if ( v23 )
        goto LABEL_59;
    }
  }
  v24 = pszFileName;
  pItem->hIcon = ExtractApplicationIcon(pszFileName, 1);
  SendMessageW(ghMainWnd, WM_MSG_7F3, 0, pItem);
  pItem->hFileIcon = ExtractApplicationIcon(v24, 0);
LABEL_59:
  if ( pszFileName )
    free(pszFileName);
  return 1;
}

//----- (00FDD670) --------------------------------------------------------
int __cdecl VerifyImage(tagTREEVIEWLISTITEMPARAM *pItem, char a2)
{
  WCHAR *v2; // eax
  int *v3; // ecx
  const unsigned __int16 *v4; // ebx
  int *v5; // edx
  wchar_t **v6; // esi
  int v7; // eax
  int v8; // esi
  HCURSOR v9; // eax
  DWORD v10; // eax
  DWORD v11; // esi
  wchar_t *v12; // esi
  int v13; // ecx
  wchar_t v14; // ax
  size_t v15; // esi
  wchar_t *v16; // ebx
  wchar_t *v17; // eax
  unsigned int v18; // esi
  unsigned int v19; // ecx
  size_t v20; // esi
  wchar_t *v21; // eax
  wchar_t *v22; // eax
  HCURSOR hCursor; // [esp+Ch] [ebp-8C0h]
  wchar_t *v25; // [esp+10h] [ebp-8BCh]
  int a6; // [esp+14h] [ebp-8B8h]
  wchar_t *a1; // [esp+18h] [ebp-8B4h]
  int *v28; // [esp+1Ch] [ebp-8B0h]
  wchar_t **v29; // [esp+20h] [ebp-8ACh]
  int *v30; // [esp+24h] [ebp-8A8h]
  wchar_t *v31[32]; // [esp+28h] [ebp-8A4h]
  __int16 szBuffer[1040]; // [esp+A8h] [ebp-824h]

  if ( pItem->nListType == 1 )
  {
    v2 = *&pItem->gap154[4];
    v3 = &pItem->gap154[12];
    v4 = *pItem->gap154;
    v5 = &pItem->gap154[16];
    v6 = &pItem->gap154[20];
  }
  else
  {
    v2 = pItem->szProcessName;
    v3 = &pItem->field_340;
    v4 = pItem->field_314;
    v5 = &pItem->field_344;
    v6 = &pItem->field_348;
  }
  v29 = v6;
  v28 = v5;
  a1 = v2;
  v30 = v3;
  if ( !v2 || *v2 == 91 )
    return 0;
  if ( !*v3 )
  {
    if ( a2 )
    {
      v7 = sub_FE0D70(v2);
      v8 = v7;
      if ( v7 )
      {
        *v29 = _wcsdup(*(v7 + 4));
        *v30 = *(v8 + 8);
      }
      else
      {
        *v29 = _wcsdup(L"Verifying...");
        SendMessageW(ghMainWnd, WM_MSG_7F0, 0, pItem);
        v9 = LoadCursorW(0, IDC_WAIT);
        hCursor = SetCursor(v9);
        a6 = 32;
        v10 = sub_F99BB0(a1, 0, 0, 0, 0, &a6, v31, 0, 0, 0, 0, 0, -1);
        v11 = v10;
        if ( v10 )
        {
          SetLastError(v10);
          if ( v11 == 0x800B0101 )
            wcscpy_s(szBuffer, 0x410u, L"Certificate expired");
          else
            sub_FDBE70(szBuffer, 0x410u);
          if ( wcschr(szBuffer, 0x2Eu) )
            *wcschr(szBuffer, 0x2Eu) = 0;
          if ( v4 )
            v19 = wcslen(v4);
          else
            v19 = 1;
          v20 = wcslen(szBuffer) + v19 + 32;
          v21 = malloc(2 * v20);
          v25 = v21;
          *v30 = 2;
          if ( v4 )
            swprintf_s(v21, v20, L"(%s) %s", szBuffer, v4);
          else
            swprintf_s(v21, v20, L"(%s)", szBuffer);
          v16 = v25;
        }
        else
        {
          v12 = v31[0];
          *v30 = 1;
          v13 = (v12 + 1);
          do
          {
            v14 = *v12;
            ++v12;
          }
          while ( v14 );
          v15 = ((v12 - v13) >> 1) + 64;
          v16 = malloc(2 * v15);
          swprintf_s(v16, v15, L"(Verified) %s", v31[0]);
          v17 = _wcsdup(v31[0]);
          v18 = 0;
          *v28 = v17;
          if ( a6 )
          {
            do
              free(v31[v18++]);
            while ( v18 < a6 );
          }
        }
        SetCursor(hCursor);
        v22 = _wcsdup(v16);
        *v29 = v22;
        sub_FF53D0(a1, *v30, v22);
        free(v16);
      }
    }
    else
    {
      *v6 = _wcsdup(v4);
    }
    SendMessageW(ghMainWnd, WM_MSG_7F0, 0, pItem);
  }
  return *v28;
}

//----- (00FDD9D0) --------------------------------------------------------
SYSTEM_HANDLE_INFORMATION *__cdecl sub_FDD9D0(SYSTEM_HANDLE_INFORMATION *a1)
{
  SYSTEM_HANDLE_INFORMATION *result; // eax

  result = a1;
  if ( a1 )
    result = a1->NumberOfHandles;
  return result;
}

//----- (00FDD9E0) --------------------------------------------------------
SYSTEM_HANDLE_TABLE_ENTRY_INFO **__cdecl GetHandleTableEntry(SYSTEM_HANDLE_INFORMATION *pHandleInfo, int nIndex, SYSTEM_HANDLE_TABLE_ENTRY_INFO **pEntry)
{
  SYSTEM_HANDLE_TABLE_ENTRY_INFO **result; // eax
  SYSTEM_HANDLE_TABLE_ENTRY_INFO *v4; // ecx

  if ( gbSupportExtendedSystemHandleInformation )
  {
    result = pEntry;
    *pEntry = (pHandleInfo->Handles + sizeof(SYSTEM_HANDLE_TABLE_ENTRY_INFO_EX) * nIndex + 4);
  }
  else
  {
    v4 = (pHandleInfo + sizeof(SYSTEM_HANDLE_TABLE_ENTRY_INFO) * nIndex);
    word_107BC1C = v4->HandleValue;
    dword_107BC18 = *&v4[1].UniqueProcessId;
    byte_107BC20 = BYTE1(v4->Object);
    dword_107BC14 = HIWORD(v4->Object);
    dword_107BC0C = v4->GrantedAccess;
    word_107BC1E = LOBYTE(v4->Object);
    dword_107BC10 = *&v4->ObjectTypeIndex;
    result = pEntry;
    *pEntry = &dword_107BC0C;
  }
  return result;
}
// 106ABA5: using guessed type char gbSupportExtendedSystemHandleInformation;
// 107BC0C: using guessed type int dword_107BC0C;
// 107BC10: using guessed type int dword_107BC10;
// 107BC14: using guessed type int dword_107BC14;
// 107BC18: using guessed type int dword_107BC18;
// 107BC1C: using guessed type __int16 word_107BC1C;
// 107BC1E: using guessed type __int16 word_107BC1E;
// 107BC20: using guessed type char byte_107BC20;

//----- (00FDDA60) --------------------------------------------------------
struct _FILETIME __cdecl GetSystemProcessInfo(SYSTEM_PROCESS_INFORMATION **ppSystemProcessInfo, PULONG cbRet)
{
  PULONG cbLength; // esi
  SYSTEM_PROCESS_INFORMATION *v3; // eax
  struct _FILETIME SystemTimeAsFileTime; // [esp+8h] [ebp-Ch]
  char v6; // [esp+10h] [ebp-4h]

  cbLength = &v6;
  if ( cbRet )
    cbLength = cbRet;
  if ( !*ppSystemProcessInfo )
  {
    *cbLength = 1000;
    *ppSystemProcessInfo = malloc(1000u);
  }
  GetSystemTimeAsFileTime(&SystemTimeAsFileTime);
  if ( NtQuerySystemInformation(SystemProcessInformation, *ppSystemProcessInfo, *cbLength, &cbRet) )
  {
    do
    {
      free(*ppSystemProcessInfo);
      *cbLength += 10000;
      v3 = malloc(*cbLength);
      *ppSystemProcessInfo = v3;
    }
    while ( NtQuerySystemInformation(SystemProcessInformation, v3, *cbLength, &cbRet) );
  }
  return SystemTimeAsFileTime;
}

//----- (00FDDAF0) --------------------------------------------------------
FILETIME __cdecl RequerySystemStatus(SYSTEM_PROCESS_INFORMATION **ppSystemProcessInfo, PULONG cbRet, SYSTEM_PROCESSOR_PERFORMANCE_INFORMATION *pSystemProcessorPerformanceInfo, SYSTEM_INTERRUPT_INFORMATION *pSystemInterruptInfo, SYSTEM_PROCESSOR_IDLE_CYCLE_TIME_INFORMATION *pSystemProcessorCycleTimeInfo, CSystemProcessInfoMap *pMap, int dwBufLen)
{
  struct _FILETIME timeReturned; // rax
  DWORD v8; // ebx
  SYSTEM_PROCESSOR_IDLE_CYCLE_TIME_INFORMATION *pSystemProcessorCycleTimeInfo_1; // edi
  SYSTEM_PROCESS_INFORMATION *gpSystemProcessInfoLast; // esi
  CSystemProcessInfoMapNode *_Node; // eax
  ULONG i; // eax
  CSystemProcessInfoMapNode *_Node_1; // eax
  std__Tree_node *pNodeRet; // eax
  CSystemProcessInfoMap *pMapIn; // ecx
  CSystemProcessInfoMap LocalMap; // rax
  CSystemProcessInfoMap *pLocalMapIn; // ST0C_4
  int _Where; // [esp+10h] [ebp-2Ch]
  CSystemProcessInfoMapPair pair; // [esp+18h] [ebp-24h]
  CSystemProcessInfoMap *pLocalMap; // [esp+20h] [ebp-1Ch]
  int v22; // [esp+24h] [ebp-18h]
  ULONG nSize; // [esp+28h] [ebp-14h]
  unsigned int v24; // [esp+2Ch] [ebp-10h]
  int v25; // [esp+38h] [ebp-4h]

  timeReturned = GetSystemProcessInfo(ppSystemProcessInfo, cbRet);
  v24 = timeReturned.dwHighDateTime;
  v8 = timeReturned.dwLowDateTime;
  if ( pSystemProcessorPerformanceInfo )
    NtQuerySystemInformation(
      SystemProcessorPerformanceInformation,
      pSystemProcessorPerformanceInfo,
      sizeof(SYSTEM_PROCESSOR_PERFORMANCE_INFORMATION) * gSystemInfo.dwNumberOfProcessors,
      &nSize);
  if ( pSystemInterruptInfo )
    NtQuerySystemInformation(
      SystemInterruptInformation,
      pSystemInterruptInfo,
      sizeof(SYSTEM_INTERRUPT_INFORMATION) * gSystemInfo.dwNumberOfProcessors,
      &nSize);
  pSystemProcessorCycleTimeInfo_1 = pSystemProcessorCycleTimeInfo;
  if ( pSystemProcessorCycleTimeInfo )
    NtQuerySystemInformation(
      SystemProcessorCycleTimeInformation,
      pSystemProcessorCycleTimeInfo,
      sizeof(SYSTEM_PROCESSOR_IDLE_CYCLE_TIME_INFORMATION) * gSystemInfo.dwNumberOfProcessors,
      &nSize);
  if ( GetProcessorSystemCycleTime && pSystemProcessorCycleTimeInfo_1 )
  {
    v22 = 0;
    pLocalMap = std::_Tree_comp_alloc<std::_Tmap_traits<unsigned long,_SYSTEM_PROCESSOR_IDLE_CYCLE_TIME_INFORMATION *,std::less<unsigned long>,std::allocator<std::pair<unsigned long const,_SYSTEM_PROCESSOR_IDLE_CYCLE_TIME_INFORMATION *>>,0>>::_Buyheadnode();
    gpSystemProcessInfoLast = ::gpSystemProcessInfoLast;
    v25 = 0;
    if ( ::gpSystemProcessInfoLast )
    {
      pair._Key = ::gpSystemProcessInfoLast->UniqueProcessId;
      pair._Value = ::gpSystemProcessInfoLast;
      _Node = std::_Tree_comp_alloc<std::_Tmap_traits<unsigned long,_SYSTEM_PROCESSOR_IDLE_CYCLE_TIME_INFORMATION *,std::less<unsigned long>,std::allocator<std::pair<unsigned long const,_SYSTEM_PROCESSOR_IDLE_CYCLE_TIME_INFORMATION *>>,0>>::_Buynode<std::piecewise_construct_t const &,std::tuple<unsigned long &&>,std::tuple<>>(
                &pLocalMap,
                &pair);
      std::_Tree<std::_Tmap_traits<unsigned long,_SYSTEM_PROCESSOR_IDLE_CYCLE_TIME_INFORMATION *,std::less<unsigned long>,std::allocator<std::pair<unsigned long const,_SYSTEM_PROCESSOR_IDLE_CYCLE_TIME_INFORMATION *>>,0>>::_Insert_hint<std::pair<unsigned long const,_SYSTEM_PROCESSOR_IDLE_CYCLE_TIME_INFORMATION *> &,std::_Tree_node<std::pair<unsigned long const,_SYSTEM_PROCESSOR_IDLE_CYCLE_TIME_INFORMATION *>,void *> *>(
        &pLocalMap,
        &_Where,
        0,
        &_Node->_Keyvalue,
        _Node);
      for ( i = gpSystemProcessInfoLast->NextEntryOffset;
            gpSystemProcessInfoLast->NextEntryOffset;
            i = gpSystemProcessInfoLast->NextEntryOffset )
      {
        gpSystemProcessInfoLast = (gpSystemProcessInfoLast + i);
        pair._Value = gpSystemProcessInfoLast;
        pair._Key = gpSystemProcessInfoLast->UniqueProcessId;
        _Node_1 = std::_Tree_comp_alloc<std::_Tmap_traits<unsigned long,_SYSTEM_PROCESSOR_IDLE_CYCLE_TIME_INFORMATION *,std::less<unsigned long>,std::allocator<std::pair<unsigned long const,_SYSTEM_PROCESSOR_IDLE_CYCLE_TIME_INFORMATION *>>,0>>::_Buynode<std::piecewise_construct_t const &,std::tuple<unsigned long &&>,std::tuple<>>(
                    &pLocalMap,
                    &pair);
        std::_Tree<std::_Tmap_traits<unsigned long,_SYSTEM_PROCESSOR_IDLE_CYCLE_TIME_INFORMATION *,std::less<unsigned long>,std::allocator<std::pair<unsigned long const,_SYSTEM_PROCESSOR_IDLE_CYCLE_TIME_INFORMATION *>>,0>>::_Insert_hint<std::pair<unsigned long const,_SYSTEM_PROCESSOR_IDLE_CYCLE_TIME_INFORMATION *> &,std::_Tree_node<std::pair<unsigned long const,_SYSTEM_PROCESSOR_IDLE_CYCLE_TIME_INFORMATION *>,void *> *>(
          &pLocalMap,
          &_Where,
          0,
          &_Node_1->_Keyvalue,
          _Node_1);
      }
    }
    pNodeRet = sub_FDE4B0(&pLocalMap, *ppSystemProcessInfo, pSystemProcessorCycleTimeInfo_1, dwBufLen);
    pMapIn = pMap;
    pMap->_Header = pNodeRet;
    LocalMap._Header = pLocalMap;
    pLocalMapIn = pLocalMap;
    pMapIn->_Size = LocalMap._Size;
    sub_FF5510(&pLocalMap, &pSystemProcessorPerformanceInfo, LocalMap._Header->_Left, pLocalMapIn);
    j__free(pLocalMap);
  }
  return __PAIR__(v24, v8);
}
// 106F2F4: using guessed type int GetProcessorSystemCycleTime;

//----- (00FDDC80) --------------------------------------------------------
void QueryServiceNames()
{
  DWORD v0; // esi
  char cbSizeNeeded; // [esp+0h] [ebp-8h]
  int dwResumeHandle; // [esp+4h] [ebp-4h]

  if ( *EnumServicesStatusExW )
  {
    EnterCriticalSection(&gServiceLock);
    dwResumeHandle = 0;
    if ( !EnumServicesStatusExW(
            ghSCManagerHandle,
            SC_ENUM_PROCESS_INFO,
            SERVICE_WIN32,
            SERVICE_ACTIVE,
            gpszServiceNames,
            gdwServiceNamesLength,
            &cbSizeNeeded,
            &gdwServiceReturned,
            &dwResumeHandle,
            0) )
    {
      do
      {
        if ( GetLastError() != ERROR_MORE_DATA )
          break;
        dwResumeHandle = 0;
        if ( gpszServiceNames )
          free(gpszServiceNames);
        gdwServiceNamesLength += 16384;
        v0 = gdwServiceNamesLength;
        gpszServiceNames = malloc(gdwServiceNamesLength);
      }
      while ( !EnumServicesStatusExW(
                 ghSCManagerHandle,
                 0,
                 SERVICE_WIN32,
                 SERVICE_ACTIVE,
                 gpszServiceNames,
                 v0,
                 &cbSizeNeeded,
                 &gdwServiceReturned,
                 &dwResumeHandle,
                 0) );
    }
    LeaveCriticalSection(&gServiceLock);
  }
}

//----- (00FDDD60) --------------------------------------------------------
void __cdecl sub_FDDD60(char a1, unsigned int a2, int a3, unsigned int a4, int a5, int a6, int a7, unsigned int *a8)
{
  int v8; // esi
  unsigned int v9; // edx
  wchar_t *v10; // edi
  int v11; // ebx
  signed int v12; // eax
  const CHAR *v13; // ecx
  unsigned int v14; // ebx
  int v15; // esi
  int v16; // eax
  const CHAR *v17; // ebx
  const wchar_t **v18; // eax
  wchar_t *v19; // eax
  volatile signed __int32 *v20; // edx
  CString *v21; // eax
  HANDLE v22; // esi
  int v23; // ebx
  LPCSTR v24; // ebx
  CHAR *v25; // ecx
  int v26; // eax
  void *v27; // ebx
  int v28; // edx
  unsigned int v29; // ebx
  int v30; // esi
  char *v31; // eax
  LPCSTR v32; // eax
  int v33; // eax
  HANDLE v34; // esi
  const wchar_t **v35; // eax
  bool v36; // bl
  bool v37; // zf
  int v38; // ebx
  CString *v39; // eax
  const wchar_t **v40; // eax
  const wchar_t **v41; // eax
  wchar_t *v42; // eax
  DWORD v43; // ST28_4
  int v44; // eax
  int v45; // esi
  __int16 *v46; // ecx
  __int16 v47; // ax
  int v48; // ecx
  wchar_t v49; // ax
  __int16 v50; // ax
  int v51; // ecx
  wchar_t v52; // ax
  BOOL (__stdcall *v53)(HANDLE, PCWSTR, PVOID); // [esp+0h] [ebp-1288h]
  struct _MODLOAD_DATA *v54; // [esp+0h] [ebp-1288h]
  void *v55; // [esp+4h] [ebp-1284h]
  DWORD v56; // [esp+4h] [ebp-1284h]
  BOOL (__stdcall *v57)(HANDLE, PCWSTR, PVOID); // [esp+8h] [ebp-1280h]
  void *v58; // [esp+Ch] [ebp-127Ch]
  CString v59; // [esp+10h] [ebp-1278h]
  unsigned __int64 Displacement; // [esp+14h] [ebp-1274h]
  CString v61; // [esp+1Ch] [ebp-126Ch]
  CString v62; // [esp+20h] [ebp-1268h]
  int v63; // [esp+24h] [ebp-1264h]
  int v64; // [esp+28h] [ebp-1260h]
  int v65; // [esp+2Ch] [ebp-125Ch]
  CString v66; // [esp+30h] [ebp-1258h]
  int v67; // [esp+34h] [ebp-1254h]
  int v68; // [esp+38h] [ebp-1250h]
  unsigned int *v69; // [esp+3Ch] [ebp-124Ch]
  int v70; // [esp+40h] [ebp-1248h]
  int v71; // [esp+44h] [ebp-1244h]
  LPCSTR lpMultiByteStr; // [esp+48h] [ebp-1240h]
  unsigned int *v73; // [esp+4Ch] [ebp-123Ch]
  DWORD64 Address; // [esp+50h] [ebp-1238h]
  wchar_t v75; // [esp+58h] [ebp-1230h]
  struct _SYMBOL_INFOW Symbol; // [esp+858h] [ebp-A30h]
  WCHAR Buffer; // [esp+C58h] [ebp-630h]
  WCHAR Src; // [esp+E60h] [ebp-428h]
  WCHAR Dst; // [esp+106Ch] [ebp-21Ch]
  int v80; // [esp+1284h] [ebp-4h]

  HIDWORD(Displacement) = a6;
  Address = __PAIR__(a4, a2);
  v71 = a3;
  v64 = a5;
  v63 = a7;
  v69 = a8;
  if ( !a2 )
  {
    v8 = sub_FDE420(*(a3 + 44));
    if ( !v8 )
      v8 = a5;
    LODWORD(Address) = v8;
  }
  EnterCriticalSection(&gProcThreadsLock);
  GetSystemDirectoryW(&Buffer, 0x104u);
  v9 = Address;
  v10 = (a3 + 52);
  while ( 1 )
  {
    v11 = v63;
    v12 = -1;
    v73 = -1;
    *v10 = 0;
    if ( !v11 )
      goto LABEL_74;
    v70 = -1;
    v13 = *(v11 + 48);
    v14 = 0;
    lpMultiByteStr = v13;
    if ( !*v13 )
      goto LABEL_74;
    v15 = (v13 + 12);
    do
    {
      if ( v9 > *v15 )
      {
        if ( v9 >= *v15 + *(v15 + 4) )
        {
          v12 = v73;
        }
        else
        {
          v16 = *(v15 + 18) + 20;
          v70 = *v15;
          swprintf(v10, L"%S", v15 + v16);
          v9 = Address;
          v12 = v14;
          v73 = v14;
        }
      }
      ++v14;
      v15 += 284;
    }
    while ( v14 < *lpMultiByteStr );
    if ( v12 == -1 )
    {
LABEL_74:
      v29 = 0;
      v70 = -1;
      if ( !*v69 )
        goto LABEL_52;
      v30 = (v69 + 3);
      do
      {
        if ( v9 > *v30 )
        {
          if ( v9 >= *v30 + *(v30 + 4) )
          {
            v12 = v73;
          }
          else
          {
            v70 = *v30;
            lpMultiByteStr = (v30 + 20);
            v31 = strrchr((v30 + 20), 92);
            if ( v31 )
              v32 = v31 + 1;
            else
              v32 = lpMultiByteStr;
            swprintf(v10, L"%S", v32);
            v9 = Address;
            v12 = v29;
            v73 = v29;
          }
        }
        ++v29;
        v30 += 284;
      }
      while ( v29 < *v69 );
      if ( v12 == -1 )
      {
LABEL_52:
        v27 = HIDWORD(Address);
        goto LABEL_53;
      }
      v33 = 71 * v12;
      v34 = 0;
      v73 = &v69[v33];
      lpMultiByteStr = &v69[v33 + 8];
      v35 = ATL::CStringT<wchar_t,ATL::StrTraitATL<wchar_t,ATL::ChTraitsCRT<wchar_t>>>::CStringT<wchar_t,ATL::StrTraitATL<wchar_t,ATL::ChTraitsCRT<wchar_t>>>(
              &v61,
              lpMultiByteStr);
      v36 = _wcsnicmp(*v35, L"\\SystemRoot\\", 0xCu) == 0;
      ATL::CSimpleStringT<wchar_t,0>::~CSimpleStringT<wchar_t,0>(&v61);
      v37 = v36 == 0;
      v38 = v73;
      if ( v37 )
      {
        if ( *(v73 + 33) == 58 )
        {
          v40 = ATL::CStringT<wchar_t,ATL::StrTraitATL<wchar_t,ATL::ChTraitsCRT<wchar_t>>>::CStringT<wchar_t,ATL::StrTraitATL<wchar_t,ATL::ChTraitsCRT<wchar_t>>>(
                  &v66,
                  lpMultiByteStr);
          wcscpy_s(&Dst, 0x105u, *v40);
          ATL::CSimpleStringT<wchar_t,0>::~CSimpleStringT<wchar_t,0>(&v66);
        }
        else
        {
          if ( *(v73 + 37) != 58 )
          {
            sub_FD9D60(&Dst, L"%s\\drivers\\%s", &Buffer, v10);
            v34 = FindExecutableImageExW_0(&Dst, &Buffer, &Src, v53, v55);
            if ( v34 )
            {
              if ( !_wcsicmp(&Src, &Dst) )
                goto LABEL_46;
              CloseHandle(v34);
            }
            sub_FD9D60(&Src, L"%s\\drivers\\%s", &Buffer, v10);
            v34 = FindExecutableImageExW_0(&Src, &Buffer, &Dst, v57, v58);
            goto LABEL_46;
          }
          v41 = ATL::CStringT<wchar_t,ATL::StrTraitATL<wchar_t,ATL::ChTraitsCRT<wchar_t>>>::CStringT<wchar_t,ATL::StrTraitATL<wchar_t,ATL::ChTraitsCRT<wchar_t>>>(
                  &v62,
                  v73 + 36);
          wcscpy_s(&Dst, 0x105u, *v41);
          ATL::CSimpleStringT<wchar_t,0>::~CSimpleStringT<wchar_t,0>(&v62);
        }
      }
      else
      {
        v39 = ATL::CStringT<wchar_t,ATL::StrTraitATL<wchar_t,ATL::ChTraitsCRT<wchar_t>>>::CStringT<wchar_t,ATL::StrTraitATL<wchar_t,ATL::ChTraitsCRT<wchar_t>>>(
                &v59,
                v73 + 44);
        sub_FD9D60(&Src, L"%%SystemRoot%%\\%s", v39->pszData);
        ATL::CSimpleStringT<wchar_t,0>::~CSimpleStringT<wchar_t,0>(&v59);
        ExpandEnvironmentStringsW(&Src, &Dst, 0x105u);
      }
LABEL_46:
      v42 = _wcsdup(&Dst);
      *(v71 + 572) = v42;
      if ( SymLoadModuleExW_1 && a1 )
      {
        v43 = *(v38 + 16);
        v44 = *(v38 + 12);
        v27 = HIDWORD(Address);
        SymLoadModuleExW_1(HIDWORD(Address), v34, &Dst, 0, v44, v43, v59.pszData, Displacement);
      }
      else
      {
        v27 = HIDWORD(Address);
      }
      if ( v34 )
        CloseHandle(v34);
      goto LABEL_53;
    }
    if ( !a1 )
      goto LABEL_52;
    lpMultiByteStr += 284 * v12;
    v17 = lpMultiByteStr + 32;
    v18 = ATL::CStringT<wchar_t,ATL::StrTraitATL<wchar_t,ATL::ChTraitsCRT<wchar_t>>>::CStringT<wchar_t,ATL::StrTraitATL<wchar_t,ATL::ChTraitsCRT<wchar_t>>>(
            &v67,
            lpMultiByteStr + 32);
    v19 = _wcsdup(*v18);
    v20 = (v67 - 16);
    *(v71 + 572) = v19;
    if ( _InterlockedDecrement(v20 + 3) <= 0 )
      (*(**v20 + 4))(v20);
    if ( !SymLoadModuleExW_1 )
      goto LABEL_52;
    v21 = ATL::CStringT<wchar_t,ATL::StrTraitATL<wchar_t,ATL::ChTraitsCRT<wchar_t>>>::CStringT<wchar_t,ATL::StrTraitATL<wchar_t,ATL::ChTraitsCRT<wchar_t>>>(
            &v65,
            v17);
    v80 = 0;
    v22 = FindExecutableImageExW_0(v21->pszData, 0, &Dst, v53, v55);
    v23 = v65 - 16;
    v80 = -1;
    if ( _InterlockedDecrement((v65 - 16 + 12)) <= 0 )
      (*(**v23 + 4))(v23);
    v24 = lpMultiByteStr;
    v25 = ATL::CStringT<wchar_t,ATL::StrTraitATL<wchar_t,ATL::ChTraitsCRT<wchar_t>>>::CStringT<wchar_t,ATL::StrTraitATL<wchar_t,ATL::ChTraitsCRT<wchar_t>>>(
            &v68,
            lpMultiByteStr + 32)->pszData;
    v26 = *(v24 + 3);
    v27 = HIDWORD(Address);
    v80 = 1;
    SymLoadModuleExW_1(HIDWORD(Address), v22, v25, 0, v26, 0, v54, v56);
    v28 = v68 - 16;
    v80 = -1;
    if ( _InterlockedDecrement((v68 - 16 + 12)) <= 0 )
      (*(**v28 + 4))(v28);
    if ( v22 )
      CloseHandle(v22);
LABEL_53:
    v45 = Address;
    Symbol.SizeOfStruct = 88;
    Symbol.MaxNameLen = 469;
    if ( a1 )
    {
      if ( *SymFromAddrW && SymFromAddrW(v27, Address, &Displacement, &Symbol) )
        break;
    }
    if ( *v10 )
    {
      wsprintfW(&v75, L"+0x%x", v45 - v70);
      goto LABEL_70;
    }
    if ( v45 == v64 )
    {
      wsprintfW(&v75, L"0x%x", v45);
LABEL_70:
      wcscat_s(v10, 0x104u, &v75);
      goto LABEL_71;
    }
    v9 = v64;
    LODWORD(Address) = v64;
  }
  v46 = (a3 + 52);
  LOBYTE(Symbol.Name[Symbol.NameLen]) = 0;
  if ( Displacement )
  {
    do
    {
      v47 = *v46;
      ++v46;
    }
    while ( v47 );
    v48 = (v46 - a3 - 54) >> 1;
    do
    {
      v49 = *v10;
      ++v10;
    }
    while ( v49 );
    _snwprintf_s((v71 + 2 * ((v10 - a3 - 54) >> 1) + 52), 260 - v48, 0xFFFFFFFF, L"!%s+0x%x", Symbol.Name, Displacement);
  }
  else
  {
    do
    {
      v50 = *v46;
      ++v46;
    }
    while ( v50 );
    v51 = (v46 - a3 - 54) >> 1;
    do
    {
      v52 = *v10;
      ++v10;
    }
    while ( v52 );
    _snwprintf_s((v71 + 2 * ((v10 - a3 - 54) >> 1) + 52), 260 - v51, 0xFFFFFFFF, L"!%s", Symbol.Name);
  }
LABEL_71:
  LeaveCriticalSection(&gProcThreadsLock);
}
// 1042BE0: using guessed type wchar_t a0xX_0[5];

//----- (00FDE420) --------------------------------------------------------
int __cdecl sub_FDE420(HANDLE hObject)
{
  HANDLE v1; // esi
  struct _OBJECT_ATTRIBUTES ObjectAttributes; // [esp+0h] [ebp-28h]
  struct _CLIENT_ID ClientId; // [esp+18h] [ebp-10h]
  ULONG ReturnLength; // [esp+20h] [ebp-8h]
  int ThreadInformation; // [esp+24h] [ebp-4h]

  ClientId.UniqueThread = hObject;
  ThreadInformation = 0;
  ClientId.UniqueProcess = 0;
  ObjectAttributes.Length = 24;
  ObjectAttributes.RootDirectory = 0;
  ObjectAttributes.Attributes = 0;
  ObjectAttributes.ObjectName = 0;
  ObjectAttributes.SecurityDescriptor = 0;
  ObjectAttributes.SecurityQualityOfService = 0;
  if ( NtOpenThread(&hObject, 0x40u, &ObjectAttributes, &ClientId) )
    return ThreadInformation;
  v1 = hObject;
  if ( hObject )
  {
    NtQueryInformationThread(hObject, ThreadQuerySetWin32StartAddress, &ThreadInformation, 4u, &ReturnLength);
    CloseHandle(v1);
  }
  return ThreadInformation;
}

//----- (00FDE4B0) --------------------------------------------------------
int __cdecl sub_FDE4B0(CSystemProcessInfoMap *theMap, SYSTEM_PROCESS_INFORMATION *pSystemProcessInfo, SYSTEM_PROCESSOR_IDLE_CYCLE_TIME_INFORMATION *pProcessorIdleCycleTimeInfo, unsigned int dwProcessorIdleCycleTimeInfoLen)
{
  unsigned __int64 ThisMap; // rcx
  SYSTEM_PROCESS_INFORMATION *SystemProcessInfo; // esi
  unsigned int v6; // edx
  DWORD dwNumberOfProcessors; // edi
  DWORD dwIndex; // edx
  __m128i v9; // xmm1
  __m128i v10; // xmm2
  char *v11; // eax
  __m128i v12; // xmm0
  __m128i v13; // xmm1
  __m128i v14; // xmm1
  unsigned __int64 v15; // kr08_8
  unsigned int v16; // eax
  unsigned int v17; // edi
  int v18; // kr18_4
  unsigned __int8 v19; // cf
  unsigned __int64 v20; // kr28_8
  DWORD v21; // kr04_4
  int v22; // ebx
  int v23; // ecx
  HANDLE v24; // edx
  int v25; // eax
  int *v26; // eax
  _DWORD *v27; // eax
  int v28; // edx
  CSystemProcessInfoMap *theMap_2; // esi
  std__Tree_node *_Node; // eax
  _DWORD *v31; // edi
  std__Tree_node *v32; // edx
  std__Tree_node_For__bstr_t *v33; // ecx
  std__Tree_node_For__bstr_t *_Node_1; // ecx
  std__Tree_node *_Node_2; // ecx
  std__Tree_node *_Node_3; // ecx
  unsigned int dwIndex_1; // edx
  __m128i v38; // xmm1
  __m128i v39; // xmm2
  SYSTEM_PROCESSOR_IDLE_CYCLE_TIME_INFORMATION *pProcessorIdleCycleTimeInfo2; // eax
  __m128i v41; // xmm0
  __m128i v42; // xmm1
  __m128i v43; // xmm1
  unsigned __int64 v44; // kr20_8
  unsigned __int64 v45; // rcx
  int v46; // eax
  unsigned int v47; // edi
  unsigned int v48; // eax
  ULONGLONG v49; // kr40_8
  ULONGLONG v50; // kr48_8
  unsigned int v51; // edi
  unsigned __int64 v52; // rax
  ULONG Buffer; // [esp+0h] [ebp-83Ch]
  int v55; // [esp+4h] [ebp-838h]
  int v56; // [esp+8h] [ebp-834h]
  DWORD v57; // [esp+Ch] [ebp-830h]
  _DWORD a2[2]; // [esp+10h] [ebp-82Ch]
  unsigned int dwProcessorIdleCycleTimeInfoLength; // [esp+18h] [ebp-824h]
  __int64 v60; // [esp+1Ch] [ebp-820h]
  __int64 v61; // [esp+24h] [ebp-818h]
  CSystemProcessInfoMap *theMap_1; // [esp+2Ch] [ebp-810h]
  unsigned int v63; // [esp+30h] [ebp-80Ch]
  unsigned int v64; // [esp+34h] [ebp-808h]
  ULONG64 ProcessorIdleCycleTime; // [esp+38h] [ebp-804h]
  int v66; // [esp+40h] [ebp-7FCh]
  int v67; // [esp+44h] [ebp-7F8h]
  char v68; // [esp+48h] [ebp-7F4h]

  ThisMap = theMap;
  SystemProcessInfo = pSystemProcessInfo;
  v60 = 0i64;
  v6 = 0;
  dwNumberOfProcessors = gSystemInfo.dwNumberOfProcessors;
  theMap_1 = theMap;
  dwProcessorIdleCycleTimeInfoLength = dwProcessorIdleCycleTimeInfoLen;
  v63 = 0;
  v64 = 0;
  while ( 1 )
  {
    if ( !SystemProcessInfo->UniqueProcessId && !SystemProcessInfo->SpareLi3.QuadPart )
    {
      Buffer = 8 * dwNumberOfProcessors;
      QueryIdleProcessorCycleTime(&Buffer, &ProcessorIdleCycleTime);
      dwNumberOfProcessors = gSystemInfo.dwNumberOfProcessors;
      dwIndex = 0;
      if ( gSystemInfo.dwNumberOfProcessors && gSystemInfo.dwNumberOfProcessors >= 4 )
      {
        v9 = 0i64;
        v10 = 0i64;
        v11 = &v68;
        do
        {
          v12 = _mm_loadu_si128(v11 - 1);
          dwIndex += 4;
          v11 += 32;
          v9 = _mm_add_epi64(v9, v12);
          v10 = _mm_add_epi64(v10, _mm_loadu_si128(v11 - 2));
        }
        while ( dwIndex < gSystemInfo.dwNumberOfProcessors - (gSystemInfo.dwNumberOfProcessors & 3) );
        v13 = _mm_add_epi64(v9, v10);
        v14 = _mm_add_epi64(v13, _mm_srli_si128(v13, 8));
        LODWORD(ThisMap) = _mm_cvtsi128_si32(v14);
        v15 = ThisMap + __PAIR__(_mm_cvtsi128_si32(_mm_srli_si128(v14, 4)), v64);
        HIDWORD(ThisMap) = HIDWORD(v15);
        v63 = v15 >> 32;
        v64 = v15;
      }
      v60 = 0i64;
      v61 = 0i64;
      if ( dwIndex >= gSystemInfo.dwNumberOfProcessors )
      {
        v6 = v64;
      }
      else
      {
        ThisMap = __PAIR__(HIDWORD(v61), v60);
        if ( gSystemInfo.dwNumberOfProcessors - dwIndex < 2 )
        {
          HIDWORD(v61) = v61;
          v16 = HIDWORD(v60);
        }
        else
        {
          v57 = gSystemInfo.dwNumberOfProcessors - 1;
          HIDWORD(v61) = v61;
          v16 = HIDWORD(v60);
          v17 = v61;
          do
          {
            v16 = (__PAIR__(*(&ProcessorIdleCycleTime + 2 * dwIndex + 1), *(&ProcessorIdleCycleTime + 2 * dwIndex))
                 + __PAIR__(v16, ThisMap)) >> 32;
            LODWORD(ThisMap) = *(&ProcessorIdleCycleTime + 2 * dwIndex) + ThisMap;
            v18 = *(&v66 + 2 * dwIndex) + v17;
            HIDWORD(ThisMap) = (__PAIR__(*(&v67 + 2 * dwIndex), *(&v66 + 2 * dwIndex)) + __PAIR__(HIDWORD(ThisMap), v17)) >> 32;
            v17 += *(&v66 + 2 * dwIndex);
            dwIndex += 2;
          }
          while ( dwIndex < v57 );
          HIDWORD(v61) = v18;
          dwNumberOfProcessors = gSystemInfo.dwNumberOfProcessors;
        }
        if ( dwIndex < dwNumberOfProcessors )
        {
          v19 = __CFADD__(*(&ProcessorIdleCycleTime + 2 * dwIndex), v64);
          v64 += *(&ProcessorIdleCycleTime + 2 * dwIndex);
          v63 += *(&ProcessorIdleCycleTime + 2 * dwIndex + 1) + v19;
          dwNumberOfProcessors = gSystemInfo.dwNumberOfProcessors;
        }
        v20 = __PAIR__(v16, HIDWORD(v61)) + ThisMap + __PAIR__(v63, v64);
        HIDWORD(ThisMap) = HIDWORD(v20);
        v6 = v20;
      }
      LODWORD(ThisMap) = theMap_1;
    }
    v21 = SystemProcessInfo->SpareLi3.LowPart;
    v64 = SystemProcessInfo->SpareLi3.LowPart + v6;
    HIDWORD(ThisMap) = (__PAIR__(HIDWORD(ThisMap), v21) + __PAIR__(SystemProcessInfo->SpareLi3.HighPart, v6)) >> 32;
    v6 += v21;
    v63 = HIDWORD(ThisMap);
    if ( ThisMap )
    {
      v22 = *ThisMap;
      v23 = v22;
      v24 = SystemProcessInfo->UniqueProcessId;
      v25 = *(v22 + 4);
      while ( !*(v25 + 13) )
      {
        if ( *(v25 + 16) >= v24 )
        {
          v23 = v25;
          v25 = *v25;
        }
        else
        {
          v25 = *(v25 + 8);
        }
      }
      if ( v23 == v22 || v24 < *(v23 + 16) )
      {
        v56 = v22;
        v26 = &v56;
      }
      else
      {
        v55 = v23;
        v26 = &v55;
      }
      v27 = *v26;
      if ( v27 != v22 )
      {
        v28 = v27[5];
        if ( *(v28 + 32) == SystemProcessInfo->CreateTime.LowPart )
        {
          LODWORD(ThisMap) = theMap_1;
          if ( *(v28 + 36) != SystemProcessInfo->CreateTime.HighPart )
          {
LABEL_35:
            v6 = v64;
            HIDWORD(ThisMap) = v63;
            goto LABEL_36;
          }
          sub_FF55B0(theMap_1, &a2[1], v27);
          dwNumberOfProcessors = gSystemInfo.dwNumberOfProcessors;
        }
      }
      LODWORD(ThisMap) = theMap_1;
      goto LABEL_35;
    }
LABEL_36:
    if ( !SystemProcessInfo->NextEntryOffset )
      break;
    SystemProcessInfo = (SystemProcessInfo + SystemProcessInfo->NextEntryOffset);
  }
  theMap_2 = theMap_1;
  if ( theMap_1 )
  {
    _Node = theMap_1->_Header->_Left;
    if ( _Node != theMap_1->_Header )
    {
      v31 = dwProcessorIdleCycleTimeInfoLength;
      do
      {
        v32 = _Node[1]._Parent;
        v33 = v32[1]._Right;
        v19 = __CFADD__(v33, *v31);
        *v31 += v33;
        v31[1] += *&v32[1]._Color + v19;
        if ( !_Node->_IsNil )
        {
          _Node_1 = _Node->_Right;
          if ( _Node_1->_IsNil )
          {
            for ( _Node_3 = _Node->_Parent; !_Node_3->_IsNil; _Node_3 = _Node_3->_Parent )
            {
              if ( _Node != _Node_3->_Right )
                break;
              _Node = _Node_3;
            }
            _Node = _Node_3;
          }
          else
          {
            _Node = _Node->_Right;
            for ( _Node_2 = _Node_1->_Left; !_Node_2->_IsNil; _Node_2 = _Node_2->_Left )
              _Node = _Node_2;
          }
        }
      }
      while ( _Node != theMap_2->_Header );
      dwNumberOfProcessors = gSystemInfo.dwNumberOfProcessors;
    }
  }
  dwIndex_1 = 0;
  if ( dwNumberOfProcessors && dwNumberOfProcessors >= 4 )
  {
    v38 = 0i64;
    v39 = 0i64;
    pProcessorIdleCycleTimeInfo2 = pProcessorIdleCycleTimeInfo + 2;
    do
    {
      *v41.m128i_i8 = pProcessorIdleCycleTimeInfo2[-2];
      pProcessorIdleCycleTimeInfo2 += 4;
      v41.m128i_i64[1] = pProcessorIdleCycleTimeInfo2[-5].CycleTime;
      dwIndex_1 += 4;
      v38 = _mm_add_epi64(v38, v41);
      *v41.m128i_i8 = pProcessorIdleCycleTimeInfo2[-4];
      v41.m128i_i64[1] = pProcessorIdleCycleTimeInfo2[-3].CycleTime;
      v39 = _mm_add_epi64(v39, v41);
    }
    while ( dwIndex_1 < dwNumberOfProcessors - (dwNumberOfProcessors & 3) );
    v42 = _mm_add_epi64(v38, v39);
    v43 = _mm_add_epi64(v42, _mm_srli_si128(v42, 8));
    LODWORD(ThisMap) = _mm_cvtsi128_si32(v43);
    v44 = ThisMap + __PAIR__(_mm_cvtsi128_si32(_mm_srli_si128(v43, 4)), v64);
    v63 = v44 >> 32;
    v64 = v44;
  }
  *a2 = 0i64;
  v60 = 0i64;
  if ( dwIndex_1 >= dwNumberOfProcessors )
  {
    LODWORD(v52) = v64;
  }
  else
  {
    v45 = __PAIR__(HIDWORD(v60), a2[0]);
    if ( dwNumberOfProcessors - dwIndex_1 < 2 )
    {
      HIDWORD(v61) = v60;
      v48 = a2[1];
    }
    else
    {
      v46 = dwNumberOfProcessors - 1;
      v47 = v60;
      dwProcessorIdleCycleTimeInfoLength = v46;
      v48 = a2[1];
      do
      {
        v49 = pProcessorIdleCycleTimeInfo[dwIndex_1].CycleTime + __PAIR__(v48, v45);
        v48 = HIDWORD(v49);
        LODWORD(v45) = v49;
        v50 = pProcessorIdleCycleTimeInfo[dwIndex_1 + 1].CycleTime + __PAIR__(HIDWORD(v45), v47);
        HIDWORD(v45) = HIDWORD(v50);
        v47 = v50;
        dwIndex_1 += 2;
      }
      while ( dwIndex_1 < dwProcessorIdleCycleTimeInfoLength );
      HIDWORD(v61) = v50;
      dwNumberOfProcessors = gSystemInfo.dwNumberOfProcessors;
    }
    if ( dwIndex_1 >= dwNumberOfProcessors )
    {
      v51 = v63;
    }
    else
    {
      v51 = (pProcessorIdleCycleTimeInfo[dwIndex_1].CycleTime + __PAIR__(v63, v64)) >> 32;
      v64 += LODWORD(pProcessorIdleCycleTimeInfo[dwIndex_1].CycleTime);
    }
    v52 = __PAIR__(v48, HIDWORD(v61)) + v45 + __PAIR__(v51, v64);
  }
  return v52;
}

//----- (00FDE920) --------------------------------------------------------
signed int sub_FDE920()
{
  HANDLE v0; // edi
  SYSTEM_HANDLE_INFORMATION *v1; // eax
  ULONG v2; // esi
  int v3; // esi
  signed int result; // eax
  SYSTEM_HANDLE_INFORMATION *v5; // eax
  ULONG v6; // esi
  int v7; // esi
  void *pEntry; // [esp+4h] [ebp-808h]
  __int16 v9; // [esp+8h] [ebp-804h]

  if ( *CreateJobObjectW )
  {
    v0 = CreateJobObjectW(0, 0);
    if ( v0 )
    {
      GetSystemProcessInfo(&gpSystemProcessInfo, &gnSystemProcessInfoLength);
      QuerySystemHandleInfo(0);
      v1 = gpSystemHandleInfo2;
      if ( gpSystemHandleInfo2 )
        v2 = gpSystemHandleInfo2->NumberOfHandles;
      else
        v2 = 0;
      v3 = v2 - 1;
      if ( v3 >= 0 )
      {
        while ( 1 )
        {
          GetHandleTableEntry(v1, v3, &pEntry);
          if ( *(pEntry + 1) == GetCurrentProcessId() && *(pEntry + 2) == v0 )
            break;
          if ( --v3 < 0 )
            goto LABEL_12;
          v1 = gpSystemHandleInfo2;
        }
        v9 = 0;
        sub_FDC750(&gpszObjectTypeNames[64 * *(pEntry + 9)], pEntry, &v9, 0x400u, 0);
      }
LABEL_12:
      CloseHandle(v0);
    }
    result = 1;
  }
  else
  {
    GetSystemProcessInfo(&gpSystemProcessInfo, &gnSystemProcessInfoLength);
    QuerySystemHandleInfo(0);
    v5 = gpSystemHandleInfo2;
    if ( gpSystemHandleInfo2 )
      v6 = gpSystemHandleInfo2->NumberOfHandles;
    else
      v6 = 0;
    v7 = v6 - 1;
    if ( v7 >= 0 )
    {
      while ( 1 )
      {
        GetHandleTableEntry(v5, v7, &pEntry);
        if ( !gpszObjectTypeNames[64 * *(pEntry + 9)] )
        {
          v9 = 0;
          sub_FDC750(&gpszObjectTypeNames[64 * *(pEntry + 9)], pEntry, &v9, 0x400u, 0);
        }
        if ( --v7 < 0 )
          break;
        v5 = gpSystemHandleInfo2;
      }
    }
    result = 1;
  }
  return result;
}

//----- (00FDEAA0) --------------------------------------------------------
LPVOID __cdecl sub_FDEAA0(LPCVOID pBlock, int a2)
{
  LPVOID result; // eax
  unsigned int puLen; // [esp+8h] [ebp-Ch]
  __int16 v4; // [esp+Ch] [ebp-8h]
  LPVOID lpBuffer; // [esp+10h] [ebp-4h]

  v4 = 1024;
  lpBuffer = &v4;
  VerQueryValueW(pBlock, L"\\VarFileInfo\\Translation", &lpBuffer, &puLen);
  result = sub_FDC190(pBlock, *lpBuffer, *(lpBuffer + 1), a2);
  if ( !result )
  {
    result = sub_FDC190(pBlock, *lpBuffer, 0x4E4u, a2);
    if ( !result )
      result = sub_FDC190(pBlock, 1033, 0x4E4u, a2);
  }
  return result;
}

//----- (00FDEB20) --------------------------------------------------------
DWORD __cdecl sub_FDEB20(void *a1, PVOID *a2, DWORD *a3, _DWORD *a4, _DWORD *a5, _DWORD *a6, DWORD *a7)
{
  DWORD result; // eax
  unsigned int v8; // ecx
  int v9; // eax

  *a4 = 0;
  *a5 = 0;
  *a6 = 0;
  *a7 = 0;
  while ( 1 )
  {
    if ( QueryWorkingSet(a1, *a2, *a3) )
    {
      if ( !*a2 )
        goto LABEL_7;
      if ( *a3 >= 4 * **a2 )
        break;
    }
    if ( *a2 )
      free(*a2);
LABEL_7:
    result = GetLastError();
    if ( result != 24 )
    {
      *a2 = 0;
      *a3 = 0;
      return result;
    }
    *a3 += 0x4000;
    *a2 = malloc(*a3);
  }
  v8 = 0;
  if ( **a2 )
  {
    do
    {
      v9 = *(*a2 + v8 + 1);
      ++*a4;
      if ( v9 & 0x100 )
      {
        ++*a6;
        if ( (v9 & 0xE0u) > 0x20 )
          ++*a7;
      }
      else
      {
        ++*a5;
      }
      ++v8;
    }
    while ( v8 < **a2 );
  }
  *a4 *= gSystemInfo.dwPageSize;
  *a5 *= gSystemInfo.dwPageSize;
  *a6 *= gSystemInfo.dwPageSize;
  result = gSystemInfo.dwPageSize * *a7;
  *a7 = result;
  return result;
}

//----- (00FDEC30) --------------------------------------------------------
BOOL __stdcall DlgSystemInfoGPUNodes(HWND hDlg, UINT msg, WPARAM wParam, LPARAM lParam)
{
  int v4; // ebx
  int v5; // esi
  HWND v6; // eax
  int v7; // ST24_4
  int v8; // ST20_4
  int v9; // ST1C_4
  HWND v10; // eax
  HICON v11; // eax
  HWND v12; // eax
  int v13; // ebx
  int v14; // eax
  int v15; // eax
  signed int v16; // esi
  HWND v17; // eax
  CGraphData *v18; // eax
  int v19; // esi
  unsigned int v20; // edx
  int v21; // ecx
  LONG v22; // eax
  LONG v23; // ecx
  int v24; // ebx
  int v25; // esi
  HWND v26; // esi
  CResizer *v27; // eax
  CResizer *v28; // esi
  char *v29; // eax
  HWND v30; // eax
  struct tagResizerItem *v31; // eax
  HMENU v32; // ST2C_4
  HWND v33; // eax
  double v34; // xmm0_8
  double *v35; // eax
  DWORD v37; // ecx
  int v38; // esi
  int v39; // ebx
  int v40; // esi
  int v41; // ebx
  HWND v42; // eax
  HWND v43; // eax
  int v44; // ebx
  int v45; // esi
  HWND v46; // eax
  double v47; // [esp+10h] [ebp-94h]
  LRESULT wParama; // [esp+14h] [ebp-90h]
  double v49; // [esp+18h] [ebp-8Ch]
  int v50; // [esp+1Ch] [ebp-88h]
  double v51; // [esp+20h] [ebp-84h]
  int v52; // [esp+24h] [ebp-80h]
  double v53; // [esp+28h] [ebp-7Ch]
  double v54; // [esp+28h] [ebp-7Ch]
  int v55; // [esp+2Ch] [ebp-78h]
  int v56; // [esp+30h] [ebp-74h]
  int nWidth; // [esp+34h] [ebp-70h]
  int v58; // [esp+38h] [ebp-6Ch]
  double v59; // [esp+3Ch] [ebp-68h]
  signed int ArgList; // [esp+40h] [ebp-64h]
  LONG ArgLista; // [esp+40h] [ebp-64h]
  struct tagPOINT Point; // [esp+44h] [ebp-60h]
  int v63; // [esp+4Ch] [ebp-58h]
  HMENU hMenu; // [esp+50h] [ebp-54h]
  struct tagRECT v65; // [esp+54h] [ebp-50h]
  struct tagRECT Rect; // [esp+64h] [ebp-40h]
  WCHAR String; // [esp+74h] [ebp-30h]
  int v68; // [esp+A0h] [ebp-4h]

  if ( msg > 0x113 )
  {
    if ( msg > 0x138 )
    {
      if ( msg == 1124 )
      {
        v43 = GetDlgItem(hDlg, 2501);
        ShowWindow(v43, 0);
        v44 = 1;
        if ( gdwAdapterRuntingTime + 1 > 1 )
        {
          v45 = 2503;
          do
          {
            v46 = GetDlgItem(hDlg, v45);
            ShowWindow(v46, 5);
            ++v44;
            v45 += 2;
          }
          while ( v44 < gdwAdapterRuntingTime + 1 );
        }
      }
    }
    else if ( msg == 312 || msg == 307 || msg == 310 )
    {
      return PE_FillControl(hDlg, wParam);
    }
    return 0;
  }
  if ( msg == 275 )
  {
    v40 = 0;
    if ( gdwAdapterRuntingTime > 0 )
    {
      v41 = 2502;
      do
      {
        v42 = GetDlgItem(hDlg, v41);
        SendMessageW(v42, 0x400u, 0, 0);
        ++v40;
        v41 += 2;
      }
      while ( v40 < gdwAdapterRuntingTime );
    }
    return 0;
  }
  if ( msg > 0x110 )
  {
    if ( msg == 273 )
    {
      if ( wParam == 1 )
      {
        v37 = 0;
        v38 = 0;
        hMenu = 0;
        if ( gdwAdapterRuntingTime > 0 )
        {
          v39 = 2503;
          do
          {
            if ( IsDlgButtonChecked(hDlg, v39) == 1 )
            {
              v37 = (1 << v38) | hMenu;
              hMenu = ((1 << v38) | hMenu);
            }
            else
            {
              v37 = hMenu;
            }
            ++v38;
            v39 += 2;
          }
          while ( v38 < gdwAdapterRuntingTime );
        }
        if ( v37 != gConfig.dwGpuNodeUsageMask )
        {
          gConfig.dwGpuNodeUsageMask = v37;
          gpGraphInfoOfGPU->field_888 = 0;
          gpGraphInfoOfGPU->field_88C = 0;
        }
        EndDialog(hDlg, 0);
      }
      else if ( wParam == 2 )
      {
        EndDialog(hDlg, 0);
      }
    }
    return 0;
  }
  if ( msg != 272 )
  {
    if ( msg == 5 )
    {
      v4 = 0;
      if ( gdwAdapterRuntingTime > 0 )
      {
        v5 = 2503;
        do
        {
          v6 = GetDlgItem(hDlg, v5 - 1);
          GetWindowRect(v6, &Rect);
          Point.x = Rect.left;
          Point.y = Rect.bottom + 2;
          ScreenToClient(hDlg, &Point);
          v7 = Rect.right - Rect.left;
          v8 = Point.y;
          v9 = Point.x;
          v10 = GetDlgItem(hDlg, v5);
          SetWindowPos(v10, 0, v9, v8, v7, 14, 0);
          ++v4;
          v5 += 2;
        }
        while ( v4 < gdwAdapterRuntingTime );
      }
    }
    else if ( msg == 36 )
    {
      *(lParam + 8) = 2 * gdwVirtualScreenWidth;
    }
    return 0;
  }
  v11 = LoadIconW(ghInstance, 0x65);
  SendMessageW(hDlg, 0x80u, 0, v11);
  v12 = GetDlgItem(hDlg, 2501);
  GetWindowRect(v12, &v65);
  v13 = gdwAdapterRuntingTime;
  v56 = gdwAdapterRuntingTime;
  if ( gdwAdapterRuntingTime > 8 )
  {
    v13 = 8 * (gdwAdapterRuntingTime / 8 > 16) + 8;
    v56 = 8 * (gdwAdapterRuntingTime / 8 > 16) + 8;
  }
  v14 = (v13 + gdwAdapterRuntingTime - 1) / v13;
  v58 = v14;
  v15 = v13 * v14 - gdwAdapterRuntingTime;
  if ( v15 )
  {
    v13 += v15 / -2;
    v56 = v13;
    v58 = (v13 + gdwAdapterRuntingTime - 1) / v13;
  }
  v16 = 4;
  if ( gdwAdapterRuntingTime > 16 )
    v16 = 3;
  ArgList = v16;
  if ( gdwAdapterRuntingTime > 32 )
    ArgList = --v16;
  nWidth = (v65.right - v16 * (v13 - 1) - v65.left) / v13;
  v52 = (v65.bottom - v16 * (v58 - 1) - v65.top) / v58;
  v17 = GetDlgItem(hDlg, 2501);
  GetWindowRect(v17, &v65);
  MapWindowPoints(0, hDlg, &v65, 2u);
  if ( !dword_107BA1C )
  {
    v18 = InitGraphData(gdwAdapterRuntingTime, 1, 0);
    v19 = 0;
    dword_107BA1C = v18;
    if ( gdwAdapterRuntingTime > 0 )
    {
      v20 = 0;
      while ( 1 )
      {
        v18[v20 / 0x898].m_ProcessorID = v19;
        *(v20 + dword_107BA1C + 28) = 1;
        *(v20 + dword_107BA1C + 32) = 4;
        *(v20 + dword_107BA1C + 48) = 8421631;
        *(v20 + dword_107BA1C + 40) = db_onehundred;
        *(v20 + dword_107BA1C + 2172) = gpGraphInfoOfGPU;
        if ( v19 )
        {
          v21 = dword_107BA1C;
          *(v20 + dword_107BA1C + 2148) = *(dword_107BA1C + 2148);
          *(v20 + dword_107BA1C + 2152) = *(v21 + 2152);
        }
        ++v19;
        v20 += 2200;
        if ( v19 >= gdwAdapterRuntingTime )
          break;
        v18 = dword_107BA1C;
      }
    }
    v16 = ArgList;
  }
  Rect.bottom = v65.left;
  wParama = SendMessageW(hDlg, 0x31u, 0, 0);
  v22 = 0;
  ArgLista = 0;
  if ( gdwAdapterRuntingTime > 0 )
  {
    v63 = 0;
    v50 = v16 + nWidth;
    v23 = v65.left;
    hMenu = 2503;
    do
    {
      v24 = 0;
      Point.y = v22 + 1;
      v55 = (v22 + 1) % v56;
      if ( !v55 )
        v24 = v65.right - v23 - nWidth;
      v25 = MulDiv(14, gLogPixelSize.y, 96);
      CreateWindowExW(
        0,
        L"Static",
        0,
        0x40000000u,
        v65.left,
        v65.top,
        v24 + nWidth,
        v52 - v25 - 1,
        hDlg,
        (hMenu - 1),
        ghInstance,
        0);
      CreateGraphWindow(hDlg, hMenu - 1, (v63 + dword_107BA1C));
      v26 = CreateWindowExW(
              0,
              L"Button",
              0,
              0x40010003u,
              v65.left,
              v52 + v65.top - v25,
              nWidth,
              v25,
              hDlg,
              hMenu,
              ghInstance,
              0);
      sub_FA13E0(&String, L"Engine %d", ArgLista);
      SetWindowTextW(v26, &String);
      SendMessageW(v26, 0x30u, wParama, 1);
      EnableWindow(v26, 1);
      ShowWindow(v26, 5);
      if ( (1 << ArgLista) & gConfig.dwGpuNodeUsageMask )
        CheckDlgButton(hDlg, hMenu, 1u);
      v23 = v50 + v65.left;
      v65.left += v50;
      if ( !v55 )
      {
        v23 = Rect.bottom;
        v65.left = Rect.bottom;
        v65.top += v52 + 2;
      }
      v22 = Point.y;
      v63 += 2200;
      ArgLista = Point.y;
      hMenu = (hMenu + 2);
    }
    while ( Point.y < gdwAdapterRuntingTime );
    v13 = v56;
  }
  v27 = operator new(0x40u);
  v28 = v27;
  Point.y = v27;
  v68 = 0;
  if ( v27 )
  {
    v27->baseclass.m_hThemeHandle = 0;
    LOBYTE(v68) = 1;
    v27->baseclass.vtptr = &CResizer::`vftable';
    v27->m_OldWndProc = 0;
    v27->m_nXRatio = 50;
    v27->m_nYRatio = 67;
    v27->m_pItem = 0;
    v27->m_dwItemCount = 0;
    v27->m_FixedBorder = 1;
    if ( hDlg )
      CResizer::InitWnd(v27, hDlg);
  }
  else
  {
    v28 = 0;
  }
  v68 = -1;
  *&Point = 0.0;
  *&Rect.right = 0i64;
  v63 = 0;
  if ( gdwAdapterRuntingTime > 0 )
  {
    v29 = 2502;
    hMenu = 2502;
    v47 = 1.0 / v13;
    v49 = 1.0 / v58;
    do
    {
      v30 = GetDlgItem(hDlg, v29);
      v59 = v49 + *&Rect.right;
      v53 = v49 + *&Rect.right;
      if ( v49 + *&Rect.right >= 0.99999 )
        v53 = db_one;
      v31 = CResizer::AddItem(v28, v30, 1);
      v32 = hMenu;
      *&v31->m_rect2.left = *&Rect.right;
      *&v31->m_rect2.right = v53;
      v33 = GetDlgItem(hDlg, v32);
      v34 = v47 + *&Point;
      v51 = v47 + *&Point;
      v54 = v47 + *&Point;
      if ( v47 + *&Point >= 0.99999 )
        v54 = db_one;
      if ( v33 )
      {
        v35 = CResizer::AddItem(v28, v33, 1);
        *v35 = *&Point;
        v35[1] = v54;
        v34 = v51;
      }
      *&Point = v34;
      if ( !(++v63 % v13) )
      {
        *&Point = 0.0;
        *&Rect.right = v59;
      }
      v29 = hMenu + 2;
      hMenu = (hMenu + 2);
    }
    while ( v63 < gdwAdapterRuntingTime );
  }
  SendMessageW(hDlg, 0x464u, 0, 0);
  SetTimer(hDlg, 0, 0x3E8u, 0);
  return 1;
}
// 103C888: using guessed type void *CResizer::`vftable';
// 103CDC0: using guessed type double db_onehundred;
// 1064E28: using guessed type int gdwVirtualScreenWidth;
// 107BA1C: using guessed type int dword_107BA1C;

//----- (00FDF3E0) --------------------------------------------------------
signed int __cdecl sub_FDF3E0(int ThreadId, int a2, int a3)
{
  void *v3; // esi
  signed int result; // eax
  int v5; // [esp+4h] [ebp-10h]
  int v6; // [esp+8h] [ebp-Ch]
  int v7; // [esp+Ch] [ebp-8h]
  int v8; // [esp+10h] [ebp-4h]

  v5 = ThreadId;
  v6 = a2;
  v7 = a3;
  v3 = _beginthreadex(0, 0, sub_FDC090, &v5, 0, &ThreadId);
  if ( WaitForSingleObject(v3, 0x1388u) == 258 )
  {
    TerminateThread(v3, 1u);
    CloseHandle(v3);
    result = 32;
  }
  else
  {
    CloseHandle(v3);
    result = v8;
  }
  return result;
}

//----- (00FDF460) --------------------------------------------------------
char __cdecl sub_FDF460(_DWORD *a1)
{
  void *v1; // ecx
  SYSTEM_HANDLE_INFORMATION *v2; // eax
  unsigned int i; // esi
  void *pEntry; // [esp+0h] [ebp-4h]

  pEntry = v1;
  v2 = gpSystemHandleInfo2;
  if ( !gpSystemHandleInfo2 )
    return 0;
  for ( i = 0; v2 && i < v2->NumberOfHandles; ++i )
  {
    GetHandleTableEntry(v2, i, &pEntry);
    if ( *(pEntry + 1) == a1[9] && *(pEntry + 2) == a1[11] && *pEntry == a1[10] )
      return 1;
    v2 = gpSystemHandleInfo2;
  }
  return 0;
}

//----- (00FDF4D0) --------------------------------------------------------
int __cdecl sub_FDF4D0(int a1, SECURITY_INFORMATION SecurityInformation, PSECURITY_DESCRIPTOR SecurityDescriptor, PSECURITY_DESCRIPTOR pSecurityDescriptor, int a5)
{
  SECURITY_INFORMATION v5; // esi
  DWORD v6; // eax
  void *v7; // eax
  void *v8; // ebx
  signed int v10; // edi
  int v11; // esi
  bool v12; // al

  v5 = SecurityInformation;
  switch ( SecurityInformation )
  {
    case 1u:
      v6 = 0x80000;
      break;
    case 4u:
      v6 = 0x40000;
      break;
    case 8u:
      v6 = 0x1000000;
      break;
    default:
      v6 = SecurityInformation;
      break;
  }
  v7 = PE_DuplicateProcessHandle(*(a1 + 36), *(a1 + 44), v6);
  v8 = v7;
  if ( !v7 || !SetKernelObjectSecurity(v7, v5, SecurityDescriptor) )
    return 5;
  v10 = 5;
  if ( pSecurityDescriptor )
  {
    v11 = v5 | 3;
    if ( v11 == 1 )
      v11 = 5;
    v12 = GetKernelObjectSecurity(v8, v11, pSecurityDescriptor, 0x2000u, &SecurityInformation);
    *a5 = v12;
  }
  CloseHandle(v8);
  if ( !a5 )
    return 0;
  if ( *a5 )
    v10 = 0;
  return v10;
}

//----- (00FDF580) --------------------------------------------------------
int __stdcall Fake_GetProcessDEPPolicy(HANDLE hProcess, LPDWORD lpFlags, PBOOL lpPermanent)
{
  int (__stdcall *v3)(HANDLE, LPDWORD, PBOOL); // eax
  HMODULE v4; // eax

  v3 = GetProcessDEPPolicy;
  if ( GetProcessDEPPolicy )
    return v3(hProcess, lpFlags, lpPermanent);
  v4 = GetModuleHandleW(L"KERNEL32.DLL");
  v3 = GetProcAddress(v4, "GetProcessDEPPolicy");
  GetProcessDEPPolicy = v3;
  if ( v3 )
    return v3(hProcess, lpFlags, lpPermanent);
  SetLastError(ERROR_CALL_NOT_IMPLEMENTED);
  return 0;
}

//----- (00FDF5C0) --------------------------------------------------------
int __stdcall sub_FDF5C0(int a1, int a2, int a3, int a4)
{
  int (__stdcall *v4)(int, int, int, int); // eax
  HMODULE v5; // eax

  v4 = GetProcessMitigationPolicy;
  if ( GetProcessMitigationPolicy )
    return v4(a1, a2, a3, a4);
  v5 = GetModuleHandleW(L"KERNEL32.DLL");
  v4 = GetProcAddress(v5, "GetProcessMitigationPolicy");
  GetProcessMitigationPolicy = v4;
  if ( v4 )
    return v4(a1, a2, a3, a4);
  SetLastError(0x78u);
  return 0;
}

//----- (00FDF600) --------------------------------------------------------
char __cdecl sub_FDF600(_DWORD *a1, int a2, int a3, int a4)
{
  _DWORD *v4; // eax
  int v5; // ecx

  v4 = a1;
  if ( !a1 )
    return 0;
  while ( 1 )
  {
    if ( v4[10] == a2 && v4[146] == a4 )
    {
      v5 = v4[11];
      if ( v5 == a3 || v5 == 16777343 && !a3 )
        break;
      if ( !v5 && a3 == 16777343 )
        break;
    }
    v4 = v4[547];
    if ( !v4 )
      return 0;
  }
  return 1;
}

//----- (00FDF660) --------------------------------------------------------
int __thiscall sub_FDF660(int *this, HMODULE hModule, int a3)
{
  int *v3; // edi
  HRSRC v4; // eax
  unsigned __int16 *v5; // eax
  unsigned __int16 *v6; // ebx
  int v7; // eax
  int v8; // esi
  int result; // eax

  v3 = this;
  v4 = FindResourceW(hModule, ((a3 >> 4) + 1), 6);
  if ( !v4 )
    return 0;
  v5 = ATL::AtlGetStringResourceImage(hModule, v4, a3);
  v6 = v5;
  if ( !v5 )
    return 0;
  v7 = WideCharToMultiByte(3u, 0, v5 + 1, *v5, 0, 0, 0, 0);
  v8 = v7;
  if ( v7 < 0 )
    goto LABEL_12;
  if ( ((*(*v3 - 8) - v7) | (1 - *(*v3 - 4))) < 0 )
    sub_FE2330(v3, v7);
  WideCharToMultiByte(3u, 0, v6 + 1, *v6, *v3, v8, 0, 0);
  if ( v8 > *(*v3 - 8) )
LABEL_12:
    ATL::AtlThrowImpl(-2147024809);
  *(*v3 - 12) = v8;
  result = 1;
  *(v8 + *v3) = 0;
  return result;
}

//----- (00FDF720) --------------------------------------------------------
char LoadSystemApis()
{
  HMODULE v0; // eax
  HMODULE v2; // eax
  HMODULE v3; // eax
  HMODULE v4; // eax
  HMODULE v5; // eax
  HMODULE v6; // eax
  HMODULE v7; // eax
  HMODULE v8; // eax
  HMODULE v9; // eax
  HMODULE v10; // eax
  HMODULE v11; // eax
  HMODULE v12; // eax
  HMODULE v13; // eax
  HMODULE v14; // eax
  HMODULE v15; // eax
  HMODULE v16; // eax
  HMODULE v17; // eax
  HMODULE v18; // eax
  HMODULE v19; // eax
  HMODULE v20; // eax
  HMODULE v21; // eax
  HMODULE v22; // eax
  HMODULE v23; // eax
  HMODULE v24; // eax
  HMODULE v25; // eax
  HMODULE v26; // eax
  HMODULE v27; // eax
  HMODULE v28; // eax
  HMODULE v29; // eax
  HMODULE v30; // eax
  HMODULE v31; // eax
  HMODULE v32; // eax
  HMODULE v33; // eax
  HMODULE v34; // eax
  HMODULE v35; // eax
  HMODULE v36; // eax
  HMODULE v37; // eax
  HMODULE v38; // eax
  HMODULE v39; // eax
  HMODULE v40; // eax
  HMODULE v41; // eax
  HMODULE v42; // eax
  HMODULE v43; // eax
  HMODULE v44; // eax
  HMODULE v45; // eax
  HMODULE v46; // eax
  HMODULE v47; // eax
  HMODULE v48; // eax
  HMODULE v49; // eax
  HMODULE v50; // eax
  HMODULE v51; // eax
  HMODULE v52; // eax
  HMODULE v53; // eax
  HMODULE v54; // eax
  HMODULE v55; // eax
  HMODULE v56; // eax
  HMODULE hModule_1; // eax
  HMODULE v58; // eax
  HMODULE v59; // eax
  int (__stdcall *FindExecutableImage)(PCSTR, PCSTR, PSTR); // eax
  int (__stdcall *v61)(LPCWSTR, LPCWSTR, int); // ecx
  HMODULE v62; // eax
  HMODULE v63; // eax
  HMODULE v64; // eax
  HMODULE v65; // eax
  HMODULE v66; // eax
  HMODULE v67; // eax
  HMODULE v68; // eax
  HMODULE v69; // eax
  HMODULE v70; // eax
  HMODULE v71; // eax
  HMODULE v72; // eax
  HMODULE v73; // eax
  HMODULE v74; // eax
  HMODULE v75; // eax
  HKEY hKey; // [esp+8h] [ebp-218h]
  DWORD cbLength; // [esp+Ch] [ebp-214h]
  HMODULE hModule; // [esp+10h] [ebp-210h]
  WCHAR Text; // [esp+14h] [ebp-20Ch]

  InitTlhlpApis();
  v0 = GetModuleHandleW(L"ntdll.dll");
  NtQuerySystemInformation = GetProcAddress(v0, "NtQuerySystemInformation");
  if ( !NtQuerySystemInformation )
  {
    swprintf(
      &Text,
      L"Not able to run on this version of Windows:\nMissing function: %s",
      L"Ntdll!NtQuerySystemInformation");
LABEL_3:
    MessageBoxW(0, &Text, L"Process Explorer", 0x10u);
    return 0;
  }
  v2 = GetModuleHandleW(L"ntdll.dll");
  gpfn_NtQuerySymbolicLinkObject = GetProcAddress(v2, "NtQuerySymbolicLinkObject");
  if ( !gpfn_NtQuerySymbolicLinkObject )
  {
    swprintf(
      &Text,
      L"Not able to run on this version of Windows:\nMissing function: %s",
      L"Ntdll!NtQuerySymbolicLinkObject");
    goto LABEL_3;
  }
  v3 = GetModuleHandleW(L"ntdll.dll");
  NtQueryDirectoryObject = GetProcAddress(v3, "NtQueryDirectoryObject");
  if ( !NtQueryDirectoryObject )
  {
    swprintf(
      &Text,
      L"Not able to run on this version of Windows:\nMissing function: %s",
      L"Ntdll!NtQueryDirectoryObject");
    goto LABEL_3;
  }
  v4 = GetModuleHandleW(L"ntdll.dll");
  gpfn_NtOpenSymbolicLinkObject = GetProcAddress(v4, "NtOpenSymbolicLinkObject");
  if ( !gpfn_NtOpenSymbolicLinkObject )
    return ReportMsg(L"Ntdll!NtOpenSymbolicLinkObject");
  v5 = GetModuleHandleW(L"ntdll.dll");
  NtOpenDirectoryObject = GetProcAddress(v5, "NtOpenDirectoryObject");
  if ( !NtOpenDirectoryObject )
    return ReportMsg(L"Ntdll!NtOpenDirectoryObject");
  v6 = GetModuleHandleW(L"ntdll.dll");
  NtQueryObject = GetProcAddress(v6, "NtQueryObject");
  if ( !NtQueryObject )
    return ReportMsg(L"Ntdll!NtQueryObject");
  v7 = GetModuleHandleW(L"ntdll.dll");
  NtQueryInformationProcess = GetProcAddress(v7, "NtQueryInformationProcess");
  if ( !NtQueryInformationProcess )
    return ReportMsg(L"Ntdll!NtQueryInformationProcess");
  v8 = GetModuleHandleW(L"ntdll.dll");
  NtSetInformationProcess = GetProcAddress(v8, "NtSetInformationProcess");
  if ( !NtSetInformationProcess )
    return ReportMsg(L"Ntdll!NtSetInformationProcess");
  v9 = GetModuleHandleW(L"ntdll.dll");
  NtSetInformationProcess_0 = GetProcAddress(v9, "NtQuerySemaphore");
  if ( !NtSetInformationProcess_0 )
    return ReportMsg(L"Ntdll!NtQuerySemaphore");
  v10 = GetModuleHandleW(L"ntdll.dll");
  gpfn_NtOpenSymbolicLinkObject = GetProcAddress(v10, "NtOpenSymbolicLinkObject");
  if ( !gpfn_NtOpenSymbolicLinkObject )
    return ReportMsg(L"Ntdll!NtOpenSymbolicLinkObject");
  v11 = GetModuleHandleW(L"ntdll.dll");
  NtQuerySection = GetProcAddress(v11, "NtQuerySection");
  if ( !NtQuerySection )
    return ReportMsg(L"Ntdll!NtQuerySection");
  v12 = GetModuleHandleW(L"ntdll.dll");
  NtQueryEvent = GetProcAddress(v12, "NtQueryEvent");
  if ( !NtQueryEvent )
    return ReportMsg(L"Ntdll!NtQueryEvent");
  v13 = GetModuleHandleW(L"ntdll.dll");
  NtQueryMutant = GetProcAddress(v13, "NtQueryMutant");
  if ( !NtQueryMutant )
    return ReportMsg(L"Ntdll!NtQueryMutant");
  v14 = GetModuleHandleW(L"ntdll.dll");
  NtResumeThread = GetProcAddress(v14, "NtResumeThread");
  if ( !NtResumeThread )
    return ReportMsg(L"Ntdll!NtResumeThread");
  v15 = GetModuleHandleW(L"ntdll.dll");
  NtSuspendThread = GetProcAddress(v15, "NtSuspendThread");
  if ( !NtSuspendThread )
    return ReportMsg(L"Ntdll!NtSuspendThread");
  v16 = GetModuleHandleW(L"ntdll.dll");
  NtOpenThread = GetProcAddress(v16, "NtOpenThread");
  if ( !NtOpenThread )
    return ReportMsg(L"Ntdll!NtOpenThread");
  v17 = GetModuleHandleW(L"ntdll.dll");
  NtQueryInformationThread = GetProcAddress(v17, "NtQueryInformationThread");
  if ( !NtQueryInformationThread )
    return ReportMsg(L"Ntdll!NtQueryInformationThread");
  v18 = GetModuleHandleW(L"ntdll.dll");
  NtQueryVirtualMemory = GetProcAddress(v18, "NtQueryVirtualMemory");
  if ( !NtQueryVirtualMemory )
    return ReportMsg(L"Ntdll!NtQueryVirtualMemory");
  v19 = GetModuleHandleW(L"ntdll.dll");
  RtlCreateQueryDebugBuffer = GetProcAddress(v19, "RtlCreateQueryDebugBuffer");
  if ( !RtlCreateQueryDebugBuffer )
    return ReportMsg(L"Ntdll!RtlCreateQueryDebugBuffer");
  v20 = GetModuleHandleW(L"ntdll.dll");
  RtlQueryProcessDebugInformation = GetProcAddress(v20, "RtlQueryProcessDebugInformation");
  if ( !RtlQueryProcessDebugInformation )
    return ReportMsg(L"Ntdll!RtlQueryProcessDebugInformation");
  v21 = GetModuleHandleW(L"ntdll.dll");
  RtlDestroyQueryDebugBuffer = GetProcAddress(v21, "RtlDestroyQueryDebugBuffer");
  if ( !RtlDestroyQueryDebugBuffer )
    return ReportMsg(L"Ntdll!RtlDestroyQueryDebugBuffer");
  v22 = GetModuleHandleW(L"ntdll.dll");
  RtlTimeToTimeFields = GetProcAddress(v22, "RtlTimeToTimeFields");
  if ( !RtlTimeToTimeFields )
    return ReportMsg(L"Ntdll!RtlTimeToTimeFields");
  v23 = LoadLibraryW(L"aclui.dll");
  *CreateSecurityPage = GetProcAddress(v23, "CreateSecurityPage");
  if ( *CreateSecurityPage )
    goto LABEL_70;
  v24 = LoadLibraryW(L"acledit.dll");
  SedDiscretionaryAclEditor = GetProcAddress(v24, "SedDiscretionaryAclEditor");
  if ( !SedDiscretionaryAclEditor )
    return ReportMsg(L"Acledit!SedDiscretionaryAclEditor");
  v25 = GetModuleHandleW(L"acledit.dll");
  SedSystemAclEditor = GetProcAddress(v25, "SedSystemAclEditor");
  if ( !SedSystemAclEditor )
    return ReportMsg(L"Acledit!SedSystemAclEditor");
  v26 = GetModuleHandleW(L"acledit.dll");
  SedTakeOwnership = GetProcAddress(v26, "SedTakeOwnership");
  if ( !SedTakeOwnership )
    return ReportMsg(L"Acledit!SedTakeOwnership");
LABEL_70:
  v27 = LoadLibraryW(L"shcore.dll");
  GetProcessDpiAwareness = GetProcAddress(v27, "GetProcessDpiAwareness");
  v28 = LoadLibraryW(L"iphlpapi.dll");
  *GetTcpTable = GetProcAddress(v28, "GetTcpTable");
  v29 = LoadLibraryW(L"iphlpapi.dll");
  *GetUdpTable = GetProcAddress(v29, "GetUdpTable");
  v30 = LoadLibraryW(L"iphlpapi.dll");
  AllocateAndGetTcpExTableFromStack = GetProcAddress(v30, "AllocateAndGetTcpExTableFromStack");
  v31 = LoadLibraryW(L"iphlpapi.dll");
  AllocateAndGetUdpExTableFromStack = GetProcAddress(v31, "AllocateAndGetUdpExTableFromStack");
  v32 = LoadLibraryW(L"iphlpapi.dll");
  *GetExtendedTcpTable = GetProcAddress(v32, "GetExtendedTcpTable");
  v33 = LoadLibraryW(L"iphlpapi.dll");
  *GetExtendedUdpTable = GetProcAddress(v33, "GetExtendedUdpTable");
  v34 = LoadLibraryW(L"iphlpapi.dll");
  AllocateAndGetTcpExTable2FromStack = GetProcAddress(v34, "AllocateAndGetTcpExTable2FromStack");
  v35 = LoadLibraryW(L"iphlpapi.dll");
  AllocateAndGetUdpExTable2FromStack = GetProcAddress(v35, "AllocateAndGetUdpExTable2FromStack");
  v36 = LoadLibraryW(L"user32.dll");
  *GetGuiResources = GetProcAddress(v36, "GetGuiResources");
  v37 = LoadLibraryW(L"psapi.dll");
  *QueryWorkingSet = GetProcAddress(v37, "QueryWorkingSet");
  v38 = LoadLibraryW(L"psapi.dll");
  *GetMappedFileNameW = GetProcAddress(v38, "GetMappedFileNameW");
  v39 = LoadLibraryW(L"psapi.dll");
  *EnumProcessModulesEx = GetProcAddress(v39, "EnumProcessModulesEx");
  v40 = LoadLibraryW(L"kernel32.dll");
  GlobalMemoryStatusEx = GetProcAddress(v40, "GlobalMemoryStatusEx");
  v41 = LoadLibraryW(L"user32.dll");
  IsHungAppWindow = GetProcAddress(v41, "IsHungAppWindow");
  v42 = LoadLibraryW(L"user32.dll");
  HungWindowFromGhostWindow = GetProcAddress(v42, "HungWindowFromGhostWindow");
  v43 = LoadLibraryW(L"kernel32.dll");
  *GetLogicalProcessorInformation = GetProcAddress(v43, "GetLogicalProcessorInformation");
  v44 = LoadLibraryW(L"kernel32.dll");
  GetLogicalProcessorInformationEx = GetProcAddress(v44, "GetLogicalProcessorInformationEx");
  v45 = LoadLibraryW(L"kernel32.dll");
  SetThreadGroupAffinity = GetProcAddress(v45, "SetThreadGroupAffinity");
  v46 = LoadLibraryW(L"wtsapi32.dll");
  WTSEnumerateSessionsW = GetProcAddress(v46, "WTSEnumerateSessionsW");
  v47 = LoadLibraryW(L"wtsapi32.dll");
  WTSDisconnectSession = GetProcAddress(v47, "WTSDisconnectSession");
  v48 = LoadLibraryW(L"winsta.dll");
  WinStationConnectW = GetProcAddress(v48, "WinStationConnectW");
  v49 = LoadLibraryW(L"winsta.dll");
  WinStationShadow = GetProcAddress(v49, "WinStationShadow");
  v50 = LoadLibraryW(L"wtsapi32.dll");
  WTSLogoffSessio = GetProcAddress(v50, "WTSLogoffSession");
  v51 = LoadLibraryW(L"wtsapi32.dll");
  WTSSendMessageW = GetProcAddress(v51, "WTSSendMessageW");
  v52 = LoadLibraryW(L"wtsapi32.dll");
  WTSFreeMemory = GetProcAddress(v52, "WTSFreeMemory");
  v53 = LoadLibraryW(L"wtsapi32.dll");
  WTSQuerySessionInformationW = GetProcAddress(v53, "WTSQuerySessionInformationW");
  v54 = LoadLibraryW(L"kernel32.dll");
  *WTSGetActiveConsoleSessionId = GetProcAddress(v54, "WTSGetActiveConsoleSessionId");
  v55 = LoadLibraryW(L"user32.dll");
  *SetMenuInfo = GetProcAddress(v55, "SetMenuInfo");
  v56 = LoadLibraryW(L"user32.dll");
  *GetMenuInfo = GetProcAddress(v56, "GetMenuInfo");
  hModule_1 = LoadLibraryW(gConfig.strDbgHelpModuleName);
  hModule = hModule_1;
  if ( !hModule_1 )
  {
    if ( RegOpenKeyW(HKEY_CURRENT_USER, L"Software\\Microsoft\\DebuggingTools", &hKey) )
      goto __directLoad;
    cbLength = 520;
    RegQueryValueExW(hKey, L"Windbg", 0, 0, gConfig.strDbgHelpModuleName, &cbLength);
    wcscat_s(gConfig.strDbgHelpModuleName, MAX_PATH, L"DbgHelp.dll");
    hModule_1 = LoadLibraryW(gConfig.strDbgHelpModuleName);
    hModule = hModule_1;
    if ( !hModule_1 )
    {
      wcscpy_s(gConfig.strDbgHelpModuleName, MAX_PATH, L"C:\\Debuggers\\dbghelp.dll");
      hModule_1 = LoadLibraryW(gConfig.strDbgHelpModuleName);
      hModule = hModule_1;
      if ( !hModule_1 )
      {
        ExpandEnvironmentStringsW(
          L"%ProgramFiles%\\Debugging Tools for Windows (x86)\\dbghelp.dll",
          gConfig.strDbgHelpModuleName,
          MAX_PATH);
        hModule_1 = LoadLibraryW(gConfig.strDbgHelpModuleName);
        hModule = hModule_1;
        if ( !hModule_1 )
        {
          GetCurrentDirectoryW(MAX_PATH, gConfig.strDbgHelpModuleName);
          wcscat_s(gConfig.strDbgHelpModuleName, MAX_PATH, L"\\dbghelp.dll");
          hModule_1 = LoadLibraryW(gConfig.strDbgHelpModuleName);
          hModule = hModule_1;
          if ( !hModule_1 )
          {
__directLoad:
            hModule_1 = LoadLibraryW(L"dbghelp.dll");
            hModule = hModule_1;
            if ( !hModule_1 )
            {
              hModule_1 = LoadLibraryW(L"imagehlp.dll");
              hModule = hModule_1;
            }
          }
        }
      }
    }
  }
  GetModuleFileNameW(hModule_1, gConfig.strDbgHelpModuleName, MAX_PATH);
  LoadDbgHelp(gConfig.strDbgHelpModuleName);
  if ( !*ImageNtHeader )
  {
    v58 = LoadLibraryW(L"imagehlp.dll");
    *ImageNtHeader = GetProcAddress(v58, "ImageNtHeader");
  }
  *FindExecutableImageExW = GetProcAddress(hModule, "FindExecutableImageExW");
  if ( *FindExecutableImageExW )
  {
    *FindExecutableImageExW_0 = FindExecutableImageExW_1;
  }
  else
  {
    v59 = LoadLibraryW(L"imagehlp.dll");
    FindExecutableImage = GetProcAddress(v59, "FindExecutableImage");
    v61 = 0;
    ::FindExecutableImage = FindExecutableImage;
    if ( FindExecutableImage )
      v61 = sub_FDBC50;
    *FindExecutableImageExW_0 = v61;
  }
  v62 = GetModuleHandleW(L"ntdll.dll");
  NtSuspendProcess = GetProcAddress(v62, "NtSuspendProcess");
  v63 = GetModuleHandleW(L"ntdll.dll");
  NtResumeProcess = GetProcAddress(v63, "NtResumeProcess");
  v64 = GetModuleHandleW(L"kernel32.dll");
  QueryProcessCycleTime = GetProcAddress(v64, "QueryProcessCycleTime");
  v65 = GetModuleHandleW(L"kernel32.dll");
  QueryIdleProcessorCycleTime = GetProcAddress(v65, "QueryIdleProcessorCycleTime");
  v66 = GetModuleHandleW(L"kernel32.dll");
  QueryThreadCycleTime = GetProcAddress(v66, "QueryThreadCycleTime");
  v67 = GetModuleHandleW(L"Shell32.dll");
  SHGetStockIconInfo = GetProcAddress(v67, "SHGetStockIconInfo");
  v68 = GetModuleHandleW(L"kernel32.dll");
  *CreateJobObjectW = GetProcAddress(v68, "CreateJobObjectW");
  v69 = GetModuleHandleW(L"user32.dll");
  ChangeWindowMessageFilter = GetProcAddress(v69, "ChangeWindowMessageFilter");
  v70 = LoadLibraryW(L"advapi32.dll");
  I_QueryTagInformation = GetProcAddress(v70, "I_QueryTagInformation");
  v71 = LoadLibraryW(L"wow64cpu");
  CpuGetContext = GetProcAddress(v71, "CpuGetContext");
  v72 = LoadLibraryW(L"kernel32.dll");
  GetProcessorSystemCycleTime = GetProcAddress(v72, "GetProcessorSystemCycleTime");
  v73 = LoadLibraryW(L"kernel32.dll");
  GetThreadIdealProcessorEx = GetProcAddress(v73, "GetThreadIdealProcessorEx");
  v74 = LoadLibraryW(L"user32.dll");
  IsImmersiveProcess = GetProcAddress(v74, "IsImmersiveProcess");
  v75 = LoadLibraryW(L"kernel32.dll");
  GetPackageFullName = GetProcAddress(v75, "GetPackageFullName");
  return 1;
}
// 1043420: using guessed type wchar_t aNtdllNtquerysy[31];
// 1043480: using guessed type wchar_t aNtdllNtquerysy_0[32];
// 10434D8: using guessed type wchar_t aNtdllNtquerydi[29];
// 1043530: using guessed type wchar_t aNtdllNtopensym[31];
// 1043588: using guessed type wchar_t aNtdllNtopendir[28];
// 10435D0: using guessed type wchar_t aNtdllNtqueryob[20];
// 1043618: using guessed type wchar_t aNtdllNtqueryin[32];
// 1043670: using guessed type wchar_t aNtdllNtsetinfo[30];
// 10436C0: using guessed type wchar_t aNtdllNtqueryse[23];
// 1043700: using guessed type wchar_t aNtdllNtqueryse_0[21];
// 104373C: using guessed type wchar_t aNtdllNtqueryev[19];
// 1043774: using guessed type wchar_t aNtdllNtquerymu[20];
// 10437AC: using guessed type wchar_t aNtdllNtresumet[21];
// 10437E8: using guessed type wchar_t aNtdllNtsuspend[22];
// 1043824: using guessed type wchar_t aNtdllNtopenthr[19];
// 1043868: using guessed type wchar_t aNtdllNtqueryin_0[31];
// 10438C0: using guessed type wchar_t aNtdllNtqueryvi[27];
// 1043918: using guessed type wchar_t aNtdllRtlcreate[32];
// 1043978: using guessed type wchar_t aNtdllRtlqueryp[38];
// 10439E0: using guessed type wchar_t aNtdllRtldestro[33];
// 1043A38: using guessed type wchar_t aNtdllRtltimeto[26];
// 1043AC8: using guessed type wchar_t aAcleditSeddisc[34];
// 1043B20: using guessed type wchar_t aAcleditSedsyst[27];
// 1043B6C: using guessed type wchar_t aAcleditSedtake[25];
// 106B1C8: using guessed type int (__stdcall *NtSetInformationProcess)(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 106F214: using guessed type int NtOpenDirectoryObject;
// 106F220: using guessed type int RtlTimeToTimeFields;
// 106F224: using guessed type int NtQueryDirectoryObject;
// 106F228: using guessed type int (__stdcall *NtSetInformationProcess_0)(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 106F230: using guessed type int (__stdcall *NtQueryEvent)(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 106F234: using guessed type int (__stdcall *NtQueryMutant)(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 106F258: using guessed type int (__stdcall *GetThreadIdealProcessorEx)(_DWORD, _DWORD);
// 106F260: using guessed type int (__stdcall *RtlQueryProcessDebugInformation)(_DWORD, _DWORD, _DWORD);
// 106F264: using guessed type int (__stdcall *RtlDestroyQueryDebugBuffer)(_DWORD);
// 106F2E8: using guessed type int (__stdcall *GlobalMemoryStatusEx)(_DWORD);
// 106F2F4: using guessed type int GetProcessorSystemCycleTime;
// 106F328: using guessed type int (__stdcall *GetLogicalProcessorInformationEx)(_DWORD, _DWORD, _DWORD);
// 106F32C: using guessed type int SetThreadGroupAffinity;
// 106F334: using guessed type int (__stdcall *WTSDisconnectSession)(_DWORD, _DWORD, _DWORD);
// 106F338: using guessed type int (__stdcall *WinStationConnectW)(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 106F33C: using guessed type int (__stdcall *WinStationShadow)(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 106F34C: using guessed type int (__stdcall *WTSLogoffSessio)(_DWORD, _DWORD, _DWORD);
// 106F350: using guessed type int (__stdcall *WTSSendMessageW)(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 106F360: using guessed type int (__stdcall *ChangeWindowMessageFilter)(_DWORD, _DWORD);
// 106F364: using guessed type int CpuGetContext;
// 106F36C: using guessed type int (__stdcall *GetProcessDpiAwareness)(_DWORD, _DWORD);
// 107BA4C: using guessed type int (__stdcall *IsImmersiveProcess)(_DWORD);
// 107BA50: using guessed type int (__stdcall *SHGetStockIconInfo)(_DWORD, _DWORD, _DWORD);

//----- (00FE01B0) --------------------------------------------------------
char InitTlhlpApis()
{
  HMODULE v0; // eax
  HMODULE v2; // eax
  HMODULE v3; // eax
  HMODULE v4; // eax
  HMODULE v5; // eax
  HMODULE v6; // eax
  HMODULE v7; // eax
  HMODULE v8; // eax
  HMODULE v9; // eax
  HMODULE v10; // eax

  v0 = GetModuleHandleW(L"kernel32.dll");
  *CreateToolhelp32Snapshot_0 = GetProcAddress(v0, "CreateToolhelp32Snapshot");
  if ( !*CreateToolhelp32Snapshot_0 )
    return 0;
  v2 = GetModuleHandleW(L"kernel32.dll");
  *Process32FirstW_0 = GetProcAddress(v2, "Process32FirstW");
  if ( !*Process32FirstW_0 )
    return 0;
  v3 = GetModuleHandleW(L"kernel32.dll");
  *Process32NextW_0 = GetProcAddress(v3, "Process32NextW");
  if ( !*Process32NextW_0 )
    return 0;
  v4 = GetModuleHandleW(L"kernel32.dll");
  *Thread32First_0 = GetProcAddress(v4, "Thread32First");
  if ( !*Thread32First_0 )
    return 0;
  v5 = GetModuleHandleW(L"kernel32.dll");
  *Thread32Next_0 = GetProcAddress(v5, "Thread32Next");
  if ( !*Thread32Next_0 )
    return 0;
  v6 = GetModuleHandleW(L"kernel32.dll");
  *Module32FirstW_0 = GetProcAddress(v6, "Module32FirstW");
  if ( !*Module32FirstW_0 )
    return 0;
  v7 = GetModuleHandleW(L"kernel32.dll");
  *Module32NextW_0 = GetProcAddress(v7, "Module32NextW");
  if ( !*Module32NextW_0 )
    return 0;
  v8 = LoadLibraryW(L"dbghelp.dll");
  *ImageNtHeader = GetProcAddress(v8, "ImageNtHeader");
  if ( !*ImageNtHeader )
  {
    v9 = LoadLibraryW(L"imagehlp.dll");
    *ImageNtHeader = GetProcAddress(v9, "ImageNtHeader");
  }
  v10 = LoadLibraryW(L"user32.dll");
  IsHungThread = GetProcAddress(v10, "IsHungThread");
  return 1;
}
// 106F320: using guessed type int IsHungThread;

//----- (00FE02C0) --------------------------------------------------------
void __cdecl QueryProcessArguments(HANDLE hProcess, ULONG_PTR dwProcessId, WCHAR **ppszCommandLine, WCHAR **ppszCurrentDirectory, WCHAR **ppszEnvBlock, PDWORD pbFlagsInExtendedProcessBasicInfo)
{
  PDWORD pdwValue6In; // eax
  WCHAR **ppszCommandLineIn; // edi
  WCHAR **ppszCurrentDirectoryIn; // esi
  WCHAR **ppszEnvBlockIn; // ebx
  WCHAR *v10; // eax
  _PROCESS_EXTENDED_BASIC_INFORMATION ProcessInformation; // [esp+0h] [ebp-20h]

  pdwValue6In = pbFlagsInExtendedProcessBasicInfo;
  ProcessInformation.Size = 0;
  *&ProcessInformation.BasicInfo.UniqueProcessId = 0i64;
  ProcessInformation.Flags = 0;
  _mm_storeu_si128(&ProcessInformation.BasicInfo, 0i64);
  if ( pdwValue6In )
    *pdwValue6In = 0;
  ppszCommandLineIn = ppszCommandLine;
  if ( ppszCommandLine )
    *ppszCommandLine = 0;
  ppszCurrentDirectoryIn = ppszCurrentDirectory;
  if ( ppszCurrentDirectory )
    *ppszCurrentDirectory = 0;
  ppszEnvBlockIn = ppszEnvBlock;
  if ( ppszEnvBlock )
    *ppszEnvBlock = 0;
  if ( hProcess )
  {
    ProcessInformation.Size = 0x20;
    if ( !NtQueryInformationProcess(
            hProcess,
            ProcessBasicInformation,
            &ProcessInformation,
            sizeof(_PROCESS_EXTENDED_BASIC_INFORMATION),
            &ppszCommandLine)
      || !NtQueryInformationProcess(
            hProcess,
            ProcessBasicInformation,
            &ProcessInformation.BasicInfo,
            sizeof(PROCESS_BASIC_INFORMATION),
            &ppszCommandLine) )
    {
      if ( pbFlagsInExtendedProcessBasicInfo )
        *pbFlagsInExtendedProcessBasicInfo = ProcessInformation.Flags & 1;
      if ( ProcessInformation.BasicInfo.PebBaseAddress )
        QueryProcessCommandLineArgs(
          hProcess,
          ProcessInformation.BasicInfo.PebBaseAddress,
          ppszCommandLineIn,
          ppszCurrentDirectoryIn,
          ppszEnvBlockIn);
      if ( ppszCurrentDirectoryIn )
      {
        if ( *ppszCurrentDirectoryIn )
          PE_GetFullPathName(ppszCurrentDirectoryIn);
        else
          *ppszCurrentDirectoryIn = _wcsdup(&gszNullString);
      }
      if ( ppszCommandLineIn && !*ppszCommandLineIn )
        *ppszCommandLineIn = _wcsdup(&gszNullString);
      if ( ppszEnvBlockIn )
      {
        if ( !*ppszEnvBlockIn )
        {
          v10 = _wcsdup(L" ");
          *ppszEnvBlockIn = v10;
          *v10 = 0;
        }
      }
    }
  }
}

//----- (00FE03E0) --------------------------------------------------------
char __cdecl QueryProcessImageBase(HANDLE hProcess, DWORD dwPid, LPCWSTR lpszProcessName, LPVOID *ppBufer, PDWORD pdwSize)
{
  HANDLE v5; // ebx
  HANDLE hFound; // ebx
  const wchar_t *v7; // eax
  WCHAR *v8; // edi
  DWORD v9; // eax
  DWORD v10; // ebx
  SIZE_T v12; // edi
  WCHAR *v13; // esi
  void *v14; // edi
  int v15; // ebx
  IAtlStringMgr *v16; // eax
  volatile signed __int32 *v17; // edi
  struct _MEMORY_BASIC_INFORMATION Buffer; // [esp+10h] [ebp-474h]
  WCHAR *v19; // [esp+2Ch] [ebp-458h]
  PDWORD pdwLength; // [esp+30h] [ebp-454h]
  WCHAR *v21; // [esp+34h] [ebp-450h]
  wchar_t *v22; // [esp+38h] [ebp-44Ch]
  LPVOID *ppBuf; // [esp+3Ch] [ebp-448h]
  wchar_t *v24; // [esp+40h] [ebp-444h]
  size_t SizeInWords; // [esp+44h] [ebp-440h]
  HANDLE v26; // [esp+48h] [ebp-43Ch]
  MODULEENTRY32W me; // [esp+4Ch] [ebp-438h]
  int v28; // [esp+480h] [ebp-4h]

  v5 = hProcess;
  v22 = lpszProcessName;
  ppBuf = ppBufer;
  pdwLength = pdwSize;
  v26 = hProcess;
  v24 = dwPid;
  if ( *CreateToolhelp32Snapshot_0 )
  {
    hFound = CreateToolhelp32Snapshot_0(TH32CS_SNAPMODULE, dwPid);
    v26 = hFound;
    if ( hFound != -1 )
    {
      me.dwSize = sizeof(MODULEENTRY32W);
      if ( Module32FirstW_0(hFound, &me) )
      {
        do
        {
          v28 = 0;
          if ( !wcsncmp(me.szExePath, L"\\??\\", 4u) )
          {
            v7 = &me.szExePath[4];
          }
          else
          {
            if ( !_wcsnicmp(me.szExePath, L"\\Systemroot\\", 0xCu) )
            {
              SizeInWords = ExpandEnvironmentStringsW(L"%SystemRoot%", 0, 0) + 1 + wcslen(me.szExePath);
              v8 = malloc(2 * SizeInWords);
              v21 = v8;
              ExpandEnvironmentStringsW(L"%SystemRoot%", v8, SizeInWords);
              wcscat_s(v8, SizeInWords, &me.szExePath[11]);
              goto LABEL_10;
            }
            v7 = me.szExePath;
          }
          v8 = _wcsdup(v7);
          v21 = v8;
LABEL_10:
          if ( *GetLongPathNameW )
          {
            v9 = GetLongPathNameW(v8, 0, 0);
            v10 = v9;
            if ( v9 )
            {
              v19 = malloc(2 * v9 + 2);
              LOBYTE(v28) = 1;
              GetLongPathNameW(v8, v19, v10 + 1);
              free(v8);
              v8 = v19;
              LOBYTE(v28) = 0;
              j__free(0);
            }
            hFound = v26;
          }
          if ( me.th32ProcessID == v24 && !_wcsicmp(v22, v8) )
          {
            *ppBuf = me.modBaseAddr;
            *pdwLength = me.modBaseSize;
            j__free(v8);
            return 1;
          }
          v28 = -1;
          j__free(v8);
        }
        while ( Module32NextW_0(hFound, &me) );
      }
      CloseHandle(hFound);
    }
    return 0;
  }
  Buffer.BaseAddress = 0;
  if ( !VirtualQueryEx(hProcess, 0, &Buffer, 0x1Cu) )
    return 0;
  while ( 1 )
  {
    if ( Buffer.Type != 0x40000
      || NtQueryVirtualMemory(v5, Buffer.BaseAddress, MemoryMappedFilenameInformation, 0, 0, &SizeInWords) != STATUS_INFO_LENGTH_MISMATCH )
    {
      goto LABEL_30;
    }
    v12 = SizeInWords;
    v13 = malloc(SizeInWords);
    v19 = v13;
    v28 = 2;
    if ( !NtQueryVirtualMemory(v5, Buffer.BaseAddress, MemoryMappedFilenameInformation, v13, v12, &SizeInWords) )
      break;
LABEL_29:
    v28 = -1;
    j__free(v13);
LABEL_30:
    Buffer.BaseAddress = Buffer.BaseAddress + Buffer.RegionSize;
    if ( !VirtualQueryEx(v5, Buffer.BaseAddress, &Buffer, 0x1Cu) )
      return 0;
  }
  v14 = *(v13 + 1);
  v15 = *v13 >> 1;
  v16 = ATL::StrTraitATL<wchar_t,ATL::ChTraitsCRT<wchar_t>>::GetDefaultManager();
  sub_FACF80(&v24, v14, v15, v16);
  v17 = (v24 - 8);
  if ( _wcsicmp(v24, v22) )
  {
    if ( _InterlockedDecrement(v17 + 3) <= 0 )
      (*(**v17 + 4))(v17);
    v5 = v26;
    goto LABEL_29;
  }
  *ppBuf = Buffer.BaseAddress;
  *pdwLength = Buffer.RegionSize;
  if ( _InterlockedDecrement(v17 + 3) <= 0 )
    (*(**v17 + 4))(v17);
  j__free(v13);
  return 1;
}

//----- (00FE07B0) --------------------------------------------------------
DWORD __cdecl LoadSystemModulesSymbolAddress(LPCWSTR lpszName)
{
  RTL_PROCESS_MODULES *ProcessModules; // edi
  ULONG v2; // esi
  ULONG Index; // esi
  const CHAR *v4; // ebx
  const wchar_t **v5; // eax
  CStringData *v6; // eax
  int BaseOfDll_1; // ebx
  HANDLE hFile; // edi
  HANDLE v9; // eax
  DWORD result; // eax
  HANDLE hProcess; // eax
  __int64 v12; // rax
  HANDLE v13; // eax
  const CHAR *Name_1; // ST1C_4
  HANDLE hProcess_1; // eax
  int v16; // eax
  HANDLE v17; // eax
  struct _MODLOAD_DATA *Data; // [esp-Ch] [ebp-740h]
  DWORD Flags; // [esp-8h] [ebp-73Ch]
  CStringData *v20; // [esp+0h] [ebp-734h]
  CString strFullPathName; // [esp+4h] [ebp-730h]
  PCSTR Name; // [esp+8h] [ebp-72Ch]
  DWORD64 BaseOfDll; // [esp+Ch] [ebp-728h]
  WCHAR szDir[260]; // [esp+14h] [ebp-720h]
  WCHAR FileName[260]; // [esp+21Ch] [ebp-518h]
  wchar_t ImageName[260]; // [esp+424h] [ebp-310h]
  IMAGEHLP_SYMBOL Symbol; // [esp+62Ch] [ebp-108h]

  Name = lpszName;
  if ( !SymCleanup || !SymInitialize || !SymLoadModuleExW_1 || !SymGetSymFromName )
    return 0;
  HIDWORD(BaseOfDll) = 1000;
  ProcessModules = malloc(0x3E8u);
  if ( NtQuerySystemInformation(SystemModuleInformation, ProcessModules, 0x3E8u, &BaseOfDll + 1) )
  {
    do
    {
      HIDWORD(BaseOfDll) += 1000;
      free(ProcessModules);
      v2 = HIDWORD(BaseOfDll);
      ProcessModules = malloc(HIDWORD(BaseOfDll));
    }
    while ( NtQuerySystemInformation(SystemModuleInformation, ProcessModules, v2, &BaseOfDll + 1) );
  }
  if ( IsPAEEnabled() )
    wcscpy_s(ImageName, MAX_PATH, L"ntkrnlpa.exe");
  else
    wcscpy_s(ImageName, MAX_PATH, L"ntoskrnl.exe");
  Index = 0;
  if ( ProcessModules->NumberOfModules )
  {
    v4 = ProcessModules->Modules[0].FullPathName;
    while ( 1 )
    {
      v5 = ATL::CStringT<wchar_t,ATL::StrTraitATL<wchar_t,ATL::ChTraitsCRT<wchar_t>>>::CStringT<wchar_t,ATL::StrTraitATL<wchar_t,ATL::ChTraitsCRT<wchar_t>>>(
             &strFullPathName,
             v4);
      LODWORD(BaseOfDll) = wcsstr(*v5, ImageName);
      v6 = (strFullPathName.pszData - 16);
      v20 = (strFullPathName.pszData - 16);
      if ( _InterlockedDecrement(strFullPathName.pszData - 1) <= 0 )
        (v6->pStringMgr->vtptr->Free)(v20);
      if ( BaseOfDll )
        break;
      ++Index;
      v4 += sizeof(RTL_PROCESS_MODULE_INFORMATION);
      if ( Index >= ProcessModules->NumberOfModules )
        goto LABEL_16;
    }
    BaseOfDll_1 = ProcessModules->Modules[Index].ImageBase;
  }
  else
  {
LABEL_16:
    BaseOfDll_1 = BaseOfDll;
  }
  free(ProcessModules);
  GetSystemDirectoryW(szDir, MAX_PATH);
  swprintf(FileName, L"%s\\%s", szDir, ImageName);
  hFile = CreateFileW(FileName, GENERIC_READ, 3u, 0, OPEN_EXISTING, 0, 0);
  EnterCriticalSection(&gProcThreadsLock);
  v9 = GetCurrentThread();
  if ( SymInitialize(v9, 0, 0) )
  {
    hProcess = GetCurrentThread();
    LODWORD(v12) = SymLoadModuleExW_1(hProcess, hFile, ImageName, 0, BaseOfDll_1, 0, Data, Flags);
    if ( v12 )
    {
      Symbol.SizeOfStruct = sizeof(IMAGEHLP_SYMBOL);
      Name_1 = Name;
      Symbol.MaxNameLength = 237;
      hProcess_1 = GetCurrentThread();
      v16 = SymGetSymFromName(hProcess_1, Name_1, &Symbol);
      Symbol.Address &= -(v16 != 0);
      CloseHandle(hFile);
      v17 = GetCurrentThread();
      SymCleanup(v17);
      LeaveCriticalSection(&gProcThreadsLock);
      result = Symbol.Address;
    }
    else
    {
      CloseHandle(hFile);
      v13 = GetCurrentThread();
      SymCleanup(v13);
      LeaveCriticalSection(&gProcThreadsLock);
      result = 0;
    }
  }
  else
  {
    LeaveCriticalSection(&gProcThreadsLock);
    CloseHandle(hFile);
    result = 0;
  }
  return result;
}
// 10456FC: using guessed type wchar_t aNtkrnlpaExe[13];
// FE09BE: user specified stroff has not been processed: RTL_PROCESS_MODULE_INFORMATION offset 284

//----- (00FE0A90) --------------------------------------------------------
char __cdecl sub_FE0A90(HANDLE hProcess, DWORD dwProcessId, LPWSTR *ppszFileName, tagTREEVIEWLISTITEMPARAM *pItem)
{
  DWORD dwIndex; // eax
  WCHAR **v5; // ecx
  SC_HANDLE hService; // ebx
  DWORD v8; // esi
  wchar_t *pstr; // eax
  LPWSTR v10; // eax
  LPWSTR v11; // ecx
  int v12; // edx
  WCHAR v13; // ax
  rsize_t v14; // edi
  wchar_t *v15; // eax
  const wchar_t **v16; // esi
  DWORD v17; // eax
  DWORD v18; // edi
  WCHAR *v19; // eax
  DWORD v20; // eax
  DWORD v21; // esi
  WCHAR *v22; // eax
  LPWSTR v23; // ecx
  WCHAR v24; // ax
  struct _QUERY_SERVICE_CONFIGW *pServiceConfig; // [esp+Ch] [ebp-21Ch]
  LPWSTR *ppszFileNameIn; // [esp+14h] [ebp-214h]
  DWORD dwRet; // [esp+18h] [ebp-210h]
  __int16 Src[260]; // [esp+1Ch] [ebp-20Ch]

  ppszFileNameIn = ppszFileName;
  *ppszFileName = 0;
  if ( !hProcess )
  {
    if ( pItem->dwStyle & TVLS_SHOWSERVICE )
    {
      dwIndex = 0;
      if ( gdwServiceReturned )
      {
        v5 = gpszServiceNames + 9;
        while ( *v5 != dwProcessId )
        {
          ++dwIndex;
          v5 += 11;
          if ( dwIndex >= gdwServiceReturned )
            return 0;
        }
        hService = OpenServiceW(ghSCManagerHandle, gpszServiceNames[11 * dwIndex], 5u);
        QueryServiceConfigW(hService, 0, 0, &dwRet);
        v8 = dwRet;
        pServiceConfig = malloc(dwRet);
        QueryServiceConfigW(hService, pServiceConfig, v8, &dwRet);
        if ( pServiceConfig->lpBinaryPathName )
        {
          if ( !pItem->pszCommandLine )
            pItem->pszCommandLine = _wcsdup(pServiceConfig->lpBinaryPathName);
          pstr = wcsstr(pServiceConfig->lpBinaryPathName, L".exe");
          if ( pstr && pstr[4] )
            pstr[4] = 0;
          v10 = pServiceConfig->lpBinaryPathName;
          if ( *v10 == '"' )
            pServiceConfig->lpBinaryPathName = v10 + 1;
          v11 = pServiceConfig->lpBinaryPathName;
          v12 = (v11 + 1);
          do
          {
            v13 = *v11;
            ++v11;
          }
          while ( v13 );
          v14 = ((v11 - v12) >> 1) + 5;
          v15 = malloc(2 * v14);
          v16 = ppszFileNameIn;
          *ppszFileNameIn = v15;
          wcscpy_s(v15, v14, pServiceConfig->lpBinaryPathName);
          free(pServiceConfig);
          if ( GetFileAttributesW(*v16) == -1 )
          {
            if ( **v16 != 34 && wcschr(*v16, ' ') )
              *wcschr(*v16, ' ') = 0;
            if ( GetFileAttributesW(*v16) == -1 )
              wcscat_s(*v16, v14, L".exe");
          }
          return 1;
        }
        free(pServiceConfig);
      }
    }
    return 0;
  }
  if ( !sub_FDCF30(hProcess, ppszFileName) )
  {
    v17 = GetModuleFileNameExW(hProcess, 0, &ppszFileNameIn, 2u);
    v18 = v17;
    if ( !v17 )
      return 0;
    v19 = malloc(2 * v17 + 2);
    *ppszFileName = v19;
    if ( !GetModuleFileNameExW(hProcess, 0, v19, v18) )
      return 0;
  }
  if ( !_wcsnicmp(*ppszFileName, L"\\SystemRoot\\", 0xCu) )
  {
    swprintf(Src, L"%%SystemRoot%%\\%s", *ppszFileName + 12);
    v20 = ExpandEnvironmentStringsW(Src, 0, 0);
    v21 = v20;
    v22 = malloc(2 * v20);
    *ppszFileName = v22;
    ExpandEnvironmentStringsW(Src, v22, v21);
    return 1;
  }
  if ( !wcsncmp(*ppszFileName, L"\\??\\", 4u) )
  {
    v23 = *ppszFileName;
    do
    {
      v24 = *v23;
      ++v23;
    }
    while ( v24 );
    wcscpy_s(*ppszFileName, v23 - (*ppszFileName + 1), *ppszFileName + 4);
  }
  return 1;
}

//----- (00FE0D70) --------------------------------------------------------
int __cdecl sub_FE0D70(wchar_t *a1)
{
  int v1; // esi
  int result; // eax

  EnterCriticalSection(&gProcThreadsLock);
  v1 = dword_106B1DC;
  if ( dword_106B1DC )
  {
    while ( _wcsicmp(*v1, a1) )
    {
      v1 = *(v1 + 12);
      if ( !v1 )
        goto LABEL_4;
    }
    LeaveCriticalSection(&gProcThreadsLock);
    result = v1;
  }
  else
  {
LABEL_4:
    LeaveCriticalSection(&gProcThreadsLock);
    result = 0;
  }
  return result;
}
// 106B1DC: using guessed type int dword_106B1DC;

//----- (00FE0DD0) --------------------------------------------------------
void __cdecl sub_FE0DD0(wchar_t *a1)
{
  int v1; // edi
  wchar_t *v2; // ebx
  WCHAR *v3; // ecx
  size_t v4; // esi
  int v5; // edx
  unsigned int v6; // ecx
  WCHAR *v7; // esi
  WCHAR v8; // ax
  int v9; // esi
  WCHAR *v10; // edx
  int v11; // esi
  int v12; // edi
  WCHAR v13; // ax

  v1 = 0;
  if ( gszDriverLinkName[0] )
  {
    v2 = a1;
    v3 = gszDriverLinkName;
    while ( 1 )
    {
      v4 = wcslen(v3);
      if ( !_wcsnicmp(v3, v2, v4) && v2[v4] == 92 )
        break;
      v3 = &gszDriverLinkName[257 * ++v1];
      if ( !gszDriverLinkName[257 * v1] )
        return;
    }
    v5 = 257 * v1;
    *v2 = gszDriverName[0][257 * v1];
    v2[1] = 58;
    v6 = wcslen(v2);
    v7 = &gszDriverLinkName[257 * v1 + 1];
    do
    {
      v8 = *v7;
      ++v7;
    }
    while ( v8 );
    v9 = v7 - &gszDriverLinkName[v5 + 2];
    v10 = &gszDriverLinkName[v5];
    v11 = v9 >> 1;
    v12 = (v10 + 1);
    do
    {
      v13 = *v10;
      ++v10;
    }
    while ( v13 );
    memmove_0(v2 + 2, &v2[(v10 - v12) >> 1], 2 * (v6 - v11));
    sub_FDC270(&a1, 0x104u);
  }
}

//----- (00FE0EE0) --------------------------------------------------------
int __cdecl sub_FE0EE0(wchar_t *pszBuffer)
{
  int nIndex; // ebx
  size_t *pszPosition; // esi
  int v3; // ebx
  RegItem *v4; // esi
  int result; // eax
  int ret; // eax
  char found; // cl
  wchar_t *pszText; // esi
  wchar_t i; // ax
  const wchar_t *v10; // esi
  char found_1; // [esp+Ch] [ebp-Ch]

  nIndex = 0;
  pszPosition = &stru_1060320[0].field_240;
  do
  {
    if ( !_wcsnicmp(pszBuffer, pszPosition - 288, *pszPosition)
      && !_wcsnicmp(&pszBuffer[*pszPosition], gpszCurAuthInfo, wcslen(gpszCurAuthInfo)) )
    {
      ret = _wcsnicmp(&pszBuffer[wcslen(gpszCurAuthInfo) + stru_1060320[nIndex].field_240], L"_Classes", 8u);
      found = 0;
      if ( !ret )
        found = 1;
      found_1 = found;
      pszText = &pszBuffer[stru_1060320[nIndex].field_240];
      for ( i = *pszText; i; ++pszText )
      {
        if ( i == '\\' )
          break;
        i = pszText[1];
      }
      wcscpy_s(pszBuffer, pszText - pszBuffer, &stru_1060320[nIndex].gap4[508]);
      if ( found_1 )
        wcscat_s(pszBuffer, pszText - pszBuffer, L"\\Software\\Classes");
      return wcscat_s(pszBuffer, 1024u, pszText);
    }
    pszPosition += 145;
    ++nIndex;
  }
  while ( pszPosition < &stru_1060320[2].field_240 );
  v3 = 0;
  v4 = &stru_1060320[2];
  while ( 1 )
  {
    result = _wcsnicmp(pszBuffer, v4, v4->field_240);
    if ( !result )
      break;
    ++v4;
    ++v3;
    if ( v4 >= gdwValue_4F10B8 )
      return result;
  }
  v10 = &pszBuffer[stru_1060320[v3 + 2].field_240];
  wcscpy_s(pszBuffer, 2 * stru_1060320[v3 + 2].field_240 >> 1, &stru_1060320[v3 + 2].gap4[508]);
  return wcscat_s(pszBuffer, 1024u, v10);
}
// 1060320: using guessed type RegItem stru_1060320[4];
// 10610B8: using guessed type int gdwValue_4F10B8[3];

//----- (00FE1080) --------------------------------------------------------
char __cdecl ReportMsg(int ArgList)
{
  WCHAR Text; // [esp+0h] [ebp-20Ch]

  swprintf(&Text, L"Not able to run on this version of Windows:\nMissing function: %s", ArgList);
  MessageBoxW(0, &Text, L"Process Explorer", 0x10u);
  return 0;
}

//----- (00FE10E0) --------------------------------------------------------
signed int __userpurge PropHandleInfo@<eax>(char a1@<bl>, HWND hWnd, unsigned int a2, unsigned __int16 a3, int a4)
{
  HWND v6; // eax
  POINT v7; // ST18_8
  DWORD v8; // esi
  const WCHAR *v9; // ebx
  bool v10; // cl
  const WCHAR *v11; // esi
  int v12; // eax
  int v13; // eax
  int v14; // eax
  int v15; // eax
  const wchar_t *v16; // eax
  const wchar_t *v17; // eax
  int v18; // eax
  void (__stdcall *v19)(HANDLE); // ebx
  const wchar_t *v20; // eax
  int v21; // eax
  HWND v22; // eax
  HWND v23; // eax
  HWND v24; // eax
  char v25; // [esp-4h] [ebp-6D4h]
  char v26; // [esp-4h] [ebp-6D4h]
  int ThreadInformation; // [esp+8h] [ebp-6C8h]
  DWORD dwProcessId; // [esp+10h] [ebp-6C0h]
  int InformationBuffer; // [esp+24h] [ebp-6ACh]
  int v30; // [esp+28h] [ebp-6A8h]
  char v31[4]; // [esp+2Ch] [ebp-6A4h]
  ULONG ResultLength; // [esp+34h] [ebp-69Ch]
  struct _FILETIME LocalFileTime; // [esp+38h] [ebp-698h]
  FILETIME FileTime; // [esp+40h] [ebp-690h]
  int v35; // [esp+48h] [ebp-688h]
  int v36; // [esp+4Ch] [ebp-684h]
  int v37; // [esp+50h] [ebp-680h]
  char v38; // [esp+55h] [ebp-67Bh]
  struct tagPOINT Point; // [esp+58h] [ebp-678h]
  char v40[4]; // [esp+60h] [ebp-670h]
  char v41[4]; // [esp+64h] [ebp-66Ch]
  ULONG ReturnLength; // [esp+68h] [ebp-668h]
  struct _UNICODE_STRING LinkTarget; // [esp+6Ch] [ebp-664h]
  void *OutBuffer; // [esp+74h] [ebp-65Ch]
  DWORD BytesReturned; // [esp+78h] [ebp-658h]
  ULONG ReturnedLength; // [esp+7Ch] [ebp-654h]
  void *InBuffer; // [esp+80h] [ebp-650h]
  int ObjectInformation; // [esp+84h] [ebp-64Ch]
  int v49; // [esp+8Ch] [ebp-644h]
  int v50; // [esp+90h] [ebp-640h]
  char ArgList[4]; // [esp+94h] [ebp-63Ch]
  char v52[4]; // [esp+98h] [ebp-638h]
  FILETIME v53; // [esp+B4h] [ebp-61Ch]
  struct _SYSTEMTIME SystemTime; // [esp+BCh] [ebp-614h]
  char v55; // [esp+CCh] [ebp-604h]
  wchar_t Dst; // [esp+2CCh] [ebp-404h]
  WCHAR String; // [esp+4CCh] [ebp-204h]

  if ( a2 == 16 )
    goto LABEL_5;
  if ( a2 == 272 )
  {
    v25 = a1;
    GetCursorPos(&Point);
    v6 = GetParent(hWnd);
    sub_FDBDA0(v6);
    v7.y = Point.y - 430;
    v7.x = Point.x - 375;
    PE_SetWindowPlacement(hWnd, v7);
    PostMessageW(hWnd, 0x46Bu, 0, 0);
    v8 = *(a4 + 28);
    BytesReturned = v8;
    v9 = (v8 + 56);
    v10 = !_wcsicmp((v8 + 56), L"Mutant")
       || !_wcsicmp((v8 + 56), L"Section")
       || !_wcsicmp((v8 + 56), L"Event")
       || !_wcsicmp((v8 + 56), L"Semaphore");
    InBuffer = PE_DuplicateProcessHandle(*(v8 + 36), *(v8 + 44), v10 != 0);
    if ( !InBuffer )
    {
      if ( *(v8 + 16) == 1 )
        MessageBoxW(ghMainWnd, L"Object does not exist.", L"Object Properties Error", 0x10u);
      else
        MessageBoxW(ghMainWnd, L"Unable to query the object", L"Object Properties Error", 0x10u);
      v23 = GetParent(hWnd);
      EndDialog(v23, 0);
      v24 = GetParent(hWnd);
      PostMessageW(v24, 0x471u, 5u, 0);
      return 0;
    }
    v11 = (v8 + 2232);
    wsprintf(&String, L"%s Properties", v11);
    SetWindowTextW(hWnd, &String);
    SetDlgItemTextW(hWnd, 1005, v11);
    SetDlgItemTextW(hWnd, 1006, v9);
    if ( _wcsicmp(v9, L"file") )
    {
      if ( _wcsicmp(v9, L"directory") )
      {
        if ( _wcsicmp(v9, L"symboliclink") )
        {
          if ( _wcsicmp(v9, L"key") )
          {
            if ( _wcsicmp(v9, L"process") )
            {
              v12 = wcscmp(v9, L"thread");
              if ( v12 )
                v12 = -(v12 < 0) | 1;
              if ( v12 )
              {
                if ( _wcsicmp(v9, L"iocompletion") )
                {
                  if ( _wcsicmp(v9, L"mutant") )
                  {
                    if ( _wcsicmp(v9, L"event") && _wcsicmp(v9, L"semaphore") )
                    {
                      if ( _wcsicmp(v9, L"windowstation") )
                      {
                        if ( _wcsicmp(v9, L"desktop") )
                        {
                          if ( _wcsicmp(v9, L"port") && _wcsicmp(v9, L"waitableport") )
                          {
                            if ( _wcsicmp(v9, L"section") )
                            {
                              if ( _wcsicmp(v9, L"token") )
                              {
                                if ( !_wcsicmp(v9, L"timer") )
                                  SetDlgItemTextW(hWnd, 1050, L"A time-based synchronization object.");
                              }
                              else
                              {
                                SetDlgItemTextW(hWnd, 1050, L"Identifies a security context.");
                              }
                            }
                            else
                            {
                              SetDlgItemTextW(hWnd, 1050, L"A memory mapped file or paging-file backed memory region.");
                            }
                          }
                          else
                          {
                            SetDlgItemTextW(hWnd, 1050, L"An interprocess communications endpoint.");
                          }
                        }
                        else
                        {
                          SetDlgItemTextW(hWnd, 1050, L"Contains application windows.");
                        }
                      }
                      else
                      {
                        SetDlgItemTextW(hWnd, 1050, L"Contains one or more desktops with windows.");
                      }
                    }
                    else
                    {
                      SetDlgItemTextW(hWnd, 1050, L"A synchronization object.");
                    }
                  }
                  else
                  {
                    SetDlgItemTextW(hWnd, 1050, L"A synchronization object (a Win32 mutex).");
                  }
                }
                else
                {
                  SetDlgItemTextW(hWnd, 1050, L"An asynchronous I/O notification object.");
                }
              }
              else
              {
                SetDlgItemTextW(hWnd, 1050, L"An object that executes program code.");
              }
            }
            else
            {
              SetDlgItemTextW(hWnd, 1050, L"Contains threads, an address space, and handles.");
            }
          }
          else
          {
            SetDlgItemTextW(hWnd, 1050, L"A Registry key.");
          }
        }
        else
        {
          SetDlgItemTextW(hWnd, 1050, L"An Object Manager namespace link.");
        }
      }
      else
      {
        SetDlgItemTextW(hWnd, 1050, L"An Object Manager namespace directory.");
      }
    }
    else
    {
      SetDlgItemTextW(hWnd, 1050, L"A disk file, communications endpoint, or driver interface.");
    }
    wsprintf(&String, L"0x%X", *(BytesReturned + 40));
    SetDlgItemTextW(hWnd, 1051, &String);
    NtQueryObject(InBuffer, 0, &ObjectInformation, 0x38u, &ReturnLength);
    wsprintf(&String, L"%d", v49 - 1);
    SetDlgItemTextW(hWnd, 1008, &String);
    wsprintf(&String, L"%d", v50 - 2);
    SetDlgItemTextW(hWnd, 1019, &String);
    wsprintf(&String, L"%d", ArgList[0]);
    SetDlgItemTextW(hWnd, 1010, &String);
    wsprintf(&String, L"%d", v52[0]);
    SetDlgItemTextW(hWnd, 1013, &String);
    v13 = wcscmp(v9, L"SymbolicLink");
    if ( v13 )
      v13 = -(v13 < 0) | 1;
    if ( !v13 )
    {
      SetDlgItemTextW(hWnd, 1025, L"Symbolic Link Info");
      SetDlgItemTextW(hWnd, 1024, L"Creation Time:");
      FileTime = v53;
      FileTimeToLocalFileTime(&FileTime, &LocalFileTime);
      FileTimeToSystemTime(&LocalFileTime, &SystemTime);
      wsprintf(&String, L"%d:%02d:%02d, %d/%d/%d", SystemTime.wHour);
      SetDlgItemTextW(hWnd, 1022, &String);
      SetDlgItemTextW(hWnd, 1028, L"Link:");
      LinkTarget.MaximumLength = 256;
      LinkTarget.Buffer = &v55;
      if ( gpfn_NtQuerySymbolicLinkObject(InBuffer, &LinkTarget, &ReturnedLength) )
        wcscpy_s(&String, 0x100u, L"<Error Querying Link>");
      else
        wsprintf(&String, L"%s", LinkTarget.Buffer);
      SetDlgItemTextW(hWnd, 1027, &String);
      goto LABEL_94;
    }
    v14 = wcscmp(v9, L"Semaphore");
    if ( v14 )
      v14 = -(v14 < 0) | 1;
    if ( v14 )
    {
      v15 = wcscmp(v9, L"Event");
      if ( v15 )
        v15 = -(v15 < 0) | 1;
      if ( v15 )
      {
        v18 = wcscmp(v9, L"Mutant");
        if ( v18 )
          v18 = -(v18 < 0) | 1;
        if ( !v18 )
        {
          SetDlgItemTextW(hWnd, 1025, L"Mutant Info");
          SetDlgItemTextW(hWnd, 1024, L"Held:");
          NtQueryMutant(InBuffer, 0, &v37, 8, &ReturnedLength);
          wsprintf(&String, L"FALSE", v25);
          if ( v37 <= 0
            && (wsprintf(&String, L"TRUE", v26),
                DeviceIoControl(ghDriverHandle, 0x8335002C, &InBuffer, 4u, &OutBuffer, 4u, &BytesReturned, 0))
            && OutBuffer )
          {
            if ( !NtQueryInformationThread(OutBuffer, 0, &ThreadInformation, 0x1Cu, &ReturnLength) )
            {
              SystemProcessInfo_GetSystemProcessName(dwProcessId, 0, &Dst, 0x100u);
              wsprintf(&String, L"%s(%d): %d", &Dst);
            }
            v19 = CloseHandle;
            CloseHandle(OutBuffer);
          }
          else
          {
            v19 = CloseHandle;
          }
          SetDlgItemTextW(hWnd, 1022, &String);
          SetDlgItemTextW(hWnd, 1028, L"Abandoned:");
          v20 = L"TRUE";
          if ( !v38 )
            v20 = L"FALSE";
          wsprintf(&String, L"%s", v20);
          SetDlgItemTextW(hWnd, 1027, &String);
          v19(InBuffer);
          return 1;
        }
        v21 = wcscmp(v9, L"Section");
        if ( v21 )
          v21 = -(v21 < 0) | 1;
        if ( v21 )
        {
          v22 = GetDlgItem(hWnd, 1025);
          ShowWindow(v22, 0);
        }
        else
        {
          SetDlgItemTextW(hWnd, 1025, L"Section Info");
          NtQuerySection(InBuffer, 0, &InformationBuffer, 0x10u, &ResultLength);
          if ( v30 & 0x1000000 )
          {
            SetDlgItemTextW(hWnd, 1024, L"Type:");
            wcscpy_s(&String, 0x100u, L"IMAGE");
          }
          else if ( v30 & 0x800000 )
          {
            SetDlgItemTextW(hWnd, 1024, L"Type:");
            wcscpy_s(&String, 0x100u, L"FILE");
          }
          else if ( v30 & 0x4000000 )
          {
            SetDlgItemTextW(hWnd, 1024, L"Type:");
            wcscpy_s(&String, 0x100u, L"RESERVED");
          }
          else if ( v30 & 0x8000000 )
          {
            SetDlgItemTextW(hWnd, 1024, L"Type:");
            wcscpy_s(&String, 0x100u, L"COMMITED");
          }
          SetDlgItemTextW(hWnd, 1022, &String);
          SetDlgItemTextW(hWnd, 1028, L"Size:");
          wsprintf(&String, L"0x%08x", v31[0]);
          SetDlgItemTextW(hWnd, 1027, &String);
        }
LABEL_94:
        CloseHandle(InBuffer);
        return 1;
      }
      SetDlgItemTextW(hWnd, 1025, L"Event Info");
      SetDlgItemTextW(hWnd, 1024, L"Type:");
      NtQueryEvent(InBuffer, 0, &v35, 8, &ReturnedLength);
      v16 = L"Notification";
      if ( v35 )
        v16 = L"Synchronization";
      wsprintf(&String, L"%s", v16);
      SetDlgItemTextW(hWnd, 1022, &String);
      SetDlgItemTextW(hWnd, 1028, L"Signaled:");
      v17 = L"TRUE";
      if ( !v36 )
        v17 = L"FALSE";
      wsprintf(&String, L"%s", v17);
    }
    else
    {
      SetDlgItemTextW(hWnd, 1025, L"Semaphore Info");
      SetDlgItemTextW(hWnd, 1024, L"Count:");
      NtSetInformationProcess_0(InBuffer, 0, v40, 8, &ReturnedLength);
      wsprintf(&String, L"%d", v40[0]);
      SetDlgItemTextW(hWnd, 1022, &String);
      SetDlgItemTextW(hWnd, 1028, L"Limit:");
      wsprintf(&String, L"%d", v41[0]);
    }
    SetDlgItemTextW(hWnd, 1027, &String);
    goto LABEL_94;
  }
  if ( a2 == 273 && a3 - 1 <= 1 )
  {
LABEL_5:
    DestroyWindow(hWnd);
    return 1;
  }
  return 0;
}
// FE10E0: could not find valid save-restore pair for ebx
// 10448C0: using guessed type wchar_t aADiskFileCommu[59];
// 1044950: using guessed type wchar_t aAnObjectManage[39];
// 10449C0: using guessed type wchar_t aAnObjectManage_0[34];
// 1044A0C: using guessed type wchar_t aARegistryKey[16];
// 1044A30: using guessed type wchar_t aContainsThread[49];
// 1044A98: using guessed type wchar_t aAnObjectThatEx[38];
// 1044B00: using guessed type wchar_t aAnAsynchronous[41];
// 1044B68: using guessed type wchar_t aASynchronizati[42];
// 1044C30: using guessed type wchar_t aContainsOneOrM[44];
// 1044C98: using guessed type wchar_t aContainsApplic[30];
// 1044D00: using guessed type wchar_t aAnInterprocess[41];
// 1044D68: using guessed type wchar_t aAMemoryMappedF[58];
// 1044DDC: using guessed type wchar_t aIdentifiesASec[31];
// 1044E28: using guessed type wchar_t aATimeBasedSync[37];
// 1044E74: using guessed type wchar_t aSymboliclink_0[13];
// 1044FA4: using guessed type wchar_t aNotification[13];
// 1044FC0: using guessed type wchar_t aSynchronizatio[16];
// 104504C: using guessed type wchar_t aImage_0[6];
// 1045058: using guessed type wchar_t aFile_2[5];
// 1045064: using guessed type wchar_t aReserved[9];
// 10450D8: using guessed type wchar_t aObjectDoesNotE[23];
// 106F228: using guessed type int (__stdcall *NtSetInformationProcess_0)(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 106F230: using guessed type int (__stdcall *NtQueryEvent)(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 106F234: using guessed type int (__stdcall *NtQueryMutant)(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD);

//----- (00FE1C00) --------------------------------------------------------
int __stdcall PropSecurity(HWND hDlg, UINT msg, WPARAM wParam, LPARAM lParam)
{
  int result; // eax
  HWND v5; // edi
  HWND v6; // eax
  int v7; // eax
  int v8; // eax
  int v9; // eax
  int v10; // ecx
  char v11; // al
  void *v12; // esi
  HWND v13; // eax
  unsigned int v14; // edx
  const unsigned __int16 *v15; // ebx
  __int16 *v16; // ecx
  __int16 v17; // ax
  WCHAR *v18; // esi
  WCHAR v19; // ax
  unsigned int v20; // edx
  HWND hWnda; // [esp+8h] [ebp+8h]

  if ( msg == WM_INITDIALOG )
  {
    v5 = hDlg;
    PostMessageW(hDlg, 0x46Bu, 0, 0);
    dword_107C038 = *(lParam + 0x1C);
    hWnda = PE_DuplicateProcessHandle(*(dword_107C038 + 36), *(dword_107C038 + 44), 0x80000000);
    if ( hWnda )
    {
      byte_107C083 = 0;
      byte_107C084 = 0;
      byte_107C085 = 0;
      byte_107C082 = 0;
      v7 = wcscmp((dword_107C038 + 0x38), L"Directory");
      if ( v7 )
        v7 = -(v7 < 0) | 1;
      if ( v7 )
      {
        v8 = wcscmp((dword_107C038 + 0x38), L"Device");
        if ( v8 )
          v8 = -(v8 < 0) | 1;
        if ( v8 )
        {
          v9 = wcscmp((dword_107C038 + 0x38), L"Process");
          if ( v9 )
            v9 = -(v9 < 0) | 1;
          if ( v9 )
          {
            v10 = wcscmp((dword_107C038 + 0x38), L"Key");
            if ( v10 )
              v10 = -(v10 < 0) | 1;
            v11 = byte_107C084;
            if ( !v10 )
              v11 = 1;
            byte_107C084 = v11;
          }
          else
          {
            byte_107C082 = 1;
          }
        }
        else
        {
          byte_107C085 = 1;
        }
      }
      else
      {
        byte_107C083 = 1;
      }
      wParam = 23;
      byte_107C080 = GetUserObjectSecurity(hWnda, &wParam, pSID, 0x2000u, &msg) != 0;
      CloseHandle(hWnda);
    }
    else
    {
      byte_107C080 = 0;
      v6 = GetDlgItem(v5, 127);
      EnableWindow(v6, 0);
    }
    v12 = PE_DuplicateProcessHandle(*(dword_107C038 + 36), *(dword_107C038 + 44), 0x81000000);
    if ( v12 || (v12 = PE_DuplicateProcessHandle(*(dword_107C038 + 36), *(dword_107C038 + 44), 0x1000000u)) != 0 )
    {
      wParam = 9;
      byte_107C081 = GetUserObjectSecurity(v12, &wParam, ObjectSecurity, 0x2000u, &msg) != 0;
      CloseHandle(v12);
    }
    else
    {
      byte_107C081 = 0;
      v13 = GetDlgItem(v5, 128);
      EnableWindow(v13, 0);
    }
    v14 = 0;
    v15 = (dword_107C038 + 184);
    v16 = (dword_107C038 + 184);
    do
    {
      v17 = *v16;
      ++v16;
    }
    while ( v17 );
    if ( (v16 - dword_107C038 - 186) >> 1 )
    {
      v18 = (dword_107C038 + 184);
      do
      {
        v19 = *v18;
        ++v18;
        gObjectName[v14++] = v19;
      }
      while ( v14 < wcslen(v15) );
    }
    v20 = v14;
    if ( v20 >= 1024 )
    {
      __report_rangecheckfailure();
      JUMPOUT(*algn_FE224B);
    }
    gAclDlgControl.Version = 257;
    gObjectName[v20] = 0;
    if ( byte_107C084 )
    {
      gAclDlgControl.GenericAccessMap = RegistryAccessMasks;
      gAclDlgControl.SpecificAccessMap = RegistryAccessMasks;
    }
    else
    {
      gAclDlgControl.GenericAccessMap = AccessMasks;
      gAclDlgControl.SpecificAccessMap = AccessMasks;
    }
    gAclDlgControl.Reserved = 0;
    gAclDlgControl.SubReplaceTitle = 0;
    gAclDlgControl.SubReplaceConfirmation = 0;
    result = 1;
    gAclDlgControl.DialogTitle = aObject_0;
    gAclDlgControl.HelpInfo = &HelpInfo;
    gAclDlgControl.SpecialAccess = aSpecialAccess;
    return result;
  }
  if ( msg != 273 )
    return 0;
  if ( wParam != 127 )
  {
    if ( wParam == 128 )
    {
      if ( !byte_107C081 )
      {
        MessageBoxW(0, L"You do not have permission to view the Audit Information for\nthis object.", L"WinObj", 0x10u);
        return 0;
      }
      gAclEditControl.NumberOfEntries = 7;
      gAclEditControl.Entries = aclEditEntryFile;
      dword_107C040 = *(dword_107C038 + 44);
      dword_107C03C = *(dword_107C038 + 36);
      dword_107C044 = 1;
      dword_107C048 = dword_107BC38;
      dword_107C04C = ObjectSecurity;
      dword_107C050 = &byte_107C081;
      if ( SedSystemAclEditor(
             0,
             0,
             0,
             &gAclDlgControl,
             &gAclEditControl,
             gObjectName,
             pfnAclChangeCallback,
             &dword_107C03C,
             ObjectSecurity,
             0,
             &msg,
             0) )
      {
        MessageBoxW(0, L"The SACL Editor does not understand the Security Information.", L"WinObj", 0x10u);
        return 0;
      }
      return 0;
    }
    if ( wParam == 129 )
    {
      if ( byte_107C080 )
      {
        dword_107C040 = *(dword_107C038 + 44);
        dword_107C03C = *(dword_107C038 + 36);
        dword_107C044 = 2;
        dword_107C048 = dword_107BC38;
        dword_107C04C = pSID;
        dword_107C050 = &byte_107C080;
        wcscpy_s(&gObjectType, 0x400u, L"&Object");
        if ( SedTakeOwnership(
               0,
               0,
               0,
               &gObjectType,
               gObjectName,
               1u,
               pfnAclChangeCallback,
               &dword_107C03C,
               pSID,
               0,
               0,
               &msg,
               &HelpInfo,
               0) )
        {
          if ( IsValidSecurityDescriptor(pSID) )
          {
            MessageBoxW(0, L"The Ownership Editor does not understand the Security Information.", L"WinObj", 0x10u);
            return 0;
          }
          goto LABEL_10;
        }
        return 0;
      }
      goto LABEL_29;
    }
    return 0;
  }
  if ( !byte_107C080 )
  {
LABEL_29:
    MessageBoxW(0, L"You do not have permission to view the Security Information for\nthis object.", L"WinObj", 0x10u);
    return 0;
  }
  if ( !byte_107C083 )
  {
    if ( byte_107C084 )
    {
      gAclEditControl.Entries = stru_10601C0;
    }
    else
    {
      if ( byte_107C085 )
      {
        gAclEditControl.NumberOfEntries = 11;
        gAclEditControl.Entries = stru_1060110;
        goto LABEL_26;
      }
      if ( byte_107C082 )
      {
        gAclEditControl.NumberOfEntries = 14;
        gAclEditControl.Entries = &dword_105FED0;
        goto LABEL_26;
      }
      gAclEditControl.Entries = &HelpInfo.Reserved1;
    }
    gAclEditControl.NumberOfEntries = 12;
    goto LABEL_26;
  }
  gAclEditControl.NumberOfEntries = 22;
  gAclEditControl.Entries = stru_105FFB0;
LABEL_26:
  dword_107C040 = *(dword_107C038 + 44);
  dword_107C03C = *(dword_107C038 + 36);
  dword_107C044 = 0;
  dword_107C048 = dword_107BC38;
  dword_107C04C = pSID;
  dword_107C050 = &byte_107C080;
  if ( !SedDiscretionaryAclEditor(
          0,
          0,
          0,
          &gAclDlgControl,
          &gAclEditControl,
          gObjectName,
          pfnAclChangeCallback,
          &dword_107C03C,
          pSID,
          0,
          0,
          &msg,
          0) )
    return 0;
  if ( !IsValidSecurityDescriptor(pSID) )
  {
LABEL_10:
    MessageBoxW(0, L"The Security Information is invalid.", L"WinObj", 0x10u);
    return 0;
  }
  MessageBoxW(0, L"The ACL Editor does not understand the Security Information.", L"WinObj", 0x10u);
  return 0;
}
// 10067E8: using guessed type int __report_rangecheckfailure(void);
// 105FCB8: using guessed type wchar_t aObject_0[7];
// 105FCE0: using guessed type wchar_t aSpecialAccess[18];
// 105FED0: using guessed type int dword_105FED0;
// 105FFB0: using guessed type _ACLEDITENTRY stru_105FFB0[22];
// 1060110: using guessed type _ACLEDITENTRY stru_1060110[11];
// 10601C0: using guessed type _ACLEDITENTRY stru_10601C0[12];
// 1060280: using guessed type _ACLEDITENTRY aclEditEntryFile[7];
// 10602F0: using guessed type int AccessMasks[4];
// 1060300: using guessed type int RegistryAccessMasks[4];
// 107BC38: using guessed type int dword_107BC38[256];
// 107C038: using guessed type int dword_107C038;
// 107C03C: using guessed type int dword_107C03C;
// 107C040: using guessed type int dword_107C040;
// 107C044: using guessed type int dword_107C044;
// 107C048: using guessed type int dword_107C048;
// 107C04C: using guessed type int dword_107C04C;
// 107C050: using guessed type int dword_107C050;
// 107C080: using guessed type char byte_107C080;
// 107C081: using guessed type char byte_107C081;
// 107C082: using guessed type char byte_107C082;
// 107C083: using guessed type char byte_107C083;
// 107C084: using guessed type char byte_107C084;
// 107C085: using guessed type char byte_107C085;

//----- (00FE2250) --------------------------------------------------------
int __cdecl PE_DuplicateProcessHandle(DWORD dwProcessId, HANDLE hSourceHandle, DWORD dwDesiredAccess)
{
  DWORD dwPid; // edi
  HANDLE ProcessHandle; // esi
  DWORD v5; // ST14_4
  HANDLE v6; // ST0C_4
  HANDLE SourceHandle; // edi
  DWORD DesiredAccess; // ST14_4
  HANDLE TargetHandle; // ST0C_4
  int InBuf[4]; // [esp+8h] [ebp-20h]
  DWORD v12; // [esp+18h] [ebp-10h]
  DWORD BytesReturned; // [esp+1Ch] [ebp-Ch]
  DWORD InBuffer; // [esp+20h] [ebp-8h]
  int pTargetHandle; // [esp+24h] [ebp-4h]

  dwPid = dwProcessId;
  pTargetHandle = 0;
  InBuffer = dwProcessId;
  ProcessHandle = OpenProcess(PROCESS_DUP_HANDLE, 0, dwProcessId);
  dwProcessId = ProcessHandle;
  if ( ProcessHandle )
    goto LABEL_14;
  if ( GetLastError() == ERROR_ACCESS_DENIED )
    DeviceIoControl(ghDriverHandle, CTRLCODE_QUERY_PROCESS_HANDLE, &InBuffer, 4u, &dwProcessId, 4u, &BytesReturned, 0);
  ProcessHandle = dwProcessId;
  if ( dwProcessId )
  {
LABEL_14:
    if ( dwPid <= 8 )
    {
      InBuf[0] = dwPid;
      SourceHandle = hSourceHandle;
      InBuf[3] = hSourceHandle;
      if ( ghDriverHandle == -1
        || !DeviceIoControl(ghDriverHandle, 0x83350014, InBuf, 0x10u, &pTargetHandle, 4u, &v12, 0) )
      {
        DesiredAccess = dwDesiredAccess;
        TargetHandle = GetCurrentProcess();
        DuplicateHandle(ProcessHandle, SourceHandle, TargetHandle, &pTargetHandle, DesiredAccess, 0, 0);
      }
    }
    else
    {
      v5 = dwDesiredAccess;
      v6 = GetCurrentProcess();
      DuplicateHandle(ProcessHandle, hSourceHandle, v6, &pTargetHandle, v5, 0, 0);
    }
    CloseHandle(ProcessHandle);
  }
  return pTargetHandle;
}

//----- (00FE2330) --------------------------------------------------------
int *__thiscall sub_FE2330(int *this, int a2)
{
  int v2; // esi
  int *v3; // edi
  int v4; // ecx
  int *result; // eax
  signed int v6; // ecx
  int v7; // ecx
  int v8; // ecx

  v2 = a2;
  v3 = this;
  v4 = *this;
  if ( *(v4 - 12) > a2 )
    v2 = *(v4 - 12);
  if ( *(v4 - 4) > 1 )
    return sub_FDBDF0(v3, v2);
  v6 = *(v4 - 8);
  if ( v6 < v2 )
  {
    if ( v6 <= 0x40000000 )
    {
      v8 = v6 / 2 + v6;
      if ( v8 < v2 )
        v8 = v2;
      result = sub_FEDE20(v3, v8);
    }
    else
    {
      v7 = v6 + 0x100000;
      if ( v7 < v2 )
        v7 = v2;
      result = sub_FEDE20(v3, v7);
    }
  }
  return result;
}

//----- (00FE23A0) --------------------------------------------------------
int __stdcall PageProcCPU(HWND hWnd, int a2, WPARAM wParam, LONG dwNewLong)
{
  HWND v4; // eax
  int result; // eax
  CResizer *v6; // eax
  LONG v7; // eax
  HWND (__stdcall *v8)(HWND, int); // esi
  HWND v9; // edi
  HWND v10; // esi
  HWND v11; // edi
  HWND v12; // esi
  HWND v13; // edi
  HWND v14; // esi
  CResizer *v15; // edi
  HWND v16; // eax
  HWND v17; // ST2C_4
  HWND v18; // eax
  HWND v19; // ST2C_4
  HWND v20; // eax
  HWND v21; // ST2C_4
  HWND v22; // eax
  HWND v23; // eax
  HWND v24; // eax
  HWND v25; // eax
  HWND v26; // eax
  HWND v27; // eax
  HWND v28; // eax
  HWND v29; // eax
  HWND v30; // eax
  WPARAM v31; // [esp-8h] [ebp-38h]
  CResizer *v32; // [esp+10h] [ebp-20h]
  HWND v33; // [esp+14h] [ebp-1Ch]
  HWND v34; // [esp+18h] [ebp-18h]
  HWND v35; // [esp+1Ch] [ebp-14h]
  int v36; // [esp+2Ch] [ebp-4h]

  GetWindowLongW(hWnd, -21);
  if ( a2 > 0x113 )
  {
    if ( a2 == 307 || a2 == 310 || a2 == 312 )
      return PE_FillControl(hWnd, wParam);
    return 0;
  }
  if ( a2 == 275 || a2 == 5 )
  {
    if ( IsWindowVisible(hWnd) )
    {
      v25 = GetDlgItem(hWnd, 1158);
      SendMessageW(v25, 0x400u, 0, 0);
      v26 = GetDlgItem(hWnd, 2000);
      SendMessageW(v26, 0x400u, 0, 0);
      v27 = GetDlgItem(hWnd, 1161);
      SendMessageW(v27, 0x400u, 0, 0);
      v28 = GetDlgItem(hWnd, 1159);
      SendMessageW(v28, 0x400u, 0, 0);
      v29 = GetDlgItem(hWnd, 1332);
      SendMessageW(v29, 0x400u, 0, 0);
      v30 = GetDlgItem(hWnd, 1330);
      SendMessageW(v30, 0x400u, 0, 0);
      return 0;
    }
    return 0;
  }
  if ( a2 != 272 )
  {
    if ( a2 == 273 )
    {
      switch ( wParam )
      {
        case 0x9C41u:
          v31 = 40014;
          goto LABEL_8;
        case 0x9C42u:
          SetEvent(ghRefreshEventHandle);
          result = 0;
          break;
        case 0x9C9Cu:
        case 0x9C9Du:
          v31 = wParam;
LABEL_8:
          v4 = GetParent(hWnd);
          PostMessageW(v4, 0x111u, v31, 0);
          result = 0;
          break;
        default:
          return 0;
      }
      return result;
    }
    return 0;
  }
  v6 = operator new(0x40u);
  v36 = 0;
  if ( v6 )
    v32 = CResizer::CResizer(v6, hWnd);
  else
    v32 = 0;
  v36 = -1;
  v7 = GetWindowLongW(hWnd, -16);
  SetWindowLongW(hWnd, -16, v7 | 0x2000000);
  SetWindowLongW(hWnd, -21, dwNewLong);
  CreateGraphWindow(hWnd, 1158, *(dwNewLong + 1372));
  CreateGraphWindow(hWnd, 2000, *(dwNewLong + 1372));
  CreateGraphWindow(hWnd, 1161, *(dwNewLong + 908));
  CreateGraphWindow(hWnd, 1159, *(dwNewLong + 908));
  if ( *(dwNewLong + 1064) )
  {
    CreateGraphWindow(hWnd, 1332, *(dwNewLong + 1064));
    CreateGraphWindow(hWnd, 1330, *(dwNewLong + 1064));
  }
  v8 = GetDlgItem;
  if ( *(dwNewLong + 1064) )
  {
    v9 = GetDlgItem(hWnd, 1331);
    v10 = GetDlgItem(hWnd, 1160);
    v33 = GetDlgItem(hWnd, 1157);
    v34 = v10;
    v35 = v9;
    sub_FF0550(v32, 3, &v33);
    v11 = GetDlgItem(hWnd, 1332);
    v12 = GetDlgItem(hWnd, 1161);
    v33 = GetDlgItem(hWnd, 1158);
    v34 = v12;
    v35 = v11;
    sub_FF0550(v32, 3, &v33);
    v13 = GetDlgItem(hWnd, 1330);
    v14 = GetDlgItem(hWnd, 1159);
    v33 = GetDlgItem(hWnd, 2000);
    v35 = v13;
    v15 = v32;
    v34 = v14;
    sub_FF0550(v32, 3, &v33);
    v8 = GetDlgItem;
    v16 = GetDlgItem(hWnd, 1331);
    *&CResizer::AddItem(v32, v16, 1)->m_rect2.right = db_four;
  }
  else
  {
    v17 = GetDlgItem(hWnd, 1160);
    v18 = GetDlgItem(hWnd, 1157);
    v15 = v32;
    sub_FF04E0(v32, v18, v17);
    v19 = GetDlgItem(hWnd, 1161);
    v20 = GetDlgItem(hWnd, 1158);
    sub_FF04E0(v32, v20, v19);
    v21 = GetDlgItem(hWnd, 1159);
    v22 = GetDlgItem(hWnd, 2000);
    sub_FF04E0(v32, v22, v21);
  }
  v23 = v8(hWnd, 1157);
  *&CResizer::AddItem(v15, v23, 1)->m_rect2.right = db_four;
  v24 = v8(hWnd, 1160);
  *&CResizer::AddItem(v15, v24, 1)->m_rect2.right = db_four;
  PropSheet_UpdateTab(hWnd);
  SendMessageW(hWnd, 0x113u, 0, 0);
  return 1;
}
// 103CB38: using guessed type double db_four;

//----- (00FE2810) --------------------------------------------------------
int __stdcall PageProcEnv(HWND hWnd, int a2, WPARAM wParam, int a4)
{
  HWND v4; // ebx
  CResizer *v5; // eax
  LONG v6; // eax
  void (__stdcall *v7)(HWND, UINT, WPARAM, LPARAM); // edi
  HWND v8; // eax
  __int16 *v9; // esi
  __int16 *v10; // ecx
  int v11; // edi
  __int16 i; // ax
  LRESULT v13; // edx
  char *v14; // ecx
  __int16 v15; // ax
  HWND v17; // eax
  LRESULT v18; // esi
  WPARAM v19; // [esp-8h] [ebp-2ACh]
  LPARAM v20; // [esp+10h] [ebp-294h]
  int v21; // [esp+1Ch] [ebp-288h]
  int v22; // [esp+20h] [ebp-284h]
  void *v23; // [esp+44h] [ebp-260h]
  LPARAM lParam; // [esp+48h] [ebp-25Ch]
  LRESULT v25; // [esp+4Ch] [ebp-258h]
  int v26; // [esp+50h] [ebp-254h]
  int v27; // [esp+54h] [ebp-250h]
  int v28; // [esp+58h] [ebp-24Ch]
  __int16 *v29; // [esp+5Ch] [ebp-248h]
  int v30; // [esp+64h] [ebp-240h]
  int v31; // [esp+68h] [ebp-23Ch]
  UINT pnIDs; // [esp+7Ch] [ebp-228h]
  int v33; // [esp+80h] [ebp-224h]
  WORD pnWidths[2]; // [esp+84h] [ebp-220h]
  LPMEASUREITEMSTRUCT lpmis; // [esp+88h] [ebp-21Ch]
  __int16 v36; // [esp+8Ch] [ebp-218h]
  int v37; // [esp+2A0h] [ebp-4h]

  lpmis = a4;
  GetWindowLongW(hWnd, -21);
  lParam = 0;
  memset(&v25, 0, 0x30u);
  v4 = GetDlgItem(hWnd, 1055);
  pnIDs = 1057;
  v33 = 1058;
  pnWidths[0] = MulDiv(100, gLogPixelSize.x, 96);
  pnWidths[1] = MulDiv(100, gLogPixelSize.x, 96);
  if ( a2 > 0x111 )
  {
    if ( a2 == 307 || a2 == 310 || a2 == 312 )
      return PE_FillControl(hWnd, wParam);
    return 0;
  }
  switch ( a2 )
  {
    case 273:
      if ( wParam <= 40093 )
      {
        if ( wParam >= 40092 )
        {
          v19 = wParam;
        }
        else
        {
          if ( wParam != 40001 )
            return 0;
          v19 = 40014;
        }
        v17 = GetParent(hWnd);
        PostMessageW(v17, 0x111u, v19, 0);
        return 0;
      }
      if ( wParam == 40631 )
      {
        v18 = 0;
        if ( SendMessageW(v4, 0x1004u, 0, 0) > 0 )
        {
          do
          {
            v22 = 2;
            v21 = 2;
            SendMessageW(v4, 0x102Bu, v18++, &v20);
          }
          while ( v18 < SendMessageW(v4, 0x1004u, 0, 0) );
          return 0;
        }
      }
      return 0;
    case 43:
      CMainWnd::DrawList(lpmis);
      return 0;
    case 44:
      return CMainWnd::HandleMeasureItem(hWnd, 0x2Cu, wParam, lpmis);
  }
  if ( a2 != 272 )
    return 0;
  v5 = operator new(0x40u);
  v23 = v5;
  v37 = 0;
  if ( v5 )
    CResizer::CResizer(v5, hWnd);
  PropSheet_UpdateTab(hWnd);
  v6 = GetWindowLongW(v4, -16);
  SetWindowLongW(v4, -16, v6 & 0xFFFFFFFD | 1);
  v7 = SendMessageW;
  SendMessageW(v4, 0x1036u, 0x4020u, 16416);
  v8 = SendMessageW(v4, 0x104Eu, 0, 0);
  CTreeList::InitToolTips(v8);
  SetWindowLongW(v4, -4, Proxy_ListCtrlWndProc);
  SendMessageW(v4, 0x30u, ghConfigFont, 0);
  CTreeView::InitListHeader(v4, &pnIDs, pnWidths, 2u);
  v9 = lpmis[33].itemHeight;
  if ( v9 )
  {
    while ( *v9 )
    {
      v10 = &v36;
      v36 = 0;
      v11 = 0;
      for ( i = *v9; i; ++v9 )
      {
        if ( !v11 )
        {
          if ( i == 61 )
          {
            v11 = (v9 + 1);
            *v10 = 0;
          }
          else
          {
            *v10 = i;
            ++v10;
          }
        }
        i = v9[1];
      }
      lParam = 5;
      v29 = &v36;
      v25 = 0x7FFFFFFF;
      v26 = 0;
      v27 = 0;
      v28 = 0;
      v30 = 0;
      v31 = 1;
      v13 = SendMessageW(v4, 0x104Du, 0, &lParam);
      if ( v13 == -1 )
        return 0;
      if ( v11 )
      {
        v14 = v11;
        lpmis = (v11 + 2);
        do
        {
          v15 = *v14;
          v14 += 2;
        }
        while ( v15 );
        if ( ((v14 - lpmis) >> 1) > 0x1FFF )
          *(v11 + 16382) = 0;
        v29 = v11;
        v7 = SendMessageW;
        lParam = 1;
        v25 = v13;
        v26 = 1;
        SendMessageW(v4, 0x104Cu, 0, &lParam);
      }
      else
      {
        v7 = SendMessageW;
      }
      ++v9;
      if ( !v9 )
        break;
    }
  }
  v7(v4, 0x101Eu, 0, 0xFFFF);
  v7(v4, 0x101Eu, 1u, 0xFFFF);
  return 1;
}

//----- (00FE2C20) --------------------------------------------------------
HBRUSH __stdcall PageProcInfo(HWND hWnd, UINT a2, WPARAM a3, TreeViewParamInfo *dwNewLong)
{
  HWND v4; // ebx
  LONG v5; // edx
  Data_t_bstr_t *v6; // esi
  CResizer *v7; // eax
  CResizer *v8; // eax
  HWND v9; // eax
  struct tagResizerItem *v10; // eax
  HWND v11; // eax
  struct tagResizerItem *v12; // eax
  bool v13; // zf
  void *v14; // ST08_4
  void *v15; // ST04_4
  void *v16; // ST00_4
  const WCHAR *v17; // edi
  const WCHAR *v18; // eax
  BOOL v19; // ST2C_4
  HWND v20; // eax
  LPARAM v21; // edi
  BOOL v22; // ST2C_4
  HWND v23; // eax
  HWND v24; // eax
  int v25; // ebx
  HWND v26; // eax
  HWND v27; // eax
  char v28; // al
  HWND v29; // eax
  HWND v30; // eax
  HWND v31; // eax
  OLECHAR *v32; // ST2C_4
  _bstr_t *v33; // edi
  Data_t_bstr_t **v34; // eax
  _bstr_t *v35; // eax
  _bstr_t *v36; // eax
  const WCHAR *v37; // eax
  const WCHAR *v38; // eax
  HWND v39; // eax
  _WORD *v40; // eax
  int v41; // ST2C_4
  HWND v42; // eax
  HWND v43; // eax
  _WORD *v44; // eax
  HWND v45; // eax
  DWORD v46; // edi
  void *v47; // edi
  wchar_t *v48; // eax
  HICON v49; // eax
  LPARAM v50; // ST2C_4
  HWND v51; // eax
  HICON v52; // eax
  LPARAM v53; // ST2C_4
  HWND v54; // eax
  HICON v55; // eax
  LPARAM v56; // ST2C_4
  HWND v57; // eax
  int v58; // eax
  int v59; // ST2C_4
  HWND v60; // eax
  HBRUSH v61; // edi
  const unsigned __int16 *v62; // eax
  int v63; // eax
  HWND v64; // eax
  int v65; // ST2C_4
  HWND v66; // eax
  const WCHAR *v67; // eax
  HWND v68; // eax
  WCHAR *v69; // edi
  char v70; // cl
  int v71; // eax
  int v72; // ST2C_4
  HWND v73; // eax
  HWND v75; // eax
  int v76; // [esp-8h] [ebp-1664h]
  struct _FILETIME LocalFileTime; // [esp+10h] [ebp-164Ch]
  DWORD dwHandle; // [esp+18h] [ebp-1644h]
  _bstr_t v79; // [esp+1Ch] [ebp-1640h]
  _bstr_t v80; // [esp+20h] [ebp-163Ch]
  _bstr_t v81; // [esp+24h] [ebp-1638h]
  _bstr_t v82; // [esp+28h] [ebp-1634h]
  DWORD pdwValue5; // [esp+2Ch] [ebp-1630h]
  char v84[5]; // [esp+33h] [ebp-1629h]
  LPARAM lParam; // [esp+38h] [ebp-1624h]
  HANDLE hObject; // [esp+3Ch] [ebp-1620h]
  LPCWSTR lpString; // [esp+40h] [ebp-161Ch]
  EventItem v88; // [esp+44h] [ebp-1618h]
  WCHAR DateStr; // [esp+860h] [ebp-DFCh]
  WCHAR v90; // [esp+A60h] [ebp-BFCh]
  WCHAR Dest; // [esp+C4Ch] [ebp-A10h]
  WCHAR String; // [esp+E4Ch] [ebp-810h]
  int v93; // [esp+1658h] [ebp-4h]

  v4 = hWnd;
  *&v84[1] = hWnd;
  v88.field_4 = a3;
  lParam = dwNewLong;
  v5 = GetWindowLongW(hWnd, -21);
  v6 = 0;
  lpString = v5;
  v88.strEventTrace.m_Data = 0;
  v93 = 0;
  switch ( a2 )
  {
    case 0x110u:
      v7 = operator new(0x40u);
      pdwValue5 = v7;
      LOBYTE(v93) = 1;
      if ( v7 )
        v8 = CResizer::CResizer(v7, hWnd);
      else
        v8 = 0;
      v88.field_4 = v8;
      LOBYTE(v93) = 0;
      v8->m_nXRatio = 85;
      v8->m_nYRatio = 100;
      v9 = GetDlgItem(hWnd, IDC_DLG_DLLINFO_EDIT_PATH);
      if ( v9 )
      {
        v10 = CResizer::AddItem(v88.field_4, v9, 1);
        *&v10->m_rect1.left = 0i64;
        *&v10->m_rect1.right = db_one;
      }
      v11 = GetDlgItem(hWnd, 1656);
      if ( v11 )
      {
        v12 = CResizer::AddItem(v88.field_4, v11, 1);
        *&v12->m_rect1.left = 0i64;
        *&v12->m_rect1.right = db_one;
      }
      SetWindowLongW(hWnd, -21, dwNewLong);
      wsprintfW(&String, L"%s(%08X) (netsvcs) Properties", dwNewLong[1].field_14, dwNewLong[1].field_1C);
      SetWindowTextW(hWnd, &String);
      v13 = (dwNewLong[1].field_0 & 0x100) == 0;
      lpString = dwNewLong[19].field_20;
      if ( !v13 )
        SetDlgItemTextW(hWnd, 106, L"Path (Image is probably packed):");
      hObject = PE_OpenProcess(0x2000000u, 0, dwNewLong[1].field_1C);
      QueryProcessArguments(hObject, dwNewLong[1].field_1C, &v88.guid, &v88.field_4, &pdwValue5, v84);
      v14 = dwNewLong[20].field_0;
      dwNewLong[20].field_0 = v88.guid.Data1;
      free(v14);
      v15 = dwNewLong[20].field_4;
      dwNewLong[20].field_4 = v88.field_4;
      free(v15);
      v16 = dwNewLong[20].field_8;
      dwNewLong[20].field_8 = pdwValue5;
      free(v16);
      SetDlgItemTextW(hWnd, 1032, dwNewLong[20].field_0);
      SetDlgItemTextW(hWnd, 1035, dwNewLong[20].field_4);
      v17 = L"n/a";
      v18 = L"n/a";
      if ( lpString )
        v18 = lpString;
      SetDlgItemTextW(hWnd, 1015, v18);
      SetDlgItemTextW(hWnd, 1190, *(lParam + 796));
      if ( *(lParam + 828) )
        v17 = *(lParam + 828);
      SetDlgItemTextW(hWnd, 1656, v17);
      v19 = lpString != 0;
      v20 = GetDlgItem(hWnd, 1307);
      EnableWindow(v20, v19);
      v21 = lParam;
      v22 = *(lParam + 828) != 0;
      v23 = GetDlgItem(hWnd, 1306);
      EnableWindow(v23, v22);
      v24 = GetDlgItem(hWnd, 1195);
      ShowWindow(v24, 0);
      if ( gbIsProcessDEPEnabled )
      {
        Fake_GetProcessMitigationPolicy(v21, hObject);
        v25 = *(v21 + 636);
        if ( v25 == -1 )
        {
          wcscpy_s(&String, 0x400u, L"n/a");
        }
        else
        {
          if ( v25 & 1 )
            wcscpy_s(&String, 0x400u, L"Enabled");
          else
            wcscpy_s(&String, 0x400u, L"Disabled");
          if ( v25 & 8 )
            wcscat_s(&String, 0x400u, L" (permanent)");
        }
        v4 = *&v84[1];
        SetDlgItemTextW(*&v84[1], 1202, &String);
      }
      else
      {
        v26 = GetDlgItem(hWnd, 1203);
        ShowWindow(v26, 0);
        v27 = GetDlgItem(hWnd, 1202);
        ShowWindow(v27, 0);
      }
      if ( gdwVersion >= 3 && hObject )
      {
        if ( sub_FDF5C0(hObject, 1, &v88.field_4, 4) )
        {
          _bstr_t::operator=(&v88, &gszNullString);
          v28 = v88.field_4;
          if ( v88.field_4 & 8 )
          {
            _bstr_t::_bstr_t(&v88.guid, L"Disallow-Stripped");
            LOBYTE(v93) = 2;
            _bstr_t::operator+=(&v88.strEventTrace, &v88.guid);
            LOBYTE(v93) = 0;
            _bstr_t::_Free(&v88.guid);
            v28 = v88.field_4;
          }
          if ( v28 & 4 )
          {
            if ( sub_F80440(&v88) )
            {
              _bstr_t::_bstr_t(&v88.guid, L", ");
              LOBYTE(v93) = 3;
              _bstr_t::operator+=(&v88.strEventTrace, &v88.guid);
              LOBYTE(v93) = 0;
              _bstr_t::_Free(&v88.guid);
            }
            _bstr_t::_bstr_t(&v88.guid, L"High-Entropy");
            LOBYTE(v93) = 4;
            _bstr_t::operator+=(&v88.strEventTrace, &v88.guid);
            LOBYTE(v93) = 0;
            _bstr_t::_Free(&v88.guid);
            v28 = v88.field_4;
          }
          if ( v28 & 1 )
          {
            if ( sub_F80440(&v88) )
            {
              _bstr_t::_bstr_t(&v88.guid, L", ");
              LOBYTE(v93) = 5;
              _bstr_t::operator+=(&v88.strEventTrace, &v88.guid);
              LOBYTE(v93) = 0;
              _bstr_t::_Free(&v88.guid);
            }
            _bstr_t::_bstr_t(&v88.guid, L"Bottom-Up");
            LOBYTE(v93) = 6;
            _bstr_t::operator+=(&v88.strEventTrace, &v88.guid);
            LOBYTE(v93) = 0;
            _bstr_t::_Free(&v88.guid);
            v28 = v88.field_4;
          }
          if ( v28 & 2 )
          {
            if ( sub_F80440(&v88) )
            {
              _bstr_t::_bstr_t(&v88.guid, L", ");
              LOBYTE(v93) = 7;
              _bstr_t::operator+=(&v88.strEventTrace, &v88.guid);
              LOBYTE(v93) = 0;
              _bstr_t::_Free(&v88.guid);
            }
            _bstr_t::_bstr_t(&v88.guid, L"Force-Relocate");
            LOBYTE(v93) = 8;
            _bstr_t::operator+=(&v88.strEventTrace, &v88.guid);
            LOBYTE(v93) = 0;
            _bstr_t::_Free(&v88.guid);
          }
          if ( sub_F80440(&v88) )
          {
            v6 = v88.strEventTrace.m_Data;
            if ( v88.strEventTrace.m_Data )
              wcscpy_s(&String, 0x400u, v88.strEventTrace.m_Data->m_wstr);
            else
              wcscpy_s(&String, 0x400u, 0);
          }
          else
          {
            wcscat_s(&String, 0x400u, L"Disabled");
            v6 = v88.strEventTrace.m_Data;
          }
        }
        else
        {
          sub_FDBE70(&String, 0x400u);
        }
      }
      else
      {
        if ( gdwVersion < 1 )
        {
          v29 = GetDlgItem(v4, 1204);
          ShowWindow(v29, 0);
          v30 = GetDlgItem(v4, 1205);
          ShowWindow(v30, 0);
          goto LABEL_56;
        }
        if ( *(v21 + 650) & 0x40 )
        {
          wcscpy_s(&String, 0x400u, L"Enabled");
        }
        else if ( *(v21 + 648) )
        {
          wcscpy_s(&String, 0x400u, L"Disabled");
        }
        else
        {
          wcscpy_s(&String, 0x400u, L"n/a");
        }
      }
      SetDlgItemTextW(v4, 1205, &String);
LABEL_56:
      if ( gdwVersion < 4 )
      {
        v31 = GetDlgItem(v4, 1666);
        ShowWindow(v31, 0);
      }
      else
      {
        if ( *(v21 + 650) & 0x4000 )
        {
          wcscpy_s(&String, 0x400u, L"Enabled");
        }
        else if ( *(v21 + 648) && *(v21 + 650) )
        {
          wcscpy_s(&String, 0x400u, L"Disabled");
        }
        else
        {
          wcscpy_s(&String, 0x400u, L"n/a");
        }
        SetDlgItemTextW(v4, 1666, &String);
      }
      if ( hObject )
        CloseHandle(hObject);
      if ( *(v21 + 784) )
      {
        _bstr_t::_bstr_t(&hObject, *(v21 + 784));
        v13 = *(v21 + 824) == 0;
        LOBYTE(v93) = 9;
        if ( !v13 )
        {
          _bstr_t::_bstr_t(&v88.guid, L")");
          v32 = *(v21 + 824);
          LOBYTE(v93) = 10;
          v33 = _bstr_t::_bstr_t(&v81, v32);
          LOBYTE(v93) = 11;
          v34 = _bstr_t::_bstr_t(&v79, L" (");
          LOBYTE(v93) = 12;
          v35 = _bstr_t::operator+(v34, &v82, v33);
          LOBYTE(v93) = 13;
          v36 = _bstr_t::operator+(&v35->m_Data, &v80, &v88.guid);
          LOBYTE(v93) = 14;
          _bstr_t::operator+=(&hObject, v36);
          _bstr_t::_Free(&v80);
          _bstr_t::_Free(&v82);
          _bstr_t::_Free(&v79);
          _bstr_t::_Free(&v81);
          _bstr_t::_Free(&v88.guid);
          v21 = lParam;
        }
        if ( hObject )
          v37 = *hObject;
        else
          v37 = 0;
        SetDlgItemTextW(v4, 1183, v37);
        LOBYTE(v93) = 0;
        _bstr_t::_Free(&hObject);
      }
      v38 = VerifyImage(v21, gConfig.bVerifySignatures);
      SetDlgItemTextW(v4, 3, v38);
      v39 = GetDlgItem(v4, 1672);
      SetWindowSubclass(v39, EditVTClassCallback, 0, 0);
      sub_1001A50(*(v21 + 844), &String);
      SetDlgItemTextW(v4, 1672, &String);
      v40 = *(v21 + 792);
      if ( v40 && *v40 != 91 )
      {
        v41 = sub_1001C10(*(v21 + 844));
        v42 = GetDlgItem(v4, 1671);
        EnableWindow(v42, v41);
      }
      if ( gbWintrustInited )
      {
        if ( *(v21 + 832) || (v44 = *(v21 + 792)) == 0 || *v44 == 91 )
        {
          v45 = GetDlgItem(v4, 1005);
          EnableWindow(v45, 0);
        }
      }
      else
      {
        v43 = GetDlgItem(v4, 1005);
        ShowWindow(v43, 0);
      }
      wsprintfW(&String, L"n/a");
      if ( lpString )
      {
        v84[1] = unknown_libname_2(255);
        v46 = GetFileVersionInfoSizeW(lpString, &dwHandle);
        v88.guid.Data1 = malloc(v46);
        if ( GetFileVersionInfoW(lpString, 0, v46, v88.guid.Data1) )
        {
          v47 = v88.guid.Data1;
          sub_FD9660(*(v88.guid.Data1 + 52), *(v88.guid.Data1 + 48), &String);
        }
        else
        {
          wsprintfW(&String, L"n/a");
          v47 = v88.guid.Data1;
        }
        free(v47);
        unknown_libname_2(v84[1]);
        v21 = lParam;
      }
      SetDlgItemTextW(v4, 25, &String);
      if ( *(v21 + 640) )
        v48 = _wctime32((v21 + 640));
      else
        v48 = L"n/a";
      SetDlgItemTextW(v4, 30, v48);
      v49 = *(v21 + 56);
      if ( !v49 )
        v49 = LoadIconW(0, 0x7F00);
      v50 = v49;
      v51 = GetDlgItem(v4, 1033);
      SendMessageW(v51, 0x172u, 1u, v50);
      v52 = *(v21 + 56);
      if ( !v52 )
        v52 = LoadIconW(0, 0x7F00);
      v53 = v52;
      v54 = GetParent(v4);
      SendMessageW(v54, 0x80u, 1u, v53);
      if ( *(v21 + 56) )
        v55 = *(v21 + 52);
      else
        v55 = LoadIconW(0, 0x7F00);
      v56 = v55;
      v57 = GetParent(v4);
      SendMessageW(v57, 0x80u, 0, v56);
      SetDlgItemTextW(v4, 35, *(v21 + 72));
      wsprintfW(&String, L"%d K", *(v21 + 900) >> 10);
      SetDlgItemTextW(v4, 1008, &String);
      wsprintfW(&String, L"%d K", *(v21 + 888) >> 10);
      SetDlgItemTextW(v4, 1009, &String);
      if ( *(v21 + 624) )
      {
        FileTimeToLocalFileTime((v21 + 624), &LocalFileTime);
        FileTimeToSystemTime(&LocalFileTime, &v88.guid.Data2);
        GetTimeFormatW(0x400u, 0, &v88.guid.Data2, 0, &String, 512);
        GetDateFormatW(0x400u, 0, &v88.guid.Data2, 0, &DateStr, 128);
        wcscat_s(&String, 0x400u, L"   ");
        wcscat_s(&String, 0x400u, &DateStr);
      }
      else
      {
        wcscpy_s(&String, 0x400u, L"n/a");
      }
      SetDlgItemTextW(v4, 1007, &String);
      SetDlgItemTextW(v4, 19, *(v21 + 88));
      PropSheet_UpdateTab(v4);
      ShowWindow(v4, 1);
      goto LABEL_141;
    case 0x111u:
      if ( LOWORD(v88.field_4) > 1306 )
      {
        if ( LOWORD(v88.field_4) > 40001 )
        {
          if ( LOWORD(v88.field_4) == 40002 )
          {
            SetEvent(ghRefreshEventHandle);
            return 0;
          }
          if ( LOWORD(v88.field_4) - 40092 > 1 )
            return 0;
          v76 = v88.field_4;
        }
        else
        {
          if ( LOWORD(v88.field_4) != 40001 )
          {
            if ( LOWORD(v88.field_4) == 1307 )
            {
              sub_FAB780(hWnd, *(v5 + 792));
              goto LABEL_141;
            }
            if ( LOWORD(v88.field_4) != 1671 )
              return 0;
            if ( SubmitExeToVirusTotalDotCom() )
            {
              v69 = lpString;
              v70 = 0;
              v71 = *(lpString + 211);
              if ( v71 )
              {
                v70 = 1;
                *(v71 + 4) = 6;
              }
              sub_1001C30(v69, 1, v70 != 0);
              v72 = sub_1001C10(*(v69 + 211));
              v73 = GetDlgItem(hWnd, 1671);
              EnableWindow(v73, v72);
              sub_1001A50(*(v69 + 211), &Dest);
              SetDlgItemTextW(hWnd, 1672, &Dest);
              PostMessageW(ghMainWnd, 0x7F9u, 0, *(v69 + 211));
            }
            goto LABEL_141;
          }
          v76 = 40014;
        }
        v75 = GetParent(hWnd);
        PostMessageW(v75, 0x111u, v76, 0);
        return 0;
      }
      if ( LOWORD(v88.field_4) == 1306 )
      {
        sub_FAB780(hWnd, *(v5 + 828));
        goto LABEL_141;
      }
      if ( LOWORD(v88.field_4) > 1004 )
      {
        if ( LOWORD(v88.field_4) == 1005 )
        {
          v67 = VerifyImage(v5, 1);
          SetDlgItemTextW(hWnd, 3, v67);
          v68 = GetDlgItem(hWnd, 1005);
          EnableWindow(v68, 0);
          goto LABEL_141;
        }
        if ( LOWORD(v88.field_4) == 1160 )
        {
          v65 = *(v5 + 68);
          v66 = GetParent(hWnd);
          sub_FC6B90(v66, 40084, v65);
          RefreshMenuWithTreeViewItemStatus(lpString);
          goto LABEL_141;
        }
        return 0;
      }
      switch ( LOWORD(v88.field_4) )
      {
        case 0x3ECu:
          if ( sub_FF8030(*(v5 + 60), *(v5 + 68)) )
          {
            v64 = GetParent(hWnd);
            PostMessageW(v64, 0x471u, 5u, 0);
          }
          break;
        case 1u:
          GetDlgItemTextW(hWnd, 1190, &v88.List._Mysize, 1024);
          v62 = *(lpString + 199);
          if ( !v62 )
            goto LABEL_159;
          v63 = wcscmp(&v88.List._Mysize, v62);
          if ( v63 )
            v63 = -(v63 < 0) | 1;
          if ( v63 )
LABEL_159:
            sub_FC62A0(lpString, &v88.List._Mysize);
          break;
        case 2u:
          break;
        default:
          return 0;
      }
LABEL_141:
      v61 = 1;
LABEL_142:
      if ( v6 && !InterlockedDecrement(&v6->m_RefCount) )
      {
        if ( v6->m_wstr )
        {
          SysFreeString(v6->m_wstr);
          v6->m_wstr = 0;
        }
        if ( v6->m_str )
        {
          j_j__free(v6->m_str);
          v6->m_str = 0;
        }
        j__free(v6);
      }
      return v61;
    case 0x113u:
      GetDlgItemTextW(hWnd, 1672, &v90, 245);
      sub_1001A50(*(lpString + 211), &Dest);
      v58 = wcscmp(&v90, &Dest);
      if ( v58 )
        v58 = -(v58 < 0) | 1;
      if ( v58 )
      {
        SetDlgItemTextW(hWnd, 1672, &Dest);
        v59 = sub_1001C10(*(lpString + 211));
        v60 = GetDlgItem(hWnd, 1671);
        EnableWindow(v60, v59);
      }
      goto LABEL_141;
    case 0x133u:
    case 0x136u:
      goto LABEL_112;
    case 0x138u:
      if ( dwNewLong == GetDlgItem(hWnd, 1672) && sub_1001820(*(lpString + 211)) )
      {
        if ( sub_1002910(*(lpString + 211)) )
          SetTextColor(v88.field_4, 0xFFu);
        else
          SetTextColor(v88.field_4, 0xFF0000u);
        SelectObject(v88.field_4, ghDefaultUnderlineFontHandle);
        v61 = GetSysColorBrush(20);
      }
      else
      {
LABEL_112:
        v61 = PE_FillControl(hWnd, v88.field_4);
      }
      goto LABEL_142;
    default:
      return 0;
  }
}
// FC5410: using guessed type _DWORD __cdecl unknown_libname_2(char);
// 1064E54: using guessed type int gdwVersion;
// 106A390: using guessed type char gbIsProcessDEPEnabled;
// 106A391: using guessed type char gbWintrustInited;

//----- (00FE3C50) --------------------------------------------------------
int __stdcall PageProcJob(HWND hWnd, int a2, WPARAM wParam, LONG dwNewLong)
{
  CResizer *v4; // eax
  void (__stdcall *v5)(HANDLE); // edi
  HWND v6; // edi
  LONG v7; // eax
  LRESULT (__stdcall *v8)(HWND, UINT, WPARAM, LPARAM); // esi
  DWORD *v9; // edi
  DWORD v10; // esi
  DWORD *v11; // eax
  HWND v12; // eax
  LRESULT v13; // eax
  HWND v14; // eax
  HWND v15; // ebx
  LONG v16; // eax
  HWND v17; // eax
  __int16 v18; // ax
  HANDLE v19; // esi
  char v20; // al
  void *v21; // edi
  DWORD v22; // esi
  int result; // eax
  HWND v24; // eax
  WPARAM v25; // [esp-8h] [ebp-1174h]
  LPARAM v26; // [esp+10h] [ebp-115Ch]
  int v27; // [esp+1Ch] [ebp-1150h]
  int v28; // [esp+20h] [ebp-114Ch]
  LPARAM lParam; // [esp+44h] [ebp-1128h]
  LRESULT v30; // [esp+48h] [ebp-1124h]
  int v31; // [esp+4Ch] [ebp-1120h]
  int v32; // [esp+50h] [ebp-111Ch]
  int v33; // [esp+54h] [ebp-1118h]
  wchar_t *v34; // [esp+58h] [ebp-1114h]
  int v35; // [esp+60h] [ebp-110Ch]
  HWND v36; // [esp+64h] [ebp-1108h]
  UINT v37; // [esp+78h] [ebp-10F4h]
  int v38; // [esp+7Ch] [ebp-10F0h]
  UINT pnIDs; // [esp+80h] [ebp-10ECh]
  int v40; // [esp+84h] [ebp-10E8h]
  DWORD dwValue4; // [esp+88h] [ebp-10E4h]
  HANDLE v42; // [esp+8Ch] [ebp-10E0h]
  WORD pnWidths[2]; // [esp+90h] [ebp-10DCh]
  _DWORD *v44; // [esp+94h] [ebp-10D8h]
  HANDLE hObject; // [esp+98h] [ebp-10D4h]
  HWND v46; // [esp+9Ch] [ebp-10D0h]
  HWND v47; // [esp+A0h] [ebp-10CCh]
  size_t ReturnLength; // [esp+A4h] [ebp-10C8h]
  int v49; // [esp+A8h] [ebp-10C4h]
  __int64 JobObjectInformation; // [esp+ACh] [ebp-10C0h]
  __int64 v51; // [esp+B4h] [ebp-10B8h]
  int v52; // [esp+BCh] [ebp-10B0h]
  unsigned int v53; // [esp+C0h] [ebp-10ACh]
  unsigned int v54; // [esp+C4h] [ebp-10A8h]
  char ArgList[4]; // [esp+C8h] [ebp-10A4h]
  char v56[4]; // [esp+CCh] [ebp-10A0h]
  char v57[4]; // [esp+D0h] [ebp-109Ch]
  char v58[4]; // [esp+D4h] [ebp-1098h]
  unsigned int v59; // [esp+10Ch] [ebp-1060h]
  unsigned int v60; // [esp+110h] [ebp-105Ch]
  wchar_t pszText; // [esp+11Ch] [ebp-1050h]
  wchar_t Dst; // [esp+91Ch] [ebp-850h]
  wchar_t v63; // [esp+111Ch] [ebp-50h]
  int v64; // [esp+1168h] [ebp-4h]

  GetWindowLongW(hWnd, -21);
  lParam = 0;
  memset(&v30, 0, 0x30u);
  pnIDs = 3;
  v40 = 4;
  v37 = 1075;
  v38 = 1058;
  pnWidths[0] = MulDiv(100, gLogPixelSize.x, 96);
  pnWidths[1] = MulDiv(100, gLogPixelSize.x, 96);
  if ( a2 > 0x111 )
  {
    if ( a2 == 307 || a2 == 310 || a2 == 312 )
      return PE_FillControl(hWnd, wParam);
    return 0;
  }
  switch ( a2 )
  {
    case 273:
      switch ( wParam )
      {
        case 0x9C41u:
          v25 = 40014;
          goto LABEL_90;
        case 0x9C42u:
          SetEvent(ghRefreshEventHandle);
          result = 0;
          break;
        case 0x9C9Cu:
        case 0x9C9Du:
          v25 = wParam;
LABEL_90:
          v24 = GetParent(hWnd);
          PostMessageW(v24, 0x111u, v25, 0);
          result = 0;
          break;
        default:
          return 0;
      }
      return result;
    case 43:
      CMainWnd::DrawList(dwNewLong);
      return 0;
    case 44:
      return CMainWnd::HandleMeasureItem(hWnd, 0x2Cu, wParam, dwNewLong);
  }
  if ( a2 != 272 )
    return 0;
  v4 = operator new(0x40u);
  v42 = v4;
  v64 = 0;
  if ( v4 )
    CResizer::CResizer(v4, hWnd);
  v64 = -1;
  PropSheet_UpdateTab(hWnd);
  SetWindowLongW(hWnd, -21, dwNewLong);
  QuerySystemHandleInfo(1u);
  v42 = PE_OpenProcess(0x2000000u, 0, *(dwNewLong + 68));
  v5 = CloseHandle;
  if ( PE_IsProcessInJob(v42, *(dwNewLong + 68), &hObject, &dwValue4) )
  {
    if ( *dwValue4 )
      SetDlgItemTextW(hWnd, 1075, dwValue4);
    else
      SetDlgItemTextW(hWnd, 1075, L"<Unnamed Job>");
    v6 = GetDlgItem(hWnd, 1076);
    v46 = v6;
    v7 = GetWindowLongW(v6, -16);
    SetWindowLongW(v6, -16, v7 & 0xFFFFFFFD | 1);
    v8 = SendMessageW;
    SendMessageW(v6, 0x1036u, 0x4020u, 16416);
    gOldListWndProc = SetWindowLongW(v6, -4, Proxy_ListCtrlWndProc);
    SendMessageW(v6, 0x30u, ghConfigFont, 0);
    CTreeView::InitListHeader(v6, &pnIDs, pnWidths, 2u);
    ReturnLength = 1200;
    v9 = malloc(0x4B0u);
    if ( !QueryInformationJobObject(hObject, JobObjectBasicProcessIdList, v9, 0x4B0u, &ReturnLength) )
    {
      do
      {
        if ( GetLastError() != 24 )
          break;
        free(v9);
        v10 = ReturnLength;
        v9 = malloc(ReturnLength);
      }
      while ( !QueryInformationJobObject(hObject, JobObjectBasicProcessIdList, v9, v10, &ReturnLength) );
      v8 = SendMessageW;
    }
    if ( v9 )
    {
      v47 = 0;
      if ( v9[1] )
      {
        v11 = v9 + 2;
        v44 = v9 + 2;
        do
        {
          SystemProcessInfo_GetSystemProcessName(*v11, 0, &pszText, 0x400u);
          wsprintf_s(&v63, L"%d", *v44);
          lParam = 5;
          v34 = &pszText;
          v12 = (v47 + 1);
          v30 = 0x7FFFFFFF;
          v47 = v12;
          v36 = v12;
          v31 = 0;
          v33 = 0;
          v32 = 0;
          v35 = 0;
          v13 = v8(v46, 0x104Du, 0, &lParam);
          if ( v13 == -1 )
            return 0;
          v30 = v13;
          v34 = &v63;
          lParam = 1;
          v31 = 1;
          v8(v46, 0x104Cu, 0, &lParam);
          v11 = v44 + 1;
          ++v44;
        }
        while ( v47 < v9[1] );
      }
      v8(v46, 0x101Eu, 0, 0xFFFF);
      v8(v46, 0x101Eu, 1u, 65534);
      v28 = 3;
      v27 = 3;
      v8(v46, 0x102Bu, 0, &v26);
      SetFocus(v46);
      free(v9);
    }
    v14 = GetDlgItem(hWnd, 1077);
    v15 = v14;
    v47 = v14;
    v16 = GetWindowLongW(v14, -16);
    SetWindowLongW(v15, -16, v16 & 0xFFFFFFFD | 1);
    v8(v15, 0x1036u, 0x4020u, 16416);
    v17 = v8(v15, 0x104Eu, 0, 0);
    CTreeList::InitToolTips(v17);
    gOldListWndProc = SetWindowLongW(v15, -4, Proxy_ListCtrlWndProc);
    v8(v15, 0x30u, ghConfigFont, 0);
    CTreeView::InitListHeader(v15, &v37, pnWidths, 2u);
    QueryInformationJobObject(
      hObject,
      MaxJobObjectInfoClass|JobObjectBasicAccountingInformation,
      &JobObjectInformation,
      0x70u,
      &ReturnLength);
    v18 = v52;
    if ( v52 & 0x2000 )
    {
      sub_FF7F90(v15, L"Kill on Job Close", L"True");
      v18 = v52;
    }
    if ( v18 & 0x400 )
    {
      sub_FF7F90(v15, L"Die on Unhandled Exception", L"True");
      v18 = v52;
    }
    if ( v18 & 0x800 )
    {
      sub_FF7F90(v15, L"Breakaway OK", L"True");
      v18 = v52;
    }
    if ( v18 & 0x1000 )
    {
      sub_FF7F90(v15, L"Silent Breakaway OK", L"True");
      v18 = v52;
    }
    if ( v18 & 0x40 )
    {
      sub_FF7F90(v15, L"Preserve Job Time", L"True");
      v18 = v52;
    }
    if ( v18 & 0x4000 )
    {
      sub_FF7F90(v15, L"Subset Affinity Allowed", L"True");
      v18 = v52;
    }
    if ( v18 & 2 )
    {
      wsprintfW(&Dst, L"%I64d s", JobObjectInformation / 10000000);
      sub_FF7F90(v15, L"Process CPU Limit", &Dst);
      v18 = v52;
    }
    if ( v18 & 4 )
    {
      wsprintfW(&Dst, L"%I64d s", v51 / 10000000);
      sub_FF7F90(v15, L"User CPU Limit", &Dst);
      v18 = v52;
    }
    if ( v18 & 1 )
    {
      wsprintfW(&Dst, L"%d", v53 >> 10);
      sub_FC3290(&Dst, 0x400u);
      wcscat_s(&Dst, 0x400u, L" KB");
      sub_FF7F90(v15, L"Min Working Set", &Dst);
      v18 = v52;
      if ( v52 & 1 )
      {
        wsprintfW(&Dst, L"%d", v54 >> 10);
        sub_FC3290(&Dst, 0x400u);
        wcscat_s(&Dst, 0x400u, L" KB");
        sub_FF7F90(v15, L"Max Working Set", &Dst);
        v18 = v52;
      }
    }
    if ( v18 & 0x100 )
    {
      wsprintfW(&Dst, L"%d", v59 >> 10);
      sub_FC3290(&Dst, 0x400u);
      wcscat_s(&Dst, 0x400u, L" KB");
      sub_FF7F90(v15, L"Process Memory Limit", &Dst);
      v18 = v52;
    }
    if ( v18 & 0x200 )
    {
      wsprintfW(&Dst, L"%d", v60 >> 10);
      sub_FC3290(&Dst, 0x400u);
      wcscat_s(&Dst, 0x400u, L" KB");
      sub_FF7F90(v15, L"Job Memory Limit", &Dst);
      LOBYTE(v18) = v52;
    }
    if ( v18 & 8 )
    {
      wsprintfW(&Dst, L"%d", *ArgList);
      sub_FF7F90(v15, L"Active Processes", &Dst);
      LOBYTE(v18) = v52;
    }
    if ( v18 & 0x10 )
    {
      wsprintfW(&Dst, L"%x", *v56);
      sub_FF7F90(v15, L"Affinity", &Dst);
      LOBYTE(v18) = v52;
    }
    if ( v18 & 0x20 )
    {
      wsprintfW(&Dst, L"%d", *v57);
      sub_FF7F90(v15, L"Priority Class", &Dst);
      LOBYTE(v18) = v52;
    }
    if ( (v18 & 0x80u) != 0 )
    {
      wsprintfW(&Dst, L"%d", *v58);
      sub_FF7F90(v15, L"Scheduling Class", &Dst);
      LOBYTE(v18) = v52;
    }
    if ( v18 & 4 )
    {
      wsprintfW(
        &Dst,
        L"%I64d:%02I64d:%02I64d.%03I64d",
        v51 / 0x861C46800ui64,
        v51 / 0x23C34600ui64 % 0x3C,
        v51 / 10000000 % 60,
        v51 % 10000000 / 10000);
      v15 = v47;
      sub_FF7F90(v47, L"Job Time", &Dst);
      LOBYTE(v18) = v52;
    }
    if ( v18 & 2 )
    {
      wsprintfW(
        &Dst,
        L"%I64d:%02I64d:%02I64d.%03I64d",
        JobObjectInformation / 0x861C46800ui64,
        JobObjectInformation / 0x23C34600ui64 % 0x3C,
        JobObjectInformation / 10000000 % 60,
        JobObjectInformation % 10000000 / 10000);
      v15 = v47;
      sub_FF7F90(v47, L"Process Time", &Dst);
    }
    v19 = hObject;
    QueryInformationJobObject(hObject, JobObjectBasicUIRestrictions, &v49, 4u, &ReturnLength);
    v20 = v49;
    if ( v49 & 0x40 )
    {
      sub_FF7F90(v15, L"Desktop", L"Limited");
      v20 = v49;
    }
    if ( v20 & 0x10 )
    {
      sub_FF7F90(v15, L"Display Settings", L"Limited");
      v20 = v49;
    }
    if ( v20 < 0 )
    {
      sub_FF7F90(v15, L"Exit Windows", L"Limited");
      v20 = v49;
    }
    if ( v20 & 0x20 )
    {
      sub_FF7F90(v15, L"Global Atoms", L"Limited");
      v20 = v49;
    }
    if ( v20 & 1 )
    {
      sub_FF7F90(v15, L"USER Handles", L"Limited");
      v20 = v49;
    }
    if ( v20 & 2 )
    {
      sub_FF7F90(v15, L"Read Clipboard", L"Limited");
      v20 = v49;
    }
    if ( v20 & 8 )
    {
      sub_FF7F90(v15, L"System Parameters", L"Limited");
      v20 = v49;
    }
    if ( v20 & 4 )
      sub_FF7F90(v15, L"Write Clipboard", L"Limited");
    ReturnLength = 2000;
    v21 = malloc(0x7D0u);
    if ( !QueryInformationJobObject(v19, JobObjectSecurityLimitInformation, v21, 0x7D0u, &ReturnLength) )
    {
      do
      {
        if ( GetLastError() != 24 )
          break;
        free(v21);
        v22 = ReturnLength;
        v21 = malloc(ReturnLength);
      }
      while ( !QueryInformationJobObject(hObject, JobObjectSecurityLimitInformation, v21, v22, &ReturnLength) );
    }
    if ( v49 & 1 )
      sub_FF7F90(v15, L"Administrator Access", L"Limited");
    free(v21);
    if ( SendMessageW(v15, 0x1004u, 0, 0) )
    {
      SendMessageW(v15, 0x101Eu, 0, 0xFFFF);
      SendMessageW(v15, 0x101Eu, 1u, 65534);
      v28 = 3;
      v27 = 3;
      SendMessageW(v15, 0x102Bu, 0, &v26);
    }
    v5 = CloseHandle;
    CloseHandle(hObject);
    free(dwValue4);
  }
  else
  {
    SetDlgItemTextW(hWnd, 1075, L"<Access denied>");
  }
  if ( v42 )
    v5(v42);
  return 1;
}
// 103BDE8: using guessed type wchar_t aDesktop_0[8];
// 1045C9C: using guessed type wchar_t aTrue_1[5];
// 1045CA8: using guessed type wchar_t aKillOnJobClose[18];
// 1045CCC: using guessed type wchar_t aDieOnUnhandled[27];
// 1045D04: using guessed type wchar_t aBreakawayOk[13];
// 1045D20: using guessed type wchar_t aSilentBreakawa[20];
// 1045D48: using guessed type wchar_t aPreserveJobTim[18];
// 1045D6C: using guessed type wchar_t aSubsetAffinity[24];
// 1045DAC: using guessed type wchar_t aProcessCpuLimi[18];
// 1045DD0: using guessed type wchar_t aUserCpuLimit[15];
// 1045DF0: using guessed type wchar_t aMinWorkingSet[16];
// 1045E10: using guessed type wchar_t aMaxWorkingSet[16];
// 1045E30: using guessed type wchar_t aProcessMemoryL[21];
// 1045E5C: using guessed type wchar_t aJobMemoryLimit[17];
// 1045E80: using guessed type wchar_t aActiveProcesse[17];
// 1045EAC: using guessed type wchar_t aAffinity[9];
// 1045EC0: using guessed type wchar_t aPriorityClass[15];
// 1045EE0: using guessed type wchar_t aSchedulingClas[17];
// 1045F04: using guessed type wchar_t aJobTime[9];
// 1045F18: using guessed type wchar_t aProcessTime[13];
// 1045F34: using guessed type wchar_t aLimited[8];
// 1045F44: using guessed type wchar_t aDisplaySetting[17];
// 1045F68: using guessed type wchar_t aExitWindows[13];
// 1045F84: using guessed type wchar_t aGlobalAtoms[13];
// 1045FA0: using guessed type wchar_t aUserHandles[13];
// 1045FBC: using guessed type wchar_t aReadClipboard[15];
// 1045FDC: using guessed type wchar_t aSystemParamete[18];
// 1046000: using guessed type wchar_t aWriteClipboard[16];
// 1046020: using guessed type wchar_t aAdministratorA[21];

//----- (00FE4990) --------------------------------------------------------
int __stdcall PageProcGPU(HWND hWnd, int a2, WPARAM wParam, LONG dwNewLong)
{
  HWND v4; // eax
  int result; // eax
  CResizer *v6; // eax
  LONG v7; // eax
  HWND v8; // ebx
  HWND v9; // edi
  HWND v10; // esi
  HWND v11; // ebx
  HWND v12; // edi
  HWND v13; // esi
  HWND v14; // ebx
  HWND v15; // edi
  HWND v16; // esi
  HWND v17; // eax
  HWND v18; // eax
  HWND v19; // eax
  HWND v20; // eax
  HWND v21; // eax
  HWND v22; // eax
  HWND v23; // eax
  HWND v24; // eax
  HWND v25; // eax
  HWND v26; // eax
  HWND v27; // eax
  HWND v28; // eax
  WPARAM v29; // [esp-8h] [ebp-40h]
  CResizer *v30; // [esp+10h] [ebp-28h]
  HWND v31; // [esp+18h] [ebp-20h]
  HWND v32; // [esp+1Ch] [ebp-1Ch]
  HWND v33; // [esp+20h] [ebp-18h]
  HWND v34; // [esp+24h] [ebp-14h]
  int v35; // [esp+34h] [ebp-4h]

  GetWindowLongW(hWnd, -21);
  if ( a2 > 0x113 )
  {
    if ( a2 == 307 || a2 == 310 || a2 == 312 )
      return PE_FillControl(hWnd, wParam);
    return 0;
  }
  if ( a2 == 275 || a2 == 5 )
  {
    if ( IsWindowVisible(hWnd) )
    {
      v21 = GetDlgItem(hWnd, 1158);
      SendMessageW(v21, 0x400u, 0, 0);
      v22 = GetDlgItem(hWnd, 2000);
      SendMessageW(v22, 0x400u, 0, 0);
      v23 = GetDlgItem(hWnd, 1160);
      SendMessageW(v23, 0x400u, 0, 0);
      v24 = GetDlgItem(hWnd, 2601);
      SendMessageW(v24, 0x400u, 0, 0);
      v25 = GetDlgItem(hWnd, 1162);
      SendMessageW(v25, 0x400u, 0, 0);
      v26 = GetDlgItem(hWnd, 2602);
      SendMessageW(v26, 0x400u, 0, 0);
      v27 = GetDlgItem(hWnd, 1164);
      SendMessageW(v27, 0x400u, 0, 0);
      v28 = GetDlgItem(hWnd, 2603);
      SendMessageW(v28, 0x400u, 0, 0);
      return 0;
    }
    return 0;
  }
  if ( a2 == 272 )
  {
    v6 = operator new(0x40u);
    v35 = 0;
    if ( v6 )
      v30 = CResizer::CResizer(v6, hWnd);
    else
      v30 = 0;
    v35 = -1;
    v7 = GetWindowLongW(hWnd, -16);
    SetWindowLongW(hWnd, -16, v7 | 0x2000000);
    SetWindowLongW(hWnd, -21, dwNewLong);
    CreateGraphWindow(hWnd, 1158, *(dwNewLong + 1392));
    CreateGraphWindow(hWnd, 2000, *(dwNewLong + 1392));
    CreateGraphWindow(hWnd, 1160, *(dwNewLong + 1432));
    CreateGraphWindow(hWnd, 2601, *(dwNewLong + 1432));
    CreateGraphWindow(hWnd, 1162, *(dwNewLong + 1416));
    CreateGraphWindow(hWnd, 2602, *(dwNewLong + 1416));
    CreateGraphWindow(hWnd, 1164, *(dwNewLong + 1448));
    CreateGraphWindow(hWnd, 2603, *(dwNewLong + 1448));
    v8 = GetDlgItem(hWnd, 1659);
    v9 = GetDlgItem(hWnd, 1161);
    v10 = GetDlgItem(hWnd, 1159);
    v31 = GetDlgItem(hWnd, 1157);
    v32 = v10;
    v33 = v9;
    v34 = v8;
    sub_FF0550(v30, 4, &v31);
    v11 = GetDlgItem(hWnd, 1164);
    v12 = GetDlgItem(hWnd, 1162);
    v13 = GetDlgItem(hWnd, 1160);
    v31 = GetDlgItem(hWnd, 1158);
    v32 = v13;
    v33 = v12;
    v34 = v11;
    sub_FF0550(v30, 4, &v31);
    v14 = GetDlgItem(hWnd, 2603);
    v15 = GetDlgItem(hWnd, 2602);
    v16 = GetDlgItem(hWnd, 2601);
    v31 = GetDlgItem(hWnd, 2000);
    v33 = v15;
    v32 = v16;
    v34 = v14;
    sub_FF0550(v30, 4, &v31);
    v17 = GetDlgItem(hWnd, 1157);
    *&CResizer::AddItem(v30, v17, 1)->m_rect2.right = db_four;
    v18 = GetDlgItem(hWnd, 1159);
    *&CResizer::AddItem(v30, v18, 1)->m_rect2.right = db_four;
    v19 = GetDlgItem(hWnd, 1161);
    *&CResizer::AddItem(v30, v19, 1)->m_rect2.right = db_four;
    v20 = GetDlgItem(hWnd, 1659);
    *&CResizer::AddItem(v30, v20, 1)->m_rect2.right = db_four;
    PropSheet_UpdateTab(hWnd);
    SendMessageW(hWnd, 0x113u, 0, 0);
    return 1;
  }
  if ( a2 != 273 )
    return 0;
  switch ( wParam )
  {
    case 0x9C41u:
      v29 = 40014;
      goto LABEL_8;
    case 0x9C42u:
      SetEvent(ghRefreshEventHandle);
      result = 0;
      break;
    case 0x9C9Cu:
    case 0x9C9Du:
      v29 = wParam;
LABEL_8:
      v4 = GetParent(hWnd);
      PostMessageW(v4, 0x111u, v29, 0);
      result = 0;
      break;
    default:
      return 0;
  }
  return result;
}
// 103CB38: using guessed type double db_four;

//----- (00FE4E40) --------------------------------------------------------
signed int __stdcall PageProcPerf(HWND hWnd, unsigned int a2, HDC hdc, int a4)
{
  HWND v4; // ebx
  char *v5; // esi
  HICON v6; // ST50_4
  HWND v7; // eax
  char *v8; // esi
  HANDLE v9; // edi
  HWND v10; // eax
  HWND v11; // eax
  HWND v12; // eax
  signed int result; // eax
  HWND v14; // eax
  HANDLE v15; // edi
  void (__stdcall *v16)(HWND, int, LPCWSTR); // esi
  const WCHAR *v17; // eax
  const WCHAR *v18; // eax
  const WCHAR *v19; // eax
  const WCHAR *v20; // eax
  const WCHAR *v21; // eax
  const WCHAR *v22; // eax
  __m128i *v23; // eax
  const WCHAR *v24; // eax
  int v25; // ecx
  const WCHAR *v26; // ST50_4
  const WCHAR *v27; // eax
  const WCHAR *v28; // ST50_4
  char v29; // al
  const WCHAR *v30; // eax
  char v31; // al
  const WCHAR *v32; // eax
  signed __int64 v33; // [esp+4Ch] [ebp-500h]
  char v34; // [esp+54h] [ebp-4F8h]
  int v35; // [esp+60h] [ebp-4ECh]
  char ArgList[4]; // [esp+6Ch] [ebp-4E0h]
  struct _FILETIME LocalFileTime; // [esp+78h] [ebp-4D4h]
  char v38; // [esp+80h] [ebp-4CCh]
  _DWORD v39[2]; // [esp+84h] [ebp-4C8h]
  char v40[4]; // [esp+8Ch] [ebp-4C0h]
  char ProcessInformation[4]; // [esp+90h] [ebp-4BCh]
  char v42[4]; // [esp+94h] [ebp-4B8h]
  char v43[4]; // [esp+98h] [ebp-4B4h]
  int v44; // [esp+9Ch] [ebp-4B0h]
  unsigned int v45; // [esp+A0h] [ebp-4ACh]
  unsigned int v46; // [esp+A4h] [ebp-4A8h]
  HANDLE v47; // [esp+A8h] [ebp-4A4h]
  void *v48; // [esp+ACh] [ebp-4A0h]
  HWND hDlg; // [esp+B0h] [ebp-49Ch]
  ULONG ReturnLength; // [esp+B4h] [ebp-498h]
  char *v51; // [esp+B8h] [ebp-494h]
  struct _SYSTEMTIME SystemTime; // [esp+BCh] [ebp-490h]
  char v53[16]; // [esp+CCh] [ebp-480h]
  __int128 v54; // [esp+DCh] [ebp-470h]
  int v55; // [esp+ECh] [ebp-460h]
  unsigned int v56; // [esp+F0h] [ebp-45Ch]
  unsigned int v57; // [esp+F4h] [ebp-458h]
  char v58[16]; // [esp+F8h] [ebp-454h]
  char v59[16]; // [esp+108h] [ebp-444h]
  __int128 v60; // [esp+118h] [ebp-434h]
  FILETIME FileTime; // [esp+128h] [ebp-424h]
  unsigned __int64 v62; // [esp+138h] [ebp-414h]
  unsigned __int64 v63; // [esp+140h] [ebp-40Ch]
  WCHAR DateStr; // [esp+148h] [ebp-404h]
  WCHAR String; // [esp+348h] [ebp-204h]

  v4 = hWnd;
  hDlg = hWnd;
  v5 = GetWindowLongW(hWnd, -21);
  v48 = 0;
  v51 = v5;
  if ( a2 <= 0x133 )
  {
    if ( a2 != 307 )
    {
      switch ( a2 )
      {
        case 0x100u:
          if ( hdc != 116 )
            return 0;
          PostMessageW(hWnd, 0x113u, 1u, 0);
          result = 0;
          break;
        case 0x110u:
          PropSheet_UpdateTab(hWnd);
          v6 = LoadIconW(ghInstance, 0x6E);
          v7 = GetDlgItem(hWnd, 1119);
          SendMessageW(v7, 0x172u, 1u, v6);
          v8 = malloc(0x60u);
          v48 = v8;
          *v8 = a4;
          v9 = OpenProcess(0x400u, 0, *(a4 + 68));
          if ( v9 || (v9 = OpenProcess(0x1000u, 0, *(*v8 + 68))) != 0 )
          {
            NtQueryInformationProcess(v9, ProcessVmCounters, v8 + 4, 0x2Cu, &ReturnLength);
            NtQueryInformationProcess(v9, ProcessIoCounters, v8 + 48, 0x30u, &ReturnLength);
            if ( NtQueryInformationProcess(v9, ProcessHandleCount, ProcessInformation, 8u, &ReturnLength) )
            {
              v10 = GetDlgItem(hWnd, 1609);
              EnableWindow(v10, 0);
              v11 = GetDlgItem(hWnd, 1052);
              EnableWindow(v11, 0);
              v8 = v48;
            }
            CloseHandle(v9);
          }
          if ( !QueryProcessCycleTime )
          {
            v12 = GetDlgItem(hWnd, 1324);
            SetWindowTextW(v12, L"Context Switch Delta");
          }
          SetWindowLongW(hWnd, -21, v8);
          SendMessageW(hWnd, 0x113u, 0, 0);
          result = 0;
          break;
        case 0x111u:
          switch ( hdc )
          {
            case 0x9C41u:
              v33 = 40014i64;
              goto LABEL_18;
            case 0x9C42u:
              SetEvent(ghRefreshEventHandle);
              result = 0;
              break;
            case 0x9C9Cu:
            case 0x9C9Du:
              v33 = hdc;
LABEL_18:
              v14 = GetParent(hWnd);
              PostMessageW(v14, 0x111u, v33, SHIDWORD(v33));
              result = 0;
              break;
            default:
              return 0;
          }
          break;
        case 0x113u:
          v15 = OpenProcess(0x400u, 0, *(*v5 + 68));
          v47 = v15;
          if ( v15 || (v15 = OpenProcess(0x1000u, 0, *(*v5 + 68)), (v47 = v15) != 0) )
          {
            v16 = SetDlgItemTextW;
            if ( !NtQueryInformationProcess(v15, 0, &v35, 0x18u, &ReturnLength) )
            {
              wsprintf(&String, L"%d", ArgList[0]);
              SetDlgItemTextW(hWnd, 1042, &String);
            }
            if ( !NtQueryInformationProcess(v15, ProcessTimes, &FileTime, 0x20u, &ReturnLength) )
            {
              if ( FileTime )
              {
                FileTimeToLocalFileTime(&FileTime, &LocalFileTime);
                FileTimeToSystemTime(&LocalFileTime, &SystemTime);
                GetTimeFormatW(0x400u, 0, &SystemTime, 0, &String, 128);
                GetDateFormatW(0x400u, 0, &SystemTime, 0, &DateStr, 128);
                wcscat_s(&String, 0x100u, L"   ");
                wcscat_s(&String, 0x100u, &DateStr);
              }
              else
              {
                wcscpy_s(&String, 0x100u, L"n/a");
              }
              SetDlgItemTextW(hWnd, 1007, &String);
              wsprintf(&String, L"%I64d:%02I64d:%02I64d.%03I64d", v62 / 0x861C46800i64);
              SetDlgItemTextW(hDlg, 1012, &String);
              wsprintf(&String, L"%I64d:%02I64d:%02I64d.%03I64d", v63 / 0x861C46800i64);
              SetDlgItemTextW(hDlg, 1013, &String);
              v46 = v62 + v63;
              wsprintf(&String, L"%I64d:%02I64d:%02I64d.%03I64d", (v62 + v63) / 0x861C46800i64);
              v4 = hDlg;
              v16 = SetDlgItemTextW;
              SetDlgItemTextW(hDlg, 1014, &String);
              v15 = v47;
            }
            if ( NtQueryInformationProcess(v15, ProcessIoCounters, v58, 0x30u, &ReturnLength) )
            {
              v23 = v51;
            }
            else
            {
              wsprintf(&String, L"%I64d", v58[0]);
              v17 = sub_FC3290(&String, 0x100u);
              v16(v4, 1041, v17);
              wsprintf(&String, L"%I64d", v58[0] - v51[48]);
              v18 = sub_FC3290(&String, 0x100u);
              v16(v4, 1044, v18);
              wsprintf(&String, L"%I64d", v58[8]);
              v19 = sub_FC3290(&String, 0x100u);
              v16(v4, 1043, v19);
              wsprintf(&String, L"%I64d", v58[8] - v51[56]);
              v20 = sub_FC3290(&String, 0x100u);
              v16(v4, 1050, v20);
              wsprintf(&String, L"%I64d", v59[0]);
              v21 = sub_FC3290(&String, 0x100u);
              v16(v4, 1045, v21);
              wsprintf(&String, L"%I64d", v59[0] - v51[64]);
              v22 = sub_FC3290(&String, 0x100u);
              v16(v4, 1049, v22);
              sub_FB2200(0, &String, 0x100u, COERCE__INT64((v60 - *(v51 + 10))), 0i64, 0i64 >> 63);
              v16(v4, 1334, &String);
              sub_FB2200(0, &String, 0x100u, COERCE__INT64((*&v59[8] - *(v51 + 9))), 0i64, 0i64 >> 63);
              v16(v4, 1333, &String);
              sub_FB2200(0, &String, 0x100u, COERCE__INT64((*(&v60 + 1) - *(v51 + 11))), 0i64, 0i64 >> 63);
              v16(v4, 1051, &String);
              v23 = v51;
              _mm_storeu_si128(v51 + 3, _mm_loadu_si128(v58));
              _mm_storeu_si128(v23 + 4, _mm_loadu_si128(v59));
              _mm_storeu_si128(v23 + 5, _mm_loadu_si128(&v60));
            }
            if ( QueryProcessCycleTime )
            {
              QueryProcessCycleTime(QueryProcessCycleTime, v15);
              wsprintf(&String, L"%I64u", v39[0]);
            }
            else
            {
              wsprintf(&String, L"%I64d", *(v23->m128i_i32[0] + 1336));
            }
            v24 = sub_FC3290(&String, 0x100u);
            v16(v4, 1195, v24);
            if ( NtQueryInformationProcess(v15, ProcessPagePriority, v43, 4u, &ReturnLength) )
              wsprintf(&String, L"n/a", v34);
            else
              wsprintf(&String, L"%d", v43[0]);
            v16(v4, 1339, &String);
            if ( NtQueryInformationProcess(v15, ProcessIoPriority, &v44, 4u, &ReturnLength) )
              wsprintf(&String, L"n/a", v34);
            else
              sub_FF7790(v44, &String, 0x100u);
            v16(v4, 1340, &String);
            v47 = 0;
            sub_FDEB20(v15, &v48, &v47, &v38, &v46, &v45, &hDlg);
            free(v48);
            wsprintf(&String, L"%ld", v46 >> 10);
            sub_FC3290(&String, 0x100u);
            wcscat_s(&String, 0x100u, L" K");
            v16(v4, 1067, &String);
            wsprintf(&String, L"%ld", hDlg >> 10);
            sub_FC3290(&String, 0x100u);
            wcscat_s(&String, 0x100u, L" K");
            v16(v4, 1069, &String);
            wsprintf(&String, L"%ld", v45 >> 10);
            sub_FC3290(&String, 0x100u);
            wcscat_s(&String, 0x100u, L" K");
            v16(v4, 1068, &String);
            if ( !NtQueryInformationProcess(v15, ProcessVmCounters, v53, 0x2Cu, &ReturnLength) )
            {
              wsprintf(&String, L"%ld", v54 >> 10);
              sub_FC3290(&String, 0x100u);
              wcscat_s(&String, 0x100u, L" K");
              v16(v4, 1008, &String);
              wsprintf(&String, L"%ld", *&v53[12] >> 10);
              sub_FC3290(&String, 0x100u);
              wcscat_s(&String, 0x100u, L" K");
              v16(v4, 1064, &String);
              wsprintf(&String, L"%ld", v56 >> 10);
              sub_FC3290(&String, 0x100u);
              wcscat_s(&String, 0x100u, L" K");
              v16(v4, 1009, &String);
              wsprintf(&String, L"%ld", v57 >> 10);
              sub_FC3290(&String, 0x100u);
              wcscat_s(&String, 0x100u, L" K");
              v16(v4, 1010, &String);
              wsprintf(&String, L"%I64u", *&v53[4] >> 10);
              sub_FC3290(&String, 0x100u);
              wcscat_s(&String, 0x100u, L" K");
              v16(v4, 1060, &String);
              wsprintf(&String, L"%ld", v53[8]);
              sub_FC3290(&String, 0x100u);
              v16(v4, 1065, &String);
              wsprintf(&String, L"%d", v53[8] - v51[12]);
              sub_FC3290(&String, 0x100u);
              v16(v4, 1066, &String);
              v25 = v51;
              _mm_storeu_si128((v51 + 4), _mm_loadu_si128(v53));
              _mm_storeu_si128((v25 + 20), _mm_loadu_si128(&v54));
              _mm_storel_epi64((v25 + 36), _mm_loadl_epi64(&v55));
              *(v25 + 44) = v57;
            }
            if ( NtQueryInformationProcess(v15, ProcessHandleCount, ProcessInformation, 8u, &ReturnLength) )
            {
              if ( !NtQueryInformationProcess(v15, ProcessHandleCount, v40, 4u, &ReturnLength) )
              {
                wsprintf(&String, L"%d", v40[0]);
                v26 = sub_FC3290(&String, 0x100u);
                v16(v4, 1048, v26);
              }
            }
            else
            {
              wsprintf(&String, L"%d", ProcessInformation[0]);
              v27 = sub_FC3290(&String, 0x100u);
              v16(v4, 1048, v27);
              wsprintf(&String, L"%d", v42[0]);
              v28 = sub_FC3290(&String, 0x100u);
              v16(v4, 1052, v28);
            }
            if ( *GetGuiResources )
            {
              v29 = GetGuiResources(v15, 0);
              wsprintf(&String, L"%d", v29);
              v30 = sub_FC3290(&String, 0x100u);
              v16(v4, 1046, v30);
              v31 = GetGuiResources(v15, 1u);
              wsprintf(&String, L"%d", v31);
              v32 = sub_FC3290(&String, 0x100u);
              v16(v4, 1047, v32);
            }
            CloseHandle(v15);
          }
          result = 1;
          break;
        default:
          return 0;
      }
      return result;
    }
    return PE_FillControl(hWnd, hdc);
  }
  if ( a2 == 310 || a2 == 312 )
    return PE_FillControl(hWnd, hdc);
  if ( a2 == 2033 )
  {
    free(v5);
    DestroyWindow(hWnd);
  }
  return 0;
}

//----- (00FE5E50) --------------------------------------------------------
int __stdcall PageProcPerfETW(HWND hWnd, int a2, HDC hdc, int a4)
{
  void *v4; // eax
  void *v5; // ebx
  _DWORD *v6; // eax
  int result; // eax
  HWND v8; // eax
  const WCHAR *v9; // eax
  const WCHAR *v10; // eax
  const WCHAR *v11; // eax
  const WCHAR *v12; // eax
  const WCHAR *v13; // eax
  const WCHAR *v14; // eax
  const WCHAR *v15; // eax
  const WCHAR *v16; // eax
  const WCHAR *v17; // eax
  const WCHAR *v18; // eax
  const WCHAR *v19; // eax
  const WCHAR *v20; // eax
  signed __int64 v21; // [esp+10h] [ebp-218h]
  WCHAR String; // [esp+24h] [ebp-204h]

  v4 = GetWindowLongW(hWnd, -21);
  v5 = v4;
  if ( a2 <= 0x133 )
  {
    if ( a2 != 307 )
    {
      switch ( a2 )
      {
        case 256:
          if ( hdc != 116 )
            return 0;
          PostMessageW(hWnd, 0x113u, 1u, 0);
          result = 0;
          break;
        case 272:
          PropSheet_UpdateTab(hWnd);
          v6 = malloc(0x60u);
          *v6 = a4;
          SetWindowLongW(hWnd, -21, v6);
          SendMessageW(hWnd, 0x113u, 0, 0);
          result = 0;
          break;
        case 273:
          switch ( hdc )
          {
            case 0x9C41u:
              v21 = 40014i64;
              goto LABEL_11;
            case 0x9C42u:
              SetEvent(ghRefreshEventHandle);
              result = 0;
              break;
            case 0x9C9Cu:
            case 0x9C9Du:
              v21 = hdc;
LABEL_11:
              v8 = GetParent(hWnd);
              PostMessageW(v8, 0x111u, v21, SHIDWORD(v21));
              result = 0;
              break;
            default:
              return 0;
          }
          break;
        case 275:
          wsprintf(&String, L"%u", *(*v4 + 1176));
          v9 = sub_FC3290(&String, 0x100u);
          SetDlgItemTextW(hWnd, 1186, v9);
          wsprintf(&String, L"%u", *(*v5 + 1192));
          v10 = sub_FC3290(&String, 0x100u);
          SetDlgItemTextW(hWnd, 1048, v10);
          wsprintf(&String, L"%u", *(*v5 + 1208));
          v11 = sub_FC3290(&String, 0x100u);
          SetDlgItemTextW(hWnd, 1187, v11);
          wsprintf(&String, L"%u", *(*v5 + 1224));
          v12 = sub_FC3290(&String, 0x100u);
          SetDlgItemTextW(hWnd, 1053, v12);
          wsprintf(&String, L"%u", *(*v5 + 1240));
          v13 = sub_FC3290(&String, 0x100u);
          SetDlgItemTextW(hWnd, 1047, v13);
          wsprintf(&String, L"%u", *(*v5 + 1256));
          v14 = sub_FC3290(&String, 0x100u);
          SetDlgItemTextW(hWnd, 1052, v14);
          sub_FB2200(0, &String, 0x100u, COERCE__INT64(*(*v5 + 1232)), 0i64, 0i64 >> 63);
          SetDlgItemTextW(hWnd, 1336, &String);
          sub_FB2200(0, &String, 0x100u, COERCE__INT64(*(*v5 + 1200)), 0i64, 0i64 >> 63);
          SetDlgItemTextW(hWnd, 1335, &String);
          sub_FB2200(0, &String, 0x100u, COERCE__INT64(*(*v5 + 1264)), 0i64, 0i64 >> 63);
          SetDlgItemTextW(hWnd, 1054, &String);
          sub_FB2200(0, &String, 0x100u, COERCE__INT64(*(*v5 + 1216)), 0i64, 0i64 >> 63);
          SetDlgItemTextW(hWnd, 1204, &String);
          sub_FB2200(0, &String, 0x100u, COERCE__INT64(*(*v5 + 1184)), 0i64, 0i64 >> 63);
          SetDlgItemTextW(hWnd, 1202, &String);
          sub_FB2200(0, &String, 0x100u, COERCE__INT64(*(*v5 + 1248)), 0i64, 0i64 >> 63);
          SetDlgItemTextW(hWnd, 1206, &String);
          wsprintf(&String, L"%u", *(*v5 + 1072));
          v15 = sub_FC3290(&String, 0x100u);
          SetDlgItemTextW(hWnd, 1638, v15);
          wsprintf(&String, L"%u", *(*v5 + 1088));
          v16 = sub_FC3290(&String, 0x100u);
          SetDlgItemTextW(hWnd, 1639, v16);
          wsprintf(&String, L"%u", *(*v5 + 1104));
          v17 = sub_FC3290(&String, 0x100u);
          SetDlgItemTextW(hWnd, 1641, v17);
          wsprintf(&String, L"%u", *(*v5 + 1120));
          v18 = sub_FC3290(&String, 0x100u);
          SetDlgItemTextW(hWnd, 1643, v18);
          wsprintf(&String, L"%u", *(*v5 + 1136));
          v19 = sub_FC3290(&String, 0x100u);
          SetDlgItemTextW(hWnd, 1645, v19);
          wsprintf(&String, L"%u", *(*v5 + 1152));
          v20 = sub_FC3290(&String, 0x100u);
          SetDlgItemTextW(hWnd, 1646, v20);
          sub_FB2200(0, &String, 0x100u, COERCE__INT64(*(*v5 + 1128)), 0i64, 0i64 >> 63);
          SetDlgItemTextW(hWnd, 1644, &String);
          sub_FB2200(0, &String, 0x100u, COERCE__INT64(*(*v5 + 1096)), 0i64, 0i64 >> 63);
          SetDlgItemTextW(hWnd, 1640, &String);
          sub_FB2200(0, &String, 0x100u, COERCE__INT64(*(*v5 + 1160)), 0i64, 0i64 >> 63);
          SetDlgItemTextW(hWnd, 1647, &String);
          sub_FB2200(0, &String, 0x100u, COERCE__INT64(*(*v5 + 1112)), 0i64, 0i64 >> 63);
          SetDlgItemTextW(hWnd, 1205, &String);
          sub_FB2200(0, &String, 0x100u, COERCE__INT64(*(*v5 + 1080)), 0i64, 0i64 >> 63);
          SetDlgItemTextW(hWnd, 1203, &String);
          sub_FB2200(0, &String, 0x100u, COERCE__INT64(*(*v5 + 1144)), 0i64, 0i64 >> 63);
          SetDlgItemTextW(hWnd, 1207, &String);
          result = 1;
          break;
        default:
          return 0;
      }
      return result;
    }
    return PE_FillControl(hWnd, hdc);
  }
  if ( a2 == 310 || a2 == 312 )
    return PE_FillControl(hWnd, hdc);
  if ( a2 == 2033 )
  {
    free(v4);
    DestroyWindow(hWnd);
  }
  return 0;
}

//----- (00FE66A0) --------------------------------------------------------
BOOL __stdcall ProcPropSheet(HWND hDlg, UINT uMsg, WPARAM wParam, PROPITEM *PropItem)
{
  HWND hWndTab; // eax
  HWND hWndTab_1; // ebx
  HWND *v6; // eax
  HWND *v8; // edi
  HWND v9; // eax
  LRESULT v10; // eax
  _DWORD *v11; // ebx
  LRESULT v12; // esi
  char *v13; // edi
  BOOL (__stdcall *v14)(HWND, UINT, WPARAM, LPARAM); // ST14_4
  signed int v15; // edi
  HWND *v16; // esi
  WPARAM v17; // eax
  LRESULT v18; // eax
  WPARAM v19; // ecx
  _DWORD *i; // eax
  CResizer *v21; // eax
  LONG v22; // eax
  LONG v23; // eax
  const wchar_t *v24; // ecx
  WPARAM nTabIndex; // ebx
  WPARAM nTabIndex_1; // esi
  WPARAM nTabIndex_2; // esi
  tagTREEVIEWLISTITEMPARAM *pListItem; // eax
  WPARAM nTabIndex_3; // esi
  WPARAM nTabIndex_4; // esi
  HWND hWndTab_3; // esi
  WPARAM nTabIdx; // ebx
  _DWORD *v33; // eax
  int nTabItem; // ebx
  int v35; // esi
  int nTabItem_1; // esi
  int v37; // ebx
  HANDLE ProcessHandle; // eax
  tagTREEVIEWLISTITEMPARAM *pListItem_1; // ecx
  HANDLE v40; // esi
  bool v41; // zf
  tagTREEVIEWLISTITEMPARAM *pListItem_2; // eax
  int v43; // esi
  int v44; // esi
  void *v45; // esi
  int v46; // esi
  int v47; // esi
  WPARAM v48; // ST14_4
  _DWORD *v49; // eax
  HWND hWnd; // esi
  UINT v51; // eax
  WPARAM nTab; // ecx
  POINT v53; // ST14_8
  HCURSOR v54; // eax
  struct tagPOINT Point; // [esp+10h] [ebp-264h]
  NMHDR lParam; // [esp+18h] [ebp-25Ch]
  tagTCITEMW tcitem; // [esp+24h] [ebp-250h]
  HWND hDlg_1; // [esp+40h] [ebp-234h]
  HWND hWndTab_2; // [esp+44h] [ebp-230h]
  HANDLE hObject; // [esp+48h] [ebp-22Ch]
  struct tagRECT Rect; // [esp+4Ch] [ebp-228h]
  WCHAR pszBuffer[260]; // [esp+5Ch] [ebp-218h]
  int v63; // [esp+270h] [ebp-4h]

  hDlg_1 = hDlg;
  hWndTab = GetDlgItem(hDlg, IDS_PROCPROPSHEET_TABCTRL);
  hWndTab_1 = hWndTab;
  hWndTab_2 = hWndTab;
  v6 = GetWindowLongW(hDlg, GWL_USERDATA);
  hObject = v6;
  if ( uMsg > WM_NOTIFY )
  {
    if ( uMsg == WM_INITDIALOG )
    {
      ShowWindow(hDlg, 0);
      v21 = operator new(0x40u);
      hObject = v21;
      v63 = 0;
      if ( v21 )
        CResizer::CResizer(v21, hDlg);
      v63 = -1;
      SetWindowLongW(hDlg, GWL_USERDATA, PropItem);
      tcitem.mask = 3;
      tcitem.iImage = -1;
      v22 = GetWindowLongW(hWndTab_1, GWL_EXSTYLE);
      SetWindowLongW(hWndTab_1, -20, v22 | WS_EX_CONTROLPARENT);
      v23 = GetWindowLongW(hWndTab_1, -16);
      SetWindowLongW(hWndTab_1, GWL_STYLE, v23 | WS_CLIPCHILDREN);
      if ( PropItem->pListItem )
      {
        TreeViewItemParam_InitGraph(PropItem->pListItem);
        tcitem.pszText = L"Image";
        SendMessageW(hWndTab_1, TCM_INSERTITEMW, 0, &tcitem);
        wcscpy_s(PropItem->PageData[1].szTemplateName, 256u, L"PROCPERF");
        PropItem->PageData[1].nTabId = 2;
        PropItem->PageData[1].PageWndProc = PageProcPerf;
        tcitem.pszText = L"Performance";
        SendMessageW(hWndTab_1, TCM_INSERTITEMW, 1u, &tcitem);
        v24 = L"PROCCPUIO";
        if ( !*(PropItem->pListItem + 266) )
          v24 = L"PROCCPU";
        wcscpy_s(PropItem->PageData[2].szTemplateName, 256u, v24);
        PropItem->PageData[2].nTabId = 4;
        PropItem->PageData[2].PageWndProc = PageProcCPU;
        tcitem.pszText = L"Performance Graph";
        SendMessageW(hWndTab_1, TCM_INSERTITEMW, 2u, &tcitem);
        nTabIndex = 3;
        if ( gbFlagsInProcPropSheet )
        {
          wcscpy_s(PropItem->PageData[3].szTemplateName, 256u, L"PROCPERFETW");
          PropItem->PageData[3].nTabId = 14;
          PropItem->PageData[3].PageWndProc = PageProcPerfETW;
          tcitem.pszText = L"Disk and Network";
          SendMessageW(hWndTab_2, TCM_INSERTITEMW, 3u, &tcitem);
          nTabIndex = 4;
        }
        if ( gdwAdapterRuntingTime )
        {
          nTabIndex_1 = nTabIndex;
          wcscpy_s(PropItem->PageData[nTabIndex].szTemplateName, 256u, L"PROCGPU");
          PropItem->PageData[nTabIndex_1].nTabId = 15;
          PropItem->PageData[nTabIndex_1].PageWndProc = PageProcGPU;
          tcitem.pszText = L"GPU Graph";
          SendMessageW(hWndTab_2, TCM_INSERTITEMW, nTabIndex++, &tcitem);
        }
        if ( *(PropItem->pListItem + 40) & 0x20 )
        {
          nTabIndex_2 = nTabIndex;
          wcscpy_s(PropItem->PageData[nTabIndex].szTemplateName, 256u, L"PROCSERVICES");
          PropItem->PageData[nTabIndex_2].nTabId = 5;
          PropItem->PageData[nTabIndex_2].PageWndProc = PageProcServices;
          tcitem.pszText = L"Services";
          SendMessageW(hWndTab_2, TCM_INSERTITEMW, nTabIndex++, &tcitem);
        }
        pListItem = PropItem->pListItem;
        if ( pListItem && pListItem->bSupportWMIProviders )
        {
          nTabIndex_3 = nTabIndex;
          wcscpy_s(PropItem->PageData[nTabIndex].szTemplateName, 256u, L"PROCWMIPROVIDERS");
          PropItem->PageData[nTabIndex_3].nTabId = 16;
          PropItem->PageData[nTabIndex_3].PageWndProc = PageProcWMIProviders;
          tcitem.pszText = L"WMI Providers";
          SendMessageW(hWndTab_2, TCM_INSERTITEMW, nTabIndex++, &tcitem);
        }
        nTabIndex_4 = nTabIndex;
        wcscpy_s(PropItem->PageData[nTabIndex].szTemplateName, 256u, L"PROCTHREADS");
        PropItem->PageData[nTabIndex_4].nTabId = 6;
        PropItem->PageData[nTabIndex_4].PageWndProc = PageProcThreads;
        hWndTab_3 = hWndTab_2;
        tcitem.pszText = L"Threads";
        SendMessageW(hWndTab_2, TCM_INSERTITEMW, nTabIndex, &tcitem);
        nTabIdx = nTabIndex + 1;
        hObject = PropItem + sizeof(PROPPAGEDATA) * nTabIdx;
        if ( AllocateAndGetUdpExTable2FromStack )
          wcscpy_s(hObject + 6, 256u, L"PROCTCPUDPSTACK");
        else
          wcscpy_s(hObject + 6, 256u, L"PROCTCPUDP");
        v33 = hObject;
        tcitem.pszText = L"TCP/IP";
        *(hObject + 131) = 7;
        v33[132] = PageProcTcpUdp;
        SendMessageW(hWndTab_3, TCM_INSERTITEMW, nTabIdx, &tcitem);
        nTabItem = nTabIdx + 1;
        v35 = nTabItem;
        wcscpy_s(PropItem->PageData[nTabItem].szTemplateName, 256u, L"PROCSECURITY");
        PropItem->PageData[v35].nTabId = 8;
        PropItem->PageData[v35].PageWndProc = PageProcSecurity;
        tcitem.pszText = L"Security";
        SendMessageW(hWndTab_2, TCM_INSERTITEMW, nTabItem++, &tcitem);
        nTabItem_1 = nTabItem;
        wcscpy_s(PropItem->PageData[nTabItem].szTemplateName, 256u, L"PROCENV");
        PropItem->PageData[nTabItem_1].nTabId = 9;
        PropItem->PageData[nTabItem_1].PageWndProc = PageProcEnv;
        tcitem.pszText = L"Environment";
        SendMessageW(hWndTab_2, TCM_INSERTITEMW, nTabItem, &tcitem);
        v37 = nTabItem + 1;
        ProcessHandle = PE_OpenProcess(MAXIMUM_ALLOWED, 0, *(PropItem->pListItem + 17));
        pListItem_1 = PropItem->pListItem;
        v40 = ProcessHandle;
        hObject = ProcessHandle;
        v41 = PE_IsProcessInJob(ProcessHandle, pListItem_1->dwProcessId, 0, 0) == 0;
        pListItem_2 = PropItem->pListItem;
        if ( v41 )
        {
          pListItem_2->dwStyle &= -0x801u;
        }
        else
        {
          pListItem_2->dwStyle |= 0x800u;
          v43 = v37;
          wcscpy_s(PropItem->PageData[v37].szTemplateName, 256u, L"PROCJOB");
          PropItem->PageData[v43].nTabId = 10;
          PropItem->PageData[v43].PageWndProc = PageProcJob;
          tcitem.pszText = L"Job";
          SendMessageW(hWndTab_2, TCM_INSERTITEMW, v37, &tcitem);
          v40 = hObject;
          ++v37;
        }
        if ( v40 )
          CloseHandle(v40);
        if ( ProcessIsNetCclr_0(PropItem->pListItem) )
        {
          v44 = v37;
          wcscpy_s(PropItem->PageData[v37].szTemplateName, 0x100u, L"PROCCLR");
          PropItem->PageData[v44].nTabId = 11;
          PropItem->PageData[v44].PageWndProc = PageProcCclr;
          tcitem.pszText = L".NET Assemblies";
          SendMessageW(hWndTab_2, TCM_INSERTITEMW, v37++, &tcitem);
          if ( !*(PropItem->pListItem + 321) )
          {
            v45 = malloc(0x88u);
            memset(v45, 0, 0x88u);
            *(PropItem->pListItem + 321) = v45;
          }
        }
        if ( *(PropItem->pListItem + 321) )
        {
          CoInitialize(0);
          v46 = v37;
          wcscpy_s(PropItem->PageData[v37].szTemplateName, 0x100u, L"PROCNET");
          PropItem->PageData[v46].nTabId = 12;
          PropItem->PageData[v46].PageWndProc = PageProcNet;
          tcitem.pszText = L".NET Performance";
          SendMessageW(hWndTab_2, TCM_INSERTITEMW, v37++, &tcitem);
        }
        v47 = v37;
        wcscpy_s(PropItem->PageData[v37].szTemplateName, 0x100u, L"PROCSTRINGS");
        PropItem->PageData[v47].nTabId = 13;
        PropItem->PageData[v47].PageWndProc = PageProcStrings;
        tcitem.pszText = L"Strings";
        v48 = v37;
        hWndTab_1 = hWndTab_2;
        SendMessageW(hWndTab_2, TCM_INSERTITEMW, v48, &tcitem);
        v49 = PropItem->pListItem;
        if ( v49[216] )
        {
          swprintf(pszBuffer, L"%s:%d (%s) Properties", v49[15], v49[17], v49[216]);
        }
        else if ( v49[17] < 0 )
        {
          swprintf(pszBuffer, L"%s Properties", v49[15]);
        }
        else
        {
          swprintf(pszBuffer, L"%s:%d Properties", v49[15], v49[17]);
        }
        hWnd = hDlg_1;
        SetWindowTextW(hDlg_1, pszBuffer);
        PropItem->PageData[0].hWnd = CreateDialogParamW(
                                       ghMainInstance,
                                       L"PROCINFO",
                                       hWnd,
                                       PageProcInfo,
                                       PropItem->pListItem);
        PropItem->PageData[0].nTabId = 1;
      }
      else
      {
        hWnd = hDlg_1;
      }
      ShowWindow(PropItem->PageData[0].hWnd, SW_SHOW);
      SetForegroundWindow(hWnd);
      v51 = PropItem->PageData[0].nTabId;
      nTab = 0;
      if ( v51 )
      {
        while ( gConfig.dwDefaultProcPropPage != v51 )
        {
          v51 = *(&PropItem->nTabIndex + 131 * (++nTab + 1));
          if ( !v51 )
            goto LABEL_77;
        }
      }
      else
      {
LABEL_77:
        nTab = 0;
      }
      SendMessageW(hWndTab_1, TCM_SETCURSEL, nTab, 0);
      lParam.idFrom = IDS_PROCPROPSHEET_TABCTRL;
      lParam.code = TCN_SELCHANGE;
      SendMessageW(hWnd, WM_NOTIFY, 0, &lParam);
      if ( gConfig.WindowPlacement[PropWindowplacement].rcNormalPosition.right == gConfig.WindowPlacement[PropWindowplacement].rcNormalPosition.left )
      {
        GetCursorPos(&Point);
        v53.y = Point.y - 408;
        v53.x = Point.x - 385;
        PE_SetWindowPlacement(hWnd, v53);
      }
      else
      {
        sub_FEDC50(hWnd, PropItem->pListItem);
      }
      ShowWindow(hWnd, 5);
      InterlockedDecrement(&gnRefCount);
      v54 = LoadCursorW(0, IDC_ARROW);
      SetCursor(v54);
      return 1;
    }
    if ( uMsg == 273 )
    {
      if ( wParam > 40092 )
      {
        if ( wParam == 40093 )
        {
          v18 = SendMessageW(hWndTab_1, TCM_GETCURSEL, 0, 0);
          v19 = v18 - 1;
          if ( !v18 )
          {
            v19 = 0;
            for ( i = hObject + 1052; *i; ++v19 )
              i += 131;
          }
          SendMessageW(hWndTab_1, TCM_SETCURSEL, v19, 0);
          lParam.idFrom = 1110;
          lParam.code = -551;
          SendMessageW(hDlg, WM_NOTIFY, 0, &lParam);
        }
      }
      else
      {
        if ( wParam == 40092 )
        {
          v17 = SendMessageW(hWndTab_1, TCM_GETCURSEL, 0, 0) + 1;
          if ( !*(hObject + 131 * v17 + 132) )
            v17 = 0;
          SendMessageW(hWndTab_1, TCM_SETCURSEL, v17, 0);
          lParam.idFrom = 1110;
          lParam.code = -551;
          SendMessageW(hDlg_1, WM_NOTIFY, 0, &lParam);
          return 0;
        }
        if ( wParam > 0 && (wParam <= 2 || wParam == 40014) )
        {
          ShowWindow(hDlg, 0);
          v15 = 32;
          v16 = (hObject + 8);
          while ( 1 )
          {
            if ( *v16 )
            {
              SendMessageW(*v16, WM_COMMAND, wParam, 0);
              SendMessageW(*v16, WM_MSG_7F1, 0, 0);
            }
            v16 += 131;
            if ( !--v15 )
            {
              PostMessageW(ghMainWnd, WM_MSG_7ED, 0, *(hObject + 1));
              if ( *(*(hObject + 1) + 1284) )
                CoUninitialize();
              free(hObject);
              GetWindowPlacement(hDlg_1, &gConfig.WindowPlacement[2]);
              DestroyWindow(hDlg_1);
              _endthread();
            }
          }
        }
      }
    }
    return 0;
  }
  if ( uMsg == WM_NOTIFY )
  {
    if ( PropItem->pListItem == 1110 && PropItem->PageData[0].hWnd == -551 )
    {
      v10 = SendMessageW(hWndTab_1, TCM_GETCURSEL, 0, 0);
      v11 = hObject;
      v12 = v10;
      v13 = hObject + 524 * v10;
      hObject = v13;
      gConfig.dwDefaultProcPropPage = *(v13 + 131);
      ShowWindow(v11[131 * *v11 + 2], 0);
      *v11 = v12;
      if ( !*(v13 + 2) )
      {
        v14 = *(v13 + 132);
        v13 = hObject;
        *(hObject + 2) = CreateDialogParamW(ghMainInstance, hObject + 6, hDlg_1, v14, v11[1]);
      }
      ShowWindow(*(v13 + 2), 5);
      return 0;
    }
    return 0;
  }
  if ( uMsg != 5 )
  {
    if ( uMsg == 36 )
    {
      PropItem->PageData[0].hWnd = (2 * gdwVirtualScreenWidth);
      return 0;
    }
    return 0;
  }
  v8 = v6 + 2;
  v9 = 32;
  hDlg_1 = 32;
  do
  {
    if ( *v8 )
    {
      GetWindowRect(hWndTab_1, &Rect);
      SendMessageW(hWndTab_1, TCM_ADJUSTRECT, 0, &Rect);
      MapWindowPoints(0, hDlg, &Rect, 2u);
      MoveWindow(*v8, Rect.left, Rect.top, Rect.right - Rect.left, Rect.bottom - Rect.top, 1);
      InvalidateRect(*v8, 0, 1);
      v9 = hDlg_1;
    }
    v8 += 131;
    v9 = (v9 - 1);
    hDlg_1 = v9;
  }
  while ( v9 );
  return 0;
}
// 100A009: using guessed type int _endthread(void);
// 102CFEC: using guessed type wchar_t aEnvironment[12];
// 1045168: using guessed type wchar_t aSecurity_0[9];
// 1046390: using guessed type wchar_t aPerformance[12];
// 10463A8: using guessed type wchar_t aProccpuio[10];
// 10463CC: using guessed type wchar_t aPerformanceGra[18];
// 1046408: using guessed type wchar_t aDiskAndNetwork[17];
// 104643C: using guessed type wchar_t aGpuGraph[10];
// 104646C: using guessed type wchar_t aServices_0[9];
// 10464A4: using guessed type wchar_t aWmiProviders_0[14];
// 10464D8: using guessed type wchar_t aThreads[8];
// 10464E8: using guessed type wchar_t aProctcpudpstac[16];
// 1046520: using guessed type wchar_t aTcpIp[7];
// 104657C: using guessed type wchar_t aNetAssemblies[16];
// 10465AC: using guessed type wchar_t aNetPerformance[17];
// 10465E8: using guessed type wchar_t aStrings[8];
// 1064E28: using guessed type int gdwVirtualScreenWidth;
// 1065390: using guessed type char gbFlagsInProcPropSheet;

//----- (00FE7240) --------------------------------------------------------
void __cdecl __noreturn CTreeList::BackendFillTreeViewParamThreadProc(tagTREEVIEWLISTITEMPARAM *pItem)
{
  HCURSOR v1; // eax
  PROPITEM *PropItem; // esi
  HWND hDlgSheet; // ebx
  char *v4; // edi
  HWND v5; // eax
  HWND hWndFind; // esi
  DWORD dwRet; // ebx
  PROPPAGEDATA *PageData; // esi
  signed int nPageIndex; // edi
  UINT uMsg; // eax
  struct tagMSG msg; // [esp+Ch] [ebp-2Ch]
  HANDLE Handles[2]; // [esp+28h] [ebp-10h]
  HACCEL hAccel; // [esp+30h] [ebp-8h]
  PROPITEM *v14; // [esp+34h] [ebp-4h]
  tagTREEVIEWLISTITEMPARAM *pInfoa; // [esp+40h] [ebp+8h]

  InterlockedIncrement(&gnRefCount);
  v1 = LoadCursorW(0, IDC_APPSTARTING);
  SetCursor(v1);
  PropItem = malloc(sizeof(PROPITEM));
  v14 = PropItem;
  memset(PropItem, 0, sizeof(PROPITEM));
  PropItem->pListItem = pItem;
  hDlgSheet = CreateDialogParamW(ghMainInstance, L"PROCPROPSHEET", ghMainWnd, ProcPropSheet, PropItem);
  pInfoa = hDlgSheet;
  hAccel = LoadAcceleratorsW(ghMainInstance, L"PROCPROPERTIES");
  while ( !PeekMessageW(&msg, 0, 0, 0, PM_REMOVE) )
  {
LABEL_15:
    Handles[0] = ghTimerRefreshProcPageEventHandle;
    Handles[1] = ghEvent6;
    dwRet = MsgWaitForMultipleObjects(2u, Handles, 0, 0xFFFFFFFF, QS_ALLINPUT);
    if ( dwRet != 2 )
    {
      PageData = PropItem->PageData;
      nPageIndex = 32;
      do
      {
        if ( PageData->hWnd )
        {
          uMsg = WM_USER;
          if ( !dwRet )
            uMsg = WM_TIMER;
          PostMessageW(PageData->hWnd, uMsg, 1u, 0);
        }
        ++PageData;
        --nPageIndex;
      }
      while ( nPageIndex );
      PropItem = v14;
    }
    hDlgSheet = pInfoa;
  }
  while ( 1 )
  {
    v4 = PropItem + sizeof(PROPPAGEDATA) * PropItem->nTabIndex;
    v5 = *(v4 + 2);
    if ( v5 && TranslateAcceleratorW(v5, hAccel, &msg) )
      goto LABEL_14;
    hWndFind = GetPropW(hDlgSheet, L"FindWindow");
    if ( !hWndFind )
    {
LABEL_10:
      if ( !IsDialogMessageW(*(v4 + 2), &msg) && !IsDialogMessageW(hDlgSheet, &msg) )
      {
        TranslateMessage(&msg);
        DispatchMessageW(&msg);
      }
      goto LABEL_13;
    }
    if ( IsDialogMessageW(hWndFind, &msg) )
    {
      if ( msg.message != WM_COMMAND || LOWORD(msg.wParam) != 40014 )
        goto LABEL_13;
    }
    else if ( msg.message != WM_COMMAND || LOWORD(msg.wParam) != 40014 )
    {
      goto LABEL_10;
    }
    PostMessageW(hWndFind, WM_COMMAND, IDABORT, 0);
    SetPropW(hDlgSheet, L"FindWindow", 0);
LABEL_13:
    PropItem = v14;
LABEL_14:
    if ( !PeekMessageW(&msg, 0, 0, 0, 1u) )
      goto LABEL_15;
  }
}

//----- (00FE7440) --------------------------------------------------------
int __stdcall sub_FE7440(volatile LONG *lpAddend)
{
  signed int v1; // edi
  HWND v2; // ST0C_4
  DWORD v3; // eax
  void *v4; // ST18_4
  PSID v5; // ST14_4
  DWORD v6; // eax
  HWND v7; // eax
  wchar_t *v8; // eax
  LPARAM v9; // ST18_4
  HWND v10; // eax
  HWND v11; // ST0C_4
  LPARAM lParam; // [esp+Ch] [ebp-46Ch]
  int v14; // [esp+10h] [ebp-468h]
  int v15; // [esp+14h] [ebp-464h]
  int v16; // [esp+2Ch] [ebp-44Ch]
  enum _SID_NAME_USE peUse; // [esp+40h] [ebp-438h]
  WPARAM wParam; // [esp+44h] [ebp-434h]
  WPARAM v19; // [esp+48h] [ebp-430h]
  DWORD cchName; // [esp+4Ch] [ebp-42Ch]
  void *v21; // [esp+50h] [ebp-428h]
  DWORD cchReferencedDomainName; // [esp+54h] [ebp-424h]
  LRESULT v23; // [esp+58h] [ebp-420h]
  PSID Sid; // [esp+5Ch] [ebp-41Ch]
  int v25; // [esp+60h] [ebp-418h]
  WCHAR Name; // [esp+64h] [ebp-414h]
  WCHAR ReferencedDomainName; // [esp+26Ch] [ebp-20Ch]

  lParam = 0;
  memset(&v14, 0, 0x30u);
  EnterCriticalSection((lpAddend + 3));
  v1 = 0;
  v23 = SendMessageW(*(lpAddend + 9), 0x1004u, 0, 0);
  if ( v23 > 0 )
  {
    do
    {
      if ( *(lpAddend + 40) == 1 )
        break;
      lParam = 4;
      v2 = *(lpAddend + 9);
      v14 = v1;
      v15 = 0;
      if ( !SendMessageW(v2, 0x104Bu, 0, &lParam) )
        break;
      v25 = v16;
      v3 = GetLengthSid(*(v16 + 36));
      Sid = malloc(v3);
      v4 = *(v25 + 36);
      v5 = Sid;
      v6 = GetLengthSid(*(v25 + 36));
      CopySid(v6, v5, v4);
      LeaveCriticalSection((lpAddend + 3));
      cchName = 260;
      cchReferencedDomainName = 260;
      if ( LookupAccountSidW(
             &gszNullString,
             Sid,
             &Name,
             &cchName,
             &ReferencedDomainName,
             &cchReferencedDomainName,
             &peUse) )
      {
        if ( ReferencedDomainName )
        {
          wcscat_s(&ReferencedDomainName, 0x104u, L"\\");
          wcscat_s(&ReferencedDomainName, 0x104u, &Name);
        }
        else
        {
          wcscpy_s(&ReferencedDomainName, 0x104u, &Name);
        }
        EnterCriticalSection((lpAddend + 3));
        if ( *(lpAddend + 40) )
          break;
        LeaveCriticalSection((lpAddend + 3));
        v7 = GetParent(*(lpAddend + 9));
        SendMessageW(v7, 0x7F7u, v1, &ReferencedDomainName);
        v21 = *(v25 + 40);
        v8 = _wcsdup(&ReferencedDomainName);
        *(v25 + 40) = v8;
        if ( v21 )
          free(v21);
      }
      EnterCriticalSection((lpAddend + 3));
      free(Sid);
      ++v1;
    }
    while ( v1 < v23 );
  }
  v9 = *(lpAddend + 9);
  v10 = GetParent(*(lpAddend + 9));
  SendMessageW(v10, 0x7F6u, 0, v9);
  LeaveCriticalSection((lpAddend + 3));
  SendMessageW(*(lpAddend + 9), 0x101Eu, 0, 0xFFFF);
  if ( !InterlockedDecrement(lpAddend) )
  {
    DeleteCriticalSection((lpAddend + 3));
    free(lpAddend);
  }
  InvalidateRect(*(lpAddend + 9), 0, 0);
  v19 = nItem;
  v11 = *(lpAddend + 9);
  wParam = 1040;
  SendMessageW(v11, 0x1030u, &wParam, PropProcThreadsSortCallback);
  return 0;
}

//----- (00FE7710) --------------------------------------------------------
int __stdcall PageProcSecurity(HWND hWnd, UINT msg, WPARAM wParam, LPARAM lParam)
{
  LONG v4; // ebx
  CResizer *v5; // eax
  CResizer *v6; // esi
  HWND v7; // eax
  HWND v8; // eax
  HWND v9; // eax
  HWND v10; // eax
  HWND v11; // eax
  struct tagResizerItem *v12; // eax
  HWND v13; // eax
  HWND v14; // eax
  HWND v15; // eax
  HWND v16; // eax
  HWND v17; // eax
  HICON v18; // ST24_4
  HWND v19; // eax
  HICON v20; // ST24_4
  HWND v21; // eax
  HWND v22; // edi
  LONG v23; // eax
  HWND v24; // eax
  struct _IMAGELIST *v25; // edi
  HICON v26; // eax
  HICON v27; // eax
  HWND v28; // esi
  LONG v29; // eax
  LRESULT (__stdcall *SendMessageW)(HWND, UINT, WPARAM, LPARAM); // ebx
  HWND v31; // esi
  HWND v32; // edi
  LONG v33; // eax
  HWND v34; // eax
  void *v35; // esi
  HWND v36; // eax
  HWND v37; // eax
  HWND v38; // eax
  HWND v39; // eax
  HWND v40; // esi
  const WCHAR *v41; // esi
  const WCHAR *v42; // eax
  unsigned __int8 v43; // cl
  void (__stdcall *GetTokenInformatio)(HANDLE, TOKEN_INFORMATION_CLASS, LPVOID, DWORD, PDWORD); // ebx
  DWORD (__stdcall *GetLastError)(); // esi
  unsigned int v46; // eax
  TOKEN_INFORMATION_CLASS TokenClassInfo; // edi
  DWORD v48; // esi
  int *v49; // ebx
  bool v50; // zf
  int *v51; // esi
  void *v52; // edi
  tagTREEVIEWITEMPARAM *v53; // ebx
  DWORD v54; // eax
  void *v55; // eax
  void *v56; // ST20_4
  DWORD v57; // eax
  DWORD v58; // esi
  PSID *v59; // edi
  tagTREEVIEWITEMPARAM *v60; // eax
  tagTREEVIEWITEMPARAM *v61; // ebx
  DWORD v62; // eax
  void *v63; // eax
  PSID v64; // ST24_4
  void *v65; // ST20_4
  DWORD v66; // eax
  HWND v67; // esi
  int v68; // eax
  wchar_t *v69; // eax
  DWORD v70; // esi
  DWORD v71; // esi
  void **v72; // edi
  void **v73; // ecx
  void *v74; // esi
  tagTREEVIEWITEMPARAM *v75; // edi
  DWORD v76; // eax
  void *v77; // eax
  void *v78; // ST20_4
  DWORD v79; // eax
  HWND v80; // esi
  int v81; // eax
  wchar_t *v82; // eax
  unsigned int v83; // ecx
  char *v84; // eax
  int v85; // edi
  DWORD v86; // esi
  TOKEN_PRIVILEGES *v87; // eax
  struct _LUID *v88; // esi
  HWND v89; // esi
  HWND v90; // eax
  HWND v91; // edi
  HWND v93; // eax
  TOKEN_PRIVILEGES *v94; // ebx
  LONG v95; // eax
  HWND v96; // ST18_4
  HWND v97; // ST18_4
  WPARAM v98; // [esp-8h] [ebp-1C10h]
  WCHAR *v99; // [esp-4h] [ebp-1C0Ch]
  LVITEMW Item; // [esp+10h] [ebp-1BF8h]
  UINT v101; // [esp+44h] [ebp-1BC4h]
  int v102; // [esp+48h] [ebp-1BC0h]
  UINT pnIDs; // [esp+4Ch] [ebp-1BBCh]
  int v104; // [esp+50h] [ebp-1BB8h]
  WPARAM wParama; // [esp+54h] [ebp-1BB4h]
  WPARAM v106; // [esp+58h] [ebp-1BB0h]
  DWORD ReturnLength; // [esp+5Ch] [ebp-1BACh]
  DWORD cchName; // [esp+60h] [ebp-1BA8h]
  enum _SID_NAME_USE peUse; // [esp+64h] [ebp-1BA4h]
  WORD v110[2]; // [esp+68h] [ebp-1BA0h]
  WORD pnWidths[2]; // [esp+6Ch] [ebp-1B9Ch]
  DWORD cchReferencedDomainName; // [esp+70h] [ebp-1B98h]
  HWND v113; // [esp+74h] [ebp-1B94h]
  LVITEMW lParama; // [esp+78h] [ebp-1B90h]
  unsigned int v115; // [esp+ACh] [ebp-1B5Ch]
  HANDLE InBuffer; // [esp+B0h] [ebp-1B58h]
  int v117; // [esp+B4h] [ebp-1B54h]
  LPVOID TokenInformation; // [esp+B8h] [ebp-1B50h]
  HWND v119; // [esp+BCh] [ebp-1B4Ch]
  DWORD BytesReturned; // [esp+C0h] [ebp-1B48h]
  DWORD cbSid; // [esp+C4h] [ebp-1B44h]
  DWORD TokenInformationLength; // [esp+C8h] [ebp-1B40h]
  HANDLE OutBuffer; // [esp+CCh] [ebp-1B3Ch]
  HWND hDlg; // [esp+D0h] [ebp-1B38h]
  TOKEN_PRIVILEGES *pTokenPrivileges; // [esp+D4h] [ebp-1B34h]
  tagHANDLELISTITEMPARAM pListParam[1034]; // [esp+D8h] [ebp-1B30h]
  TOKEN_STATISTICS TokenStatisticsInfo; // [esp+1198h] [ebp-A70h]
  WCHAR Name[260]; // [esp+11D0h] [ebp-A38h]
  WCHAR ReferencedDomainName[260]; // [esp+13D8h] [ebp-830h]
  WCHAR Dst[260]; // [esp+15E0h] [ebp-628h]
  WCHAR String[260]; // [esp+17E8h] [ebp-420h]
  WCHAR szBuffer[260]; // [esp+19F0h] [ebp-218h]
  int v133; // [esp+1C04h] [ebp-4h]

  hDlg = hWnd;
  pTokenPrivileges = lParam;
  OutBuffer = 0;
  v4 = GetWindowLongW(hWnd, -21);
  lParama.mask = 0;
  v117 = v4;
  memset(&lParama.iItem, 0, 0x30u);
  pnIDs = 1046;
  v104 = 1049;
  pnWidths[0] = MulDiv(100, gLogPixelSize.x, 96);
  pnWidths[1] = MulDiv(100, gLogPixelSize.x, 96);
  v101 = 1047;
  v102 = 1051;
  v110[0] = MulDiv(100, gLogPixelSize.x, 96);
  v110[1] = MulDiv(100, gLogPixelSize.x, 96);
  if ( msg <= WM_CTLCOLOREDIT )
  {
    if ( msg != WM_CTLCOLOREDIT )
    {
      switch ( msg )
      {
        case WM_ALTTABACTIVE|WM_DESTROY:
          CMainWnd::DrawList(pTokenPrivileges);
          return 0;
        case 0x2Cu:
          return CMainWnd::HandleMeasureItem(hWnd, msg, wParam, pTokenPrivileges);
        case WM_NOTIFY:
          v94 = pTokenPrivileges;
          v95 = pTokenPrivileges->Privileges[0].Luid.HighPart;
          if ( v95 == -108 )
            return sub_FBD040(wParam, pTokenPrivileges);
          if ( v95 == -101 || v95 == -2 )
          {
            v96 = pTokenPrivileges->PrivilegeCount;
            lParama.mask = 4;
            lParama.iItem = ::SendMessageW(v96, 0x100Cu, 0xFFFFFFFF, 2);
            v97 = v94->PrivilegeCount;
            lParama.iSubItem = 0;
            if ( ::SendMessageW(v97, LVM_GETITEMW, 0, &lParama) && lParama.lParam > 1 )
            {
              if ( v94->PrivilegeCount == GetDlgItem(hWnd, 1040) )
              {
                cbSid = 260;
                QueryAuthorityInfoFromSID(lParama.lParam->field_24, String, &cbSid);
                SetDlgItemTextW(hWnd, 1342, String);
              }
              else
              {
                GetDlgItem(hWnd, 1038);
              }
            }
          }
          return 0;
        case WM_INITDIALOG:
          v5 = operator new(0x40u);
          BytesReturned = v5;
          v133 = 0;
          if ( v5 )
            v6 = CResizer::CResizer(v5, hWnd);
          else
            v6 = 0;
          v133 = -1;
          v7 = GetDlgItem(hWnd, 1337);
          if ( v7 )
            CResizer::AddItem(v6, v7, 1)->m_rect1 = 0i64;
          v8 = GetDlgItem(hWnd, 1669);
          if ( v8 )
            CResizer::AddItem(v6, v8, 1)->m_rect1 = 0i64;
          v9 = GetDlgItem(hWnd, 1668);
          if ( v9 )
            CResizer::AddItem(v6, v9, 1)->m_rect1 = 0i64;
          v10 = GetDlgItem(hWnd, 1057);
          if ( v10 )
            CResizer::AddItem(v6, v10, 1)->m_rect1 = 0i64;
          v11 = GetDlgItem(hWnd, 1040);
          if ( v11 )
          {
            v12 = CResizer::AddItem(v6, v11, 1);
            *&v12->m_rect2.left = 0i64;
            *&v12->m_rect2.right = db_one;
          }
          v13 = GetDlgItem(hWnd, 1342);
          if ( v13 )
            CResizer::AddItem(v6, v13, 1)->m_rect2 = stru_1046C70;
          v14 = GetDlgItem(hWnd, 1346);
          if ( v14 )
            CResizer::AddItem(v6, v14, 1)->m_rect2 = stru_1046C70;
          v15 = GetDlgItem(hWnd, 1128);
          if ( v15 )
            CResizer::AddItem(v6, v15, 1)->m_rect2 = stru_1046C70;
          v16 = GetDlgItem(hWnd, 1038);
          if ( v16 )
            CResizer::AddItem(v6, v16, 1)->m_rect2 = stru_1046C70;
          v17 = GetDlgItem(hWnd, 1038);
          if ( v17 )
            CResizer::AddItem(v6, v17, 1)->m_rect2 = stru_1046C70;
          PropSheet_UpdateTab(hWnd);
          v18 = LoadIconW(ghInstance, 0x70);
          v19 = GetDlgItem(hWnd, 1127);
          ::SendMessageW(v19, STM_SETIMAGE, 1u, v18);
          v20 = LoadIconW(ghInstance, 0x6F);
          v21 = GetDlgItem(hWnd, 1128);
          ::SendMessageW(v21, STM_SETIMAGE, 1u, v20);
          SetDlgItemTextW(hWnd, 1342, L"n/a");
          SetDlgItemTextW(hDlg, 1057, L"n/a");
          v22 = GetDlgItem(hDlg, 1040);
          v119 = v22;
          v23 = GetWindowLongW(v22, -16);
          SetWindowLongW(v22, -16, v23 & 0xFFFFFFFD | 1);
          ::SendMessageW(v22, LVM_SETEXTENDEDLISTVIEWSTYLE, 0x4020u, 16416);
          v24 = ::SendMessageW(v22, LVM_GETTOOLTIPS, 0, 0);
          CTreeList::InitToolTips(v24);
          gOldListWndProc = SetWindowLongW(v22, -4, Proxy_ListCtrlWndProc);
          ::SendMessageW(v22, 0x30u, ghConfigFont, 0);
          CTreeView::InitListHeader(v22, &pnIDs, pnWidths, 2u);
          v25 = ImageList_Create(16, 16, 1u, 256, 256);
          v26 = LoadIconW(ghInstance, 0xCB);
          ImageList_ReplaceIcon(v25, -1, v26);
          v27 = LoadIconW(ghInstance, 0x71);
          ImageList_ReplaceIcon(v25, -1, v27);
          v28 = v119;
          v29 = GetWindowLongW(v119, -16);
          SetWindowLongW(v28, -16, v29 | LVS_SHAREIMAGELISTS);
          SendMessageW = ::SendMessageW;
          ::SendMessageW(v28, LVM_SETIMAGELIST, 1u, v25);
          CTreeList::InitHeaderColumn(v28, nItem, nItem, byte_105D224);
          v31 = hDlg;
          v32 = GetDlgItem(hDlg, 1038);
          v113 = v32;
          v33 = GetWindowLongW(v32, -16);
          SetWindowLongW(v32, -16, v33 & 0xFFFFFFFD | 1);
          ::SendMessageW(v32, LVM_SETEXTENDEDLISTVIEWSTYLE, 0x4020u, 16416);
          v34 = ::SendMessageW(v32, LVM_GETTOOLTIPS, 0, 0);
          CTreeList::InitToolTips(v34);
          gOldListWndProc = SetWindowLongW(v32, -4, Proxy_ListCtrlWndProc);
          ::SendMessageW(v32, WM_SETFONT, ghConfigFont, 0);
          CTreeView::InitListHeader(v32, &v101, v110, 2u);
          SetDlgItemTextW(v31, 19, pTokenPrivileges[5].Privileges[0].Luid.HighPart);
          cbSid = 0;
          cchReferencedDomainName = 0;
          LookupAccountNameW(
            0,
            pTokenPrivileges[5].Privileges[0].Luid.HighPart,
            0,
            &cbSid,
            ReferencedDomainName,
            &cchReferencedDomainName,
            &peUse);
          if ( cbSid )
          {
            v35 = malloc(cbSid);
            LookupAccountNameW(
              0,
              pTokenPrivileges[5].Privileges[0].Luid.HighPart,
              v35,
              &cbSid,
              ReferencedDomainName,
              &cchReferencedDomainName,
              &peUse);
            cbSid = 260;
            QueryAuthorityInfoFromSID(v35, String, &cbSid);
            free(v35);
            v31 = hDlg;
          }
          else
          {
            swprintf(String, L"n/a");
          }
          SetDlgItemTextW(v31, 20, String);
          if ( pTokenPrivileges[6].Privileges[0].Luid.LowPart == -1 )
            swprintf(String, L"n/a");
          else
            swprintf(String, L"%d", pTokenPrivileges[6].Privileges[0].Luid.LowPart);
          SetDlgItemTextW(v31, 1056, String);
          if ( gdwVersion >= 1 )
          {
            v41 = L"Yes";
            v42 = L"Yes";
            if ( !(pTokenPrivileges[2].Privileges[0].Luid.HighPart & 0x200) )
              v42 = L"No";
            SetDlgItemTextW(hDlg, 1337, v42);
            if ( pTokenPrivileges[2].Privileges[0].Luid.HighPart & 0x400 && gdwVersion >= 3 )
            {
              v43 = BYTE1(pTokenPrivileges[40].Privileges[0].Luid.HighPart);
              Name[0] = 0;
              if ( (v43 & 0xF0u) < 0x70 )
                wcscat_s(Name, 0x104u, &aPsprotectedsig[64 * (v43 >> 4)]);
              if ( (BYTE1(pTokenPrivileges[40].Privileges[0].Luid.HighPart) & 7) == 1 )
                wcscat_s(Name, 0x104u, L"-Light");
              v99 = Name;
            }
            else
            {
              if ( !(pTokenPrivileges[2].Privileges[0].Luid.HighPart & 0x400) )
                v41 = L"No";
              v99 = v41;
            }
            v40 = hDlg;
            SetDlgItemTextW(hDlg, 1668, v99);
          }
          else
          {
            v36 = GetDlgItem(v31, 1335);
            ShowWindow(v36, 0);
            v37 = GetDlgItem(hDlg, 1337);
            ShowWindow(v37, 0);
            v38 = GetDlgItem(hDlg, 1669);
            ShowWindow(v38, 0);
            v39 = GetDlgItem(hDlg, 1668);
            ShowWindow(v39, 0);
            v40 = hDlg;
          }
          InBuffer = PE_OpenProcess(0x400u, 0, pTokenPrivileges[4].Privileges[0].Luid.LowPart);
          if ( InBuffer )
          {
            if ( !DeviceIoControl(ghDriverHandle, 0x8335000C, &InBuffer, 4u, &OutBuffer, 4u, &BytesReturned, 0) )
              OpenProcessToken(InBuffer, 8u, &OutBuffer);
            if ( OutBuffer )
            {
              GetTokenInformatio = GetTokenInformation;
              TokenStatisticsInfo.AuthenticationId.HighPart = 0;
              TokenStatisticsInfo.AuthenticationId.LowPart = 0;
              ReturnLength = 56;
              GetTokenInformation(OutBuffer, TokenStatistics, &TokenStatisticsInfo, 0x38u, &ReturnLength);
              swprintf_s(
                String,
                0x104u,
                L"%x",
                TokenStatisticsInfo.AuthenticationId.LowPart,
                TokenStatisticsInfo.AuthenticationId.HighPart);
              SetDlgItemTextW(v40, 1057, String);
              GetLastError = ::GetLastError;
              v46 = 0;
              v117 = 0;
              do
              {
                TokenClassInfo = TokenRestrictedSids;
                if ( !v46 )
                  TokenClassInfo = TokenGroups;
                GetTokenInformatio(OutBuffer, TokenClassInfo, 0, 0, &TokenInformationLength);
                if ( GetLastError() == ERROR_INSUFFICIENT_BUFFER )
                {
                  v48 = TokenInformationLength;
                  v49 = malloc(TokenInformationLength);
                  TokenInformation = v49;
                  if ( GetTokenInformation(OutBuffer, TokenClassInfo, v49, v48, &TokenInformationLength) )
                  {
                    v50 = *v49 == 0;
                    v115 = 0;
                    if ( !v50 )
                    {
                      v51 = v49 + 2;
                      do
                      {
                        v52 = *(v51 - 1);
                        v53 = malloc(0x34u);
                        memset(v53, 0, 0x34u);
                        v53->field_2C = *v51;
                        v54 = GetLengthSid(v52);
                        v55 = malloc(v54);
                        v53->field_24 = v55;
                        v56 = v55;
                        v57 = GetLengthSid(v52);
                        CopySid(v57, v56, v52);
                        QueryAuthorityInfoFromSID(v52, String, &cbSid);
                        if ( *GetSidSubAuthority(v52, 0) != 5 || *GetSidSubAuthority(v52, 1u) )
                          swprintf(ReferencedDomainName, L"%s", String);
                        else
                          swprintf(ReferencedDomainName, L"Logon SID (%s)", String);
                        lParama.pszText = ReferencedDomainName;
                        lParama.mask = 5;
                        lParama.iItem = 0x7FFFFFFF;
                        lParama.iSubItem = 0;
                        lParama.state = 0;
                        lParama.stateMask = 0;
                        lParama.iImage = 0;
                        lParama.lParam = v53;
                        BytesReturned = ::SendMessageW(v119, LVM_INSERTITEMW, 0, &lParama);
                        if ( BytesReturned == -1 )
                          return 0;
                        szBuffer[0] = 0;
                        if ( *v51 & 0x10 )
                          wcscpy_s(szBuffer, 0x104u, L"Deny");
                        if ( *v51 & 0x20000000 )
                        {
                          if ( szBuffer[0] )
                            wcscat_s(szBuffer, 0x104u, L", ");
                          wcscat_s(szBuffer, 0x104u, L"Domain-Local");
                        }
                        if ( *v51 & 1 && !(*v51 & 8) )
                        {
                          if ( szBuffer[0] )
                            wcscat_s(szBuffer, 0x104u, L", ");
                          wcscat_s(szBuffer, 0x104u, L"Mandatory");
                        }
                        if ( *v51 & 8 )
                        {
                          if ( szBuffer[0] )
                            wcscat_s(szBuffer, 0x104u, L", ");
                          wcscat_s(szBuffer, 0x104u, L"Owner");
                        }
                        if ( *v51 & 0x20 )
                        {
                          if ( szBuffer[0] )
                            wcscat_s(szBuffer, 0x104u, L", ");
                          if ( *v51 & 0x40 )
                            wcscat_s(szBuffer, 0x104u, L"Integrity");
                          else
                            wcscat_s(szBuffer, 0x104u, L"DesktopIntegrity");
                        }
                        if ( v117 == 1 )
                        {
                          if ( szBuffer[0] )
                            wcscat_s(szBuffer, 0x104u, L", ");
                          wcscat_s(szBuffer, 0x104u, L"Restricted");
                        }
                        lParama.iItem = BytesReturned;
                        lParama.pszText = szBuffer;
                        lParama.mask = 1;
                        lParama.iSubItem = 1;
                        ::SendMessageW(v119, LVM_SETITEMW, 0, &lParama);
                        v53->field_28 = _wcsdup(ReferencedDomainName);
                        v53->field_30 = _wcsdup(szBuffer);
                        v51 += 2;
                        v49 = TokenInformation;
                        ++v115;
                      }
                      while ( v115 < *TokenInformation );
                    }
                  }
                  free(v49);
                  GetTokenInformatio = GetTokenInformation;
                  GetLastError = ::GetLastError;
                }
                v46 = v117 + 1;
                v117 = v46;
              }
              while ( v46 < 2 );
              GetTokenInformatio(OutBuffer, MaxTokenInfoClass|TokenGroups, 0, 0, &TokenInformationLength);
              if ( GetLastError() == 122 )
              {
                v58 = TokenInformationLength;
                v59 = malloc(TokenInformationLength);
                if ( (GetTokenInformatio)(OutBuffer, MaxTokenInfoClass|TokenGroups, v59, v58, &TokenInformationLength)
                  && *v59 )
                {
                  v60 = malloc(0x34u);
                  v61 = v60;
                  BytesReturned = v60;
                  memset(v60, 0, 0x34u);
                  v62 = GetLengthSid(*v59);
                  v63 = malloc(v62);
                  v61->field_24 = v63;
                  v64 = *v59;
                  v65 = v63;
                  v66 = GetLengthSid(*v59);
                  CopySid(v66, v65, v64);
                  QueryAuthorityInfoFromSID(*v59, String, &cbSid);
                  v67 = v119;
                  lParama.pszText = String;
                  lParama.lParam = v61;
                  SendMessageW = ::SendMessageW;
                  lParama.mask = 5;
                  lParama.iItem = 0x7FFFFFFF;
                  lParama.iSubItem = 0;
                  lParama.state = 0;
                  lParama.stateMask = 0;
                  lParama.iImage = 0;
                  v68 = ::SendMessageW(v119, LVM_INSERTITEMW, 0, &lParama);
                  if ( v68 == -1 )
                    return 0;
                  lParama.iItem = v68;
                  lParama.mask = 1;
                  lParama.iSubItem = 1;
                  lParama.pszText = L"AppContainer";
                  ::SendMessageW(v67, LVM_SETITEMW, 0, &lParama);
                  v69 = _wcsdup(String);
                  v70 = BytesReturned;
                  *(BytesReturned + 40) = v69;
                  *(v70 + 48) = _wcsdup(lParama.pszText);
                  free(v59);
                  GetLastError = ::GetLastError;
                }
                else
                {
                  SendMessageW = ::SendMessageW;
                  free(v59);
                  GetLastError = ::GetLastError;
                }
              }
              else
              {
                SendMessageW = ::SendMessageW;
              }
              GetTokenInformation(OutBuffer, TokenLogonSid|TokenGroups, TokenInformation, 0, &TokenInformationLength);
              if ( GetLastError() == 122 )
              {
                v71 = TokenInformationLength;
                v72 = malloc(TokenInformationLength);
                BytesReturned = v72;
                if ( GetTokenInformation(OutBuffer, TokenLogonSid|TokenGroups, v72, v71, &TokenInformationLength) )
                {
                  v50 = *v72 == 0;
                  TokenInformation = 0;
                  if ( !v50 )
                  {
                    v73 = v72 + 1;
                    v115 = (v72 + 1);
                    do
                    {
                      v74 = *v73;
                      v75 = malloc(0x34u);
                      memset(v75, 0, 0x34u);
                      v76 = GetLengthSid(v74);
                      v77 = malloc(v76);
                      v75->field_24 = v77;
                      v78 = v77;
                      v79 = GetLengthSid(v74);
                      CopySid(v79, v78, v74);
                      QueryAuthorityInfoFromSID(v74, String, &cbSid);
                      v80 = v119;
                      lParama.pszText = String;
                      lParama.mask = 5;
                      lParama.iItem = 0x7FFFFFFF;
                      lParama.iSubItem = 0;
                      lParama.state = 0;
                      lParama.stateMask = 0;
                      lParama.iImage = 0;
                      lParama.lParam = v75;
                      v81 = SendMessageW(v119, LVM_INSERTITEMW, 0, &lParama);
                      if ( v81 == -1 )
                        return 0;
                      lParama.iItem = v81;
                      lParama.mask = 1;
                      lParama.iSubItem = 1;
                      lParama.pszText = L"Capability";
                      SendMessageW(v80, LVM_SETITEMW, 0, &lParama);
                      v75->field_28 = _wcsdup(String);
                      v82 = _wcsdup(lParama.pszText);
                      v83 = v115;
                      v75->field_30 = v82;
                      v73 = (v83 + 8);
                      v72 = BytesReturned;
                      TokenInformation = TokenInformation + 1;
                      v115 = v73;
                    }
                    while ( TokenInformation < *BytesReturned );
                  }
                }
                free(v72);
              }
              v84 = malloc(0x2Cu);
              v85 = v84;
              *(v84 + 1) = pTokenPrivileges;
              *(v84 + 9) = v119;
              *v84 = 2;
              v84[40] = 0;
              InitializeCriticalSection((v84 + 12));
              *(v85 + 8) = _beginthreadex(0, 0, sub_FE7440, v85, 0, 0);
              SetWindowLongW(hDlg, GWLP_USERDATA, v85);
              GetTokenInformation(OutBuffer, TokenPrivileges, 0, 0, &TokenInformationLength);
              v86 = TokenInformationLength;
              pTokenPrivileges = malloc(TokenInformationLength);
              v50 = GetTokenInformation(OutBuffer, TokenPrivileges, pTokenPrivileges, v86, &TokenInformationLength) == 0;
              v87 = pTokenPrivileges;
              if ( !v50 )
              {
                v50 = pTokenPrivileges->PrivilegeCount == 0;
                TokenInformation = 0;
                if ( !v50 )
                {
                  v88 = &pTokenPrivileges->Privileges[0].Attributes;
                  do
                  {
                    cchName = 260;
                    if ( LookupPrivilegeNameW(0, v88 - 1, Name, &cchName) )
                    {
                      lParama.mask = 5;
                      lParama.pszText = Name;
                      lParama.iItem = 0x7FFFFFFF;
                      lParama.iSubItem = 0;
                      lParama.state = 0;
                      lParama.stateMask = 0;
                      lParama.iImage = 0;
                      lParama.lParam = 1;
                      BytesReturned = SendMessageW(v113, 0x104Du, 0, &lParama);
                      if ( BytesReturned == -1 )
                        return 0;
                      Dst[0] = 0;
                      if ( v88->LowPart & 2 )
                        wcscpy_s(Dst, 0x104u, L"Enabled");
                      else
                        wcscpy_s(Dst, 0x104u, L"Disabled");
                      if ( v88->LowPart & 1 )
                      {
                        if ( Dst[0] )
                          wcscat_s(Dst, 0x104u, L", ");
                        wcscpy_s(Dst, 0x104u, L"Default Enabled");
                      }
                      lParama.iItem = BytesReturned;
                      lParama.pszText = Dst;
                      lParama.mask = 1;
                      lParama.iSubItem = 1;
                      SendMessageW(v113, 0x104Cu, 0, &lParama);
                    }
                    v88 = (v88 + 12);
                    TokenInformation = TokenInformation + 1;
                  }
                  while ( TokenInformation < pTokenPrivileges->PrivilegeCount );
                  v87 = pTokenPrivileges;
                }
              }
              free(v87);
              CloseHandle(OutBuffer);
              CloseHandle(InBuffer);
              v89 = v119;
            }
            else
            {
              v85 = v117;
              CloseHandle(InBuffer);
              v89 = v119;
            }
          }
          else
          {
            v89 = v119;
            if ( pTokenPrivileges[2].Privileges[0].Luid.HighPart & 0x400 )
            {
              lParama.mask = 5;
              lParama.iItem = 0x7FFFFFFF;
              lParama.iSubItem = 0;
              lParama.state = 0;
              lParama.stateMask = 0;
              lParama.pszText = L"Error: Process is Protected";
              lParama.iImage = 0;
              lParama.lParam = 1;
              if ( ::SendMessageW(v119, 0x104Du, 0, &lParama) == -1 )
                return 0;
            }
            v85 = v117;
          }
          if ( !v85 )
          {
            v90 = GetDlgItem(hDlg, 1210);
            EnableWindow(v90, 0);
          }
          InvalidateRect(v89, 0, 0);
          v106 = nItem;
          wParama = 1040;
          SendMessageW(v89, 0x1030u, &wParama, PropProcThreadsSortCallback);
          v91 = v113;
          SendMessageW(v113, 0x101Eu, 0, 0xFFFF);
          SendMessageW(v91, 0x101Eu, 1u, 65534);
          SendMessageW(v89, 0x101Eu, 0, 0xFFFF);
          SendMessageW(v89, 0x101Eu, 1u, 65534);
          return 1;
        case WM_COMMAND:
          if ( wParam > 40001 )
          {
            if ( wParam - 40092 > 1 )
              return 0;
            v98 = wParam;
          }
          else
          {
            if ( wParam != 40001 )
            {
              if ( wParam == 1210 )
              {
                InBuffer = OpenProcess(0xE0000u, 0, *(*(v4 + 4) + 68));
                if ( InBuffer || (InBuffer = OpenProcess(0x20000u, 0, *(*(v4 + 4) + 68))) != 0 )
                {
                  memset(pListParam, 0, 0x10C0u);
                  wsprintfW(&pListParam[46], L"%s: %d", *(*(v4 + 4) + 60), *(*(v4 + 4) + 68));
                  pListParam[10].dwValue = 0;
                  wcscpy_s(&pListParam[14], 0x40u, L"Process");
                  pListParam[11].dwValue = InBuffer;
                  pListParam[9].dwValue = GetCurrentProcessId();
                  FillHandleListParam(hWnd, pListParam);
                  CloseHandle(InBuffer);
                }
                else
                {
                  ReportMsg(L"Error opening process", hWnd);
                }
              }
              return 0;
            }
            v98 = 40014;
          }
          v93 = GetParent(hWnd);
          PostMessageW(v93, WM_COMMAND, v98, 0);
          return 0;
        default:
          return 0;
      }
    }
    return PE_FillControl(hWnd, wParam);
  }
  if ( msg > 0x7F1 )
  {
    if ( msg == 2038 )
    {
      InvalidateRect(pTokenPrivileges, 0, 0);
    }
    else if ( msg == 2039 )
    {
      Item.pszText = pTokenPrivileges;
      Item.iSubItem = 0;
      ::SendMessageW(*(v4 + 36), LVM_SETITEMTEXTW, wParam, &Item);
    }
    return 0;
  }
  if ( msg == 2033 )
  {
    if ( v4 )
    {
      EnterCriticalSection((v4 + 12));
      *(v4 + 40) = 1;
      LeaveCriticalSection((v4 + 12));
      if ( !InterlockedDecrement(v4) )
      {
        DeleteCriticalSection((v4 + 12));
        free(v4);
      }
    }
    return 0;
  }
  if ( msg == 310 || msg == 312 )
    return PE_FillControl(hWnd, wParam);
  return 0;
}
// 1042088: using guessed type wchar_t aErrorOpeningPr[22];
// 10460B4: using guessed type wchar_t aYes[4];
// 10460C4: using guessed type wchar_t aLogonSidS[15];
// 104612C: using guessed type wchar_t aIntegrity[10];
// 104617C: using guessed type wchar_t aCapability[11];
// 10461B4: using guessed type wchar_t aErrorProcessIs[28];
// 1046C70: using guessed type RECT stru_1046C70;
// 105D224: using guessed type char byte_105D224;
// 1064E54: using guessed type int gdwVersion;

//----- (00FE8E00) --------------------------------------------------------
int __stdcall PageProcServices(HWND hDlg, int a2, WPARAM wParam, int a4)
{
  HWND v4; // edi
  CResizer *v5; // eax
  HWND v6; // eax
  struct tagResizerItem *v7; // eax
  HWND v8; // eax
  HICON v9; // ST20_4
  HWND v10; // eax
  LONG v11; // eax
  HWND v12; // eax
  void *v13; // ecx
  wchar_t *v14; // eax
  wchar_t *v15; // esi
  int v16; // edx
  wchar_t v17; // cx
  HWND v18; // eax
  DWORD v19; // ebx
  LONG v20; // edx
  int v21; // esi
  int v22; // eax
  WCHAR *v23; // eax
  int result; // eax
  LONG v25; // edi
  int v26; // eax
  int v27; // eax
  HWND v28; // eax
  HWND v29; // eax
  HWND v30; // eax
  HWND v31; // eax
  HWND v32; // eax
  HWND v33; // eax
  HWND v34; // ST14_4
  SC_HANDLE v35; // esi
  size_t v36; // esi
  BYTE *v37; // edi
  DWORD v38; // ST1C_4
  HWND v39; // eax
  BOOL v40; // ST20_4
  HWND v41; // eax
  BOOL v42; // eax
  BOOL v43; // ST20_4
  HWND v44; // eax
  BOOL v45; // ST20_4
  HWND v46; // eax
  BOOL v47; // eax
  BOOL v48; // ST20_4
  HWND v49; // eax
  BOOL v50; // eax
  BOOL v51; // ST20_4
  HWND v52; // eax
  HWND v53; // eax
  HWND v54; // eax
  HWND v55; // eax
  HWND v56; // eax
  HWND v57; // eax
  HWND v58; // eax
  SC_HANDLE v59; // esi
  INT_PTR v60; // eax
  HWND v61; // eax
  WPARAM v62; // [esp-8h] [ebp-13ACh]
  LPARAM lParam; // [esp+10h] [ebp-1394h]
  int v64; // [esp+1Ch] [ebp-1388h]
  int v65; // [esp+20h] [ebp-1384h]
  LPARAM v66; // [esp+44h] [ebp-1360h]
  int v67; // [esp+4Ch] [ebp-1358h]
  int v68; // [esp+50h] [ebp-1354h]
  size_t pcbBytesNeeded; // [esp+54h] [ebp-1350h]
  LVITEMW Item; // [esp+58h] [ebp-134Ch]
  void *v71; // [esp+8Ch] [ebp-1318h]
  SC_HANDLE hSCObject; // [esp+90h] [ebp-1314h]
  LONG dwNewLong; // [esp+94h] [ebp-1310h]
  char v74; // [esp+9Bh] [ebp-1309h]
  LPARAM pListParam; // [esp+9Ch] [ebp-1308h]
  DWORD v76; // [esp+C0h] [ebp-12E4h]
  int v77; // [esp+C4h] [ebp-12E0h]
  SC_HANDLE v78; // [esp+C8h] [ebp-12DCh]
  wchar_t v79; // [esp+D4h] [ebp-12D0h]
  wchar_t Dst; // [esp+154h] [ebp-1250h]
  struct _SERVICE_STATUS ServiceStatus; // [esp+115Ch] [ebp-248h]
  UINT pnIDs; // [esp+1178h] [ebp-22Ch]
  int v83; // [esp+117Ch] [ebp-228h]
  int v84; // [esp+1180h] [ebp-224h]
  WCHAR ServiceName; // [esp+1184h] [ebp-220h]
  WORD pnWidths[2]; // [esp+138Ch] [ebp-18h]
  __int16 v87; // [esp+1390h] [ebp-14h]
  int v88; // [esp+13A0h] [ebp-4h]

  dwNewLong = a4;
  v4 = GetDlgItem(hDlg, 1036);
  GetWindowLongW(hDlg, -21);
  Item.mask = 0;
  memset(&Item.iItem, 0, 0x30u);
  v74 = 0;
  pnIDs = 1039;
  v83 = 1044;
  v84 = 1061;
  pnWidths[0] = MulDiv(100, gLogPixelSize.x, 96);
  pnWidths[1] = MulDiv(100, gLogPixelSize.x, 96);
  v87 = MulDiv(100, gLogPixelSize.x, 96);
  if ( a2 > 0x111 )
  {
    if ( a2 == 307 || a2 == 310 || a2 == 312 )
      return PE_FillControl(hDlg, wParam);
    return 0;
  }
  if ( a2 == 273 )
  {
    v71 = wParam;
    if ( wParam <= 40001 )
    {
      if ( wParam != 40001 )
      {
        switch ( wParam )
        {
          case 0x4BAu:
          case 0x4BBu:
          case 0x4BCu:
          case 0x4BDu:
          case 0x4BFu:
            Item.iItem = SendMessageW(v4, 0x100Cu, 0xFFFFFFFF, 2);
            Item.pszText = &ServiceName;
            Item.iSubItem = 0;
            Item.cchTextMax = 260;
            Item.mask = 1;
            SendMessageW(v4, 0x104Bu, 0, &Item);
            Item.iSubItem = v71;
            v60 = DialogBoxParamW(ghInstance, L"SERVICECONTROL", hDlg, DlgServiceControl, &Item);
            if ( v60 == 1 )
            {
              MessageBoxW(
                hDlg,
                L"The service didn't respond to the control request in a timely manner",
                L"Process Explorer",
                0x10u);
            }
            else if ( v60 == 2 && wParam == 1210 )
            {
              SendMessageW(v4, 0x1008u, Item.iItem, 0);
            }
            v66 = v4;
            v67 = -101;
            SendMessageW(hDlg, 0x4Eu, 0, &v66);
            QueryServiceNames();
            SetFocus(v4);
            result = 0;
            break;
          case 0x51Au:
            Item.iItem = SendMessageW(v4, 0x100Cu, 0xFFFFFFFF, 2);
            Item.pszText = &ServiceName;
            Item.iSubItem = 0;
            Item.cchTextMax = 260;
            Item.mask = 1;
            SendMessageW(v4, 0x104Bu, 0, &Item);
            v59 = OpenServiceW(ghSCManagerHandle, &ServiceName, 0x60000u);
            if ( v59 )
            {
              memset(&pListParam, 0, 0x10C0u);
              wcscpy_s(&Dst, 0x400u, &ServiceName);
              v77 = 0;
              wcscpy_s(&v79, 0x40u, L"Service");
              v78 = v59;
              v76 = GetCurrentProcessId();
              FillHandleListParam(hDlg, &pListParam);
              CloseServiceHandle(v59);
            }
            else
            {
              ReportMsg(L"Error opening service", hDlg);
            }
            result = 0;
            break;
          default:
            return 0;
        }
        return result;
      }
      v62 = 40014;
LABEL_78:
      v61 = GetParent(hDlg);
      PostMessageW(v61, 0x111u, v62, 0);
      return 0;
    }
    if ( wParam == 40002 )
    {
      SetEvent(ghRefreshEventHandle);
      return 0;
    }
    if ( wParam - 40092 <= 1 )
    {
      v62 = wParam;
      goto LABEL_78;
    }
    return 0;
  }
  switch ( a2 )
  {
    case 43:
      CMainWnd::DrawList(dwNewLong);
      return 0;
    case 44:
      return CMainWnd::HandleMeasureItem(hDlg, a2, wParam, dwNewLong);
    case 78:
      v25 = dwNewLong;
      v26 = *(dwNewLong + 8);
      if ( v26 != -101 && (v26 + 3) > 1 )
        return 0;
      SetDlgItemTextW(hDlg, 1059, &gszNullString);
      v27 = SendMessageW(*v25, 0x100Cu, 0xFFFFFFFF, 2);
      if ( v27 == -1 )
      {
        v28 = GetDlgItem(hDlg, 1306);
        EnableWindow(v28, 0);
        v29 = GetDlgItem(hDlg, 1213);
        EnableWindow(v29, 0);
        v30 = GetDlgItem(hDlg, 1210);
        EnableWindow(v30, 0);
        v31 = GetDlgItem(hDlg, 1211);
        EnableWindow(v31, 0);
        v32 = GetDlgItem(hDlg, 1212);
        EnableWindow(v32, 0);
        v33 = GetDlgItem(hDlg, 1215);
        EnableWindow(v33, 0);
        return 0;
      }
      Item.iItem = v27;
      Item.pszText = &ServiceName;
      v34 = *v25;
      Item.iSubItem = 0;
      Item.cchTextMax = 260;
      Item.mask = 1;
      if ( SendMessageW(v34, 0x104Bu, 0, &Item) != 1 )
        return 0;
      v35 = OpenServiceW(ghSCManagerHandle, &ServiceName, 5u);
      hSCObject = v35;
      if ( !v35 )
      {
        v53 = GetDlgItem(hDlg, 1306);
        EnableWindow(v53, 0);
        v54 = GetDlgItem(hDlg, 1213);
        EnableWindow(v54, 0);
        v55 = GetDlgItem(hDlg, 1215);
        EnableWindow(v55, 0);
        v56 = GetDlgItem(hDlg, 1210);
        EnableWindow(v56, 0);
        v57 = GetDlgItem(hDlg, 1211);
        EnableWindow(v57, 0);
        v58 = GetDlgItem(hDlg, 1212);
        EnableWindow(v58, 0);
        return 0;
      }
      if ( *QueryServiceConfig2W )
      {
        QueryServiceConfig2W(v35, 1u, 0, 0, &pcbBytesNeeded);
        if ( GetLastError() == 122 )
        {
          v36 = pcbBytesNeeded;
          v37 = malloc(pcbBytesNeeded);
          v38 = v36;
          v35 = hSCObject;
          QueryServiceConfig2W(hSCObject, 1u, v37, v38, &pcbBytesNeeded);
          SetDlgItemTextW(hDlg, 1059, *v37);
          free(v37);
          v25 = dwNewLong;
        }
      }
      QueryServiceStatus(v35, &ServiceStatus);
      v39 = GetDlgItem(hDlg, 1306);
      EnableWindow(v39, 1);
      v40 = ServiceStatus.dwCurrentState == 1;
      v41 = GetDlgItem(hDlg, 1213);
      EnableWindow(v41, v40);
      v42 = ServiceStatus.dwCurrentState == 4 && ServiceStatus.dwControlsAccepted & 2;
      v43 = v42;
      v44 = GetDlgItem(hDlg, 1212);
      EnableWindow(v44, v43);
      v45 = ServiceStatus.dwCurrentState == 7;
      v46 = GetDlgItem(hDlg, 1211);
      EnableWindow(v46, v45);
      v47 = (ServiceStatus.dwCurrentState == 4 || ServiceStatus.dwCurrentState == 7)
         && ServiceStatus.dwControlsAccepted & 1;
      v48 = v47;
      v49 = GetDlgItem(hDlg, 1210);
      EnableWindow(v49, v48);
      v50 = (ServiceStatus.dwCurrentState == 4 || ServiceStatus.dwCurrentState == 7)
         && ServiceStatus.dwControlsAccepted & 1;
      v51 = v50;
      v52 = GetDlgItem(hDlg, 1215);
      EnableWindow(v52, v51);
      CloseServiceHandle(hSCObject);
      if ( *(v25 + 8) == -3 )
      {
        SendMessageW(hDlg, 0x111u, 0x51Au, 0);
        return 0;
      }
      return 0;
    case 272:
      v5 = operator new(0x40u);
      v71 = v5;
      v88 = 0;
      if ( v5 )
        hSCObject = CResizer::CResizer(v5, hDlg);
      else
        hSCObject = 0;
      v88 = -1;
      v6 = GetDlgItem(hDlg, 1036);
      if ( v6 )
      {
        v7 = CResizer::AddItem(hSCObject, v6, 1);
        *&v7->m_rect2.left = 0i64;
        *&v7->m_rect2.right = db_one;
      }
      v8 = GetDlgItem(hDlg, 1210);
      if ( v8 )
        CResizer::AddItem(hSCObject, v8, 1)->m_rect1 = stru_1046C70;
      PropSheet_UpdateTab(hDlg);
      v9 = LoadIconW(ghInstance, 0xEB);
      v10 = GetDlgItem(hDlg, 1129);
      SendMessageW(v10, 0x172u, 1u, v9);
      SetWindowLongW(hDlg, -21, dwNewLong);
      v11 = GetWindowLongW(v4, -16);
      SetWindowLongW(v4, -16, v11 & 0xFFFFFFFD | 1);
      SendMessageW(v4, 0x1036u, 0x4020u, 16416);
      v12 = SendMessageW(v4, 0x104Eu, 0, 0);
      CTreeList::InitToolTips(v12);
      gOldListWndProc = SetWindowLongW(v4, -4, Proxy_ListCtrlWndProc);
      SendMessageW(v4, 0x30u, ghConfigFont, 0);
      v13 = *(dwNewLong + 792);
      hSCObject = v13;
      if ( !v13 )
      {
        v13 = *(dwNewLong + 60);
        hSCObject = *(dwNewLong + 60);
      }
      v14 = _wcsdup(v13);
      v15 = v14;
      v16 = (v14 + 1);
      do
      {
        v17 = *v14;
        ++v14;
      }
      while ( v17 );
      _wcsupr_s(v15, ((v14 - v16) >> 1) + 1);
      if ( wcsstr(v15, L"SVCHOST.EXE") )
      {
        CTreeView::InitListHeader(v4, &pnIDs, pnWidths, 3u);
        v74 = 1;
      }
      else
      {
        CTreeView::InitListHeader(v4, &pnIDs, pnWidths, 2u);
      }
      free(v15);
      if ( !*CreateSecurityPage )
      {
        v18 = GetDlgItem(hDlg, 1306);
        ShowWindow(v18, 0);
      }
      QueryServiceNames();
      EnterCriticalSection(&gServiceLock);
      v19 = 0;
      if ( !gdwServiceReturned )
        goto LABEL_29;
      v20 = dwNewLong;
      v21 = 0;
      break;
    default:
      return 0;
  }
  do
  {
    if ( gpszServiceNames[v21 + 9] == *(v20 + 68) )
    {
      Item.mask = 5;
      Item.iItem = 0x7FFFFFFF;
      Item.iSubItem = 0;
      Item.stateMask = 0;
      Item.state = 0;
      Item.pszText = gpszServiceNames[v21];
      Item.lParam = (v19 + 1);
      Item.iImage = 0;
      v22 = SendMessageW(v4, LVM_INSERTITEMW, 0, &Item);
      v68 = v22;
      if ( v22 == -1 )
        return 0;
      Item.iItem = v22;
      Item.mask = 1;
      Item.iSubItem = 1;
      Item.pszText = gpszServiceNames[v21 + 1];
      SendMessageW(v4, 0x104Cu, 0, &Item);
      if ( v74 )
      {
        v23 = sub_FC4780(hSCObject, gpszServiceNames[v21]);
        v71 = v23;
        if ( v23 )
        {
          Item.pszText = v23;
          Item.mask = 1;
          Item.iItem = v68;
          Item.iSubItem = 2;
          SendMessageW(v4, 0x104Cu, 0, &Item);
          free(v71);
        }
      }
      v20 = dwNewLong;
    }
    ++v19;
    v21 += 11;
  }
  while ( v19 < gdwServiceReturned );
LABEL_29:
  LeaveCriticalSection(&gServiceLock);
  SendMessageW(v4, 0x101Eu, 0, 0xFFFF);
  SendMessageW(v4, 0x101Eu, 1u, (v74 != 0) + 65534);
  if ( v74 )
    SendMessageW(v4, 0x101Eu, 2u, 65534);
  v65 = 3;
  v64 = 3;
  SendMessageW(v4, 0x102Bu, 0, &lParam);
  SetFocus(v4);
  return 1;
}
// 1045620: using guessed type wchar_t aErrorOpeningSe[22];
// 1046C70: using guessed type RECT stru_1046C70;

//----- (00FE9A30) --------------------------------------------------------
int __userpurge PageProcTcpUdp@<eax>(signed int a1@<ebx>, HWND hWnd, int a3, WPARAM wParam, int a5)
{
  HWND v5; // esi
  int v6; // eax
  HWND v7; // eax
  HWND v8; // edi
  CResizer *v9; // eax
  HWND v10; // eax
  void *v11; // eax
  __m128i *v12; // eax
  LONG v13; // ecx
  WPARAM v14; // esi
  UINT v15; // eax
  BOOL v16; // ST44_4
  HWND v17; // eax
  UINT v19; // eax
  HWND v20; // eax
  u_long *v21; // esi
  LRESULT v22; // eax
  char v23; // al
  char v24; // cl
  HANDLE v25; // eax
  HANDLE v26; // eax
  int v27; // eax
  PVOID v28; // ecx
  HANDLE v29; // eax
  HANDLE v30; // eax
  int v31; // eax
  int v32; // ecx
  bool v33; // zf
  SYSTEM_HANDLE_INFORMATION *v34; // ecx
  int v35; // eax
  char *v36; // eax
  _DWORD *v37; // edi
  u_long v38; // ecx
  int v39; // eax
  SYSTEM_HANDLE_INFORMATION *v40; // ecx
  char *v41; // eax
  _DWORD *v42; // edx
  size_t v43; // edi
  void *v44; // esi
  int v45; // ST30_4
  char *v46; // eax
  void *v47; // ST44_4
  HANDLE v48; // eax
  void *v49; // ST44_4
  HANDLE v50; // eax
  PVOID v51; // ST44_4
  HANDLE v52; // eax
  PVOID v53; // ST44_4
  HANDLE v54; // eax
  void *v55; // esi
  void *v56; // eax
  SYSTEM_HANDLE_INFORMATION *v57; // ecx
  int *v58; // edi
  u_long v59; // edx
  int v60; // ecx
  char *v61; // eax
  int *v62; // edi
  int *v63; // eax
  SYSTEM_HANDLE_INFORMATION *v64; // edx
  int *v65; // ecx
  char *v66; // eax
  int *v67; // edi
  SYSTEM_HANDLE_INFORMATION *v68; // ecx
  int *v69; // edi
  int v70; // ecx
  char *v71; // eax
  size_t *v72; // edi
  SYSTEM_HANDLE_INFORMATION *v73; // ecx
  char *v74; // eax
  _SYSTEM_INFORMATION_CLASS SystemInfoClass_1; // ecx
  SYSTEM_HANDLE_INFORMATION *pSystemHandleInfo_1; // edi
  ULONG v77; // esi
  _SYSTEM_INFORMATION_CLASS SystemInfoClass; // eax
  struct _MIB_TCPTABLE *v79; // eax
  struct _MIB_TCPTABLE *v80; // esi
  int v81; // eax
  struct _MIB_UDPTABLE *v82; // eax
  struct _MIB_UDPTABLE *v83; // edi
  int v84; // eax
  int v85; // eax
  int v86; // ecx
  char *v87; // ecx
  void *v88; // ST40_4
  LPARAM v89; // ecx
  int v90; // eax
  WPARAM v91; // esi
  int v92; // ST44_4
  int v93; // eax
  WPARAM v94; // [esp-8h] [ebp-B4h]
  LPARAM lParam; // [esp+Ch] [ebp-A0h]
  tagLVITEMW ItemInfo; // [esp+10h] [ebp-9Ch]
  WPARAM v97; // [esp+40h] [ebp-6Ch]
  WPARAM v98; // [esp+44h] [ebp-68h]
  void *v99; // [esp+48h] [ebp-64h]
  PVOID ppTcpTable; // [esp+4Ch] [ebp-60h]
  LPVOID lpMem; // [esp+50h] [ebp-5Ch]
  char v102[5]; // [esp+57h] [ebp-55h]
  PVOID pTcpTable; // [esp+5Ch] [ebp-50h]
  int v104; // [esp+60h] [ebp-4Ch]
  u_long *v105; // [esp+64h] [ebp-48h]
  void *v106; // [esp+68h] [ebp-44h]
  HWND v107; // [esp+6Ch] [ebp-40h]
  LONG dwNewLong; // [esp+70h] [ebp-3Ch]
  LPARAM dwInitParam; // [esp+74h] [ebp-38h]
  size_t ReturnLength; // [esp+78h] [ebp-34h]
  size_t v111; // [esp+7Ch] [ebp-30h]
  SYSTEM_HANDLE_INFORMATION *pSystemHandleInfo; // [esp+80h] [ebp-2Ch]
  UINT pnIDs; // [esp+87h] [ebp-25h]
  int v114; // [esp+98h] [ebp-14h]
  int v115; // [esp+A8h] [ebp-4h]

  v5 = hWnd;
  pSystemHandleInfo = hWnd;
  dwNewLong = a5;
  dwInitParam = GetWindowLongW(hWnd, -21);
  lParam = 0;
  memset(&ItemInfo, 0, 0x30u);
  v6 = dword_107D0B0;
  pTcpTable = 0;
  *&v102[1] = 0;
  ppTcpTable = 0;
  lpMem = 0;
  v114 = 1343;
  _mm_storeu_si128((&pnIDs + 1), _mm_load_si128(&xmmword_1046C50));
  if ( !(v6 & 1) )
  {
    dword_107D0B0 = v6 | 1;
    pnWidths = MulDiv(50, gLogPixelSize.x, 96);
    word_107D0A6 = MulDiv(100, gLogPixelSize.x, 96);
    word_107D0A8 = MulDiv(100, gLogPixelSize.x, 96);
    word_107D0AA = MulDiv(100, gLogPixelSize.x, 96);
    word_107D0AC = MulDiv(100, gLogPixelSize.x, 96);
  }
  v7 = GetDlgItem(hWnd, 1192);
  v8 = v7;
  v107 = v7;
  if ( a3 <= WM_TIMER )
  {
    if ( a3 != WM_TIMER )
    {
      switch ( a3 )
      {
        case WM_ALTTABACTIVE|WM_DESTROY:
          CMainWnd::DrawList(dwNewLong);
          return 0;
        case 0x2C:
          return CMainWnd::HandleMeasureItem(hWnd, a3, wParam, dwNewLong);
        case WM_NOTIFY:
          switch ( *(dwNewLong + 8) )
          {
            case LVN_GETDISPINFOW:
              return sub_FBD7B0(wParam, dwNewLong);
            case LVN_COLUMNCLICK:
              return sub_FBD040(wParam, dwNewLong);
            case LVN_ITEMCHANGED:
            case LVN_GETDISPINFO|0x94:
              v16 = SendMessageW(*(dwInitParam + 4), LVM_GETNEXTITEM, 0xFFFFFFFF, 2) != -1;
              v17 = GetDlgItem(hWnd, IDC_PAGE_PROCTHREADS_BUTTON_STACK);
              EnableWindow(v17, v16);
              return 0;
            case LVN_SETDISPINFO|0x94:
              SendMessageW(hWnd, WM_COMMAND, 0x43Du, 0);
              break;
            default:
              return 0;
          }
          return 0;
        case WM_INITDIALOG:
          v9 = operator new(0x40u);
          v99 = v9;
          v115 = 0;
          if ( v9 )
            v111 = CResizer::CResizer(v9, hWnd);
          else
            v111 = 0;
          v115 = -1;
          v10 = GetDlgItem(hWnd, 1209);
          if ( v10 )
            CResizer::AddItem(v111, v10, 1)->m_rect1 = stru_1046C70;
          PropSheet_UpdateTab(hWnd);
          SetWindowLongW(hWnd, GWLP_USERDATA, dwNewLong);
          if ( gdwVersion < 1 || (v11 = 5, !(*(dwNewLong + 40) & 0x20)) )
            v11 = 4;
          v106 = v11;
          sub_FB9BB0(v8, v11, (&pnIDs + 1), &pnWidths, 1);
          SetWindowLongW(v8, -4, Proxy_ListCtrlWndProc);
          SendMessageW(v8, 0x30u, ghConfigFont, 0);
          v12 = malloc(0x1Cu);
          v13 = dwNewLong;
          _mm_storeu_si128(v12, 0i64);
          _mm_storel_epi64(v12 + 1, 0i64);
          v12[1].m128i_i32[2] = 0;
          v12->m128i_i32[3] = 0;
          v12->m128i_i32[0] = v13;
          v12->m128i_i32[1] = v8;
          v12[1].m128i_i32[2] = -1;
          SetWindowLongW(hWnd, -21, v12);
          SendMessageW(hWnd, 0x113u, 0, 1);
          if ( SendMessageW(v8, 0x1004u, 0, 0) )
          {
            v14 = 0;
            if ( v106 )
            {
              do
              {
                if ( v14 == 3 )
                  SendMessageW(v8, 0x101Eu, 3u, word_107D0AA);
                else
                  SendMessageW(v8, 0x101Eu, v14, 0xFFFF);
                ++v14;
              }
              while ( v14 < v106 );
            }
            v5 = pSystemHandleInfo;
          }
          CheckDlgButton(v5, 1194, byte_10610D8 != 0);
          v15 = IsDlgButtonChecked(v5, 1194);
          SetPropW(v8, L"resolve", (v15 == 1));
          SetFocus(v8);
          ReleaseCapture();
          return 0;
        case WM_COMMAND:
          if ( wParam <= 40001 )
          {
            if ( wParam != 40001 )
            {
              if ( wParam == 1085 )
              {
                if ( AllocateAndGetTcpExTableFromStack )
                  DialogBoxParamW(ghMainInstance, L"THREADSTACK", hWnd, DlgThreadStack, dwInitParam);
                else
                  MessageBoxW(hWnd, L"Stacks not available on this version of Windows", L"Process Explorer", 0x30u);
              }
              else if ( wParam == 1194 && !(wParam >> 16) )
              {
                v19 = IsDlgButtonChecked(hWnd, 1194);
                SetPropW(v8, L"resolve", (v19 == 1));
                byte_10610D8 = IsDlgButtonChecked(pSystemHandleInfo, 1194) == 1;
                goto LABEL_33;
              }
              return 0;
            }
            v94 = 40014;
LABEL_43:
            v20 = GetParent(hWnd);
            PostMessageW(v20, 0x111u, v94, 0);
            return 0;
          }
          if ( wParam != 40002 )
          {
            if ( wParam - 40092 > 1 )
              return 0;
            v94 = wParam;
            goto LABEL_43;
          }
          SetEvent(ghRefreshEventHandle);
          break;
        default:
          return 0;
      }
      return 0;
    }
    v21 = 0;
    LOBYTE(pnIDs) = 0;
    v105 = 0;
    if ( !dwNewLong )
    {
      lParam = 4;
      v22 = SendMessageW(v7, 0x1004u, 0, 0);
      ItemInfo.iItem = 0;
      ItemInfo.mask = v22 - 1;
      if ( SendMessageW(v8, 0x104Bu, 0, &lParam) )
      {
        do
        {
          *(ItemInfo.iImage + 36) = 0;
          v23 = sub_FF58D0(a1, v8, &lParam, ItemInfo.iImage, v102);
          v24 = pnIDs;
          if ( v23 )
            v24 = 1;
          LOBYTE(pnIDs) = v24;
          if ( v102[0] )
          {
            v21 = (v21 + 1);
            *(ItemInfo.iImage + 8) = 0;
          }
          lParam = 4;
          ItemInfo.iItem = 0;
        }
        while ( SendMessageW(v8, 0x104Bu, 0, &lParam) );
        v105 = v21;
      }
    }
    if ( !AllocateAndGetTcpExTableFromStack )
    {
      if ( *GetExtendedTcpTable )
      {
        ReturnLength = 0;
        if ( GetExtendedTcpTable(0, &ReturnLength, 0, 2u, TCP_TABLE_OWNER_MODULE_ALL, 0) == 122 )
        {
          v55 = 0;
          do
          {
            if ( v55 )
              free(v55);
            v55 = malloc(ReturnLength);
          }
          while ( GetExtendedTcpTable(v55, &ReturnLength, 0, 2u, TCP_TABLE_OWNER_MODULE_ALL, 0) == 122 );
          v111 = v55;
          v33 = v55 == 0;
          v21 = v105;
          if ( !v33 )
          {
            v56 = v111;
            v57 = 0;
            pSystemHandleInfo = 0;
            if ( *v111 )
            {
              v58 = (v111 + 28);
              do
              {
                if ( *v58 == *(*dwInitParam + 68) )
                {
                  v59 = *(v58 - 2);
                  if ( v59 )
                    v60 = *(v58 - 1);
                  else
                    v60 = 0;
                  v61 = sub_FDA070(
                          v107,
                          dwNewLong,
                          0,
                          *(v58 - 5),
                          *(v58 - 4),
                          0,
                          *(v58 - 3),
                          v59,
                          0,
                          v60,
                          *v58,
                          (v58 + 3),
                          0,
                          &pnIDs);
                  v57 = pSystemHandleInfo;
                  if ( v61 )
                    LOBYTE(pnIDs) = 1;
                  else
                    v21 = (v21 - 1);
                }
                v56 = v111;
                v57 = (v57 + 1);
                v58 += 40;
                pSystemHandleInfo = v57;
              }
              while ( v57 < *v111 );
            }
            free(v56);
          }
        }
        ReturnLength = 0;
        if ( GetExtendedUdpTable(0, &ReturnLength, 0, 2u, UDP_TABLE_OWNER_MODULE, 0) == 122 )
        {
          v62 = 0;
          do
          {
            if ( v62 )
              free(v62);
            v62 = malloc(ReturnLength);
          }
          while ( GetExtendedUdpTable(v62, &ReturnLength, 0, 2u, UDP_TABLE_OWNER_MODULE, 0) == 122 );
          v111 = v62;
          if ( v62 )
          {
            v63 = v62;
            v64 = 0;
            pSystemHandleInfo = 0;
            if ( *v62 )
            {
              v65 = v62 + 4;
              v106 = v62 + 4;
              do
              {
                if ( *v65 == *(*dwInitParam + 68) )
                {
                  v66 = sub_FDA070(
                          v107,
                          dwNewLong,
                          1,
                          2,
                          *(v65 - 2),
                          0,
                          *(v65 - 1),
                          0xFFFFFFFF,
                          0,
                          -1,
                          *v65,
                          (v65 + 6),
                          0,
                          &pnIDs);
                  if ( v66 )
                  {
                    if ( dwNewLong )
                      *(v66 + 4) = 0;
                    LOBYTE(pnIDs) = 1;
                  }
                  else
                  {
                    v21 = (v21 - 1);
                  }
                  v64 = pSystemHandleInfo;
                  v65 = v106;
                }
                v63 = v111;
                v64 = (v64 + 1);
                v65 += 40;
                pSystemHandleInfo = v64;
                v106 = v65;
              }
              while ( v64 < *v111 );
            }
            free(v63);
          }
        }
        v67 = 0;
        ReturnLength = 0;
        if ( GetExtendedTcpTable(0, &ReturnLength, 0, 0x17u, TCP_TABLE_OWNER_MODULE_ALL, 0) == 122 )
        {
          do
          {
            if ( v67 )
              free(v67);
            v67 = malloc(ReturnLength);
          }
          while ( GetExtendedTcpTable(v67, &ReturnLength, 0, 0x17u, TCP_TABLE_OWNER_MODULE_ALL, 0) == 122 );
          v111 = v67;
          if ( v67 )
          {
            v68 = 0;
            pSystemHandleInfo = 0;
            if ( *v67 )
            {
              v69 = v67 + 15;
              do
              {
                if ( *v69 == *(*dwInitParam + 68) )
                {
                  if ( v69 == 28 )
                    v70 = 0;
                  else
                    v70 = *(v69 - 2);
                  v71 = sub_FDA070(
                          v107,
                          dwNewLong,
                          2,
                          *(v69 - 1),
                          0,
                          (v69 - 13),
                          *(v69 - 8),
                          0,
                          (v69 - 7),
                          v70,
                          *v69,
                          (v69 + 3),
                          0,
                          &pnIDs);
                  v68 = pSystemHandleInfo;
                  if ( v71 )
                    LOBYTE(pnIDs) = 1;
                  else
                    v21 = (v21 - 1);
                }
                v68 = (v68 + 1);
                v69 += 48;
                pSystemHandleInfo = v68;
              }
              while ( v68 < *v111 );
              v67 = v111;
            }
            free(v67);
          }
        }
        v72 = 0;
        ReturnLength = 0;
        if ( GetExtendedUdpTable(0, &ReturnLength, 0, 0x17u, UDP_TABLE_OWNER_MODULE, 0) == 122 )
        {
          do
          {
            if ( v72 )
              free(v72);
            v72 = malloc(ReturnLength);
          }
          while ( GetExtendedUdpTable(v72, &ReturnLength, 0, 0x17u, UDP_TABLE_OWNER_MODULE, 0) == 122 );
          if ( v72 )
          {
            v33 = *v72 == 0;
            v111 = 0;
            if ( !v33 )
            {
              v73 = (v72 + 8);
              pSystemHandleInfo = (v72 + 8);
              do
              {
                if ( v73->NumberOfHandles == *(*dwInitParam + 68) )
                {
                  v74 = sub_FDA070(
                          v107,
                          dwNewLong,
                          3,
                          2,
                          0,
                          &v73[-2].Handles[0].GrantedAccess,
                          v73[-1].Handles[0].GrantedAccess,
                          0xFFFFFFFF,
                          0,
                          -1,
                          v73->NumberOfHandles,
                          v73[1].Handles,
                          0,
                          &pnIDs);
                  if ( v74 )
                  {
                    if ( dwNewLong )
                      *(v74 + 4) = 0;
                    LOBYTE(pnIDs) = 1;
                  }
                  else
                  {
                    v21 = (v21 - 1);
                  }
                  v73 = pSystemHandleInfo;
                }
                v73 = (v73 + 176);
                pSystemHandleInfo = v73;
                ++v111;
              }
              while ( v111 < *v72 );
            }
            free(v72);
          }
        }
        v8 = v107;
      }
      else
      {
        ReturnLength = 64000;
        pSystemHandleInfo = malloc(64000u);
        SystemInfoClass_1 = SystemHandleInformation;
        if ( gbSupportExtendedSystemHandleInformation )
          SystemInfoClass_1 = SystemExtendedHandleInformation;
        if ( NtQuerySystemInformation(SystemInfoClass_1, pSystemHandleInfo, 0xFA00u, &ReturnLength) )
        {
          pSystemHandleInfo_1 = pSystemHandleInfo;
          do
          {
            free(pSystemHandleInfo_1);
            ReturnLength *= 2;
            v77 = ReturnLength;
            pSystemHandleInfo_1 = malloc(ReturnLength);
            SystemInfoClass = SystemHandleInformation;
            if ( gbSupportExtendedSystemHandleInformation )
              SystemInfoClass = SystemExtendedHandleInformation;
          }
          while ( NtQuerySystemInformation(SystemInfoClass, pSystemHandleInfo_1, v77, &ReturnLength) );
          v21 = v105;
          pSystemHandleInfo = pSystemHandleInfo_1;
          v8 = v107;
        }
        v111 = sub_FF39C0(pSystemHandleInfo, *(*dwInitParam + 68));
        ReturnLength = 0;
        dwInitParam = 0;
        if ( GetTcpTable(0, &ReturnLength, 1) == 122 )
        {
          do
          {
            v79 = malloc(ReturnLength);
            v80 = v79;
            dwInitParam = v79;
            v81 = GetTcpTable(v79, &ReturnLength, 1);
            v104 = v81;
            if ( v81 )
            {
              free(v80);
              v81 = v104;
              dwInitParam = 0;
            }
          }
          while ( v81 == 122 );
          v21 = v105;
        }
        ReturnLength = 0;
        v106 = 0;
        if ( GetUdpTable(0, &ReturnLength, 1) == 122 )
        {
          do
          {
            v82 = malloc(ReturnLength);
            v83 = v82;
            v106 = v82;
            v84 = GetUdpTable(v82, &ReturnLength, 1);
            v104 = v84;
            if ( v84 )
            {
              free(v83);
              v84 = v104;
              v106 = 0;
            }
          }
          while ( v84 == 122 );
          v8 = v107;
        }
        if ( dwInitParam )
        {
          v33 = *dwInitParam == 0;
          v104 = 0;
          if ( !v33 )
          {
            v85 = dwInitParam + 16;
            v105 = (dwInitParam + 16);
            do
            {
              if ( sub_FDF600(v111, 0, *(v85 - 8), *(v85 - 4)) )
              {
                if ( *v105 )
                  v86 = v105[1];
                else
                  v86 = 0;
                v8 = v107;
                if ( sub_FDA070(
                       v107,
                       dwNewLong,
                       0,
                       *(v105 - 3),
                       *(v105 - 2),
                       0,
                       *(v105 - 1),
                       *v105,
                       0,
                       v86,
                       0,
                       0,
                       0,
                       &pnIDs) )
                {
                  LOBYTE(pnIDs) = 1;
                }
                else
                {
                  v21 = (v21 - 1);
                }
              }
              v85 = (v105 + 5);
              ++v104;
              v105 += 5;
            }
            while ( v104 < *dwInitParam );
          }
        }
        if ( v106 )
        {
          v33 = *v106 == 0;
          v104 = 0;
          if ( !v33 )
          {
            v87 = v106 + 4;
            v105 = (v106 + 4);
            do
            {
              v88 = *v87;
              v107 = *(v87 + 1);
              v99 = v88;
              if ( sub_FDF600(v111, 1, v88, v107) )
              {
                if ( sub_FDA070(v8, dwNewLong, 1, 2, v99, 0, v107, 0xFFFFFFFF, 0, -1, 0, 0, 0, &pnIDs) )
                  LOBYTE(pnIDs) = 1;
                else
                  v21 = (v21 - 1);
              }
              v87 = (v105 + 2);
              ++v104;
              v105 += 2;
            }
            while ( v104 < *v106 );
          }
        }
        free(pSystemHandleInfo);
        if ( v106 )
          free(v106);
        if ( dwInitParam )
          free(dwInitParam);
        if ( v111 )
          free(v111);
      }
      goto LABEL_191;
    }
    pTcpTable = 0;
    ppTcpTable = 0;
    if ( AllocateAndGetTcpExTable2FromStack )
    {
      v25 = GetProcessHeap();
      if ( AllocateAndGetTcpExTable2FromStack(&ppTcpTable, 1, v25, 0, 2u, TCP_TABLE_OWNER_MODULE_ALL) )
        ppTcpTable = 0;
    }
    else
    {
      v26 = GetProcessHeap();
      v27 = AllocateAndGetTcpExTableFromStack(&pTcpTable, 1, v26, 2u, 2u);
      v28 = pTcpTable;
      if ( v27 )
        v28 = 0;
      pTcpTable = v28;
    }
    *&v102[1] = 0;
    lpMem = 0;
    if ( AllocateAndGetUdpExTable2FromStack )
    {
      v29 = GetProcessHeap();
      if ( AllocateAndGetUdpExTable2FromStack(&lpMem, 1, v29, 2u, 2u, UDP_TABLE_OWNER_MODULE) )
        lpMem = 0;
    }
    else
    {
      v30 = GetProcessHeap();
      v31 = AllocateAndGetUdpExTableFromStack(&v102[1], 1, v30, 2u, 2u);
      v32 = *&v102[1];
      if ( v31 )
        v32 = 0;
      *&v102[1] = v32;
    }
    if ( pTcpTable )
    {
      v33 = *pTcpTable == 0;
      v111 = 0;
      if ( !v33 )
      {
        v34 = 0;
        pSystemHandleInfo = 0;
        do
        {
          v21 = v105;
          if ( *(pTcpTable + v34 + 24) == *(*dwInitParam + 68) )
          {
            if ( *(pTcpTable + v34 + 16) )
              v35 = *(pTcpTable + v34 + 20);
            else
              v35 = 0;
            v8 = v107;
            v36 = sub_FDA070(
                    v107,
                    dwNewLong,
                    0,
                    *(pTcpTable + v34 + 4),
                    *(pTcpTable + v34 + 8),
                    0,
                    *(pTcpTable + v34 + 12),
                    *(pTcpTable + v34 + 16),
                    0,
                    v35,
                    *(pTcpTable + v34 + 24),
                    0,
                    0,
                    &pnIDs);
            v34 = pSystemHandleInfo;
            if ( v36 )
            {
              LOBYTE(pnIDs) = 1;
            }
            else
            {
              v21 = (v21 - 1);
              v105 = v21;
            }
          }
          v34 = (v34 + 24);
          ++v111;
          pSystemHandleInfo = v34;
        }
        while ( v111 < *pTcpTable );
      }
    }
    else if ( ppTcpTable )
    {
      v33 = *ppTcpTable == 0;
      v37 = ppTcpTable + 8;
      pSystemHandleInfo = 0;
      if ( !v33 )
      {
        do
        {
          if ( v37[6] == *(*dwInitParam + 68) )
          {
            v111 = *v37 - 28;
            v104 = malloc(v111);
            memmove_0(v104, v37 + 7, v111);
            v38 = v37[4];
            if ( v38 )
              v39 = v37[5];
            else
              v39 = 0;
            if ( sub_FDA070(v107, dwNewLong, 0, v37[1], v37[2], 0, v37[3], v38, 0, v39, v37[6], v104, v111, &pnIDs) )
              LOBYTE(pnIDs) = 1;
            else
              v21 = (v21 - 1);
          }
          v37 = (v37 + *v37);
          pSystemHandleInfo = (pSystemHandleInfo + 1);
        }
        while ( pSystemHandleInfo < *ppTcpTable );
        v105 = v21;
      }
      v8 = v107;
    }
    if ( *&v102[1] )
    {
      v33 = **&v102[1] == 0;
      v111 = 0;
      if ( !v33 )
      {
        v40 = 0;
        pSystemHandleInfo = 0;
        do
        {
          v8 = v107;
          if ( *(&v40->Handles[0].Object + *&v102[1]) == *(*dwInitParam + 68) )
          {
            v41 = sub_FDA070(
                    v107,
                    dwNewLong,
                    1,
                    2,
                    *(&v40->Handles[0].UniqueProcessId + *&v102[1]),
                    0,
                    *(&v40->Handles[0].ObjectTypeIndex + *&v102[1]),
                    0xFFFFFFFF,
                    0,
                    -1,
                    *(&v40->Handles[0].Object + *&v102[1]),
                    0,
                    0,
                    &pnIDs);
            if ( v41 )
            {
              if ( dwNewLong )
                *(v41 + 4) = 0;
              LOBYTE(pnIDs) = 1;
            }
            else
            {
              v21 = (v21 - 1);
            }
            v40 = pSystemHandleInfo;
          }
          v40 = (v40 + 12);
          ++v111;
          pSystemHandleInfo = v40;
        }
        while ( v111 < **&v102[1] );
      }
    }
    else
    {
      if ( !lpMem )
      {
LABEL_118:
        if ( pTcpTable )
        {
          v51 = pTcpTable;
          v52 = GetProcessHeap();
          HeapFree(v52, 0, v51);
        }
        if ( ppTcpTable )
        {
          v53 = ppTcpTable;
          v54 = GetProcessHeap();
          HeapFree(v54, 0, v53);
        }
LABEL_191:
        if ( pnIDs || v21 )
        {
          InvalidateRect(v8, 0, 0);
          CTreeList::InitHeaderColumn(v8, dword_1069B98, dword_1069B98, byte_105D225);
          v98 = dword_1069B98;
          v97 = 1192;
          SendMessageW(v8, 0x1030u, &v97, PropProcThreadsSortCallback);
          SendMessageW(v8, 0xBu, 1u, 0);
        }
        return 0;
      }
      v33 = *lpMem == 0;
      v42 = lpMem + 8;
      v106 = lpMem + 8;
      v111 = 0;
      if ( v33 )
      {
LABEL_116:
        if ( lpMem )
        {
          v49 = lpMem;
          v50 = GetProcessHeap();
          HeapFree(v50, 0, v49);
        }
        goto LABEL_118;
      }
      do
      {
        if ( v42[3] == *(*dwInitParam + 68) )
        {
          v43 = *v42 - 16;
          v44 = malloc(v43);
          memmove_0(v44, v106 + 16, v43);
          v45 = v43;
          v8 = v107;
          v46 = sub_FDA070(
                  v107,
                  dwNewLong,
                  1,
                  2,
                  *(v106 + 1),
                  0,
                  *(v106 + 2),
                  0xFFFFFFFF,
                  0,
                  -1,
                  *(v106 + 3),
                  v44,
                  v45,
                  &pnIDs);
          if ( v46 )
          {
            if ( dwNewLong )
              *(v46 + 4) = 0;
            v21 = v105;
            LOBYTE(pnIDs) = 1;
          }
          else
          {
            v21 = (v105 - 1);
            v105 = (v105 - 1);
          }
          v42 = v106;
        }
        v42 = (v42 + *v42);
        v106 = v42;
        ++v111;
      }
      while ( v111 < *lpMem );
    }
    if ( *&v102[1] )
    {
      v47 = *&v102[1];
      v48 = GetProcessHeap();
      HeapFree(v48, 0, v47);
    }
    goto LABEL_116;
  }
  if ( a3 > 0x138 )
  {
    if ( a3 == 1024 )
    {
LABEL_33:
      InvalidateRect(v8, 0, 0);
    }
    else if ( a3 == 2033 )
    {
      v89 = dwInitParam;
      if ( gdwVersion < 1 || (v90 = *dwInitParam, v111 = 5, !(*(v90 + 40) & 0x20)) )
        v111 = 4;
      if ( *(dwInitParam + 12) )
      {
        CloseHandle(*(dwInitParam + 12));
        v89 = dwInitParam;
      }
      if ( *(v89 + 16) )
      {
        RtlDestroyQueryDebugBuffer(*(v89 + 16));
        v89 = dwInitParam;
      }
      if ( *(v89 + 8) )
      {
        free(*(v89 + 8));
        v89 = dwInitParam;
      }
      free(v89);
      if ( SendMessageW(v8, 0x1004u, 0, 0) && v111 )
      {
        v91 = 0;
        do
        {
          v92 = gLogPixelSize.x;
          v93 = SendMessageW(v8, 0x101Du, v91, 0);
          *(&pnWidths + v91++) = MulDiv(v93, 96, v92);
        }
        while ( v91 < v111 );
        v5 = pSystemHandleInfo;
      }
      DestroyWindow(v5);
    }
    return 0;
  }
  if ( a3 != 312 && a3 != 307 && a3 != 310 )
    return 0;
  return PE_FillControl(hWnd, wParam);
}
// 1046C50: using guessed type __int128 xmmword_1046C50;
// 1046C70: using guessed type RECT stru_1046C70;
// 105D225: using guessed type char byte_105D225;
// 10610D8: using guessed type char byte_10610D8;
// 1064E54: using guessed type int gdwVersion;
// 106ABA5: using guessed type char gbSupportExtendedSystemHandleInformation;
// 106F264: using guessed type int (__stdcall *RtlDestroyQueryDebugBuffer)(_DWORD);
// 107D0A6: using guessed type __int16 word_107D0A6;
// 107D0A8: using guessed type __int16 word_107D0A8;
// 107D0AA: using guessed type __int16 word_107D0AA;
// 107D0AC: using guessed type __int16 word_107D0AC;
// 107D0B0: using guessed type int dword_107D0B0;

//----- (00FEACF0) --------------------------------------------------------
int __stdcall PageProcThreads(HWND hWnd, int uMsg, WPARAM wParam, int a4)
{
  HWND hWnd_1; // ebx
  tagThreadItem *pUserData; // edi
  int v6; // ST20_4
  tagThreadItem *v7; // eax
  CResizer *pResizer; // esi
  HWND hWndList_1; // eax
  struct tagResizerItem *v10; // eax
  HWND v11; // eax
  struct tagResizerItem *v12; // eax
  HWND v13; // ST20_4
  HWND v14; // eax
  struct tagResizerItem *v15; // eax
  HWND v16; // ST20_4
  HWND v17; // eax
  struct tagResizerItem *v18; // eax
  HWND v19; // ST20_4
  HWND v20; // eax
  struct tagResizerItem *v21; // eax
  HWND v22; // ST20_4
  HWND v23; // eax
  struct tagResizerItem *v24; // eax
  HWND v25; // ST20_4
  HWND v26; // eax
  struct tagResizerItem *v27; // eax
  HWND v28; // ST20_4
  HWND v29; // eax
  struct tagResizerItem *v30; // eax
  HWND v31; // ST20_4
  HWND v32; // eax
  HWND v33; // eax
  HWND v34; // eax
  struct tagResizerItem *v35; // eax
  HWND v36; // ST20_4
  __int128 *v37; // ecx
  HWND v38; // eax
  HWND v39; // eax
  HWND v40; // eax
  HWND v41; // eax
  HWND v42; // eax
  HWND v43; // eax
  int v44; // ST24_4
  HWND v45; // eax
  int v46; // ST24_4
  HWND v47; // eax
  tagThreadItem *pThreadItem; // esi
  HCURSOR lParam_1; // eax
  HWND hWndList; // eax
  LONG v51; // eax
  HWND v52; // eax
  SYSTEM_PROCESS_INFORMATION *v53; // edi
  HANDLE v54; // ecx
  HCURSOR v55; // eax
  HCURSOR v56; // eax
  int v57; // ecx
  HANDLE v58; // eax
  UINT *v59; // eax
  int result; // eax
  HANDLE v61; // eax
  HANDLE v62; // eax
  _RTL_PROCESS_MODULES *v63; // eax
  _RTL_PROCESS_MODULES *v64; // eax
  int v65; // eax
  struct _RTL_DEBUG_BUFFER *v66; // eax
  void *hThread; // edi
  struct _IMAGELIST *v68; // ebx
  HICON v69; // eax
  HICON v70; // eax
  tagThreadItem *pThreadItem_2; // esi
  LONG v72; // eax
  HANDLE v73; // eax
  void *v74; // ST24_4
  HWND hWnd_4; // esi
  HWND (__stdcall *GetDlgItem)(HWND, int); // edi
  HWND v77; // eax
  HWND v78; // eax
  HWND v79; // eax
  HWND v80; // eax
  HWND v81; // eax
  tagNMHDR *pNMHDR; // esi
  UINT v83; // eax
  HWND v84; // eax
  HWND v85; // eax
  HWND v86; // eax
  HWND v87; // eax
  HWND v88; // eax
  HWND v89; // eax
  HWND v90; // eax
  BOOL v91; // ST24_4
  HWND v92; // eax
  BOOL v93; // ST24_4
  HWND v94; // eax
  BOOL v95; // eax
  BOOL v96; // ST24_4
  HWND v97; // eax
  BOOL v98; // eax
  BOOL v99; // ST24_4
  HWND v100; // eax
  BOOL v101; // eax
  BOOL v102; // ST24_4
  HWND v103; // eax
  SYSTEM_PROCESS_INFORMATION *v104; // ecx
  HANDLE v105; // edx
  HCURSOR v106; // esi
  ULONG v107; // edx
  bool v108; // zf
  HWND v109; // ebx
  HCURSOR v110; // ebx
  HWND hWnd_2; // ebx
  HCURSOR lParamIn_1; // esi
  HWND v113; // eax
  unsigned int v114; // eax
  const WCHAR *v115; // eax
  HWND v116; // esi
  void *v117; // eax
  HANDLE *v118; // eax
  HANDLE ThreadHandle; // esi
  HANDLE ThreadHandle_1; // esi
  HWND v121; // eax
  wchar_t *v122; // ecx
  __int16 *v123; // eax
  bool v124; // cf
  unsigned __int16 v125; // dx
  int v126; // eax
  tagTREEVIEWITEMPARAM *v127; // esi
  HANDLE v128; // eax
  HWND v129; // eax
  void *v130; // ST24_4
  WPARAM v131; // [esp-8h] [ebp-1E98h]
  const WCHAR *v132; // [esp-4h] [ebp-1E94h]
  int v133; // [esp-4h] [ebp-1E94h]
  int v134; // [esp-4h] [ebp-1E94h]
  char v135[572]; // [esp+10h] [ebp-1E80h]
  int v136[21]; // [esp+24Ch] [ebp-1C44h]
  SHELLEXECUTEINFOW pExecInfo; // [esp+2A0h] [ebp-1BF0h]
  tagNMHDR nmhdr; // [esp+2DCh] [ebp-1BB4h]
  int v139; // [esp+2E8h] [ebp-1BA8h]
  struct _FILETIME LocalFileTime; // [esp+2F0h] [ebp-1BA0h]
  LPARAM dwInitParam; // [esp+2F8h] [ebp-1B98h]
  int v142; // [esp+2FCh] [ebp-1B94h]
  HANDLE hObject; // [esp+300h] [ebp-1B90h]
  HANDLE v144; // [esp+304h] [ebp-1B8Ch]
  _RTL_PROCESS_MODULES *v145; // [esp+308h] [ebp-1B88h]
  PRTL_DEBUG_BUFFER v146; // [esp+30Ch] [ebp-1B84h]
  int v147; // [esp+310h] [ebp-1B80h]
  PRTL_DEBUG_BUFFER v148; // [esp+314h] [ebp-1B7Ch]
  ULONG ReturnLength; // [esp+318h] [ebp-1B78h]
  DWORD ExitCode; // [esp+320h] [ebp-1B70h]
  DWORD ThreadId; // [esp+324h] [ebp-1B6Ch]
  tagLVITEMW lParam; // [esp+328h] [ebp-1B68h]
  int ThreadInformation; // [esp+35Ch] [ebp-1B34h]
  char ArgList[4]; // [esp+360h] [ebp-1B30h]
  UINT *pnIDs; // [esp+364h] [ebp-1B2Ch]
  HWND hWnd_3; // [esp+368h] [ebp-1B28h]
  SYSTEM_PROCESS_INFORMATION *pSystemProcessInfo; // [esp+36Ch] [ebp-1B24h]
  ULONG SystemInformationLength; // [esp+370h] [ebp-1B20h]
  tagThreadItem *pThreadItem_1; // [esp+374h] [ebp-1B1Ch]
  HCURSOR lParamIn; // [esp+378h] [ebp-1B18h]
  HWND hWndEdit; // [esp+37Ch] [ebp-1B14h]
  char ListParam[36]; // [esp+380h] [ebp-1B10h]
  DWORD v163; // [esp+3A4h] [ebp-1AECh]
  int v164; // [esp+3A8h] [ebp-1AE8h]
  HANDLE v165; // [esp+3ACh] [ebp-1AE4h]
  __int16 szText[64]; // [esp+3B8h] [ebp-1AD8h]
  __int16 szBuffer[2052]; // [esp+438h] [ebp-1A58h]
  struct _SYSTEMTIME SystemTime; // [esp+1440h] [ebp-A50h]
  __int128 v169; // [esp+1450h] [ebp-A40h]
  __int128 v170; // [esp+1460h] [ebp-A30h]
  int v171; // [esp+1470h] [ebp-A20h]
  __int16 szText2[256]; // [esp+1474h] [ebp-A1Ch]
  __int16 szBuffer2[1024]; // [esp+1674h] [ebp-81Ch]
  WORD pnWidths[2]; // [esp+1E74h] [ebp-1Ch]
  __int16 v175; // [esp+1E78h] [ebp-18h]
  __int16 v176; // [esp+1E7Ah] [ebp-16h]
  __int16 v177; // [esp+1E7Ch] [ebp-14h]
  int v178; // [esp+1E8Ch] [ebp-4h]

  hWnd_1 = hWnd;
  hWnd_3 = hWnd;
  lParamIn = a4;
  pUserData = GetWindowLongW(hWnd, GWLP_USERDATA);
  pSystemProcessInfo = 0;
  pThreadItem_1 = pUserData;
  lParam.mask = 0;
  memset(&lParam.iItem, 0, 0x30u);
  _mm_storeu_si128(&v170, _mm_load_si128(&xmmword_1046C60));
  v171 = 0x435;
  v6 = gLogPixelSize.x;
  _mm_storeu_si128(&v169, _mm_load_si128(&xmmword_1046C40));
  pnWidths[0] = MulDiv(-50, v6, 96);
  pnWidths[1] = MulDiv(-50, gLogPixelSize.x, 96);
  v175 = MulDiv(-75, gLogPixelSize.x, 96);
  v176 = MulDiv(100, gLogPixelSize.x, 96);
  v177 = MulDiv(200, gLogPixelSize.x, 96);
  SystemInformationLength = 0;
  if ( uMsg > WM_COMMAND )
  {
    if ( uMsg > WM_CTLCOLORDLG )
    {
      if ( uMsg != WM_CTLCOLORSTATIC )
      {
        if ( uMsg == 0x7F1 )
        {
          v130 = pUserData->m_hEvent2;
          pUserData->field_18 = 1;
          SetEvent(v130);
          InterlockedDecrement(&pUserData->m_nRefCount);
          return 0;
        }
        return 0;
      }
    }
    else if ( uMsg != WM_CTLCOLORDLG )
    {
      if ( uMsg == WM_TIMER )
      {
        if ( pUserData )
          SetEvent(pUserData->m_hEvent2);
        nmhdr.code = 0xFFFFFFF1;
        v139 = 0x74;
        SendMessageW(hWnd, WM_NOTIFY, 0, &nmhdr);
        return 1;
      }
      if ( uMsg != WM_CTLCOLOREDIT )
        return 0;
    }
    return PE_FillControl(hWnd, wParam);
  }
  if ( uMsg != WM_COMMAND )
  {
    switch ( uMsg )
    {
      case WM_DRAWITEM:
        CMainWnd::DrawList(lParamIn);
        return 0;
      case WM_MEASUREITEM:
        return CMainWnd::HandleMeasureItem(hWnd, uMsg, wParam, lParamIn);
      case 0x4E:                                // WM_NOTIFY
        pNMHDR = lParamIn;
        switch ( *(lParamIn + 2) )
        {
          case LVN_GETDISPINFOW:
            result = sub_FBD7B0(wParam, lParamIn);
            break;
          case LVN_COLUMNCLICK:
            result = sub_FBD040(IDC_PAGE_PROCTHREADS_LISTCTRL, lParamIn);
            break;
          case LVN_DELETEITEM:
            result = sub_FBD4B0(IDC_PAGE_PROCTHREADS_LISTCTRL, lParamIn);
            break;
          case LVN_ITEMCHANGED:
          case LVN_BEGINRDRAG|0x60:
            GetWindowLongW(pUserData->m_hWndList, GWL_STYLE);
            v83 = pNMHDR->code;
            if ( v83 != LVN_ITEMCHANGED && (v83 != -15 || pNMHDR[1].hwndFrom != 116) )
              return 0;
            v84 = ::GetDlgItem(hWnd, IDC_PAGE_PROCTHREADS_LISTCTRL);
            lParam.iItem = SendMessageW(v84, LVM_GETNEXTITEM, 0xFFFFFFFF, 2);
            lParam.iSubItem = 0;
            lParam.mask = 4;
            v85 = ::GetDlgItem(hWnd, IDC_PAGE_PROCTHREADS_LISTCTRL);
            SendMessageW(v85, LVM_GETITEMW, 0, &lParam);
            if ( lParam.iItem == -1 )
            {
              wsprintfW(szBuffer2, &gszNullString);
              SetDlgItemTextW(hWnd, IDC_PAGE_PROCTHREADS_STATIC_THREAD_ID_VALUE, szBuffer2);
              SetDlgItemTextW(hWnd, IDC_PAGE_PROCTHREADS_STATIC_START_TIME_VALUE, szBuffer2);
              SetDlgItemTextW(hWnd, IDC_PAGE_PROCTHREADS_STATIC_BASE_PRIORITY_VALUE, szBuffer2);
              SetDlgItemTextW(hWnd, IDC_PAGE_PROCTHREADS_STATIC_DYNAMIC_PRIORITY_VALUE, szBuffer2);
              SetDlgItemTextW(hWnd, IDC_PAGE_PROCTHREADS_STATIC_CONTEXT_SWITCHES_VALUE, szBuffer2);
              SetDlgItemTextW(hWnd, IDC_PAGE_PROCTHREADS_STATIC_KERNEL_TIME_VALUE, szBuffer2);
              SetDlgItemTextW(hWnd, IDC_PAGE_PROCTHREADS_STATIC_USER_TIME_VALUE, szBuffer2);
              SetDlgItemTextW(hWnd, IDC_PAGE_PROCTHREADS_STATIC_STATE_VALUE, szBuffer2);
              SetDlgItemTextW(hWnd, IDC_PAGE_PROCTHREADS_STATIC_MEMROY_PRIORITY_VALUE, szBuffer2);
              SetDlgItemTextW(hWnd, IDC_PAGE_PROCTHREADS_STATIC_IO_PRIORITY_VALUE, szBuffer2);
              SetDlgItemTextW(hWnd, IDC_PAGE_PROCTHREADS_STATIC_CYCLES_VALUE, szBuffer2);
              SetDlgItemTextW(hWnd, IDC_PAGE_PROCTHREADS_STATIC_IDLE_PROCESSOR_VALUE, szBuffer2);
              v86 = ::GetDlgItem(hWnd, IDC_PAGE_PROCTHREADS_BUTTON_MODULE);
              EnableWindow(v86, 0);
              v87 = ::GetDlgItem(hWnd, IDC_PAGE_PROCTHREADS_BUTTON_STACK);
              EnableWindow(v87, 0);
              v88 = ::GetDlgItem(hWnd, IDC_PAGE_PROCTHREADS_BUTTON_PERMISSIONS);
              EnableWindow(v88, 0);
              v89 = ::GetDlgItem(hWnd, IDC_PAGE_PROCTHREADS_BUTTON_KILL);
              EnableWindow(v89, 0);
              v90 = ::GetDlgItem(hWnd, IDC_PAGE_PROCTHREADS_BUTTON_SUSPEND);
              EnableWindow(v90, 0);
              result = 0;
            }
            else
            {
              v91 = *(pUserData->m_Param + 68) != 0;
              v92 = ::GetDlgItem(hWnd, IDC_PAGE_PROCTHREADS_BUTTON_MODULE);
              EnableWindow(v92, v91);
              v93 = *(pUserData->m_Param + 68) != 0;
              v94 = ::GetDlgItem(hWnd, IDC_PAGE_PROCTHREADS_BUTTON_STACK);
              EnableWindow(v94, v93);
              v95 = pUserData->m_hProcess && *(pUserData->m_Param + 68);
              v96 = v95;
              v97 = ::GetDlgItem(hWnd, IDC_PAGE_PROCTHREADS_BUTTON_PERMISSIONS);
              EnableWindow(v97, v96);
              v98 = pUserData->m_hProcess && *(pUserData->m_Param + 68);
              v99 = v98;
              v100 = ::GetDlgItem(hWnd, IDC_PAGE_PROCTHREADS_BUTTON_KILL);
              EnableWindow(v100, v99);
              v101 = pUserData->m_hProcess && *(pUserData->m_Param + 68);
              v102 = v101;
              v103 = ::GetDlgItem(hWnd, IDC_PAGE_PROCTHREADS_BUTTON_SUSPEND);
              EnableWindow(v103, v102);
              hWndEdit = lParam.lParam;
              pThreadItem_1 = 0;
              pSystemProcessInfo = 0;
              GetSystemProcessInfo(&pSystemProcessInfo, &pThreadItem_1);
              v104 = pSystemProcessInfo;
              v105 = *(pUserData->m_Param + 68);
              if ( pSystemProcessInfo->UniqueProcessId != v105 )
              {
                do
                {
                  if ( !v104->NextEntryOffset )
                    break;
                  v104 = (v104 + v104->NextEntryOffset);
                }
                while ( v104->UniqueProcessId != v105 );
              }
              v106 = &v104[1];
              if ( pUserData->field_34 )
                v106 = &v104->ReadOperationCount;
              v107 = 0;
              lParamIn = v106;
              v108 = v104->NumberOfThreads == 0;
              if ( v104->NumberOfThreads > 0 )
              {
                v109 = hWndEdit;
                do
                {
                  if ( !*(v106 + 9) )
                    *(v106 + 9) = v107;
                  if ( *(v109 + 11) == *(v106 + 9) )
                    break;
                  ++v107;
                  v106 += 16;
                }
                while ( v107 < v104->NumberOfThreads );
                hWnd_1 = hWnd_3;
                v108 = v107 == v104->NumberOfThreads;
                lParamIn = v106;
              }
              if ( !v108 )
              {
                wsprintfW(szBuffer2, L"%d", *(v106 + 9));
                SetDlgItemTextW(hWnd_1, IDC_PAGE_PROCTHREADS_STATIC_THREAD_ID_VALUE, szBuffer2);
                v110 = lParamIn;
                wsprintfW(
                  szBuffer2,
                  L"%I64d:%02I64d:%02I64d.%03I64d",
                  *lParamIn / 0x861C46800ui64,
                  *lParamIn / 0x23C34600ui64 % 0x3C,
                  *v106 / 10000000i64 % 60,
                  *v106 % 10000000i64 / 10000);
                SetDlgItemTextW(hWnd_3, IDC_PAGE_PROCTHREADS_STATIC_KERNEL_TIME_VALUE, szBuffer2);
                wsprintfW(
                  szBuffer2,
                  L"%I64d:%02I64d:%02I64d.%03I64d",
                  *(lParamIn + 1) / 0x861C46800ui64,
                  *(lParamIn + 1) / 0x23C34600ui64 % 0x3C,
                  *(v110 + 1) / 10000000i64 % 60,
                  *(v110 + 1) % 10000000i64 / 10000);
                hWnd_2 = hWnd_3;
                SetDlgItemTextW(hWnd_3, IDC_PAGE_PROCTHREADS_STATIC_USER_TIME_VALUE, szBuffer2);
                lParamIn_1 = lParamIn;
                if ( *(lParamIn + 2)
                  && (FileTimeToLocalFileTime(lParamIn + 2, &LocalFileTime),
                      FileTimeToSystemTime(&LocalFileTime, &SystemTime),
                      GetTimeFormatW(0x400u, 0, &SystemTime, 0, szBuffer2, 512))
                  && GetDateFormatW(0x400u, 0, &SystemTime, 0, szText2, 128) )
                {
                  wcscat_s(szBuffer2, 0x400u, L"   ");
                  wcscat_s(szBuffer2, 0x400u, szText2);
                }
                else
                {
                  wcscpy_s(szBuffer2, 0x400u, L"n/a");
                }
                SetDlgItemTextW(hWnd_2, IDC_PAGE_PROCTHREADS_STATIC_START_TIME_VALUE, szBuffer2);
                if ( *(lParamIn_1 + 13) != 5 || *(lParamIn_1 + 14) != 5 )
                  v132 = L"Sus&pend";
                else
                  v132 = L"R&esume";
                v113 = ::GetDlgItem(hWnd_2, IDC_PAGE_PROCTHREADS_BUTTON_SUSPEND);
                SetWindowTextW(v113, v132);
                switch ( *(lParamIn_1 + 13) )
                {
                  case 0:
                    wcscpy_s(szBuffer2, 0x400u, L"Initialized");
                    break;
                  case 1:
                    wcscpy_s(szBuffer2, 0x400u, L"Ready");
                    break;
                  case 2:
                    wcscpy_s(szBuffer2, 0x400u, L"Running");
                    break;
                  case 4:
                    wcscpy_s(szBuffer2, 0x400u, L"Terminated");
                    break;
                  case 5:
                    v114 = *(lParamIn_1 + 14);
                    if ( v114 >= 0x28 )
                      wsprintfW(szBuffer2, L"Waiting");
                    else
                      wsprintfW(szBuffer2, L"Wait:%s", &aExecutive[64 * v114]);
                    break;
                  case 6:
                    wcscpy_s(szBuffer2, 0x400u, L"Transition");
                    break;
                  case 7:
                    wcscpy_s(szBuffer2, 0x400u, L"DeferredReady");
                    break;
                  default:
                    wsprintfW(szBuffer2, L"<Unknown: %d>", *(lParamIn_1 + 13));
                    break;
                }
                SetDlgItemTextW(hWnd_2, IDC_PAGE_PROCTHREADS_STATIC_STATE_VALUE, szBuffer2);
                if ( *(lParamIn_1 + 8) )
                {
                  wsprintfW(szBuffer2, L"%d", *(lParamIn_1 + 11));
                  SetDlgItemTextW(hWnd_2, IDC_PAGE_PROCTHREADS_STATIC_BASE_PRIORITY_VALUE, szBuffer2);
                  wsprintfW(szBuffer2, L"%d", *(lParamIn_1 + 10));
                  SetDlgItemTextW(hWnd_2, IDC_PAGE_PROCTHREADS_STATIC_DYNAMIC_PRIORITY_VALUE, szBuffer2);
                  v133 = *(lParamIn_1 + 12);
                  if ( *(lParamIn_1 + 8) )
                  {
                    wsprintfW(szBuffer2, L"%d", v133);
                    v115 = sub_FC3290(szBuffer2, 0x400u);
                    SetDlgItemTextW(hWnd_2, IDC_PAGE_PROCTHREADS_STATIC_CONTEXT_SWITCHES_VALUE, v115);
                  }
                  else
                  {
                    wsprintfW(szBuffer2, L"n/a", v133);
                  }
                  v116 = hWndEdit;
                  *ArgList = -1;
                  ThreadInformation = -1;
                  v117 = *(hWndEdit + 10);
                  if ( v117 )
                  {
                    NtQueryInformationThread(v117, ThreadIoPriority, &ThreadInformation, 4u, &ReturnLength);
                    NtQueryInformationThread(*(v116 + 10), ThreadPagePriority, ArgList, 4u, &ReturnLength);
                  }
                  if ( *(v116 + 10) )
                  {
                    wsprintfW(szBuffer2, L"%I64u", *(v116 + 154), *(v116 + 155));
                    sub_FC3290(szBuffer2, 0x400u);
                  }
                  else
                  {
                    wsprintfW(szBuffer2, L"n/a");
                  }
                  SetDlgItemTextW(hWnd_2, IDC_PAGE_PROCTHREADS_STATIC_CYCLES_VALUE, szBuffer2);
                  if ( ThreadInformation == -1 )
                    wsprintfW(szBuffer2, L"n/a");
                  else
                    sub_FF7790(ThreadInformation, szBuffer2, 0x400u);
                  SetDlgItemTextW(hWnd_2, IDC_PAGE_PROCTHREADS_STATIC_IO_PRIORITY_VALUE, szBuffer2);
                  if ( *ArgList == -1 )
                    wsprintfW(szBuffer2, L"n/a");
                  else
                    wsprintfW(szBuffer2, L"%d", *ArgList);
                  SetDlgItemTextW(hWnd_2, IDC_PAGE_PROCTHREADS_STATIC_MEMROY_PRIORITY_VALUE, szBuffer2);
                  if ( GetThreadIdealProcessorEx )
                  {
                    v134 = *(v116 + 610);
                    if ( dword_10610DC <= 1 )
                      wsprintfW(szBuffer2, L"%d", v134);
                    else
                      wsprintfW(szBuffer2, L"[%d]:%d", *(v116 + 304), v134);
                    SetDlgItemTextW(hWnd_2, IDC_PAGE_PROCTHREADS_STATIC_IDLE_PROCESSOR_VALUE, szBuffer2);
                  }
                }
              }
              free(pSystemProcessInfo);
              result = 0;
            }
            break;
          case LVN_SETDISPINFO|0x94:
            SendMessageW(hWnd, WM_COMMAND, IDC_PAGE_PROCTHREADS_BUTTON_STACK, 0);
            result = 0;
            break;
          default:
            return 0;
        }
        return result;
      case 0x100:                               // WM_KEYDOWN
        if ( wParam != 116 )
          return 0;
        SetEvent(pUserData->m_hEvent3);
        return 0;
      case 0x110:                               // WM_INITDIALOG
        if ( GetLogicalProcessorInformationEx )
        {
          GetLogicalProcessorInformationEx(4, 0, &SystemInformationLength);
          dword_10610DC = SystemInformationLength / 0x4C;
        }
        v7 = operator new(0x40u);
        pThreadItem_1 = v7;
        v178 = 0;
        if ( v7 )
          pResizer = CResizer::CResizer(v7, hWnd);
        else
          pResizer = 0;
        v178 = -1;
        pResizer->m_nXRatio = 80;
        pResizer->m_nYRatio = 50;
        hWndList_1 = ::GetDlgItem(hWnd, IDC_PAGE_PROCTHREADS_LISTCTRL);
        if ( hWndList_1 )
        {
          v10 = CResizer::AddItem(pResizer, hWndList_1, 1);
          *&v10->m_rect2.left = 0i64;
          *&v10->m_rect2.right = db_one;
        }
        v11 = ::GetDlgItem(hWnd, IDC_PAGE_PROCTHREADS_STATIC_BASE_PRIORITY_VALUE);
        hWndEdit = v11;
        if ( v11 )
        {
          v12 = CResizer::AddItem(pResizer, v11, 1);
          v13 = hWndEdit;
          v12->m_rect1 = 0i64;
          CResizer::AddItem(pResizer, v13, 1)->m_rect2 = stru_1046C70;
        }
        v14 = ::GetDlgItem(hWnd, IDC_PAGE_PROCTHREADS_STATIC_DYNAMIC_PRIORITY_VALUE);
        hWndEdit = v14;
        if ( v14 )
        {
          v15 = CResizer::AddItem(pResizer, v14, 1);
          v16 = hWndEdit;
          v15->m_rect1 = 0i64;
          CResizer::AddItem(pResizer, v16, 1)->m_rect2 = stru_1046C70;
        }
        v17 = ::GetDlgItem(hWnd, IDC_PAGE_PROCTHREADS_STATIC_BASE_PRIORITY);
        hWndEdit = v17;
        if ( v17 )
        {
          v18 = CResizer::AddItem(pResizer, v17, 1);
          v19 = hWndEdit;
          v18->m_rect1 = 0i64;
          CResizer::AddItem(pResizer, v19, 1)->m_rect2 = stru_1046C70;
        }
        v20 = ::GetDlgItem(hWnd, IDC_PAGE_PROCTHREADS_STATIC_DYNAMIC_PRIORITY);
        hWndEdit = v20;
        if ( v20 )
        {
          v21 = CResizer::AddItem(pResizer, v20, 1);
          v22 = hWndEdit;
          v21->m_rect1 = 0i64;
          CResizer::AddItem(pResizer, v22, 1)->m_rect2 = stru_1046C70;
        }
        v23 = ::GetDlgItem(hWnd, IDC_PAGE_PROCTHREADS_STATIC_MEMROY_PRIORITY_VALUE);
        hWndEdit = v23;
        if ( v23 )
        {
          v24 = CResizer::AddItem(pResizer, v23, 1);
          v25 = hWndEdit;
          v24->m_rect1 = 0i64;
          CResizer::AddItem(pResizer, v25, 1)->m_rect2 = stru_1046C70;
        }
        v26 = ::GetDlgItem(hWnd, IDC_PAGE_PROCTHREADS_STATIC_IO_PRIORITY_VALUE);
        hWndEdit = v26;
        if ( v26 )
        {
          v27 = CResizer::AddItem(pResizer, v26, 1);
          v28 = hWndEdit;
          v27->m_rect1 = 0i64;
          CResizer::AddItem(pResizer, v28, 1)->m_rect2 = stru_1046C70;
        }
        v29 = ::GetDlgItem(hWnd, IDC_PAGE_PROCTHREADS_BUTTON_STACK);
        hWndEdit = v29;
        if ( v29 )
        {
          v30 = CResizer::AddItem(pResizer, v29, 1);
          v31 = hWndEdit;
          v30->m_rect1 = stru_1046C70;
          CResizer::AddItem(pResizer, v31, 1)->m_rect2 = stru_1046C70;
        }
        v32 = ::GetDlgItem(hWnd, IDC_PAGE_PROCTHREADS_BUTTON_PERMISSIONS);
        if ( v32 )
          CResizer::AddItem(pResizer, v32, 1)->m_rect1 = stru_1046C70;
        v33 = ::GetDlgItem(hWnd, IDC_PAGE_PROCTHREADS_BUTTON_KILL);
        if ( v33 )
          CResizer::AddItem(pResizer, v33, 1)->m_rect1 = stru_1046C70;
        v34 = ::GetDlgItem(hWnd, IDC_PAGE_PROCTHREADS_STATIC_IDLE_PROCESSOR_VALUE);
        hWndEdit = v34;
        if ( v34 )
        {
          v35 = CResizer::AddItem(pResizer, v34, 1);
          v36 = hWndEdit;
          v35->m_rect1 = 0i64;
          CResizer::AddItem(pResizer, v36, 1)->m_rect2 = stru_1046C70;
        }
        PropSheet_UpdateTab(hWnd);
        if ( *(lParamIn + 40) & 0x20 && gdwVersion >= 1 )
        {
          v37 = &v170;
          hWndEdit = 5;
        }
        else
        {
          v37 = &v169;
          hWndEdit = 4;
        }
        v108 = *(lParamIn + 17) == 0;
        pnIDs = v37;
        if ( v108 )
        {
          LODWORD(v170) = 1638;
          LODWORD(v169) = 1638;
        }
        if ( gdwVersion >= 1 )
        {
          *(v37 + 2) = 1200;
        }
        else
        {
          v38 = ::GetDlgItem(hWnd, IDC_PAGE_PROCTHREADS_STATIC_MEMORY_PRIORITY);
          ShowWindow(v38, 0);
          v39 = ::GetDlgItem(hWnd, IDC_PAGE_PROCTHREADS_STATIC_MEMROY_PRIORITY_VALUE);
          ShowWindow(v39, 0);
          v40 = ::GetDlgItem(hWnd, IDC_PAGE_PROCTHREADS_STATIC_IO_PRIORITY);
          ShowWindow(v40, 0);
          v41 = ::GetDlgItem(hWnd, IDC_PAGE_PROCTHREADS_STATIC_IO_PRIORITY_VALUE);
          ShowWindow(v41, 0);
          v42 = ::GetDlgItem(hWnd, IDC_PAGE_PROCTHREADS_STATIC_CYCLES_VALUE);
          ShowWindow(v42, 0);
          v43 = ::GetDlgItem(hWnd, IDC_PAGE_PROCTHREADS_STATIC_CYCLES);
          ShowWindow(v43, 0);
        }
        v44 = GetThreadIdealProcessorEx != 0 ? 5 : 0;
        v45 = ::GetDlgItem(hWnd, IDC_PAGE_PROCTHREADS_STATIC_IDLE_PROCESSOR);
        ShowWindow(v45, v44);
        v46 = GetThreadIdealProcessorEx != 0 ? 5 : 0;
        v47 = ::GetDlgItem(hWnd, IDC_PAGE_PROCTHREADS_STATIC_IDLE_PROCESSOR_VALUE);
        ShowWindow(v47, v46);
        pThreadItem = malloc(0x50u);
        pThreadItem_1 = pThreadItem;
        memset(pThreadItem, 0, 0x50u);
        lParam_1 = lParamIn;
        pThreadItem->m_Next = 0;
        pThreadItem->m_hProcess = 0;
        pThreadItem->m_Param = lParam_1;
        pThreadItem->m_hEvent = CreateEventW(0, 0, 0, 0);
        hWndList = ::GetDlgItem(hWnd, IDC_PAGE_PROCTHREADS_LISTCTRL);
        pThreadItem->m_hWndList = hWndList;
        SetWindowLongW(hWndList, GWLP_WNDPROC, Proxy_ListCtrlWndProc);
        SetWindowLongW(hWnd, GWLP_USERDATA, pThreadItem);
        v51 = GetWindowLongW(pThreadItem->m_hWndList, GWL_STYLE);
        SetWindowLongW(pThreadItem->m_hWndList, -16, v51 & -3u | 9);
        SetWindowLongW(pThreadItem->m_hWndList, GWLP_USERDATA, 5);
        v52 = ::GetDlgItem(hWnd, IDC_PAGE_PROCTHREADS_STATIC_LOADING_SYMBOLS_FOR);
        SetWindowTextW(v52, &gszNullString);
        ShowSymbolConfigWarning(0);
        SendMessageW(pThreadItem->m_hWndList, WM_SETFONT, ghConfigFont, 0);
        GetSystemProcessInfo(&pSystemProcessInfo, 0);
        v53 = pSystemProcessInfo;
        v54 = *(pThreadItem->m_Param + 0x44);
        if ( pSystemProcessInfo->UniqueProcessId == v54 )
          goto LABEL_43;
        break;
      default:
        return 0;
    }
    do
    {
      if ( !v53->NextEntryOffset )
      {
        free(pSystemProcessInfo);
        return 1;
      }
      v53 = (v53 + v53->NextEntryOffset);
    }
    while ( v53->UniqueProcessId != v54 );
LABEL_43:
    v55 = LoadCursorW(0, IDC_WAIT);
    v56 = SetCursor(v55);
    v57 = pThreadItem->m_Param;
    lParamIn = v56;
    v58 = OpenProcess(GENERIC_READ, 0, *(v57 + 0x44));
    pThreadItem->m_hProcess = v58;
    if ( v58 )
    {
      v59 = pnIDs;
    }
    else
    {
      pThreadItem->m_hProcess = OpenProcess(PROCESS_MODE_BACKGROUND_BEGIN, 0, *(pThreadItem->m_Param + 0x44));
      v59 = pnIDs;
      pnIDs[2] = 1092;
    }
    sub_FB9BB0(pThreadItem->m_hWndList, hWndEdit, v59, pnWidths, 1);
    if ( SymInitialize )
    {
      EnterCriticalSection(&gProcThreadsLock);
      SymSetOptions(0x10037u);
      v61 = pThreadItem->m_hProcess;
      if ( v61 )
        pThreadItem->m_bSymInited = SymInitialize(v61, 0, 1);
      if ( !pThreadItem->m_bSymInited )
      {
        if ( pThreadItem->m_hProcess )
          CloseHandle(pThreadItem->m_hProcess);
        v62 = GetCurrentProcess();
        pThreadItem->m_hProcess = v62;
        pThreadItem->m_bSymInited = SymInitialize(v62, 0, 1);
      }
    }
    SystemInformationLength = 1000;
    v63 = malloc(1000u);
    pThreadItem->m_SystemModules = v63;
    if ( NtQuerySystemInformation(SystemModuleInformation, v63, SystemInformationLength, &SystemInformationLength) )
    {
      do
      {
        free(pThreadItem->m_SystemModules);
        SystemInformationLength += 1000;
        v64 = malloc(SystemInformationLength);
        pThreadItem->m_SystemModules = v64;
      }
      while ( NtQuerySystemInformation(SystemModuleInformation, v64, SystemInformationLength, &SystemInformationLength) );
    }
    v65 = pThreadItem->m_Param;
    pThreadItem->m_DebugBuffer = 0;
    if ( !(*(v65 + 40) & 0x10) )
    {
      v66 = RtlCreateQueryDebugBuffer(0, 0);
      pThreadItem->m_DebugBuffer = v66;
      if ( v66 )
      {
        v147 = v53->UniqueProcessId;
        v148 = pThreadItem->m_DebugBuffer;
        hThread = _beginthreadex(0, 0, QueryProcessDebugInforThreadProc, &v147, 0, &ThreadId);
        CloseHandle(pThreadItem->m_hThread);
        if ( WaitForSingleObject(hThread, 4000u) == WAIT_TIMEOUT )
        {
          LeaveCriticalSection(&gProcThreadsLock);
          TerminateThread(hThread, 1u);
        }
        GetExitCodeThread(hThread, &ExitCode);
        if ( ExitCode )
        {
          RtlDestroyQueryDebugBuffer(pThreadItem->m_DebugBuffer);
          pThreadItem->m_DebugBuffer = 0;
        }
        CloseHandle(hThread);
      }
    }
    if ( SymInitialize )
      LeaveCriticalSection(&gProcThreadsLock);
    free(pSystemProcessInfo);
    v68 = ImageList_Create(16, 16, 1u, 256, 256);
    v69 = LoadIconW(ghInstance, IDC_DOWNARROW);
    ImageList_ReplaceIcon(v68, -1, v69);
    v70 = LoadIconW(ghInstance, IDC_UPARROW);
    ImageList_ReplaceIcon(v68, -1, v70);
    pThreadItem_2 = pThreadItem_1;
    v72 = GetWindowLongW(pThreadItem_1->m_hWndList, GWL_STYLE);
    SetWindowLongW(pThreadItem_2->m_hWndList, -16, v72 | 0x48);
    SendMessageW(pThreadItem_2->m_hWndList, 0x1003u, 1u, v68);
    CTreeList::InitHeaderColumn(pThreadItem_2->m_hWndList, ::wParam, ::wParam, byte_10653B4);
    pThreadItem_2->field_18 = 0;
    pThreadItem_2->m_nRefCount = 2;
    pThreadItem_2->m_hEvent2 = CreateEventW(0, 0, 1, 0);
    pThreadItem_2->m_hEvent2 = CreateEventW(0, 0, 1, 0);
    v73 = CreateEventW(0, 0, 1, 0);
    pThreadItem_2->m_hEvent3 = v73;
    ResetEvent(v73);
    v74 = pThreadItem_2->m_hEvent2;
    pThreadItem_2->field_4 = 0;
    SetEvent(v74);
    pThreadItem_2->m_hThread = _beginthreadex(0, 0, UpdateProcThreadsInfoThreadProc, pThreadItem_2, 0, &ThreadId);
    SetFocus(pThreadItem_2->m_hWndList);
    SetCursor(lParamIn);
    ReleaseCapture();
    if ( GetCurrentProcessId() != *(pThreadItem_2->m_Param + 68) && pThreadItem_2->m_hProcess )
    {
      hWnd_4 = hWnd_3;
      GetDlgItem = ::GetDlgItem;
    }
    else
    {
      hWnd_4 = hWnd_3;
      GetDlgItem = ::GetDlgItem;
      v77 = ::GetDlgItem(hWnd_3, IDC_PAGE_PROCTHREADS_BUTTON_PERMISSIONS);
      EnableWindow(v77, 0);
      v78 = ::GetDlgItem(hWnd_4, IDC_PAGE_PROCTHREADS_BUTTON_STACK);
      EnableWindow(v78, 0);
      v79 = ::GetDlgItem(hWnd_4, IDC_PAGE_PROCTHREADS_BUTTON_KILL);
      EnableWindow(v79, 0);
      v80 = ::GetDlgItem(hWnd_4, IDC_PAGE_PROCTHREADS_BUTTON_SUSPEND);
      EnableWindow(v80, 0);
    }
    if ( !*StackWalk64 )
    {
      v81 = GetDlgItem(hWnd_4, IDC_PAGE_PROCTHREADS_BUTTON_STACK);
      EnableWindow(v81, 0);
    }
    return 1;
  }
  // Handler for WM_COMMAND
  if ( wParam > IDC_PAGE_PROCTHREADS_BUTTON_MODULE )
  {
    if ( wParam > 40001 )
    {
      if ( wParam == IDM_VIEW_REFRESH_NOW )
      {
        SetEvent(ghRefreshEventHandle);
        return 0;
      }
      if ( wParam - 40092 > 1 )
        return 0;
      v131 = wParam;
    }
    else
    {
      if ( wParam != 40001 )
      {
        switch ( wParam )
        {
          case IDC_PAGE_PROCTHREADS_BUTTON_STACK:
            if ( !*StackWalk64 )
              return 0;
            lParam.iItem = SendMessageW(pUserData->m_hWndList, LVM_GETNEXTITEM, 0xFFFFFFFF, 2);
            if ( lParam.iItem == -1 )
              return 0;
            lParam.iSubItem = 0;
            lParam.mask = 4;
            if ( !SendMessageW(pUserData->m_hWndList, LVM_GETITEMW, 0, &lParam) )
              return 0;
            v127 = lParam.lParam;
            v128 = Fake_OpenThread(lParam.lParam->field_2C, 0x4Au);
            if ( v128 )
            {
              dwInitParam = *(pUserData->m_Param + 0x44);
              v142 = v127->field_2C;
              v144 = pUserData->m_hProcess;
              hObject = v128;
              v146 = pUserData->m_DebugBuffer;
              v145 = pUserData->m_SystemModules;
              DialogBoxParamW(ghMainInstance, L"THREADSTACK", hWnd, DlgThreadStack, &dwInitParam);
              if ( hObject )
              {
                CloseHandle(hObject);
                return 0;
              }
              return 0;
            }
            break;
          case IDC_PAGE_PROCTHREADS_BUTTON_KILL:
            goto LABEL_156;
          case IDC_PAGE_PROCTHREADS_BUTTON_PERMISSIONS:
            lParam.iItem = SendMessageW(pUserData->m_hWndList, LVM_GETNEXTITEM, 0xFFFFFFFF, 2);
            if ( lParam.iItem == -1 )
              return 0;
            lParam.iSubItem = 0;
            lParam.mask = 4;
            if ( !SendMessageW(pUserData->m_hWndList, LVM_GETITEMW, 0, &lParam) )
              return 0;
            pThreadItem_1 = lParam.lParam;
            ThreadHandle_1 = Fake_OpenThread(lParam.lParam->field_2C, 0x20000u);
            if ( ThreadHandle_1 )
            {
              memset(ListParam, 0, 4288u);
              wsprintfW(szBuffer, L"Thread %d", pThreadItem_1->m_hProcess);
              v164 = 0;
              wcscpy_s(szText, 0x40u, L"Thread");
              v165 = ThreadHandle_1;
              v163 = GetCurrentProcessId();
              FillHandleListParam(hWnd, ListParam);
              CloseHandle(ThreadHandle_1);
              return 0;
            }
            break;
          default:
            return 0;
        }
        MessageBoxW(pUserData->m_hWndList, L"Unable to access thread", L"Process Explorer", 0x10u);
        return 0;
      }
      v131 = 40014;
    }
    v129 = GetParent(hWnd);
    PostMessageW(v129, 0x111u, v131, 0);
    return 0;
  }
  if ( wParam == IDC_PAGE_PROCTHREADS_BUTTON_MODULE )
  {
    lParam.iItem = SendMessageW(pUserData->m_hWndList, 0x100Cu, 0xFFFFFFFF, 2);
    if ( lParam.iItem != -1 )
    {
      lParam.iSubItem = 0;
      lParam.mask = 4;
      if ( SendMessageW(pUserData->m_hWndList, 0x104Bu, 0, &lParam) )
      {
        qmemcpy(v135, lParam.lParam, 0x290u);
        if ( v136[0] )
        {
          memset(&pExecInfo, 0, 0x3Cu);
          pExecInfo.cbSize = 60;
          pExecInfo.lpFile = v136[0];
          pExecInfo.lpVerb = L"properties";
          pExecInfo.fMask = 12;
          ShellExecuteExW(&pExecInfo);
          SetFocus(pThreadItem_1->m_hWndList);
        }
        else
        {
          MessageBoxW(hWnd, L"The module cannot be located", L"Process Explorer", 0x10u);
        }
        return 0;
      }
    }
    return 0;
  }
  if ( wParam != IDC_PAGE_PROCTHREADS_BUTTON_SUSPEND )
    return 0;
LABEL_156:
  lParam.iItem = SendMessageW(pUserData->m_hWndList, LVM_GETNEXTITEM, 0xFFFFFFFF, 2);
  if ( lParam.iItem == -1 )
    return 0;
  lParam.iSubItem = 0;
  lParam.mask = 4;
  if ( !SendMessageW(pUserData->m_hWndList, LVM_GETITEMW, 0, &lParam) )
    return 0;
  v118 = lParam.lParam;
  pThreadItem_1 = lParam.lParam;
  if ( wParam == IDC_PAGE_PROCTHREADS_BUTTON_KILL )
  {
    wsprintfW(szBuffer2, L"Are you sure you want to kill thread %d?", lParam.lParam->field_2C);
    if ( MessageBoxW(ghMainWnd, szBuffer2, L"Process Explorer", 0x31u) != 2 )
    {
      v118 = &pThreadItem_1->m_Next;
      goto LABEL_161;
    }
    return 0;
  }
LABEL_161:
  ThreadHandle = Fake_OpenThread(v118[11], 3u);
  if ( !ThreadHandle )
  {
    ReportMsg(L"Unable to access thread", pUserData->m_hWndList);
    return 0;
  }
  if ( wParam == IDC_PAGE_PROCTHREADS_BUTTON_KILL )
  {
    if ( !TerminateThread(ThreadHandle, 0) )
    {
      ReportMsg(L"Unable to terminate thread", ghMainWnd);
      CloseHandle(ThreadHandle);
      return 0;
    }
  }
  else
  {
    v121 = ::GetDlgItem(hWnd, IDC_PAGE_PROCTHREADS_BUTTON_SUSPEND);
    GetWindowTextW(v121, szBuffer2, 1024);
    v122 = L"R&esume";
    v123 = szBuffer2;
    while ( 1 )
    {
      v124 = *v123 < *v122;
      if ( *v123 != *v122 )
        break;
      if ( !*v123 )
        goto LABEL_187;
      v125 = v123[1];
      v124 = v125 < v122[1];
      if ( v125 != v122[1] )
        break;
      v123 += 2;
      v122 += 2;
      if ( !v125 )
      {
LABEL_187:
        v126 = 0;
        goto LABEL_189;
      }
    }
    v126 = -v124 | 1;
LABEL_189:
    if ( v126 )
    {
      if ( NtSuspendThread(v122, ThreadHandle) )
        ReportMsg(L"Unable to suspend thread", ghMainWnd);
    }
    else if ( NtResumeThread(v122, ThreadHandle) )
    {
      ReportMsg(L"Unable to resume thread", ghMainWnd);
      CloseHandle(ThreadHandle);
      return 0;
    }
  }
  CloseHandle(ThreadHandle);
  return 0;
}
// 103E398: using guessed type wchar_t aREsume[8];
// 1045A74: using guessed type wchar_t aWaitS[8];
// 1045AF4: using guessed type wchar_t aProperties[11];
// 1045BE4: using guessed type wchar_t aUnableToTermin[27];
// 1045C1C: using guessed type wchar_t aUnableToResume[24];
// 1045C4C: using guessed type wchar_t aUnableToSuspen_0[25];
// 1046C40: using guessed type __int128 xmmword_1046C40;
// 1046C60: using guessed type __int128 xmmword_1046C60;
// 1046C70: using guessed type RECT stru_1046C70;
// 105E8B8: using guessed type wchar_t aExecutive[10];
// 10610DC: using guessed type int dword_10610DC;
// 1064E54: using guessed type int gdwVersion;
// 10653B4: using guessed type char byte_10653B4;
// 106F258: using guessed type int (__stdcall *GetThreadIdealProcessorEx)(_DWORD, _DWORD);
// 106F264: using guessed type int (__stdcall *RtlDestroyQueryDebugBuffer)(_DWORD);
// 106F328: using guessed type int (__stdcall *GetLogicalProcessorInformationEx)(_DWORD, _DWORD, _DWORD);

//----- (00FEC7F0) --------------------------------------------------------
int __stdcall UpdateProcThreadsInfoThreadProc(tagThreadItem *pThreadItem)
{
  HWND hWndList; // edi
  tagThreadItem *pThreadItem_2; // esi
  DWORD dwRet; // eax
  int v4; // ecx
  LRESULT (__stdcall *SendMessageW)(HWND, UINT, WPARAM, LPARAM); // ebx
  LRESULT nCount; // eax
  int nIndex_1; // esi
  char v8; // al
  int v9; // ecx
  struct _FILETIME FileTime; // rax
  DWORD dwLowDateTime; // ebx
  HANDLE dwProcessId; // ecx
  SYSTEM_PROCESS_INFORMATION *v13; // eax
  ULONG v14; // eax
  _RTL_PROCESS_MODULES *v15; // eax
  ULONG v16; // esi
  _SYSTEM_PROCESSOR_IDLE_CYCLE_TIME_INFORMATION *pSystemProcessorCycleTimeInfor; // edi
  __int64 v18; // rax
  ULONGLONG v19; // kr10_8
  int v20; // ebx
  unsigned int v21; // ecx
  int v22; // esi
  tagTREEVIEWITEMPARAM *v23; // ecx
  int v24; // eax
  void *v25; // eax
  tagTREEVIEWITEMPARAM *v26; // edi
  unsigned int v27; // ecx
  __int64 v28; // rax
  bool v29; // cf
  int v30; // ecx
  int v31; // edx
  double v32; // xmm0_8
  WPARAM v33; // edx
  int v34; // ecx
  double v35; // xmm0_8
  char v36; // dl
  double v37; // xmm1_8
  tagTREEVIEWITEMPARAM *v38; // ecx
  double v39; // xmm1_8
  char v40; // dh
  int v41; // eax
  char v42; // al
  int v43; // eax
  void *ThreadHandle_1; // ecx
  tagThreadItem *v45; // esi
  int v46; // eax
  HANDLE v47; // edx
  const wchar_t *v48; // eax
  HWND hWndParent_1; // ebx
  HWND v50; // eax
  HWND v51; // eax
  HWND v52; // eax
  HWND v53; // eax
  HANDLE v54; // edi
  tagThreadItem *v55; // edi
  HWND v56; // esi
  char LocalBuffer2; // [esp-294h] [ebp-E24h]
  int v59; // [esp-290h] [ebp-E20h]
  int v60; // [esp-28Ch] [ebp-E1Ch]
  int v61; // [esp-288h] [ebp-E18h]
  int v62; // [esp-284h] [ebp-E14h]
  int v63; // [esp-280h] [ebp-E10h]
  int v64; // [esp-27Ch] [ebp-E0Ch]
  int v65; // [esp-278h] [ebp-E08h]
  int v66; // [esp-274h] [ebp-E04h]
  int v67; // [esp-270h] [ebp-E00h]
  int v68; // [esp-26Ch] [ebp-DFCh]
  int v69; // [esp-268h] [ebp-DF8h]
  int v70; // [esp-264h] [ebp-DF4h]
  int v71; // [esp-260h] [ebp-DF0h]
  int v72; // [esp-25Ch] [ebp-DECh]
  int v73; // [esp-258h] [ebp-DE8h]
  int v74; // [esp-254h] [ebp-DE4h]
  int v75; // [esp-250h] [ebp-DE0h]
  int v76; // [esp-24Ch] [ebp-DDCh]
  int v77; // [esp-248h] [ebp-DD8h]
  int v78; // [esp-244h] [ebp-DD4h]
  int v79; // [esp-240h] [ebp-DD0h]
  int v80; // [esp-23Ch] [ebp-DCCh]
  int v81; // [esp-238h] [ebp-DC8h]
  int v82; // [esp-234h] [ebp-DC4h]
  int v83; // [esp-230h] [ebp-DC0h]
  int v84; // [esp-22Ch] [ebp-DBCh]
  int v85; // [esp-228h] [ebp-DB8h]
  int v86; // [esp-224h] [ebp-DB4h]
  int v87; // [esp-220h] [ebp-DB0h]
  int v88; // [esp-21Ch] [ebp-DACh]
  int v89; // [esp-218h] [ebp-DA8h]
  int v90; // [esp-214h] [ebp-DA4h]
  int v91; // [esp-210h] [ebp-DA0h]
  int v92; // [esp-20Ch] [ebp-D9Ch]
  int v93; // [esp-208h] [ebp-D98h]
  int v94; // [esp-204h] [ebp-D94h]
  int v95; // [esp-200h] [ebp-D90h]
  int v96; // [esp-1FCh] [ebp-D8Ch]
  int v97; // [esp-1F8h] [ebp-D88h]
  int v98; // [esp-1F4h] [ebp-D84h]
  int v99; // [esp-1F0h] [ebp-D80h]
  int v100; // [esp-1ECh] [ebp-D7Ch]
  int v101; // [esp-1E8h] [ebp-D78h]
  int v102; // [esp-1E4h] [ebp-D74h]
  int v103; // [esp-1E0h] [ebp-D70h]
  int v104; // [esp-1DCh] [ebp-D6Ch]
  int v105; // [esp-1D8h] [ebp-D68h]
  int v106; // [esp-1D4h] [ebp-D64h]
  int v107; // [esp-1D0h] [ebp-D60h]
  int v108; // [esp-1CCh] [ebp-D5Ch]
  int v109; // [esp-1C8h] [ebp-D58h]
  int v110; // [esp-1C4h] [ebp-D54h]
  int v111; // [esp-1C0h] [ebp-D50h]
  int v112; // [esp-1BCh] [ebp-D4Ch]
  int v113; // [esp-1B8h] [ebp-D48h]
  int v114; // [esp-1B4h] [ebp-D44h]
  int v115; // [esp-1B0h] [ebp-D40h]
  int v116; // [esp-1ACh] [ebp-D3Ch]
  int v117; // [esp-1A8h] [ebp-D38h]
  int v118; // [esp-1A4h] [ebp-D34h]
  int v119; // [esp-1A0h] [ebp-D30h]
  _SYSTEM_PROCESSOR_IDLE_CYCLE_TIME_INFORMATION *pSystemProcessorCycleTimeInfor_1; // [esp-14h] [ebp-BA4h]
  unsigned __int64 timeDelta; // [esp-10h] [ebp-BA0h]
  PRTL_DEBUG_BUFFER dwNumberOfProcessors; // [esp-8h] [ebp-B98h]
  _RTL_PROCESS_MODULES *bFalse; // [esp-4h] [ebp-B94h]
  LPARAM lParam; // [esp+Ch] [ebp-B84h]
  int v125; // [esp+18h] [ebp-B78h]
  int v126; // [esp+1Ch] [ebp-B74h]
  THREAD_BASIC_INFORMATION ThreadInformation; // [esp+24h] [ebp-B6Ch]
  SIZE_T NumberOfBytesRead; // [esp+40h] [ebp-B50h]
  ULONG ReturnLength; // [esp+44h] [ebp-B4Ch]
  CLIENT_ID ClientID; // [esp+48h] [ebp-B48h]
  int v131; // [esp+50h] [ebp-B40h]
  HANDLE hEvent2[2]; // [esp+54h] [ebp-B3Ch]
  size_t cbRet; // [esp+5Ch] [ebp-B34h]
  int v134; // [esp+60h] [ebp-B30h]
  double v135; // [esp+64h] [ebp-B2Ch]
  int ThreadHandle; // [esp+6Ch] [ebp-B24h]
  tagLVITEMW item; // [esp+70h] [ebp-B20h]
  WPARAM wParam; // [esp+A4h] [ebp-AECh]
  WPARAM v139; // [esp+A8h] [ebp-AE8h]
  _DWORD v140[2]; // [esp+ACh] [ebp-AE4h]
  WPARAM v141; // [esp+B4h] [ebp-ADCh]
  WPARAM v142; // [esp+B8h] [ebp-AD8h]
  WPARAM v143; // [esp+BCh] [ebp-AD4h]
  int dwTebAddress; // [esp+C0h] [ebp-AD0h]
  unsigned int v145; // [esp+C4h] [ebp-ACCh]
  int v146; // [esp+C8h] [ebp-AC8h]
  HANDLE hHandle; // [esp+CCh] [ebp-AC4h]
  HWND hWndParent; // [esp+D0h] [ebp-AC0h]
  int nItem; // [esp+D4h] [ebp-ABCh]
  int nIndex; // [esp+D8h] [ebp-AB8h]
  char dwHighDateTime[4]; // [esp+DCh] [ebp-AB4h]
  HWND hWndList_1; // [esp+E0h] [ebp-AB0h]
  SYSTEM_PROCESS_INFORMATION *pSystemProcessInfo; // [esp+E4h] [ebp-AACh]
  SYSTEM_PROCESS_INFORMATION *pSystemProcessInfo_1; // [esp+E8h] [ebp-AA8h]
  tagThreadItem *pThreadItem_1; // [esp+ECh] [ebp-AA4h]
  int v156; // [esp+F3h] [ebp-A9Dh]
  char fOK; // [esp+FBh] [ebp-A95h]
  int LocalBuffer[164]; // [esp+FCh] [ebp-A94h]
  __int16 String[1024]; // [esp+38Ch] [ebp-804h]

  hWndList = pThreadItem->m_hWndList;
  pThreadItem_1 = pThreadItem;
  hWndList_1 = hWndList;
  pSystemProcessInfo = 0;
  cbRet = 0;
  item.mask = 0;
  memset(&item.iItem, 0, 0x30u);
  MulDiv(-50, gLogPixelSize.x, 96);
  MulDiv(-100, gLogPixelSize.x, 96);
  MulDiv(-100, gLogPixelSize.x, 96);
  MulDiv(100, gLogPixelSize.x, 96);
  pThreadItem_2 = pThreadItem_1;
  bFalse = INFINITE;
  dwNumberOfProcessors = 0;
  hHandle = 0;
  hEvent2[0] = pThreadItem_1->m_hEvent2;
  hEvent2[1] = pThreadItem_1->m_hEvent3;
  fOK = 1;
  dwRet = WaitForMultipleObjects(2u, hEvent2, 0, INFINITE);
  SendMessageW = ::SendMessageW;
  if ( pThreadItem_2->field_18 )
    goto __cleanup;
  LOBYTE(v4) = v156;
  v142 = v139;
  *(&v156 + 1) = v4;
  v143 = wParam;
  while ( 1 )
  {
    nItem = 0;
    nIndex = 0;
    *dwHighDateTime = 0;
    if ( dwRet )
      goto LABEL_85;
    BYTE1(v156) = 0;
    hWndParent = GetParent(hWndList);
    if ( !fOK )
    {
      item.mask = LVIF_PARAM;
      nCount = SendMessageW(hWndList, LVM_GETITEMCOUNT, 0, 0);
      item.iSubItem = 0;
      item.iItem = nCount - 1;
      if ( SendMessageW(hWndList, LVM_GETITEMW, 0, &item) )
      {
        nIndex_1 = nIndex;
        do
        {
          v8 = sub_FF58D0(SendMessageW, hWndList, &item, item.lParam, &v156);
          v9 = BYTE1(v156);
          if ( v8 )
            v9 = 1;
          *(&v156 + 1) = v9;
          if ( v156 )
          {
            if ( item.lParam->field_C != 1 )
              --item.lParam->field_14;
            ++nIndex_1;
          }
          item.mask = 4;
          item.iSubItem = 0;
        }
        while ( SendMessageW(hWndList, LVM_GETITEMW, 0, &item) );
        nIndex = nIndex_1;
        pThreadItem_2 = pThreadItem_1;
      }
    }
    FileTime = GetSystemProcessInfo(&pSystemProcessInfo, &cbRet);
    dwLowDateTime = FileTime.dwLowDateTime;
    *dwHighDateTime = FileTime.dwHighDateTime;
    pSystemProcessInfo_1 = pSystemProcessInfo;
    dwProcessId = *(pThreadItem_2->m_Param + 68);
    if ( pSystemProcessInfo->UniqueProcessId != dwProcessId )
      break;
LABEL_19:
    *&dwNumberOfProcessors = gSystemInfo.dwNumberOfProcessors;
    timeDelta = __PAIR__(FileTime.dwHighDateTime, dwLowDateTime) - *&pThreadItem_2->m_TimeLast;
    v141 = timeDelta * gSystemInfo.dwNumberOfProcessors >> 32;
    v146 = timeDelta * gSystemInfo.dwNumberOfProcessors;
    if ( !(timeDelta * gSystemInfo.dwNumberOfProcessors) )
    {
      v146 = 1;
      v141 = 0;
    }
    v15 = *dwHighDateTime;
    pThreadItem_2->m_TimeLast.dwLowDateTime = dwLowDateTime;
    pThreadItem_2->m_TimeLast.dwHighDateTime = v15;
    if ( GetProcessorSystemCycleTime )
    {
      v16 = 8 * gSystemInfo.dwNumberOfProcessors;
      pSystemProcessorCycleTimeInfor = malloc(8 * gSystemInfo.dwNumberOfProcessors);
      NtQuerySystemInformation(SystemProcessorCycleTimeInformation, pSystemProcessorCycleTimeInfor, v16, &ReturnLength);
      LODWORD(v18) = sub_FDE4B0(0, pSystemProcessInfo, pSystemProcessorCycleTimeInfor, 0);
      pThreadItem_2 = pThreadItem_1;
      pSystemProcessorCycleTimeInfor_1 = pSystemProcessorCycleTimeInfor;
      v19 = v18 - pThreadItem_1->m_CycleTime;
      v142 = (v18 - pThreadItem_1->m_CycleTime) >> 32;
      v143 = v19;
      LODWORD(pThreadItem_1->m_CycleTime) = v18;
      HIDWORD(pThreadItem_2->m_CycleTime) = HIDWORD(v18);
      free(pSystemProcessorCycleTimeInfor_1);
      hWndList = hWndList_1;
    }
    v20 = &pSystemProcessInfo_1[1];
    if ( pThreadItem_2->field_34 )
      v20 = &pSystemProcessInfo_1->ReadOperationCount;
    v21 = 0;
    *dwHighDateTime = pSystemProcessInfo_1->NumberOfThreads;
    v145 = 0;
    if ( *dwHighDateTime )
    {
      while ( 1 )
      {
        if ( pThreadItem_2->field_18 )
          goto __cleanup1;
        if ( !*(v20 + 36) )
          *(v20 + 36) = v21;
        v22 = 0;
        if ( ::SendMessageW(hWndList, LVM_GETITEMCOUNT, 0, 0) )
          break;
LABEL_61:
        if ( pThreadItem_1->field_18 )
        {
          pThreadItem_2 = pThreadItem_1;
          goto __cleanup1;
        }
        if ( v22 == ::SendMessageW(hWndList, LVM_GETITEMCOUNT, 0, 0) )
        {
          BYTE1(v156) = 1;
          memset(LocalBuffer, 0, 0x290u);
          LocalBuffer[1] = 3;
          ClientID.UniqueThread = *(v20 + 36);
          ClientID.UniqueProcess = 0;
          ThreadInformation.TebBaseAddrss = sizeof(OBJECT_ATTRIBUTES);
          ThreadInformation.ClientId.UniqueProcess = 0;
          ThreadInformation.AffinityMask = 0;
          ThreadInformation.ClientId.UniqueThread = 0;
          ThreadInformation.Priority = 0;
          ThreadInformation.BasePriority = 0;
          v43 = NtOpenThread(&ThreadHandle, 0x48u, &ThreadInformation.TebBaseAddrss, &ClientID);
          ThreadHandle_1 = 0;
          if ( !v43 )
            ThreadHandle_1 = ThreadHandle;
          LocalBuffer[10] = ThreadHandle_1;
          if ( QueryThreadCycleTime && ThreadHandle_1 )
            QueryThreadCycleTime(ThreadHandle_1, &LocalBuffer[154]);
          v45 = pThreadItem_1;
          LocalBuffer[11] = *(v20 + 36);
          LocalBuffer[148] = *(v20 + 48);
          bFalse = pThreadItem_1->m_SystemModules;
          LocalBuffer[149] = 0;
          dwNumberOfProcessors = pThreadItem_1->m_DebugBuffer;
          LocalBuffer[12] = *(v20 + 28);
          sub_FDDD60(
            0,
            0,
            LocalBuffer,
            pThreadItem_1->m_hProcess,
            *(v20 + 28),
            *(v20 + 28) >> 31,
            dwNumberOfProcessors,
            &bFalse->NumberOfModules);
          *&LocalBuffer[156] = *v20 + *(v20 + 8);
          v46 = 2;
          if ( fOK )
            v46 = 0;
          LocalBuffer[5] = 0;
          LocalBuffer[4] = v46;
          LocalBuffer[158] = v45->m_Param;
          *&LocalBuffer[144] = 0i64;
          LocalBuffer[162] = 0;
          if ( GetThreadIdealProcessorEx )
            GetThreadIdealProcessorEx(LocalBuffer[10], &LocalBuffer[152]);
          if ( *(v45->m_Param + 40) & 0x20 && gdwVersion >= 1 )
          {
            if ( !NtQueryInformationThread(
                    LocalBuffer[10],
                    ThreadBasicInformation,
                    &ThreadInformation,
                    sizeof(_THREAD_BASIC_INFORMATION),
                    0) )
            {
              v47 = v45->m_hProcess;
              LocalBuffer[160] = ThreadInformation.TebBaseAddrss;
              LocalBuffer[159] = v47;
              ReadProcessMemory(
                v47,
                ThreadInformation.TebBaseAddrss + gdwTebAddressOffset,
                &dwTebAddress,
                4u,
                &NumberOfBytesRead);
              LocalBuffer[161] = dwTebAddress;
              if ( dwTebAddress )
              {
                if ( sub_FFEFB0(dwTebAddress) )
                {
                  v48 = sub_FFEFB0(dwTebAddress);
                  LocalBuffer[162] = _wcsdup(v48);
                }
              }
            }
          }
          else
          {
            LocalBuffer[161] = -1;
          }
          bFalse = v45;
          qmemcpy(&LocalBuffer2, LocalBuffer, 656u);
          hWndList = hWndList_1;
          sub_FB7E70(
            hWndList_1,
            LocalBuffer2,
            v59,
            v60,
            v61,
            v62,
            v63,
            v64,
            v65,
            v66,
            v67,
            v68,
            v69,
            v70,
            v71,
            v72,
            v73,
            v74,
            v75,
            v76,
            v77,
            v78,
            v79,
            v80,
            v81,
            v82,
            v83,
            v84,
            v85,
            v86,
            v87,
            v88,
            v89,
            v90,
            v91,
            v92,
            v93,
            v94,
            v95,
            v96,
            v97,
            v98,
            v99,
            v100,
            v101,
            v102,
            v103,
            v104,
            v105,
            v106,
            v107,
            v108,
            v109,
            v110,
            v111,
            v112,
            v113,
            v114,
            v115,
            v116,
            v117,
            v118,
            v119);
          pThreadItem_2 = pThreadItem_1;
          SetEvent(pThreadItem_1->m_hEvent);
        }
        else
        {
          pThreadItem_2 = pThreadItem_1;
        }
        v20 += 64;
        v21 = v145 + 1;
        v145 = v21;
        if ( v21 >= pSystemProcessInfo_1->NumberOfThreads )
          goto LABEL_82;
      }
      while ( 1 )
      {
        item.mask = 4;
        item.iItem = v22;
        item.iSubItem = 0;
        ::SendMessageW(hWndList, LVM_GETITEMW, 0, &item);
        v23 = item.lParam;
        if ( item.lParam->field_2C == *(v20 + 36) )
          break;
        if ( ++v22 >= ::SendMessageW(hWndList, LVM_GETITEMCOUNT, 0, 0) )
          goto LABEL_61;
      }
      v24 = *(v20 + 48) - item.lParam[7].field_4;
      if ( v24 != item.lParam[6].field_50 || 0 != item.lParam[7].field_0 )
      {
        if ( v24 <= 0 )
          item.lParam[6].field_50 = 0;
        else
          item.lParam[6].field_50 = v24;
        v23[7].field_0 = 0;
        v23 = item.lParam;
        BYTE1(v156) = 1;
      }
      v23[7].field_4 = *(v20 + 48);
      item.lParam[7].field_8 = 0;
      if ( QueryThreadCycleTime )
      {
        v25 = item.lParam->field_28;
        if ( v25 )
        {
          QueryThreadCycleTime(v25, v140);
          if ( ((*v140 - *&item.lParam[7].field_1C) >> 32) < 0
            || (*v140 < *&item.lParam[7].field_1C || (*v140 - *&item.lParam[7].field_1C) >> 32 == 0)
            && v140[0] == item.lParam[7].field_1C )
          {
            item.lParam[7].field_C = 0;
            item.lParam[7].field_10 = 0;
          }
          else
          {
            *&item.lParam[7].field_C = *v140 - *&item.lParam[7].field_1C;
          }
          BYTE1(v156) = 1;
        }
      }
      item.lParam[7].field_1C = v140[0];
      item.lParam[7].field_20 = v140[1];
      v26 = item.lParam;
      v27 = *v20 + *(v20 + 8);
      v28 = *v20 + *(v20 + 8);
      v134 = HIDWORD(v28);
      v29 = v27 < item.lParam[7].field_24;
      v30 = v27 - item.lParam[7].field_24;
      v131 = v28;
      v31 = HIDWORD(v28) - (v29 + item.lParam[7].field_28);
      if ( GetProcessorSystemCycleTime && item.lParam->field_28 )
      {
        v32 = *&item.lParam[7].field_C;
        v33 = v142;
        v34 = v143;
      }
      else
      {
        v32 = __PAIR__(v31, v30);
        v33 = v141;
        v34 = v146;
      }
      v135 = v32 * 100.0;
      v35 = __PAIR__(v33, v34);
      v36 = 0;
      v37 = v135;
      ++nItem;
      item.lParam[7].field_24 = v131;
      v26[7].field_28 = v134;
      v38 = item.lParam;
      v39 = v37 / v35;
      v40 = item.lParam->field_18;
      if ( v40 )
      {
        v41 = item.lParam->field_1C;
        if ( v41 < gConfig.dwHighlightDuration )
        {
          item.lParam->field_10 = 2;
          v38->field_14 = v41;
LABEL_59:
          hWndList = hWndList_1;
          if ( v39 != *&item.lParam[6].field_48 )
          {
            *&item.lParam[6].field_48 = v39;
            BYTE1(v156) = 1;
          }
          goto LABEL_61;
        }
        if ( v40 )
        {
          v36 = 1;
          LOBYTE(item.lParam->field_18) = 0;
        }
      }
      v42 = BYTE1(v156);
      v38->field_10 = 0;
      if ( v36 )
        v42 = 1;
      BYTE1(v156) = v42;
      goto LABEL_59;
    }
LABEL_82:
    SendMessageW = ::SendMessageW;
    if ( pThreadItem_2->field_18 )
      goto __cleanup;
    if ( nItem == nIndex )
    {
      LOBYTE(v4) = BYTE1(v156);
LABEL_85:
      if ( !v4 )
        goto LABEL_87;
    }
    InvalidateRect(hWndList, 0, 0);
    v139 = ::wParam;
    wParam = 1044;
    SendMessageW(hWndList, LVM_SORTITEMS, &wParam, PropProcThreadsSortCallback);
    SendMessageW(hWndList, WM_SETREDRAW, 1u, 0);
    bFalse = *dwHighDateTime;
    wsprintfW(String, L"%d", *dwHighDateTime);
    SetDlgItemTextW(hWndParent, IDC_PAGE_PROCTHREADS_STATIC_STATIC, String);
LABEL_87:
    if ( fOK )
    {
      SendMessageW(hWndList, LVM_SETCOLUMNWIDTH, 3u, 65534);
      v126 = 3;
      v125 = 3;
      SendMessageW(hWndList, LVM_SETITEMSTATE, 0, &lParam);
      hHandle = _beginthreadex(0, 0, sub_FED400, pThreadItem_2, 0, 0);
      fOK = 0;
    }
    if ( pThreadItem_2->field_4 )
      goto __cleanup;
    dwRet = WaitForMultipleObjects(2u, hEvent2, 0, 0xFFFFFFFF);
    if ( pThreadItem_2->field_18 )
      goto __cleanup;
    LOBYTE(v4) = BYTE1(v156);
  }
  v13 = pSystemProcessInfo_1;
  while ( 1 )
  {
    v14 = v13->NextEntryOffset;
    if ( !v14 )
      break;
    pSystemProcessInfo_1 = (pSystemProcessInfo_1 + v14);
    v13 = pSystemProcessInfo_1;
    if ( pSystemProcessInfo_1->UniqueProcessId == dwProcessId )
      goto LABEL_19;
  }
  wsprintfW(String, L"n/a");
  hWndParent_1 = hWndParent;
  SetDlgItemTextW(hWndParent, IDC_PAGE_PROCTHREADS_STATIC_THREAD_ID_VALUE, String);
  SetDlgItemTextW(hWndParent_1, IDC_PAGE_PROCTHREADS_STATIC_START_TIME_VALUE, String);
  SetDlgItemTextW(hWndParent_1, IDC_PAGE_PROCTHREADS_STATIC_BASE_PRIORITY_VALUE, String);
  SetDlgItemTextW(hWndParent_1, IDC_PAGE_PROCTHREADS_STATIC_DYNAMIC_PRIORITY_VALUE, String);
  SetDlgItemTextW(hWndParent_1, IDC_PAGE_PROCTHREADS_STATIC_CONTEXT_SWITCHES_VALUE, String);
  SetDlgItemTextW(hWndParent_1, IDC_PAGE_PROCTHREADS_STATIC_KERNEL_TIME_VALUE, String);
  SetDlgItemTextW(hWndParent_1, IDC_PAGE_PROCTHREADS_STATIC_USER_TIME_VALUE, String);
  SetDlgItemTextW(hWndParent_1, IDC_PAGE_PROCTHREADS_STATIC_STATE_VALUE, String);
  SetDlgItemTextW(hWndParent_1, IDC_PAGE_PROCTHREADS_STATIC_MEMROY_PRIORITY_VALUE, String);
  SetDlgItemTextW(hWndParent_1, IDC_PAGE_PROCTHREADS_STATIC_IO_PRIORITY_VALUE, String);
  SetDlgItemTextW(hWndParent_1, IDC_PAGE_PROCTHREADS_STATIC_IDLE_PROCESSOR_VALUE, String);
  InvalidateRect(hWndList, 0, 1);
  bFalse = 0;
  v50 = GetDlgItem(hWndParent_1, IDC_PAGE_PROCTHREADS_BUTTON_MODULE);
  EnableWindow(v50, bFalse);
  bFalse = 0;
  v51 = GetDlgItem(hWndParent_1, IDC_PAGE_PROCTHREADS_BUTTON_STACK);
  EnableWindow(v51, bFalse);
  bFalse = 0;
  v52 = GetDlgItem(hWndParent_1, IDC_PAGE_PROCTHREADS_BUTTON_KILL);
  EnableWindow(v52, bFalse);
  bFalse = 0;
  v53 = GetDlgItem(hWndParent_1, IDC_PAGE_PROCTHREADS_BUTTON_SUSPEND);
  EnableWindow(v53, bFalse);
  pThreadItem_2 = pThreadItem_1;
__cleanup1:
  SendMessageW = ::SendMessageW;
__cleanup:
  free(pSystemProcessInfo);
  if ( pThreadItem_2->field_4 || InterlockedDecrement(&pThreadItem_2->m_nRefCount) )
  {
    v56 = hWndList_1;
    InvalidateRect(hWndList_1, 0, 1);
    SendMessageW(v56, WM_SETREDRAW, 1u, 0);
  }
  else
  {
    v54 = hHandle;
    if ( hHandle )
    {
      SetEvent(pThreadItem_2->m_hEvent);
      WaitForSingleObject(v54, 0xFFFFFFFF);
    }
    v55 = pThreadItem_2->m_Next;
    if ( pThreadItem_2->m_Next )
    {
      do
      {
        pThreadItem_2->m_Next = v55;
        v55 = v55[8].m_hEvent3;
        if ( pThreadItem_2->m_Next->m_SystemModules )
          CloseHandle(pThreadItem_2->m_Next->m_SystemModules);
        if ( pThreadItem_2->m_Next[7].m_hEvent3 )
          free(pThreadItem_2->m_Next[7].m_hEvent3);
        if ( pThreadItem_2->m_Next[8].m_hEvent2 )
          free(pThreadItem_2->m_Next[8].m_hEvent2);
        free(pThreadItem_2->m_Next);
      }
      while ( v55 );
    }
    if ( pThreadItem_2->m_hProcess )
    {
      CloseHandle(pThreadItem_2->m_hProcess);
      if ( SymCleanup )
        SymCleanup(pThreadItem_2->m_hProcess);
    }
    CloseHandle(pThreadItem_2->m_hEvent);
    CloseHandle(pThreadItem_2->m_hEvent2);
    CloseHandle(pThreadItem_2->m_hEvent3);
    if ( pThreadItem_2->m_DebugBuffer )
      RtlDestroyQueryDebugBuffer(pThreadItem_2->m_DebugBuffer);
    if ( pThreadItem_2->m_SystemModules )
      free(pThreadItem_2->m_SystemModules);
    free(pThreadItem_2);
  }
  return 0;
}
// FED400: using guessed type int __stdcall sub_FED400(int);
// 103CDC0: using guessed type double db_onehundred;
// 1064E54: using guessed type int gdwVersion;
// 106B1CC: using guessed type int gdwTebAddressOffset;
// 106F258: using guessed type int (__stdcall *GetThreadIdealProcessorEx)(_DWORD, _DWORD);
// 106F264: using guessed type int (__stdcall *RtlDestroyQueryDebugBuffer)(_DWORD);
// 106F2F4: using guessed type int GetProcessorSystemCycleTime;

//----- (00FED400) --------------------------------------------------------
int __stdcall sub_FED400(int a1)
{
  HWND v1; // edi
  HWND v2; // eax
  void *v3; // ST1C_4
  unsigned int v4; // ebx
  int v5; // esi
  int v6; // edi
  int v7; // esi
  HWND v9; // eax
  HWND v10; // ST14_4
  HWND v11; // eax
  LPARAM lParam; // [esp+8h] [ebp-844h]
  int v13; // [esp+Ch] [ebp-840h]
  int v14; // [esp+10h] [ebp-83Ch]
  int v15; // [esp+28h] [ebp-824h]
  HWND hDlg; // [esp+3Ch] [ebp-810h]
  int v17; // [esp+40h] [ebp-80Ch]
  HWND hWnd; // [esp+44h] [ebp-808h]
  WCHAR String; // [esp+48h] [ebp-804h]

  v17 = a1;
  lParam = 0;
  memset(&v13, 0, 0x30u);
  v1 = *(a1 + 36);
  hWnd = v1;
  v2 = GetParent(v1);
  v3 = *(a1 + 20);
  hDlg = v2;
  WaitForSingleObject(v3, 0xFFFFFFFF);
  if ( !*(a1 + 24) )
  {
    do
    {
      v4 = SendMessageW(v1, 0x1004u, 0, 0);
      while ( 1 )
      {
        v5 = 0;
        if ( !v4 )
          break;
        while ( 1 )
        {
          lParam = 4;
          v13 = v5;
          v14 = 0;
          if ( SendMessageW(v1, 0x104Bu, 0, &lParam) )
            break;
LABEL_7:
          if ( ++v5 >= v4 )
            goto LABEL_8;
        }
        v6 = v15;
        if ( *(v15 + 36) )
        {
          v1 = hWnd;
          goto LABEL_7;
        }
        wsprintfW(&String, L"Loading symbols for %s...", v15 + 52);
        v9 = GetDlgItem(hDlg, 1341);
        SetWindowTextW(v9, &String);
        sub_FDDD60(1, 0, v15, *(v17 + 44), *(v6 + 48), *(v6 + 48) >> 31, *(v17 + 48), *(v17 + 40));
        InvalidateRect(hWnd, 0, 0);
        v10 = hDlg;
        *(v6 + 36) = 1;
        v11 = GetDlgItem(v10, 1341);
        SetWindowTextW(v11, &gszNullString);
        v1 = hWnd;
      }
LABEL_8:
      v7 = v17;
      WaitForSingleObject(*(v17 + 20), 0xFFFFFFFF);
    }
    while ( !*(v7 + 24) );
  }
  return 0;
}
// FED400: using guessed type int __stdcall sub_FED400(int);

//----- (00FED5B0) --------------------------------------------------------
BOOL __stdcall PageProcWMIProviders(HWND hDlg, int a2, WPARAM wParam, int a4)
{
  HWND v4; // edi
  CResizer *v5; // eax
  CResizer *v6; // esi
  HWND v7; // eax
  struct tagResizerItem *v8; // eax
  LONG v9; // eax
  HWND v10; // eax
  int *v11; // esi
  LONG v12; // eax
  HWND v14; // eax
  WPARAM v15; // [esp-8h] [ebp-ACh]
  LPARAM v16; // [esp+10h] [ebp-94h]
  int v17; // [esp+1Ch] [ebp-88h]
  int v18; // [esp+20h] [ebp-84h]
  void *v19; // [esp+44h] [ebp-60h]
  LPARAM lParam; // [esp+48h] [ebp-5Ch]
  LONG v21; // [esp+4Ch] [ebp-58h]
  int v22; // [esp+50h] [ebp-54h]
  int v23; // [esp+54h] [ebp-50h]
  int v24; // [esp+58h] [ebp-4Ch]
  int v25; // [esp+5Ch] [ebp-48h]
  int v26; // [esp+64h] [ebp-40h]
  int v27; // [esp+68h] [ebp-3Ch]
  LONG dwNewLong; // [esp+7Ch] [ebp-28h]
  UINT pnIDs; // [esp+80h] [ebp-24h]
  int v30; // [esp+84h] [ebp-20h]
  int v31; // [esp+88h] [ebp-1Ch]
  WORD pnWidths[2]; // [esp+8Ch] [ebp-18h]
  __int16 v33; // [esp+90h] [ebp-14h]
  int v34; // [esp+A0h] [ebp-4h]

  dwNewLong = a4;
  v4 = GetDlgItem(hDlg, 40753);
  GetWindowLongW(hDlg, -21);
  lParam = 0;
  memset(&v21, 0, 0x30u);
  pnIDs = 40754;
  v30 = 40755;
  v31 = 40756;
  pnWidths[0] = MulDiv(100, gLogPixelSize.x, 96);
  pnWidths[1] = MulDiv(100, gLogPixelSize.x, 96);
  v33 = MulDiv(100, gLogPixelSize.x, 96);
  switch ( a2 )
  {
    case 43:
      CMainWnd::DrawList(dwNewLong);
      return 0;
    case 44:
      return CMainWnd::HandleMeasureItem(hDlg, a2, wParam, dwNewLong);
    case 272:
      v5 = operator new(0x40u);
      v19 = v5;
      v34 = 0;
      if ( v5 )
        v6 = CResizer::CResizer(v5, hDlg);
      else
        v6 = 0;
      v34 = -1;
      v7 = GetDlgItem(hDlg, 40753);
      if ( v7 )
      {
        v8 = CResizer::AddItem(v6, v7, 1);
        *&v8->m_rect2.left = 0i64;
        *&v8->m_rect2.right = db_one;
      }
      PropSheet_UpdateTab(hDlg);
      SetWindowLongW(hDlg, -21, dwNewLong);
      v9 = GetWindowLongW(v4, -16);
      SetWindowLongW(v4, -16, v9 & 0xFFFFFFFD | 1);
      SendMessageW(v4, 0x1036u, 0x4020u, 16416);
      v10 = SendMessageW(v4, 0x104Eu, 0, 0);
      CTreeList::InitToolTips(v10);
      gOldListWndProc = SetWindowLongW(v4, -4, Proxy_ListCtrlWndProc);
      SendMessageW(v4, 0x30u, ghConfigFont, 0);
      CTreeView::InitListHeader(v4, &pnIDs, pnWidths, 3u);
      v11 = *(dwNewLong + 868);
      if ( !v11 )
        goto LABEL_10;
      break;
    case 273:
      switch ( wParam )
      {
        case 0x9C41u:
          v15 = 40014;
          goto LABEL_15;
        case 0x9C42u:
          SetEvent(ghRefreshEventHandle);
          break;
        case 0x9C9Cu:
        case 0x9C9Du:
          v15 = wParam;
LABEL_15:
          v14 = GetParent(hDlg);
          PostMessageW(v14, 0x111u, v15, 0);
          break;
        default:
          return 0;
      }
      return 0;
    default:
      return 0;
  }
  while ( 1 )
  {
    lParam = 5;
    v21 = 0x7FFFFFFF;
    v22 = 0;
    v24 = 0;
    v23 = 0;
    v25 = *v11;
    v26 = 0;
    v27 = 1;
    v12 = SendMessageW(v4, 0x104Du, 0, &lParam);
    dwNewLong = v12;
    if ( v12 == -1 )
      break;
    v21 = v12;
    lParam = 1;
    v22 = 1;
    v25 = v11[1];
    SendMessageW(v4, 0x104Cu, 0, &lParam);
    v21 = dwNewLong;
    lParam = 1;
    v22 = 2;
    v25 = v11[2];
    SendMessageW(v4, 0x104Cu, 0, &lParam);
    v11 = v11[3];
    if ( !v11 )
    {
LABEL_10:
      SendMessageW(v4, 0x101Eu, 0, 0xFFFF);
      SendMessageW(v4, 0x101Eu, 1u, 0xFFFF);
      SendMessageW(v4, 0x101Eu, 2u, 0xFFFF);
      v18 = 3;
      v17 = 3;
      SendMessageW(v4, 0x102Bu, 0, &v16);
      SetFocus(v4);
      return 1;
    }
  }
  return 0;
}

//----- (00FEDA70) --------------------------------------------------------
char __cdecl PE_IsProcessInJob(HANDLE ProcessHandle, DWORD dwProcessId, DWORD *dwValue3, DWORD dwValue4)
{
  SYSTEM_HANDLE_INFORMATION *v4; // eax
  ULONG v5; // edi
  int v6; // edi
  SYSTEM_HANDLE_TABLE_ENTRY_INFO *v7; // ebx
  void *v8; // esi
  _DWORD *v9; // edi
  SYSTEM_HANDLE_TABLE_ENTRY_INFO *pEntry; // [esp+4h] [ebp-818h]
  DWORD *v12; // [esp+8h] [ebp-814h]
  DWORD v13; // [esp+Ch] [ebp-810h]
  int v14; // [esp+10h] [ebp-80Ch]
  int bProcessInJob; // [esp+14h] [ebp-808h]
  wchar_t v16; // [esp+18h] [ebp-804h]

  v13 = dwValue4;
  v12 = dwValue3;
  if ( !*IsProcessInJob || !ProcessHandle )
    return 0;
  if ( !dwValue3 )
  {
    if ( IsProcessInJob(ProcessHandle, 0, &bProcessInJob) && bProcessInJob == 1 )
      return 1;
    return 0;
  }
  v4 = gpSystemHandleInfo;
  if ( gpSystemHandleInfo )
    v5 = gpSystemHandleInfo->NumberOfHandles;
  else
    v5 = 0;
  v6 = v5 - 1;
  if ( v6 < 0 )
    return 0;
  while ( 1 )
  {
    GetHandleTableEntry(v4, v6, &pEntry);
    v7 = pEntry;
    v14 = pEntry[1].CreatorBackTraceIndex;
    if ( _wcsicmp(&gpszObjectTypeNames[0x40 * v14], L"Job") )
      goto LABEL_13;
    v8 = PE_DuplicateProcessHandle(*&v7->ObjectTypeIndex, v7->Object, 0x80000000);
    if ( v8 )
    {
      if ( IsProcessInJob(ProcessHandle, v8, &bProcessInJob) && bProcessInJob == 1 )
        break;
    }
    CloseHandle(v8);
LABEL_13:
    if ( --v6 < 0 )
      return 0;
    v4 = gpSystemHandleInfo;
  }
  sub_FDC750(&gpszObjectTypeNames[0x40 * v14], v7, &v16, 0x400u, 0);
  v9 = v13;
  if ( v13 )
    *v9 = _wcsdup(&v16);
  *v12 = v8;
  return 1;
}

//----- (00FEDC00) --------------------------------------------------------
HANDLE __cdecl PE_OpenProcess(DWORD dwDesiredAccess, int a2, DWORD dwProcessId)
{
  HANDLE result; // eax
  DWORD BytesReturned; // [esp+0h] [ebp-8h]
  HANDLE OutBuffer; // [esp+4h] [ebp-4h]

  result = OpenProcess(dwDesiredAccess, 0, dwProcessId);
  OutBuffer = result;
  if ( !result )
  {
    if ( GetLastError() == ERROR_ACCESS_DENIED )
      DeviceIoControl(ghDriverHandle, 0x8335003C, &dwProcessId, 4u, &OutBuffer, 4u, &BytesReturned, 0);
    result = OutBuffer;
  }
  return result;
}

//----- (00FEDC50) --------------------------------------------------------
BOOL __cdecl sub_FEDC50(HWND hWnd_1, tagTREEVIEWLISTITEMPARAM *pItem)
{
  int v2; // ebx
  int v3; // edi
  int v4; // ebx
  int v5; // edi
  int v6; // eax
  __m128i v7; // xmm0
  __m128i v8; // xmm0
  HWND v9; // esi
  HWND v10; // eax
  HWND v11; // esi
  LONG v12; // ecx
  int v13; // edx
  HWND v14; // eax
  HWND v15; // eax
  LONG v16; // edi
  LONG v17; // esi
  __int128 v19; // [esp+Ch] [ebp-74h]
  DWORD dwProcessId; // [esp+1Ch] [ebp-64h]
  int v21; // [esp+20h] [ebp-60h]
  LONG v22; // [esp+24h] [ebp-5Ch]
  HWND hWnd; // [esp+28h] [ebp-58h]
  LONG v24; // [esp+2Ch] [ebp-54h]
  WINDOWPLACEMENT wp; // [esp+30h] [ebp-50h]
  struct tagRECT v26; // [esp+5Ch] [ebp-24h]
  struct tagRECT Rect; // [esp+6Ch] [ebp-14h]

  hWnd = hWnd_1;
  v2 = GetSystemMetrics(SM_CXVIRTUALSCREEN);
  v3 = GetSystemMetrics(SM_CYVIRTUALSCREEN);
  if ( v2 )
  {
    v21 = GetSystemMetrics(SM_XVIRTUALSCREEN);
    v4 = v21 + v2;
    v6 = GetSystemMetrics(SM_YVIRTUALSCREEN);
    v5 = v6 + v3;
    v22 = v6;
  }
  else
  {
    v22 = SM_CXSCREEN;
    v21 = SM_CXSCREEN;
    v4 = GetSystemMetrics(SM_CXSCREEN);
    v5 = GetSystemMetrics(SM_CYSCREEN);
  }
  v24 = v5;
  if ( pItem->nListType )
    v7 = _mm_loadu_si128(&gConfig.WindowPlacement[3].rcNormalPosition);
  else
    v7 = _mm_loadu_si128(&gConfig.WindowPlacement[2].rcNormalPosition);
  _mm_storeu_si128(&Rect, v7);
  _mm_storeu_si128(&v19, v7);
  memset(&wp, 0, sizeof(WINDOWPLACEMENT));
  v8 = _mm_loadu_si128(&v19);
  v9 = hWnd;
  wp.length = sizeof(WINDOWPLACEMENT);
  _mm_storeu_si128(&wp.rcNormalPosition, v8);
  wp.showCmd = 0;
  SetWindowPlacement(v9, &wp);
  GetWindowRect(v9, &Rect);
  v10 = GetDesktopWindow();
  v11 = FindWindowExW(v10, 0, 0x8002, 0);
  if ( v11 )
  {
    do
    {
      GetWindowThreadProcessId(v11, &dwProcessId);
      if ( dwProcessId == GetCurrentProcessId() && v11 != hWnd )
      {
        GetWindowRect(v11, &v26);
        v12 = Rect.top;
        if ( v26.top == Rect.top )
        {
          v13 = Rect.left;
          if ( v26.left == Rect.left )
          {
            if ( Rect.top + 20 > v5 - 50 || Rect.left + 20 > v4 - 50 )
              goto LABEL_17;
            Rect.bottom += 20;
            Rect.right += 20;
            Rect.top += 20;
            v11 = 0;
            Rect.left += 20;
          }
        }
      }
      v14 = GetDesktopWindow();
      v15 = FindWindowExW(v14, v11, 0x8002, 0);
      v5 = v24;
      v11 = v15;
    }
    while ( v15 );
  }
  v12 = Rect.top;
  v13 = Rect.left;
LABEL_17:
  v16 = Rect.right;
  if ( Rect.right > v4 )
  {
    v16 = v4;
    v13 += v4 - Rect.right;
    Rect.right = v4;
    Rect.left = v13;
  }
  if ( v13 < v21 )
  {
    v13 = v21;
    Rect.left = v21;
  }
  v17 = Rect.bottom;
  if ( Rect.bottom > v24 )
  {
    v17 = v24;
    v12 += v24 - Rect.bottom;
    Rect.bottom = v24;
    Rect.top = v12;
  }
  if ( v12 < v22 )
  {
    v12 = v22;
    Rect.top = v22;
  }
  return MoveWindow(hWnd, v13, v12, v16 - v13, v17 - v12, 0);
}

//----- (00FEDE20) --------------------------------------------------------
int __thiscall sub_FEDE20(int *this, int a2)
{
  int *v2; // edi
  _DWORD *v3; // edx
  int v4; // eax
  int result; // eax

  v2 = this;
  v3 = (*this - 16);
  if ( v3[2] >= a2 || a2 <= 0 || (v4 = (*(**v3 + 8))(v3, a2, 1)) == 0 )
    ATL::CSimpleStringT<wchar_t,0>::ThrowMemoryException();
  result = v4 + 16;
  *v2 = result;
  return result;
}

//----- (00FEDE60) --------------------------------------------------------
_DWORD *__cdecl sub_FEDE60(DWORD dwProcessId)
{
  int v1; // ecx
  _DWORD *v2; // esi
  DWORD v3; // edi
  DWORD v4; // eax
  HANDLE v6; // ebx

  v1 = 0;
  v2 = 0;
  v3 = 0;
  if ( gConfig.dwDllColumnCount <= 0 )
    return v2;
  while ( 1 )
  {
    v4 = gConfig.dwDllColumnMap[v1];
    if ( v4 == 1115 || v4 == 1116 || v4 == 1317 || v4 == 1118 )
      break;
    if ( ++v1 >= gConfig.dwDllColumnCount )
      return 0;
  }
  v6 = OpenProcess(0x410u, 0, dwProcessId);
  if ( !v6 )
    return v2;
  while ( 1 )
  {
    if ( QueryWorkingSet(v6, v2, v3) )
    {
      if ( !v2 )
        goto LABEL_14;
      if ( v3 >= 4 * *v2 )
        goto LABEL_17;
    }
    if ( v2 )
      free(v2);
LABEL_14:
    if ( GetLastError() != 24 )
      break;
    v3 += 0x4000;
    v2 = malloc(v3);
  }
  v2 = 0;
LABEL_17:
  CloseHandle(v6);
  return v2;
}

//----- (00FEDF20) --------------------------------------------------------
int __cdecl TreeViewListItemParam_GetSystemInfo(SYSTEM_PROCESS_INFORMATION *pSystemProcessInfo, HANDLE ProcessHandleIn, int a3, int a4, int a5, int a6, tagTREEVIEWLISTITEMPARAM *pItemParam, WPARAM wParam)
{
  signed int v8; // edx
  char fUsingCSwitchDelta; // bh
  char v10; // bl
  int dwIndex; // esi
  int uID; // ecx
  bool fNeedObjects; // al
  bool fUsingProcessCycle; // al
  bool fUsingMemoryPriority; // al
  int fUsingWS; // eax
  bool v17; // zf
  WPARAM v18; // ebx
  int v19; // edx
  bool v20; // cf
  int v21; // ecx
  int v22; // esi
  bool v23; // al
  char v24; // al
  unsigned int v25; // edx
  bool v26; // cl
  unsigned int v27; // edx
  unsigned int v28; // ecx
  signed int v29; // eax
  unsigned __int64 v30; // kr10_8
  __int64 v31; // kr18_8
  bool v32; // al
  char v33; // al
  int v34; // ecx
  int v35; // ecx
  bool v36; // al
  HANDLE ProcessHandle; // esi
  void *v38; // ecx
  unsigned int v39; // edx
  unsigned int v40; // ecx
  unsigned __int64 v41; // kr28_8
  bool v42; // al
  signed int v43; // ecx
  unsigned __int8 v44; // al
  int v45; // ecx
  char v46; // al
  int v47; // ecx
  char v48; // al
  char v49; // al
  char v50; // al
  char v51; // al
  char v52; // al
  char v53; // al
  int v54; // eax
  char v55; // al
  char v56; // bl
  int v57; // eax
  char v58; // al
  char v59; // cl
  char v60; // al
  char v61; // cl
  char v62; // al
  char v63; // cl
  int v64; // esi
  SYSTEM_PROCESS_INFORMATION *v65; // ecx
  int v66; // edx
  int v67; // eax
  unsigned int v68; // eax
  unsigned __int64 v69; // kr48_8
  int v70; // esi
  char v71; // al
  signed int v72; // ecx
  int v73; // esi
  char v74; // al
  signed int v75; // ecx
  HWND v76; // esi
  char v77; // al
  SYSTEM_PROCESS_INFORMATION *v78; // edx
  HWND v79; // ecx
  unsigned __int8 v80; // al
  HWND v81; // ST34_4
  int v82; // edx
  unsigned __int8 v83; // al
  HWND v84; // ecx
  HWND v85; // ST34_4
  int v86; // edx
  unsigned __int8 v87; // al
  HWND v88; // ecx
  HWND v89; // ST34_4
  unsigned int v90; // edx
  unsigned __int8 v91; // al
  HWND v92; // ecx
  HWND v93; // ST34_4
  char v94; // al
  int v95; // esi
  HWND v96; // ecx
  unsigned __int8 v97; // al
  char v98; // al
  unsigned int v99; // edx
  HWND v100; // ecx
  unsigned __int8 v101; // al
  HWND v102; // ST34_4
  char v103; // al
  int v104; // esi
  HWND v105; // ecx
  unsigned __int8 v106; // al
  char v107; // al
  unsigned int v108; // edx
  HWND v109; // ecx
  unsigned __int8 v110; // al
  HWND v111; // ST34_4
  char v112; // al
  int v113; // esi
  HWND v114; // ecx
  unsigned __int8 v115; // al
  char v116; // al
  unsigned int v117; // edx
  HWND v118; // ecx
  unsigned __int8 v119; // al
  HWND v120; // ST34_4
  char v121; // al
  SYSTEM_PROCESS_INFORMATION *v122; // ecx
  int v123; // esi
  unsigned int v124; // ecx
  char v125; // al
  signed int v126; // ecx
  unsigned int v127; // eax
  unsigned int v128; // eax
  unsigned __int64 v129; // kr58_8
  char v130; // al
  signed int v131; // ecx
  unsigned int v132; // eax
  unsigned int v133; // eax
  unsigned __int64 v134; // kr60_8
  char v135; // al
  signed int v136; // ecx
  unsigned int v137; // ecx
  int v138; // ecx
  int v139; // eax
  bool v140; // dl
  HWND v141; // ST34_4
  char v142; // al
  unsigned int v143; // edx
  signed int v144; // ecx
  int v145; // edx
  int v146; // eax
  bool v147; // cl
  HWND v148; // ST34_4
  char v149; // al
  unsigned int v150; // edx
  signed int v151; // ecx
  int v152; // edx
  int v153; // ecx
  bool v154; // al
  HWND v155; // ST34_4
  char v156; // al
  HWND v157; // ecx
  int v158; // eax
  bool v159; // al
  char v160; // al
  signed int v161; // ecx
  int v162; // edx
  int v163; // ecx
  bool v164; // al
  HWND v165; // ST34_4
  char v166; // al
  HWND v167; // ecx
  int v168; // eax
  bool v169; // al
  char v170; // al
  signed int v171; // ecx
  int v172; // edx
  int v173; // ecx
  bool v174; // al
  HWND v175; // ST34_4
  char v176; // al
  HWND v177; // ecx
  int v178; // eax
  bool v179; // al
  char v180; // al
  signed int v181; // ecx
  int v182; // edx
  int v183; // ecx
  bool v184; // al
  HWND v185; // ST34_4
  char v186; // al
  HWND v187; // esi
  HWND v188; // ecx
  int v189; // eax
  unsigned int v190; // eax
  unsigned __int64 v191; // kr70_8
  bool v192; // dl
  char v193; // al
  char v194; // cl
  _DWORD *v195; // esi
  unsigned int v196; // ecx
  char v197; // al
  signed int v198; // ecx
  unsigned int v199; // eax
  unsigned int v200; // eax
  unsigned __int64 v201; // kr80_8
  char v202; // al
  signed int v203; // ecx
  unsigned int v204; // eax
  unsigned int v205; // eax
  unsigned __int64 v206; // kr88_8
  char v207; // al
  signed int v208; // ecx
  unsigned int v209; // ecx
  int v210; // ecx
  int v211; // eax
  bool v212; // dl
  HWND v213; // ST34_4
  char v214; // al
  unsigned int v215; // edx
  signed int v216; // ecx
  int v217; // edx
  int v218; // eax
  bool v219; // cl
  HWND v220; // ST34_4
  char v221; // al
  unsigned int v222; // edx
  signed int v223; // ecx
  int v224; // edx
  int v225; // ecx
  bool v226; // al
  HWND v227; // ST34_4
  char v228; // al
  HWND v229; // ecx
  int v230; // eax
  bool v231; // al
  char v232; // al
  signed int v233; // ecx
  int v234; // edx
  int v235; // ecx
  bool v236; // al
  HWND v237; // ST34_4
  char v238; // al
  HWND v239; // ecx
  int v240; // eax
  bool v241; // al
  char v242; // al
  signed int v243; // ecx
  int v244; // edx
  int v245; // ecx
  bool v246; // al
  HWND v247; // ST34_4
  char v248; // al
  HWND v249; // ecx
  int v250; // eax
  bool v251; // al
  char v252; // al
  signed int v253; // ecx
  int v254; // edx
  int v255; // ecx
  bool v256; // al
  HWND v257; // ST34_4
  char v258; // al
  HWND v259; // esi
  HWND v260; // ecx
  int v261; // eax
  unsigned int v262; // eax
  unsigned __int64 v263; // kr98_8
  bool v264; // dl
  char v265; // cl
  UINT_PTR MaximumWorkingSetSize; // [esp+8h] [ebp-88Ch]
  UINT_PTR MinimumWorkingSetSize; // [esp+Ch] [ebp-888h]
  unsigned int v268; // [esp+10h] [ebp-884h]
  int ProcessInformation; // [esp+14h] [ebp-880h]
  int v270; // [esp+18h] [ebp-87Ch]
  int v271; // [esp+1Ch] [ebp-878h]
  ULONG ReturnLength; // [esp+20h] [ebp-874h]
  int v273; // [esp+24h] [ebp-870h]
  int v274; // [esp+28h] [ebp-86Ch]
  int v275; // [esp+2Ch] [ebp-868h]
  HANDLE hProcess; // [esp+30h] [ebp-864h]
  unsigned __int64 llValue277; // [esp+34h] [ebp-860h]
  SYSTEM_PROCESS_INFORMATION *SystemProcessInfo; // [esp+3Ch] [ebp-858h]
  char v279; // [esp+40h] [ebp-854h]
  char v280; // [esp+41h] [ebp-853h]
  char v281; // [esp+42h] [ebp-852h]
  char v282; // [esp+43h] [ebp-851h]
  int v283; // [esp+48h] [ebp-84Ch]
  unsigned int v284; // [esp+4Ch] [ebp-848h]
  bool v285; // [esp+53h] [ebp-841h]
  int v286; // [esp+54h] [ebp-840h]
  HWND hWnd[2]; // [esp+58h] [ebp-83Ch]
  IO_COUNTERS IoCounters; // [esp+60h] [ebp-834h]
  __int64 ProcessorIdleCycleTime[256]; // [esp+90h] [ebp-804h]

  LOBYTE(v8) = 0;
  fUsingCSwitchDelta = 0;
  SystemProcessInfo = pSystemProcessInfo;
  v10 = 0;
  dwIndex = 0;
  hProcess = ProcessHandleIn;
  v286 = v8;
  v281 = 0;
  v280 = 0;
  v279 = 0;
  v282 = 0;
  v285 = 0;
  llValue277 = 0i64;
  if ( gConfig.dwProcessColumnCount <= 0 )
    goto LABEL_271;
  BYTE1(v8) = 0;
  v285 = gdwVersion >= 1;
  do
  {
    uID = gConfig.dwProcessColumnMap[dwIndex];
    fNeedObjects = uID == IDS_GDI_OBJECTS || uID == IDS_USER_OBJECTS;
    v281 |= fNeedObjects;
    fUsingCSwitchDelta |= uID == IDS_CSWITCH_DELTA;
    fUsingProcessCycle = QueryProcessCycleTime
                      || uID == IDS_CPU
                      || uID == IDS_CYCLES
                      || uID == IDS_CYCLES_DELTA
                      || uID == IDS_CYCLECPUUSAGE;
    v10 |= fUsingProcessCycle;
    v279 |= v285;
    fUsingMemoryPriority = gdwVersion >= 1 && uID == IDS_MEMORY_PRIORITY;
    BYTE1(v8) |= fUsingMemoryPriority;
    fUsingWS = uID == IDS_WS_PRIVATE || uID == IDS_WS_SHAREABLE || uID == IDS_WS_SHARED;
    ++dwIndex;
    LOBYTE(v8) = fUsingWS | v8;
  }
  while ( dwIndex < gConfig.dwProcessColumnCount );
  v282 = BYTE1(v8);
  v17 = v8 == 0;
  v280 = v8;
  LOBYTE(v8) = v286;
  v285 = v10;
  if ( v17 )
  {
LABEL_271:
    fUsingWS = pItemParam->field_3A0;
    if ( fUsingWS )
    {
      free(pItemParam->field_3A0);
      LOBYTE(v8) = v286;
      pItemParam->field_3A0 = 0;
      pItemParam->field_3A4 = 0;
    }
  }
  v17 = fUsingCSwitchDelta == 0;
  v18 = wParam;
  if ( v17 )
  {
    pItemParam->ContextSwtichDelta = 0i64;
  }
  else
  {
    v284 = sub_FDA500(SystemProcessInfo);
    v20 = v284 < LODWORD(pItemParam->ContextSwtiches);
    v21 = v284 - LODWORD(pItemParam->ContextSwtiches);
    v274 = v19;
    v22 = v19 - (v20 + HIDWORD(pItemParam->ContextSwtiches));
    if ( v19 - (v20 + HIDWORD(pItemParam->ContextSwtiches)) < 0
      || v19 <= v20 + HIDWORD(pItemParam->ContextSwtiches) && !v21 )
    {
      *hWnd = 0i64;
      v22 = 0;
      v21 = 0;
    }
    v23 = v21 != LODWORD(pItemParam->ContextSwtichDelta) || v22 != HIDWORD(pItemParam->ContextSwtichDelta);
    LODWORD(pItemParam->ContextSwtichDelta) = v21;
    HIDWORD(pItemParam->ContextSwtichDelta) = v22;
    v24 = RedrawColumn(v23, ghWndTreeListView, IDS_CSWITCH_DELTA, wParam);
    v25 = v284;
    LOBYTE(v286) = v24;
    v26 = v284 != LODWORD(pItemParam->ContextSwtiches) || v274 != HIDWORD(pItemParam->ContextSwtiches);
    HIDWORD(pItemParam->ContextSwtiches) = v274;
    LODWORD(pItemParam->ContextSwtiches) = v25;
    LOBYTE(fUsingWS) = RedrawColumn(v26, ghWndTreeListView, IDS_CONTEXT_SWITCHES, wParam);
    v8 = v286;
    LOBYTE(v8) = fUsingWS | v286;
    v286 = v8;
  }
  if ( !pItemParam->dwProcessId )
  {
    if ( v285 && QueryIdleProcessorCycleTime )
    {
      if ( gdwVersion < 2
        || (v28 = SystemProcessInfo->SpareLi3.QuadPart >> 32,
            v27 = SystemProcessInfo->SpareLi3.QuadPart,
            !SystemProcessInfo->SpareLi3.QuadPart) )
      {
        ReturnLength = 8 * gSystemInfo.dwNumberOfProcessors;
        QueryIdleProcessorCycleTime(&ReturnLength, ProcessorIdleCycleTime);
        v29 = 0;
        v28 = HIDWORD(llValue277);
        v27 = llValue277;
        if ( gSystemInfo.dwNumberOfProcessors <= 0 )
        {
LABEL_50:
          v31 = __PAIR__(v28, v27) - pItemParam->Cycles;
          v32 = v31 != pItemParam->CyclesDelta;
          pItemParam->CyclesDelta = v31;
          v33 = RedrawColumn(v32, ghWndTreeListView, IDS_CYCLES_DELTA, wParam);
          v34 = v286;
          LOBYTE(v34) = v33 | v286;
          v286 = v34;
          v35 = HIDWORD(llValue277);
          v36 = llValue277 != pItemParam->Cycles;
          LODWORD(pItemParam->Cycles) = llValue277;
          HIDWORD(pItemParam->Cycles) = v35;
          LOBYTE(fUsingWS) = RedrawColumn(v36, ghWndTreeListView, IDS_CYCLES, wParam);
          LOBYTE(fUsingWS) = fUsingWS | v286;
          return fUsingWS;
        }
        do
        {
          v30 = __PAIR__(HIDWORD(ProcessorIdleCycleTime[v29]), ProcessorIdleCycleTime[v29]) + __PAIR__(v28, v27);
          v28 = (__PAIR__(HIDWORD(ProcessorIdleCycleTime[v29]), ProcessorIdleCycleTime[v29]) + __PAIR__(v28, v27)) >> 32;
          v27 = v30;
          ++v29;
        }
        while ( v29 < gSystemInfo.dwNumberOfProcessors );
      }
      llValue277 = __PAIR__(v28, v27);
      goto LABEL_50;
    }
    goto LABEL_268;
  }
  ProcessHandle = hProcess;
  if ( v285 && QueryIdleProcessorCycleTime )
  {
    v38 = SystemProcessInfo;
    if ( !hProcess )
    {
      fUsingWS = SystemProcessInfo->SpareLi3.HighPart | SystemProcessInfo->SpareLi3.LowPart;
      if ( !SystemProcessInfo->SpareLi3.QuadPart )
        goto LABEL_268;
    }
    if ( gdwVersion >= 2
      && (v38 = (SystemProcessInfo->SpareLi3.QuadPart >> 32),
          v39 = SystemProcessInfo->SpareLi3.QuadPart,
          SystemProcessInfo->SpareLi3.QuadPart) )
    {
      llValue277 = __PAIR__(v38, v39);
    }
    else
    {
      QueryProcessCycleTime(v38, hProcess);
      v38 = HIDWORD(llValue277);
      v39 = llValue277;
    }
    v41 = __PAIR__(v38, v39) - pItemParam->Cycles;
    v40 = (__PAIR__(v38, v39) - pItemParam->Cycles) >> 32;
    v42 = __PAIR__(v40, v41) != pItemParam->CyclesDelta;
    pItemParam->CyclesDelta = __PAIR__(v40, v41);
    v17 = RedrawColumn(v42, ghWndTreeListView, IDS_CYCLES_DELTA, wParam) == 0;
    v43 = v286;
    v44 = 1;
    if ( !v17 )
      v43 = 1;
    v284 = v43;
    v45 = HIDWORD(llValue277);
    if ( llValue277 == pItemParam->Cycles )
      v44 = 0;
    LODWORD(pItemParam->Cycles) = llValue277;
    HIDWORD(pItemParam->Cycles) = v45;
    v17 = RedrawColumn(v44, ghWndTreeListView, IDS_CYCLES, wParam) == 0;
    v8 = v284;
    fUsingWS = 1;
    if ( !v17 )
      v8 = 1;
    v286 = v8;
  }
  if ( !ProcessHandle )
  {
LABEL_268:
    LOBYTE(fUsingWS) = v8;
    return fUsingWS;
  }
  if ( wParam != -1 && GetProcessWorkingSetSize(ProcessHandle, &MinimumWorkingSetSize, &MaximumWorkingSetSize) )
  {
    v17 = MinimumWorkingSetSize == pItemParam->dwMinimumWorkingSetSize;
    pItemParam->dwMinimumWorkingSetSize = MinimumWorkingSetSize;
    v46 = RedrawColumn(!v17, ghWndTreeListView, IDS_MIN_WORKING_SET, wParam);
    v47 = v286;
    LOBYTE(v47) = v46 | v286;
    v17 = MaximumWorkingSetSize == pItemParam->dwMaximumWorkingSetSize;
    v286 = v47;
    pItemParam->dwMaximumWorkingSetSize = MaximumWorkingSetSize;
    v48 = RedrawColumn(!v17, ghWndTreeListView, IDS_MAX_WORKING_SET, wParam);
    LOBYTE(v286) = v48 | v286;
  }
  v49 = sub_FB3340(
          ProcessHandle,
          __PAIR__(a4, a3) / gSystemInfo.dwNumberOfProcessors,
          (__PAIR__(a4, a3) / gSystemInfo.dwNumberOfProcessors) >> 32,
          a5,
          a6,
          pItemParam,
          wParam);
  LOBYTE(v286) = v49 | v286;
  if ( v280 )
  {
    sub_FDEB20(ProcessHandle, &pItemParam->field_3A0, &pItemParam->field_3A4, &v284, &v275, &v271, &v273);
    if ( wParam != -1 )
    {
      v17 = v284 == pItemParam->WSTotal;
      pItemParam->WSTotal = v284;
      v50 = RedrawColumn(!v17, ghWndTreeListView, IDS_WS_TOTAL, wParam);
      LOBYTE(v286) = v50 | v286;
      v17 = v275 == pItemParam->WSPrivate;
      pItemParam->WSPrivate = v275;
      v51 = RedrawColumn(!v17, ghWndTreeListView, IDS_WS_PRIVATE, wParam);
      LOBYTE(v286) = v51 | v286;
      v17 = v271 == pItemParam->WSShareable;
      pItemParam->WSShareable = v271;
      v52 = RedrawColumn(!v17, ghWndTreeListView, IDS_WS_SHAREABLE, wParam);
      LOBYTE(v286) = v52 | v286;
      v17 = v273 == pItemParam->WSShared;
      pItemParam->WSShared = v273;
      v53 = RedrawColumn(!v17, ghWndTreeListView, IDS_WS_SHARED, wParam);
      LOBYTE(v286) = v53 | v286;
    }
  }
  if ( v281 )
  {
    v54 = GetGuiResources(ProcessHandle, 0);
    v17 = v54 == pItemParam->m_GdiObjects;
    pItemParam->m_GdiObjects = v54;
    v55 = RedrawColumn(!v17, ghWndTreeListView, IDS_GDI_OBJECTS, wParam);
    v56 = v286;
    if ( v55 )
      v56 = 1;
    v57 = GetGuiResources(ProcessHandle, 1u);
    v17 = v57 == pItemParam->m_UserObjects;
    pItemParam->m_UserObjects = v57;
    v58 = RedrawColumn(!v17, ghWndTreeListView, IDS_USER_OBJECTS, wParam);
    v59 = v56;
    v18 = wParam;
    if ( v58 )
      v59 = 1;
    LOBYTE(v286) = v59;
  }
  if ( v282 )
  {
    ProcessInformation = -1;
    NtQueryInformationProcess(ProcessHandle, ProcessPagePriority, &ProcessInformation, 4u, &ReturnLength);
    v17 = ProcessInformation == pItemParam->m_ProcessMemoryPriority;
    pItemParam->m_ProcessMemoryPriority = ProcessInformation;
    v60 = RedrawColumn(!v17, ghWndTreeListView, IDS_MEMORY_PRIORITY, v18);
    v61 = v286;
    if ( v60 )
      v61 = 1;
    LOBYTE(v286) = v61;
  }
  if ( v279 )
  {
    v270 = -1;
    NtQueryInformationProcess(ProcessHandle, ProcessIoPriority, &v270, 4u, &ReturnLength);
    v17 = v270 == pItemParam->m_ProcessIoPriority;
    pItemParam->m_ProcessIoPriority = v270;
    v62 = RedrawColumn(!v17, ghWndTreeListView, IDS_IO_PRIORITY, v18);
    v63 = v286;
    if ( v62 )
      v63 = 1;
    LOBYTE(v286) = v63;
  }
  fUsingWS = NtQueryInformationProcess(ProcessHandle, ProcessIoCounters, &IoCounters, 0x30u, &ReturnLength);
  if ( fUsingWS )
  {
    LOBYTE(fUsingWS) = v286;
  }
  else
  {
    v64 = LODWORD(IoCounters.ReadTransferCount) - LODWORD(pItemParam->IO_COUNTERS);
    v65 = ((IoCounters.ReadTransferCount - pItemParam->IO_COUNTERS) >> 32);
    v283 = LODWORD(IoCounters.WriteOperationCount) - LODWORD(pItemParam->WriteOperationCount);
    v66 = (IoCounters.WriteTransferCount - pItemParam->WriteTransferCount) >> 32;
    v268 = LODWORD(IoCounters.WriteTransferCount) - LODWORD(pItemParam->WriteTransferCount);
    hWnd[1] = (LODWORD(IoCounters.OtherOperationCount) - LODWORD(pItemParam->OtherOperationCount));
    v67 = (IoCounters.OtherTransferCount - pItemParam->OtherTransferCount) >> 32;
    v271 = LODWORD(IoCounters.OtherTransferCount) - LODWORD(pItemParam->OtherTransferCount);
    v274 = v64;
    v275 = v67;
    v69 = __PAIR__(v65, v64) + __PAIR__(v66, v268) + __PAIR__(v67, v271);
    v68 = (__PAIR__(v65, v64) + __PAIR__(v66, v268) + __PAIR__(v67, v271)) >> 32;
    hProcess = v69;
    SystemProcessInfo = v65;
    v70 = LODWORD(IoCounters.ReadOperationCount) - LODWORD(pItemParam->ReadOperationCount);
    v273 = v66;
    v284 = v68;
    v71 = RedrawColumn(v70 != LODWORD(pItemParam->IoDeltaReads), ghWndTreeListView, IDS_IO_DELTA_READS, v18);
    v72 = v286;
    LODWORD(pItemParam->IoDeltaReads) = v70;
    v73 = v283;
    if ( v71 )
      v72 = 1;
    v286 = v72;
    v74 = RedrawColumn(v283 != LODWORD(pItemParam->IoDeltaWrites), ghWndTreeListView, IDS_IO_DELTA_WRITES, v18);
    v75 = v286;
    LODWORD(pItemParam->IoDeltaWrites) = v73;
    v76 = hWnd[1];
    if ( v74 )
      v75 = 1;
    v283 = v75;
    v77 = RedrawColumn(hWnd[1] != LODWORD(pItemParam->IoDeltaOthers), ghWndTreeListView, IDS_IO_DELTA_OTHER, v18);
    v78 = SystemProcessInfo;
    v17 = v77 == 0;
    v79 = v283;
    v80 = 1;
    if ( !v17 )
      v79 = 1;
    LODWORD(pItemParam->IoDeltaOthers) = v76;
    hWnd[1] = v79;
    if ( v274 == LODWORD(pItemParam->DeltaReadBytes) && v78 == HIDWORD(pItemParam->DeltaReadBytes) )
      v80 = 0;
    v81 = ghWndTreeListView;
    LODWORD(pItemParam->DeltaReadBytes) = v274;
    HIDWORD(pItemParam->DeltaReadBytes) = v78;
    v17 = RedrawColumn(v80, v81, IDS_IO_DELTA_READ_BYTES, v18) == 0;
    v82 = v273;
    v83 = 1;
    v84 = LOBYTE(hWnd[1]);
    if ( !v17 )
      v84 = 1;
    hWnd[1] = v84;
    if ( v268 == LODWORD(pItemParam->DeltaWriteBytes) && v273 == HIDWORD(pItemParam->DeltaWriteBytes) )
      v83 = 0;
    v85 = ghWndTreeListView;
    LODWORD(pItemParam->DeltaWriteBytes) = v268;
    HIDWORD(pItemParam->DeltaWriteBytes) = v82;
    v17 = RedrawColumn(v83, v85, IDS_IO_DELTA_WRITE_BYTES, v18) == 0;
    v86 = v275;
    v87 = 1;
    v88 = LOBYTE(hWnd[1]);
    if ( !v17 )
      v88 = 1;
    hWnd[1] = v88;
    if ( v271 == LODWORD(pItemParam->DeltaOtherBytes) && v275 == HIDWORD(pItemParam->DeltaOtherBytes) )
      v87 = 0;
    v89 = ghWndTreeListView;
    LODWORD(pItemParam->DeltaOtherBytes) = v271;
    HIDWORD(pItemParam->DeltaOtherBytes) = v86;
    v17 = RedrawColumn(v87, v89, IDS_IO_DELTA_OTHER_BYTES, v18) == 0;
    v90 = v284;
    v91 = 1;
    v92 = LOBYTE(hWnd[1]);
    if ( !v17 )
      v92 = 1;
    hWnd[1] = v92;
    if ( hProcess == LODWORD(pItemParam->DeltaTotalBytes) && v284 == HIDWORD(pItemParam->DeltaTotalBytes) )
      v91 = 0;
    v93 = ghWndTreeListView;
    LODWORD(pItemParam->DeltaTotalBytes) = hProcess;
    HIDWORD(pItemParam->DeltaTotalBytes) = v90;
    v94 = RedrawColumn(v91, v93, IDS_IO_DELTA_TOTAL_BYTES, v18);
    v95 = IoCounters.ReadOperationCount;
    v17 = v94 == 0;
    v96 = LOBYTE(hWnd[1]);
    v97 = 1;
    if ( !v17 )
      v96 = 1;
    hWnd[1] = v96;
    if ( IoCounters.ReadOperationCount == LODWORD(pItemParam->ReadOperationCount) )
      v97 = 0;
    v283 = HIDWORD(IoCounters.ReadOperationCount);
    v98 = RedrawColumn(v97, ghWndTreeListView, IDS_IO_READS, v18);
    v99 = IoCounters.ReadTransferCount;
    v17 = v98 == 0;
    v100 = LOBYTE(hWnd[1]);
    v101 = 1;
    if ( !v17 )
      v100 = 1;
    LODWORD(pItemParam->ReadOperationCount) = v95;
    hWnd[1] = v100;
    if ( __PAIR__(HIDWORD(IoCounters.ReadTransferCount), v99) == pItemParam->IO_COUNTERS )
      v101 = 0;
    v102 = ghWndTreeListView;
    pItemParam->IO_COUNTERS = __PAIR__(HIDWORD(IoCounters.ReadTransferCount), v99);
    v103 = RedrawColumn(v101, v102, IDS_IO_READ_BYTES, v18);
    v104 = IoCounters.WriteOperationCount;
    v17 = v103 == 0;
    v105 = LOBYTE(hWnd[1]);
    v106 = 1;
    if ( !v17 )
      v105 = 1;
    hWnd[1] = v105;
    if ( IoCounters.WriteOperationCount == LODWORD(pItemParam->WriteOperationCount) )
      v106 = 0;
    v283 = HIDWORD(IoCounters.WriteOperationCount);
    v107 = RedrawColumn(v106, ghWndTreeListView, IDS_IO_WRITES, v18);
    v108 = IoCounters.WriteTransferCount;
    v17 = v107 == 0;
    v109 = LOBYTE(hWnd[1]);
    v110 = 1;
    if ( !v17 )
      v109 = 1;
    LODWORD(pItemParam->WriteOperationCount) = v104;
    hWnd[1] = v109;
    if ( __PAIR__(HIDWORD(IoCounters.WriteTransferCount), v108) == pItemParam->WriteTransferCount )
      v110 = 0;
    v111 = ghWndTreeListView;
    pItemParam->WriteTransferCount = __PAIR__(HIDWORD(IoCounters.WriteTransferCount), v108);
    v112 = RedrawColumn(v110, v111, IDS_IO_WRITE_BYTES, v18);
    v113 = IoCounters.OtherOperationCount;
    v17 = v112 == 0;
    v114 = LOBYTE(hWnd[1]);
    v115 = 1;
    if ( !v17 )
      v114 = 1;
    hWnd[1] = v114;
    if ( IoCounters.OtherOperationCount == LODWORD(pItemParam->OtherOperationCount) )
      v115 = 0;
    v283 = HIDWORD(IoCounters.OtherOperationCount);
    v116 = RedrawColumn(v115, ghWndTreeListView, IDS_IO_OTHER, v18);
    v117 = IoCounters.OtherTransferCount;
    v17 = v116 == 0;
    v118 = LOBYTE(hWnd[1]);
    v119 = 1;
    if ( !v17 )
      v118 = 1;
    LODWORD(pItemParam->OtherOperationCount) = v113;
    hWnd[1] = v118;
    if ( __PAIR__(HIDWORD(IoCounters.OtherTransferCount), v117) == pItemParam->OtherTransferCount )
      v119 = 0;
    v120 = ghWndTreeListView;
    pItemParam->OtherTransferCount = __PAIR__(HIDWORD(IoCounters.OtherTransferCount), v117);
    v121 = RedrawColumn(v119, v120, IDS_IO_OTHER_BYTES, v18);
    v122 = LOBYTE(hWnd[1]);
    if ( v121 )
      v122 = 1;
    SystemProcessInfo = v122;
    v123 = *sub_FF5820(&gMap3, &v275, &pItemParam->dwProcessId);
    if ( v123 != gMap3._Header )
    {
      v124 = (*(v123 + 48) - pItemParam->field_430) >> 32;
      hWnd[1] = (*(v123 + 48) - pItemParam->field_430);
      v125 = RedrawColumn(
               __PAIR__(v124, hWnd[1]) != pItemParam->NetworkDeltaReceives,
               ghWndTreeListView,
               IDS_NETWORK_DELTA_RECEIVES,
               v18);
      v126 = SystemProcessInfo;
      if ( v125 )
        v126 = 1;
      pItemParam->NetworkDeltaReceives = hWnd[1];
      v127 = *(v123 + 60);
      v283 = v126;
      v129 = __PAIR__(v127, *(v123 + 56)) - pItemParam->field_450;
      v128 = (__PAIR__(v127, *(v123 + 56)) - pItemParam->field_450) >> 32;
      hWnd[1] = v129;
      v130 = RedrawColumn(
               __PAIR__(v128, v129) != pItemParam->NetworkDeltaSends,
               ghWndTreeListView,
               IDS_NETWORK_DELTA_SENDS,
               v18);
      v131 = v283;
      if ( v130 )
        v131 = 1;
      pItemParam->NetworkDeltaSends = hWnd[1];
      v132 = *(v123 + 68);
      v283 = v131;
      v134 = __PAIR__(v132, *(v123 + 64)) - pItemParam->field_470;
      v133 = (__PAIR__(v132, *(v123 + 64)) - pItemParam->field_470) >> 32;
      hWnd[1] = v134;
      v135 = RedrawColumn(
               __PAIR__(v133, v134) != pItemParam->field_480,
               ghWndTreeListView,
               IDS_NETWORK_DELTA_OTHERS,
               v18);
      v136 = v283;
      if ( v135 )
        v136 = 1;
      pItemParam->field_480 = hWnd[1];
      v283 = v136;
      v137 = *(v123 + 24);
      v20 = v137 < pItemParam->field_438;
      v138 = v137 - pItemParam->field_438;
      hWnd[1] = ghWndTreeListView;
      v139 = *(v123 + 28) - (v20 + pItemParam->field_43C);
      v140 = v138 != pItemParam->field_448 || v139 != pItemParam->field_44C;
      v141 = hWnd[1];
      pItemParam->field_44C = v139;
      pItemParam->field_448 = v138;
      v142 = RedrawColumn(v140, v141, IDS_NETWORK_DELTA_RECEIVE_BYTES, v18);
      v143 = *(v123 + 32);
      v144 = v283;
      if ( v142 )
        v144 = 1;
      v20 = v143 < pItemParam->field_458;
      v145 = v143 - pItemParam->field_458;
      hWnd[1] = ghWndTreeListView;
      v146 = *(v123 + 36) - (v20 + pItemParam->field_45C);
      v283 = v144;
      v147 = v145 != pItemParam->field_468 || v146 != pItemParam->field_46C;
      v148 = hWnd[1];
      pItemParam->field_46C = v146;
      pItemParam->field_468 = v145;
      v149 = RedrawColumn(v147, v148, 1619, v18);
      v150 = *(v123 + 40);
      v151 = v283;
      if ( v149 )
        v151 = 1;
      v20 = v150 < pItemParam->field_478;
      v152 = v150 - pItemParam->field_478;
      v283 = v151;
      v153 = *(v123 + 44) - (v20 + pItemParam->field_47C);
      hWnd[1] = ghWndTreeListView;
      v154 = v152 != pItemParam->field_488 || v153 != pItemParam->field_48C;
      v155 = hWnd[1];
      pItemParam->field_488 = v152;
      pItemParam->field_48C = v153;
      v156 = RedrawColumn(v154, v155, IDS_NETWORK_DELTA_OTHER_BYTES, v18);
      v157 = v283;
      if ( v156 )
        v157 = 1;
      v158 = *(v123 + 48);
      hWnd[1] = v157;
      v283 = v158;
      v159 = v158 != pItemParam->field_430 || *(v123 + 52);
      v160 = RedrawColumn(v159, ghWndTreeListView, IDS_NETWORK_RECEIVES, v18);
      v161 = LOBYTE(hWnd[1]);
      if ( v160 )
        v161 = 1;
      pItemParam->field_430 = v283;
      v162 = *(v123 + 24);
      v284 = v161;
      v163 = *(v123 + 28);
      hWnd[1] = ghWndTreeListView;
      v164 = v162 != pItemParam->field_438 || v163 != pItemParam->field_43C;
      v165 = hWnd[1];
      pItemParam->field_438 = v162;
      pItemParam->field_43C = v163;
      v166 = RedrawColumn(v164, v165, IDS_NETWORK_RECEIVE_BYTES, v18);
      v167 = v284;
      if ( v166 )
        v167 = 1;
      v168 = *(v123 + 56);
      hWnd[1] = v167;
      v283 = v168;
      v169 = v168 != pItemParam->field_450 || *(v123 + 60);
      v170 = RedrawColumn(v169, ghWndTreeListView, IDS_NETWORK_SENDS, v18);
      v171 = LOBYTE(hWnd[1]);
      if ( v170 )
        v171 = 1;
      pItemParam->field_450 = v283;
      v172 = *(v123 + 32);
      v284 = v171;
      v173 = *(v123 + 36);
      hWnd[1] = ghWndTreeListView;
      v174 = v172 != pItemParam->field_458 || v173 != pItemParam->field_45C;
      v175 = hWnd[1];
      pItemParam->field_458 = v172;
      pItemParam->field_45C = v173;
      v176 = RedrawColumn(v174, v175, IDS_NETWORK_SEND_BYTES, v18);
      v177 = v284;
      if ( v176 )
        v177 = 1;
      v178 = *(v123 + 64);
      hWnd[1] = v177;
      v283 = v178;
      v179 = v178 != pItemParam->field_470 || *(v123 + 68);
      v180 = RedrawColumn(v179, ghWndTreeListView, IDS_NETWORK_OTHER, v18);
      v181 = LOBYTE(hWnd[1]);
      if ( v180 )
        v181 = 1;
      pItemParam->field_470 = v283;
      v182 = *(v123 + 40);
      v284 = v181;
      v183 = *(v123 + 44);
      hWnd[1] = ghWndTreeListView;
      v184 = v182 != pItemParam->field_478 || v183 != pItemParam->field_47C;
      v185 = hWnd[1];
      pItemParam->field_478 = v182;
      pItemParam->field_47C = v183;
      v186 = RedrawColumn(v184, v185, IDS_NETWORK_OTHER_BYTES, v18);
      v187 = ghWndTreeListView;
      v188 = v284;
      if ( v186 )
        v188 = 1;
      v189 = pItemParam->field_46C;
      hWnd[1] = v188;
      v191 = *&pItemParam->field_488 + *&pItemParam->field_448 + __PAIR__(v189, pItemParam->field_468);
      v190 = v191 >> 32;
      v192 = __PAIR__(v190, v191) != *&pItemParam->field_490;
      *&pItemParam->field_490 = __PAIR__(v190, v191);
      v193 = RedrawColumn(v192, v187, 1622, v18);
      v194 = hWnd[1];
      if ( v193 )
        v194 = 1;
      LOBYTE(SystemProcessInfo) = v194;
    }
    fUsingWS = sub_FF5820(&gMap2, &v275, &pItemParam->dwProcessId);
    v195 = *fUsingWS;
    if ( *fUsingWS == gMap2._Header )
    {
      LOBYTE(fUsingWS) = SystemProcessInfo;
    }
    else
    {
      v196 = (*(v195 + 6) - pItemParam->field_498) >> 32;
      hWnd[1] = (v195[12] - pItemParam->field_498);
      v197 = RedrawColumn(__PAIR__(v196, hWnd[1]) != pItemParam->field_4A8, ghWndTreeListView, 1624, v18);
      v198 = SystemProcessInfo;
      if ( v197 )
        v198 = 1;
      pItemParam->field_4A8 = hWnd[1];
      v199 = v195[15];
      v283 = v198;
      v201 = __PAIR__(v199, v195[14]) - pItemParam->field_4B8;
      v200 = (__PAIR__(v199, v195[14]) - pItemParam->field_4B8) >> 32;
      hWnd[1] = v201;
      v202 = RedrawColumn(__PAIR__(v200, v201) != pItemParam->field_4C8, ghWndTreeListView, 1626, v18);
      v203 = v283;
      if ( v202 )
        v203 = 1;
      pItemParam->field_4C8 = hWnd[1];
      v204 = v195[17];
      v283 = v203;
      v206 = __PAIR__(v204, v195[16]) - pItemParam->field_4D8;
      v205 = (__PAIR__(v204, v195[16]) - pItemParam->field_4D8) >> 32;
      hWnd[1] = v206;
      v207 = RedrawColumn(__PAIR__(v205, v206) != pItemParam->field_4E8, ghWndTreeListView, 1628, v18);
      v208 = v283;
      if ( v207 )
        v208 = 1;
      pItemParam->field_4E8 = hWnd[1];
      v283 = v208;
      v209 = v195[6];
      v20 = v209 < pItemParam->field_4A0;
      v210 = v209 - pItemParam->field_4A0;
      hWnd[1] = ghWndTreeListView;
      v211 = v195[7] - (v20 + pItemParam->field_4A4);
      v212 = v210 != pItemParam->field_4B0 || v211 != pItemParam->field_4B4;
      v213 = hWnd[1];
      pItemParam->field_4B4 = v211;
      pItemParam->field_4B0 = v210;
      v214 = RedrawColumn(v212, v213, IDS_DISK_DELTA_READ_BYTES, v18);
      v215 = v195[8];
      v216 = v283;
      if ( v214 )
        v216 = 1;
      v20 = v215 < pItemParam->field_4C0;
      v217 = v215 - pItemParam->field_4C0;
      hWnd[1] = ghWndTreeListView;
      v218 = v195[9] - (v20 + pItemParam->field_4C4);
      v283 = v216;
      v219 = v217 != pItemParam->field_4D0 || v218 != pItemParam->field_4D4;
      v220 = hWnd[1];
      pItemParam->field_4D4 = v218;
      pItemParam->field_4D0 = v217;
      v221 = RedrawColumn(v219, v220, IDS_DISK_DELTA_WRITE_BYTES, v18);
      v222 = v195[10];
      v223 = v283;
      if ( v221 )
        v223 = 1;
      v20 = v222 < pItemParam->field_4E0;
      v224 = v222 - pItemParam->field_4E0;
      v283 = v223;
      v225 = v195[11] - (v20 + pItemParam->field_4E4);
      hWnd[1] = ghWndTreeListView;
      v226 = v224 != pItemParam->field_4F0 || v225 != pItemParam->field_4F4;
      v227 = hWnd[1];
      pItemParam->field_4F0 = v224;
      pItemParam->field_4F4 = v225;
      v228 = RedrawColumn(v226, v227, IDS_DISK_DELTA_OTHER_BYTES, v18);
      v229 = v283;
      if ( v228 )
        v229 = 1;
      v230 = v195[12];
      hWnd[1] = v229;
      v283 = v230;
      v231 = v230 != pItemParam->field_498 || v195[13];
      v232 = RedrawColumn(v231, ghWndTreeListView, IDS_DISK_READS, v18);
      v233 = LOBYTE(hWnd[1]);
      if ( v232 )
        v233 = 1;
      pItemParam->field_498 = v283;
      v234 = v195[6];
      v284 = v233;
      v235 = v195[7];
      hWnd[1] = ghWndTreeListView;
      v236 = v234 != pItemParam->field_4A0 || v235 != pItemParam->field_4A4;
      v237 = hWnd[1];
      pItemParam->field_4A0 = v234;
      pItemParam->field_4A4 = v235;
      v238 = RedrawColumn(v236, v237, IDS_DISK_READ_BYTES, v18);
      v239 = v284;
      if ( v238 )
        v239 = 1;
      v240 = v195[14];
      hWnd[1] = v239;
      v283 = v240;
      v241 = v240 != pItemParam->field_4B8 || v195[15];
      v242 = RedrawColumn(v241, ghWndTreeListView, IDS_DISK_WRITES, v18);
      v243 = LOBYTE(hWnd[1]);
      if ( v242 )
        v243 = 1;
      pItemParam->field_4B8 = v283;
      v244 = v195[8];
      v284 = v243;
      v245 = v195[9];
      hWnd[1] = ghWndTreeListView;
      v246 = v244 != pItemParam->field_4C0 || v245 != pItemParam->field_4C4;
      v247 = hWnd[1];
      pItemParam->field_4C0 = v244;
      pItemParam->field_4C4 = v245;
      v248 = RedrawColumn(v246, v247, IDS_DISK_WRITE_BYTES, v18);
      v249 = v284;
      if ( v248 )
        v249 = 1;
      v250 = v195[16];
      hWnd[1] = v249;
      v283 = v250;
      v251 = v250 != pItemParam->field_4D8 || v195[17];
      v252 = RedrawColumn(v251, ghWndTreeListView, IDS_DISK_OTHER, v18);
      v253 = LOBYTE(hWnd[1]);
      if ( v252 )
        v253 = 1;
      pItemParam->field_4D8 = v283;
      v254 = v195[10];
      v284 = v253;
      v255 = v195[11];
      hWnd[1] = ghWndTreeListView;
      v256 = v254 != pItemParam->field_4E0 || v255 != pItemParam->field_4E4;
      v257 = hWnd[1];
      pItemParam->field_4E0 = v254;
      pItemParam->field_4E4 = v255;
      v258 = RedrawColumn(v256, v257, IDS_DISK_OTHER_BYTES, v18);
      v259 = ghWndTreeListView;
      v260 = v284;
      if ( v258 )
        v260 = 1;
      v261 = pItemParam->field_4F4;
      hWnd[1] = v260;
      v263 = *&pItemParam->field_4B0 + *&pItemParam->field_4D0 + __PAIR__(v261, pItemParam->field_4F0);
      v262 = v263 >> 32;
      v264 = __PAIR__(v262, v263) != *&pItemParam->field_4F8;
      *&pItemParam->field_4F8 = __PAIR__(v262, v263);
      v17 = RedrawColumn(v264, v259, IDS_DISK_DELTA_TOTAL_BYTES, v18) == 0;
      v265 = hWnd[1];
      fUsingWS = 1;
      if ( !v17 )
        v265 = 1;
      LOBYTE(fUsingWS) = v265;
    }
  }
  return fUsingWS;
}
// 1064E54: using guessed type int gdwVersion;
// FEDF20: using guessed type unsigned __int64 ProcessorIdleCycleTime[256];

//----- (00FEF7C0) --------------------------------------------------------
int __thiscall TreeList_Item1::Reset(TreeList_Item1 *this)
{
  int result; // eax

  this->field_C = this->field_0;
  this->field_30 = this->field_18;
  this->field_34 = this->field_1C;
  this->field_10 = this->field_4;
  this->field_38 = this->field_20;
  this->field_3C = this->field_24;
  this->field_14 = this->field_8;
  this->field_40 = this->field_28;
  result = this->field_2C;
  this->field_44 = result;
  this->field_0 = 0;
  this->field_4 = 0;
  this->field_8 = 0;
  this->field_18 = 0;
  this->field_1C = 0;
  this->field_20 = 0;
  this->field_24 = 0;
  this->field_28 = 0;
  this->field_2C = 0;
  this->field_48 = 0;
  this->field_4C = 0;
  this->field_50 = 0;
  this->field_54 = 0;
  *&this->field_58 = 0;
  *(&this->field_59 + 3) = 0;
  this->field_60 = 0;
  return result;
}

//----- (00FEF870) --------------------------------------------------------
char __usercall sub_FEF870@<al>(int a1@<ebx>, int a2, int a3, int a4, DWORD dwProcessId, int a6, int a7, int a8)
{
  HANDLE v8; // edi
  SIZE_T (__stdcall *v9)(HANDLE, LPCVOID, PMEMORY_BASIC_INFORMATION, SIZE_T); // esi
  SIZE_T v10; // ebx
  unsigned int v11; // kr00_4
  size_t v12; // eax
  unsigned int v13; // ebx
  WCHAR *v14; // edi
  unsigned int v15; // kr04_4
  char *v16; // eax
  DLLLISTITEMPARAM *v17; // esi
  char v18; // al
  signed int v19; // ecx
  HANDLE v20; // esi
  PIMAGE_NT_HEADERS v21; // ecx
  WORD v22; // ax
  PIMAGE_NT_HEADERS v23; // eax
  PVOID v24; // eax
  char v26; // [esp-188h] [ebp-1774h]
  wchar_t *v27; // [esp-10h] [ebp-15FCh]
  LPCWSTR v28; // [esp-Ch] [ebp-15F8h]
  WCHAR *v29; // [esp-8h] [ebp-15F4h]
  WCHAR *v30; // [esp-4h] [ebp-15F0h]
  struct _FILETIME CreationTime; // [esp+Ch] [ebp-15E0h]
  struct _FILETIME LastAccessTime; // [esp+14h] [ebp-15D8h]
  struct _MEMORY_BASIC_INFORMATION v33; // [esp+1Ch] [ebp-15D0h]
  SIZE_T NumberOfBytesRead; // [esp+38h] [ebp-15B4h]
  struct _FILETIME LocalFileTime; // [esp+3Ch] [ebp-15B0h]
  int v36; // [esp+44h] [ebp-15A8h]
  wchar_t *v37; // [esp+48h] [ebp-15A4h]
  _DWORD *v38; // [esp+4Ch] [ebp-15A0h]
  struct _FILETIME LastWriteTime; // [esp+50h] [ebp-159Ch]
  DWORD v40; // [esp+58h] [ebp-1594h]
  HWND hWnd; // [esp+5Ch] [ebp-1590h]
  int *v42; // [esp+60h] [ebp-158Ch]
  SIZE_T v43; // [esp+64h] [ebp-1588h]
  HANDLE v44; // [esp+68h] [ebp-1584h]
  struct _MEMORY_BASIC_INFORMATION Buffer; // [esp+6Ch] [ebp-1580h]
  int v46; // [esp+88h] [ebp-1564h]
  char v47; // [esp+8Fh] [ebp-155Dh]
  char v48; // [esp+90h] [ebp-155Ch]
  int v49; // [esp+A0h] [ebp-154Ch]
  wchar_t *v50; // [esp+B4h] [ebp-1538h]
  wchar_t v51; // [esp+B8h] [ebp-1534h]
  DWORD v52; // [esp+138h] [ebp-14B4h]
  PVOID v53; // [esp+13Ch] [ebp-14B0h]
  int v54; // [esp+140h] [ebp-14ACh]
  wchar_t *v55; // [esp+144h] [ebp-14A8h]
  char v56; // [esp+148h] [ebp-14A4h]
  int v57; // [esp+158h] [ebp-1494h]
  int v58; // [esp+15Ch] [ebp-1490h]
  char v59; // [esp+160h] [ebp-148Ch]
  PVOID v60; // [esp+16Ch] [ebp-1480h]
  int v61; // [esp+174h] [ebp-1478h]
  DWORD v62; // [esp+178h] [ebp-1474h]
  char hObject; // [esp+17Ch] [ebp-1470h]
  char BaseAddress; // [esp+17Eh] [ebp-146Eh]
  SIZE_T v65; // [esp+180h] [ebp-146Ch]
  __int16 v66; // [esp+184h] [ebp-1468h]
  struct _FILETIME v67; // [esp+188h] [ebp-1464h]
  int v68; // [esp+190h] [ebp-145Ch]
  wchar_t v69; // [esp+194h] [ebp-1458h]
  wchar_t Dst; // [esp+216h] [ebp-13D6h]
  DWORD dwLen; // [esp+298h] [ebp-1354h]
  int v72; // [esp+29Ch] [ebp-1350h]
  LPCWSTR lpFileName; // [esp+2A0h] [ebp-134Ch]
  wchar_t *v74; // [esp+2A4h] [ebp-1348h]
  struct _SYSTEMTIME SystemTime; // [esp+2D0h] [ebp-131Ch]
  __int16 Base; // [esp+2E0h] [ebp-130Ch]
  WCHAR DateStr; // [esp+12E0h] [ebp-30Ch]
  WCHAR TimeStr; // [esp+1360h] [ebp-28Ch]
  WCHAR FileName; // [esp+13E0h] [ebp-20Ch]

  hWnd = a2;
  LOBYTE(a1) = 0;
  v36 = a4;
  v42 = a6;
  v37 = a7;
  v40 = dwProcessId;
  v38 = a8;
  v46 = a1;
  v8 = OpenProcess(0x410u, 0, dwProcessId);
  v44 = v8;
  if ( !v8 )
    return a1;
  v9 = VirtualQueryEx;
  Buffer.BaseAddress = 0;
  if ( !VirtualQueryEx(v8, 0, &Buffer, 0x1Cu) )
    goto LABEL_68;
  while ( !a3 || *a3 != 1 )
  {
    v10 = Buffer.RegionSize;
    v47 = 0;
    v43 = Buffer.RegionSize;
    v33.BaseAddress = Buffer.BaseAddress + Buffer.RegionSize;
    if ( v9(v8, Buffer.BaseAddress + Buffer.RegionSize, &v33, 0x1Cu) )
    {
      do
      {
        if ( v33.AllocationBase != Buffer.AllocationBase )
          break;
        v33.BaseAddress = v33.BaseAddress + v33.RegionSize;
        v10 = v33.BaseAddress - Buffer.AllocationBase;
      }
      while ( v9(v8, v33.BaseAddress, &v33, 0x1Cu) );
      v43 = v10;
    }
    if ( Buffer.Type != 0x40000 && Buffer.Type != 0x1000000 )
      goto LABEL_63;
    FileName = 0;
    if ( GetMappedFileNameW(v8, Buffer.BaseAddress, &FileName, 0x104u) )
    {
      sub_FE0DD0(&FileName);
    }
    else
    {
      if ( !gConfig.bShowUnnamedHandles )
        goto LABEL_64;
      v47 = 1;
      wcscpy_s(&FileName, 0x104u, L"<Pagefile Backed>");
    }
    if ( !a3 )
    {
      v17 = gpDllListItemParamHeader;
      if ( gpDllListItemParamHeader )
      {
        while ( 1 )
        {
          if ( v17->m_LoadAddress == Buffer.BaseAddress && v17->m_MappedSize == v10 )
          {
            v30 = &FileName;
            v29 = v17->m_strPath.pszData;
            if ( !_wcsicmp(v29, &FileName) )
              break;
          }
          v17 = v17->m_Prev;
          if ( !v17 )
            goto LABEL_33;
        }
        v30 = v17;
        ++*v38;
        v18 = sub_FF8A20(v30);
        v19 = v46;
        if ( v18 )
          v19 = 1;
        Buffer.BaseAddress = Buffer.BaseAddress + v10;
        v46 = v19;
        sub_FDC400(v42, v17);
        v16 = Buffer.BaseAddress;
        v9 = VirtualQueryEx;
        goto LABEL_66;
      }
LABEL_33:
      memset(&v56, 0, 0x188u);
      if ( v47 )
        v61 |= 8u;
      lpFileName = _wcsdup(&FileName);
      wcscpy_s(&Dst, 0x41u, &gszNullString);
      v10 = v43;
      v60 = Buffer.BaseAddress;
      hObject = Buffer.Type == 0x1000000;
      v65 = v43;
      v66 = 1;
      v62 = 0;
      dwLen = 0;
      v72 = 0;
      sub_FC43C0(&FileName, &Dst, 0x41u, &dwLen, &v72);
      if ( Buffer.Type == 0x40000 )
        v61 |= 2u;
      wcscpy_s(&v69, 0x41u, &gszNullString);
      v67 = 0i64;
      v20 = CreateFileW(&FileName, 0x80000000, 7u, 0, 3u, 0, 0);
      if ( v20 != -1 )
      {
        GetFileTime(v20, &CreationTime, &LastAccessTime, &LastWriteTime);
        CloseHandle(v20);
        v67 = LastWriteTime;
        FileTimeToLocalFileTime(&LastWriteTime, &LocalFileTime);
        FileTimeToSystemTime(&LocalFileTime, &SystemTime);
        GetDateFormatW(0x400u, 1u, &SystemTime, 0, &DateStr, 64);
        GetTimeFormatW(0x400u, 2u, &SystemTime, 0, &TimeStr, 64);
        v30 = &TimeStr;
        v29 = &DateStr;
        sub_FD9DE0(&v69, L"%s %s", &DateStr, &TimeStr);
      }
      if ( a3 )
      {
        v54 = 0;
        v50 = _wcsdup(v37);
        v55 = _wcsdup(&FileName);
        v52 = v40;
        v53 = Buffer.BaseAddress;
        v49 = 0;
        wcscpy_s(&v51, 0x40u, L"DLL");
        sub_FB78D0(hWnd, &v48);
LABEL_62:
        v9 = VirtualQueryEx;
LABEL_63:
        v8 = v44;
LABEL_64:
        v16 = Buffer.BaseAddress + v10;
        goto LABEL_65;
      }
      v62 = 0;
      if ( *ImageNtHeader )
      {
        if ( !(v61 & 2) )
        {
          if ( ReadProcessMemory(v8, Buffer.AllocationBase, &Base, 0x1000u, &NumberOfBytesRead) )
          {
            if ( Base == 23117 )
            {
              v21 = ImageNtHeader(&Base);
              if ( v21 )
              {
                if ( v21->FileHeader.Characteristics & 0x100
                  && (v22 = v21->FileHeader.Machine, v22 != -31132)
                  && v22 != 512 )
                {
                  hObject = 1;
                  v23 = ImageNtHeader(&Base);
                  if ( v23 )
                  {
                    v62 = v23->OptionalHeader.ImageBase;
                    v24 = v23->OptionalHeader.ImageBase;
                    goto LABEL_52;
                  }
                }
                else
                {
                  hObject = 2;
                  v62 = v21->OptionalHeader.ImageBase;
                  v24 = v21->OptionalHeader.ImageBase;
LABEL_52:
                  if ( v24 != Buffer.AllocationBase && Buffer.Type == 0x1000000 )
                    v61 |= 1u;
                }
              }
            }
          }
        }
      }
      sub_FDC400(v42, &v56);
      v28 = lpFileName;
      v58 = 0;
      v27 = *(v36 + 88);
      v74 = sub_FABB70(v27, lpFileName);
      if ( gdwValue_4F10B8[1] == v40 )
      {
        v57 = 2;
      }
      else
      {
        v59 = 0;
        v57 = 0;
      }
      if ( Buffer.Type == 0x1000000 && sub_FCE970(lpFileName, &v68, &hObject, &BaseAddress) )
        v61 |= 4u;
      qmemcpy(&v26, &v56, 0x188u);
      sub_FB7790(hWnd, v26);
      LOBYTE(v46) = 1;
      goto LABEL_62;
    }
    v11 = wcslen(&FileName);
    v12 = wcslen(gszStringToFindLast);
    if ( v11 >= v12 )
    {
      v13 = 0;
      if ( v11 - v12 != -1 )
      {
        v14 = &FileName;
        while ( _wcsnicmp(v14, gszStringToFindLast, v12) )
        {
          ++v13;
          ++v14;
          v15 = wcslen(&FileName);
          v12 = wcslen(gszStringToFindLast);
          if ( v13 >= v15 - v12 + 1 )
          {
            v8 = v44;
            goto LABEL_22;
          }
        }
        v8 = v44;
        goto LABEL_33;
      }
    }
LABEL_22:
    v16 = Buffer.BaseAddress + v43;
    v9 = VirtualQueryEx;
LABEL_65:
    Buffer.BaseAddress = v16;
LABEL_66:
    if ( !v9(v8, v16, &Buffer, 0x1Cu) )
      break;
  }
  LOBYTE(a1) = v46;
LABEL_68:
  CloseHandle(v8);
  return a1;
}
// 10610B8: using guessed type int gdwValue_4F10B8[3];

//----- (00FEFFD0) --------------------------------------------------------
BOOL __stdcall DlgServiceControl(HWND hWnd, UINT a2, WPARAM a3, LPARAM a4)
{
  HANDLE v4; // edi
  __int16 v5; // cx
  void (__stdcall *v6)(HWND, UINT, WPARAM, LPARAM); // edi
  HWND v7; // eax
  HWND v8; // eax
  HANDLE v9; // eax
  bool v10; // zf
  HANDLE v11; // eax
  HWND v12; // eax
  HANDLE v13; // eax
  HWND v15; // eax
  HWND v16; // eax
  SC_HANDLE v17; // eax
  DWORD v18; // esi
  struct _QUERY_SERVICE_CONFIGW *v19; // ebx
  DWORD v20; // ST0C_4
  SC_HANDLE v21; // esi
  HANDLE v22; // ebx
  HANDLE v23; // eax
  DWORD pcbBytesNeeded; // [esp+14h] [ebp-2Ch]
  HANDLE hData; // [esp+18h] [ebp-28h]
  SC_HANDLE hService; // [esp+1Ch] [ebp-24h]
  struct _SERVICE_STATUS ServiceStatus; // [esp+20h] [ebp-20h]

  if ( a2 != 272 )
  {
    if ( a2 == 273 )
    {
      if ( a3 == 1 )
      {
        v13 = GetPropW(hWnd, L"hService");
        CloseServiceHandle(v13);
        EndDialog(hWnd, 0);
      }
    }
    else if ( a2 == 275 )
    {
      v4 = GetPropW(hWnd, L"hService");
      if ( !v4 )
        goto LABEL_9;
      QueryServiceStatus(v4, &ServiceStatus);
      v5 = GetPropW(hWnd, L"Command");
      switch ( v5 )
      {
        case 0x4BA:
        case 0x4BF:
          if ( ServiceStatus.dwCurrentState != 1 )
            goto LABEL_9;
          if ( v5 != 1215 )
            goto LABEL_16;
          SetPropW(hWnd, L"Command", 0x4BD);
          StartServiceW(v4, 0, 0);
          goto LABEL_9;
        case 0x4BB:
        case 0x4BD:
          v10 = ServiceStatus.dwCurrentState == 4;
          break;
        case 0x4BC:
          v10 = ServiceStatus.dwCurrentState == 7;
          break;
        default:
          goto LABEL_9;
      }
      if ( v10 )
      {
LABEL_16:
        v11 = GetPropW(hWnd, L"hService");
        CloseServiceHandle(v11);
        SetPropW(hWnd, L"hService", 0);
        v12 = GetDlgItem(hWnd, 1316);
        v6 = SendMessageW;
        SendMessageW(v12, 0x402u, 0x26u, 0);
      }
      else
      {
LABEL_9:
        v6 = SendMessageW;
      }
      v7 = GetDlgItem(hWnd, 1316);
      v6(v7, 0x405u, 0, 0);
      v8 = GetDlgItem(hWnd, 1316);
      if ( (v6)(v8, 0x408u, 0, 0) == 40 )
      {
        if ( GetPropW(hWnd, L"hService") )
        {
          v9 = GetPropW(hWnd, L"hService");
          CloseServiceHandle(v9);
          EndDialog(hWnd, 1);
        }
        else
        {
          EndDialog(hWnd, 2);
        }
      }
      return 1;
    }
    return 0;
  }
  hData = *(a4 + 8);
  switch ( hData )
  {
    case 0x4BAu:
      SetDlgItemTextW(hWnd, 1314, L"Process Explorer is attempting to stop the following service...");
      hService = 32;
      break;
    case 0x4BBu:
      SetDlgItemTextW(hWnd, 1314, L"Process Explorer is attempting to resume the following service...");
      hService = 64;
      break;
    case 0x4BCu:
      SetDlgItemTextW(hWnd, 1314, L"Process Explorer is attempting to pause the following service...");
      hService = 64;
      break;
    case 0x4BDu:
      SetDlgItemTextW(hWnd, 1314, L"Process Explorer is attempting to start the following service...");
      hService = 16;
      break;
    case 0x4BFu:
      SetDlgItemTextW(hWnd, 1314, L"Process Explorer is attempting to restart the following service...");
      hService = 48;
      break;
    default:
      hService = hData;
      break;
  }
  v15 = GetDlgItem(hWnd, 1316);
  SendMessageW(v15, 0x401u, 0, 2621440);
  v16 = GetDlgItem(hWnd, 1316);
  SendMessageW(v16, 0x404u, 1u, 0);
  v17 = OpenServiceW(ghSCManagerHandle, *(a4 + 20), hService | 5);
  hService = v17;
  if ( !v17 )
  {
    ReportMsg(L"Error opening service for control", ghMainWnd);
    EndDialog(hWnd, 0);
    return 0;
  }
  QueryServiceConfigW(v17, 0, 0, &pcbBytesNeeded);
  v18 = pcbBytesNeeded;
  v19 = malloc(pcbBytesNeeded);
  v20 = v18;
  v21 = hService;
  QueryServiceConfigW(hService, v19, v20, &pcbBytesNeeded);
  SetDlgItemTextW(hWnd, 1315, v19->lpDisplayName);
  free(v19);
  v22 = hData;
  switch ( hData )
  {
    case 0x4BAu:
    case 0x4BFu:
      v23 = ControlService(v21, 1u, &ServiceStatus);
      break;
    case 0x4BBu:
      v23 = ControlService(v21, 3u, &ServiceStatus);
      break;
    case 0x4BCu:
      v23 = ControlService(v21, 2u, &ServiceStatus);
      break;
    case 0x4BDu:
      v23 = StartServiceW(v21, 0, 0);
      break;
    default:
      v23 = hData;
      break;
  }
  if ( !v23 )
  {
    ReportMsg(L"Error sending control to service", ghMainWnd);
    EndDialog(hWnd, 0);
    CloseServiceHandle(v21);
    return 0;
  }
  SetPropW(hWnd, L"command", v22);
  SetPropW(hWnd, L"hService", hService);
  SetTimer(hWnd, 1u, 0x1F4u, 0);
  QueryServiceNames();
  return 1;
}
// 1045560: using guessed type wchar_t aErrorOpeningSe_0[34];
// 10455A8: using guessed type wchar_t aErrorSendingCo[33];

//----- (00FF0400) --------------------------------------------------------
BOOL __cdecl sub_FF0400(HWND hDlg, int nIDDlgItem, int ArgList, int a4)
{
  WCHAR String; // [esp+4h] [ebp-68h]

  sub_FD9DA0(&String, L"%I64d", ArgList, a4);
  sub_FC3290(&String, 0x32u);
  return SetDlgItemTextW(hDlg, nIDDlgItem, &String);
}

//----- (00FF0460) --------------------------------------------------------
BOOL __cdecl sub_FF0460(HWND hDlg, int nIDDlgItem, int a3, int a4)
{
  WCHAR String; // [esp+4h] [ebp-68h]

  sub_FD9DA0(&String, L"%I64d", __PAIR__(a4, a3) / 1024);
  sub_FC3290(&String, 0x32u);
  wcscat_s(&String, 0x32u, L" KB");
  return SetDlgItemTextW(hDlg, nIDDlgItem, &String);
}

//----- (00FF04E0) --------------------------------------------------------
BOOL (__stdcall *__thiscall sub_FF04E0(CResizer *this, int a2, int a3))(HWND hWnd, LPRECT lpRect)
{
  int v4; // [esp+0h] [ebp-8h]
  int v5; // [esp+4h] [ebp-4h]

  v4 = a2;
  v5 = a3;
  return sub_FF0550(this, 2, &v4);
}

//----- (00FF0510) --------------------------------------------------------
BOOL (__stdcall *__thiscall sub_FF0510(CResizer *this, int a2, int a3, int a4))(HWND hWnd, LPRECT lpRect)
{
  int v5; // [esp+4h] [ebp-10h]
  int v6; // [esp+8h] [ebp-Ch]
  int v7; // [esp+Ch] [ebp-8h]

  v5 = a2;
  v6 = a3;
  v7 = a4;
  return sub_FF0550(this, 3, &v5);
}

//----- (00FF0550) --------------------------------------------------------
BOOL (__stdcall *__thiscall sub_FF0550(CResizer *this, int a2, int a3))(HWND hWnd, LPRECT lpRect)
{
  BOOL (__stdcall *result)(HWND, LPRECT); // eax
  int v4; // esi
  int j; // esi
  struct tagResizerItem *v6; // eax
  double v7; // [esp+0h] [ebp-40h]
  CResizer *v8; // [esp+8h] [ebp-38h]
  double i; // [esp+Ch] [ebp-34h]
  double v10; // [esp+14h] [ebp-2Ch]
  struct tagRECT v11; // [esp+1Ch] [ebp-24h]
  struct tagRECT Rect; // [esp+2Ch] [ebp-14h]

  result = GetWindowRect;
  v4 = 0;
  v8 = this;
  v10 = 0.0;
  for ( i = 0.0; v4 < a2; i = (Rect.bottom - Rect.top) + i )
  {
    result(*(a3 + 4 * v4++), &Rect);
    result = GetWindowRect;
  }
  for ( j = 0; j < a2; v10 = *&Rect.right )
  {
    result(*(a3 + 4 * j), &v11);
    *&Rect.right = (v11.bottom - v11.top) / i + v10;
    v7 = (v11.bottom - v11.top) / i + v10;
    if ( *&Rect.right >= 0.99999 )
      v7 = db_one;
    v6 = CResizer::AddItem(v8, *(a3 + 4 * j++), 1);
    *&v6->m_rect2.left = v10;
    *&v6->m_rect2.right = v7;
    result = GetWindowRect;
  }
  return result;
}

//----- (00FF0640) --------------------------------------------------------
BOOL __stdcall sub_FF0640(int a1, int a2, DWORD BytesReturned, LPVOID lpOutBuffer, DWORD nOutBufferSize, int a6)
{
  BOOL result; // eax
  DWORD v7; // esi
  int InBuffer; // [esp+0h] [ebp-8h]
  int v9; // [esp+4h] [ebp-4h]

  if ( a2 >= gSystemInfo.lpMaximumApplicationAddress )
  {
    v7 = nOutBufferSize;
    InBuffer = dword_106AB88;
    v9 = a2;
    result = DeviceIoControl(ghDriverHandle, 0x83350024, &InBuffer, 8u, lpOutBuffer, nOutBufferSize, &BytesReturned, 0);
    if ( result )
    {
      *a6 = v7;
      result = 1;
    }
    else
    {
      *a6 = 0;
    }
  }
  else
  {
    result = 1;
    *a6 = 0;
  }
  return result;
}
// 106AB88: using guessed type int dword_106AB88;

//----- (00FF06C0) --------------------------------------------------------
DWORD __cdecl sub_FF06C0(char a1, int a2, int a3)
{
  int v3; // esi
  HANDLE v4; // ebx
  DWORD result; // eax
  int v6; // esi
  int v7; // ecx
  int v8; // edi
  int v9; // ebx
  _DWORD *v10; // eax
  int v11; // edx
  _DWORD *v12; // ecx
  int v13; // esi
  _DWORD *v14; // edi
  _DWORD *v15; // ebx
  void **v16; // esi
  void *v17; // ecx
  ULONG *v18; // esi
  struct _OBJECT_ATTRIBUTES ObjectAttributes; // [esp+8h] [ebp-3Ch]
  struct _CLIENT_ID ClientId; // [esp+20h] [ebp-24h]
  HANDLE v21; // [esp+28h] [ebp-1Ch]
  HANDLE hObject; // [esp+2Ch] [ebp-18h]
  int v23; // [esp+30h] [ebp-14h]
  int v24; // [esp+34h] [ebp-10h]
  int v25; // [esp+38h] [ebp-Ch]
  void **v26; // [esp+3Ch] [ebp-8h]
  char v27; // [esp+43h] [ebp-1h]

  v3 = a2;
  v27 = 0;
  v4 = OpenProcess(0x800u, 0, *(a2 + 68));
  v21 = v4;
  if ( !v4 )
    return GetLastError();
  if ( NtSuspendProcess )
  {
    if ( a1 )
      v6 = NtSuspendProcess(v4);
    else
      v6 = NtResumeProcess(v4);
    CloseHandle(v4);
    return v6;
  }
  if ( GetVersion() <= 4u )
  {
    v27 = 1;
    v7 = a2 + 136;
  }
  else
  {
    v7 = a2 + 184;
  }
  v8 = *(a2 + 4);
  v9 = 0;
  v25 = 0;
  if ( v8 )
  {
    v10 = (v7 + 56);
    v11 = v8;
    v12 = (v7 + 52);
    do
    {
      if ( *v12 == 5 && *v10 == 5 )
        ++v9;
      v12 += 16;
      v10 += 16;
      --v11;
    }
    while ( v11 );
    v25 = v9;
  }
  if ( a1 )
  {
    if ( v8 == v9 )
      goto LABEL_43;
  }
  else if ( v8 != v9 )
  {
    goto LABEL_43;
  }
  if ( v27 )
    v13 = a2 + 136;
  else
    v13 = a2 + 184;
  v23 = 0;
  if ( v8 )
  {
    v14 = (v13 + 56);
    v15 = (v13 + 52);
    v16 = (v13 + 36);
    v26 = v16;
    while ( 1 )
    {
      ClientId.UniqueThread = *v16;
      ClientId.UniqueProcess = 0;
      ObjectAttributes.Length = 24;
      ObjectAttributes.RootDirectory = 0;
      ObjectAttributes.Attributes = 0;
      ObjectAttributes.ObjectName = 0;
      ObjectAttributes.SecurityDescriptor = 0;
      ObjectAttributes.SecurityQualityOfService = 0;
      if ( !NtOpenThread(&hObject, 2u, &ObjectAttributes, &ClientId) )
        break;
LABEL_40:
      v16 += 16;
      v15 += 16;
      v26 = v16;
      v14 += 16;
      if ( ++v23 >= *(a2 + 4) )
      {
        v9 = v25;
        v3 = a2;
        goto LABEL_43;
      }
    }
    v18 = hObject;
    if ( !hObject )
    {
LABEL_39:
      v16 = v26;
      goto LABEL_40;
    }
    if ( a1 )
    {
      if ( a3 && (a3 != 1 || *v15 == 5 && *v14 == 5) )
        goto LABEL_38;
      NtSuspendThread(v17, hObject);
      if ( *v14 == 5 || !v24 )
        goto LABEL_38;
      ++v25;
    }
    NtResumeThread(v17, v18);
LABEL_38:
    CloseHandle(v18);
    goto LABEL_39;
  }
  v3 = a2;
LABEL_43:
  CloseHandle(v21);
  if ( a1 && *(v3 + 4) == v9 )
    result = 1904;
  else
    result = 0;
  return result;
}

//----- (00FF08B0) --------------------------------------------------------
DWORD64 __stdcall SymLoadModuleExW_0(HANDLE hProcess, HANDLE hFile, PCWSTR ImageName, PCWSTR ModuleName, DWORD64 BaseOfDll, DWORD DllSize, PMODLOAD_DATA Data, DWORD Flags)
{
  return SymLoadModuleExW(hProcess, hFile, ImageName, ModuleName, BaseOfDll, DllSize, 0, 0);
}

//----- (00FF08E0) --------------------------------------------------------
int __stdcall sub_FF08E0(int hProcess, int hFile, LPCWSTR a3, LPCWSTR lpWideCharStr, int BaseOfDll, int BaseOfDll_4, int SizeOfDll)
{
  int *v7; // esi
  int *v8; // eax
  int v9; // ebx
  int v10; // edx
  int v11; // edx
  int v13; // [esp+10h] [ebp-14h]
  int v14; // [esp+14h] [ebp-10h]
  int v15; // [esp+20h] [ebp-4h]

  v7 = sub_FD9E00(&v13, lpWideCharStr);
  v15 = 0;
  v8 = sub_FD9E00(&v14, a3);
  LOBYTE(v15) = 1;
  v9 = SymLoadModule64(hProcess, hFile, *v8, *v7, __PAIR__(BaseOfDll_4, BaseOfDll), SizeOfDll);
  v10 = v14 - 16;
  LOBYTE(v15) = 0;
  if ( _InterlockedDecrement((v14 - 16 + 12)) <= 0 )
    (*(**v10 + 4))(v10);
  v11 = v13 - 16;
  v15 = -1;
  if ( _InterlockedDecrement((v13 - 16 + 12)) <= 0 )
    (*(**v11 + 4))(v11);
  return v9;
}

//----- (00FF09B0) --------------------------------------------------------
int __stdcall PropSystemInfoSumETW(HWND hWnd, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
  int v4; // esi
  HWND hWnd_1; // edi
  LONG v6; // eax
  void *v7; // eax
  DWORD v8; // edx
  LOGICAL_PROCESSOR_RELATIONSHIP *v9; // eax
  CResizer *v10; // edi
  HWND v11; // eax
  DWORD v12; // ecx
  signed int v13; // esi
  int v14; // ecx
  HWND v15; // eax
  void *v16; // ecx
  int v17; // esi
  int v18; // eax
  HMENU v19; // esi
  int v20; // edi
  char v21; // al
  int v22; // ecx
  const WCHAR *v23; // eax
  const WCHAR *v24; // eax
  CResizer *v25; // eax
  CResizer *pResizer; // esi
  HWND v27; // eax
  struct tagResizerItem *v28; // eax
  HWND v29; // eax
  struct tagResizerItem *v30; // eax
  double v31; // xmm1_8
  void (__stdcall *SendMessageW)(HWND, UINT, WPARAM, LPARAM); // esi
  int v33; // esi
  HWND v34; // eax
  struct tagResizerItem *v35; // eax
  HWND v36; // eax
  double v37; // xmm0_8
  double *v38; // eax
  HWND v39; // eax
  int result; // eax
  signed int nCount; // esi
  SYSTEM_PROCESS_INFORMATION *pSystemProcessInfo_1; // eax
  ULONG HandleCount; // edx
  ULONG v44; // ecx
  CResizer *v45; // edi
  const WCHAR *v46; // eax
  const WCHAR *v47; // eax
  const WCHAR *v48; // eax
  DWORD v49; // esi
  DWORD v50; // eax
  __m128i v51; // xmm6
  __m128i v52; // xmm7
  int v53; // eax
  __m128i v54; // xmm5
  __m128i v55; // xmm4
  int v56; // ecx
  __m128i v57; // xmm2
  __m128i v58; // xmm4
  __m128i v59; // xmm5
  __m128i v60; // xmm4
  __m128i v61; // xmm5
  SYSTEM_PROCESS_INFORMATION *v62; // ecx
  int v63; // edx
  SYSTEM_PROCESS_INFORMATION *v64; // edi
  int v65; // ecx
  _DWORD *v66; // eax
  DWORD v67; // edx
  int v68; // esi
  int v69; // ST58_4
  int v70; // esi
  char *v71; // esi
  int v72; // esi
  int v73; // eax
  HWND v74; // esi
  HWND v75; // eax
  HWND v76; // eax
  HWND v77; // eax
  HWND v78; // eax
  HWND v79; // eax
  HWND v80; // eax
  signed int v81; // edi
  HWND v82; // eax
  signed int v83; // eax
  int v84; // ST2C_4
  HWND v85; // eax
  signed int i; // esi
  signed int v87; // eax
  int v88; // ST2C_4
  HWND v89; // eax
  double v90; // [esp+Ch] [ebp-3B4h]
  int nHeight; // [esp+10h] [ebp-3B0h]
  double v92; // [esp+14h] [ebp-3ACh]
  int v93; // [esp+18h] [ebp-3A8h]
  signed int v94; // [esp+20h] [ebp-3A0h]
  double v95; // [esp+24h] [ebp-39Ch]
  int v96; // [esp+28h] [ebp-398h]
  int v97; // [esp+2Ch] [ebp-394h]
  ULONG ReturnLength; // [esp+30h] [ebp-390h]
  double v99; // [esp+34h] [ebp-38Ch]
  void *v100[2]; // [esp+3Ch] [ebp-384h]
  double v101; // [esp+44h] [ebp-37Ch]
  HWND hWnd_2; // [esp+4Ch] [ebp-374h]
  int v103; // [esp+50h] [ebp-370h]
  int v104; // [esp+54h] [ebp-36Ch]
  SYSTEM_PROCESS_INFORMATION *pSystemProcessInfo; // [esp+58h] [ebp-368h]
  CResizer *NumberOfThreads; // [esp+5Ch] [ebp-364h]
  int SystemInformation[74]; // [esp+60h] [ebp-360h]
  int v108; // [esp+188h] [ebp-238h]
  struct tagRECT Rect; // [esp+198h] [ebp-228h]
  WCHAR szText[260]; // [esp+1A8h] [ebp-218h]
  int v111; // [esp+3BCh] [ebp-4h]

  v4 = 0;
  hWnd_1 = hWnd;
  hWnd_2 = hWnd;
  HIDWORD(v99) = 0;
  NumberOfThreads = 0;
  if ( uMsg <= WM_CTLCOLOREDIT )
  {
    if ( uMsg != WM_CTLCOLOREDIT )
    {
      switch ( uMsg )
      {
        case 0x24u:
          *(lParam + 8) = 2 * gdwVirtualScreenWidth;
          result = 0;
          break;
        case WM_INITDIALOG:
          v6 = GetWindowLongW(hWnd, -16);
          SetWindowLongW(hWnd, -16, v6 | 0x2000000);
          HIDWORD(gSystenPerformanceInfoInProcSecurity.CcDirtyPageThreshold) = malloc(48 * gSystemInfo.dwNumberOfProcessors);
          v7 = malloc(24 * gSystemInfo.dwNumberOfProcessors);
          v8 = gdwLogicalProcessorInfoItemCount;
          LODWORD(gSystenPerformanceInfoInProcSecurity.CcTotalDirtyPages) = v7;
          if ( gdwLogicalProcessorInfoItemCount > 0 )
          {
            v9 = &gpLogicalProcessorInfo->Relationship;
            v10 = 0;
            do
            {
              if ( *v9 )
              {
                if ( *v9 == 3 )
                  v10 = (v10 + 1);
              }
              else
              {
                ++v4;
              }
              v9 += 6;
              --v8;
            }
            while ( v8 );
            NumberOfThreads = v10;
            hWnd_1 = hWnd_2;
            HIDWORD(v99) = v4;
          }
          if ( gSystemInfo.dwNumberOfProcessors <= 1 )
          {
            v22 = 0;
            v103 = v100[1];
            NumberOfThreads = 0;
            pSystemProcessInfo = v100[1];
          }
          else
          {
            v11 = GetDlgItem(hWnd_1, 2000);
            GetWindowRect(v11, &Rect);
            v12 = gSystemInfo.dwNumberOfProcessors;
            if ( gSystemInfo.dwNumberOfProcessors > 8 )
              v12 = 8 * (gSystemInfo.dwNumberOfProcessors / 8 > 16) + 8;
            pSystemProcessInfo = ((v12 + gSystemInfo.dwNumberOfProcessors - 1) / v12);
            v13 = 4;
            v14 = (v12 * pSystemProcessInfo - gSystemInfo.dwNumberOfProcessors) / -2 + v12;
            v103 = v14;
            if ( gSystemInfo.dwNumberOfProcessors > 0x10 )
              v13 = 3;
            v94 = v13;
            if ( gSystemInfo.dwNumberOfProcessors > 0x20 )
              v94 = --v13;
            v97 = (Rect.right - v13 * (v14 - 1) - Rect.left) / v103;
            nHeight = (Rect.bottom - v13 * (&pSystemProcessInfo[-1].OtherTransferCount.QuadPart + 7) - Rect.top)
                    / pSystemProcessInfo;
            v15 = GetDlgItem(hWnd_1, 2000);
            GetWindowRect(v15, &Rect);
            MapWindowPoints(0, hWnd_1, &Rect, 2u);
            v16 = Rect.left;
            v100[1] = Rect.left;
            v104 = 0;
            if ( gSystemInfo.dwNumberOfProcessors > 0 )
            {
              v17 = 1;
              HIDWORD(v101) = 1;
              do
              {
                v93 = 0;
                v96 = v17 % v103;
                if ( !(v17 % v103) )
                  v93 = Rect.right - v16 - v97;
                v18 = sub_FC3F20(gpLogicalProcessorInfo, gdwLogicalProcessorInfoItemCount, v17 - 1);
                v19 = (v17 + 2000);
                v20 = v18;
                CreateWindowExW(
                  0,
                  L"Static",
                  0,
                  0x40000000u,
                  Rect.left,
                  Rect.top,
                  v93 + v97,
                  nHeight,
                  hWnd_2,
                  v19,
                  ghInstance,
                  0);
                CreateGraphWindow(hWnd_2, v19, gppGraphInfo[v20]);
                Rect.left += v97;
                v21 = sub_FC3F20(gpLogicalProcessorInfo, gdwLogicalProcessorInfoItemCount, SHIDWORD(v101));
                if ( sub_FC36B0(gpLogicalProcessorInfo, gdwLogicalProcessorInfoItemCount, v20, v21) )
                {
                  v16 = (Rect.left + 2);
                  v104 = v94 + v104 - 2;
                }
                else
                {
                  v16 = (v94 + v104 + Rect.left);
                  v104 = 0;
                }
                Rect.left = v16;
                if ( !v96 )
                {
                  v16 = v100[1];
                  Rect.left = v100[1];
                  Rect.top += nHeight + 2;
                }
                v17 = HIDWORD(v101) + 1;
                HIDWORD(v101) = v17;
              }
              while ( v17 - 1 < gSystemInfo.dwNumberOfProcessors );
              hWnd_1 = hWnd_2;
            }
            v22 = HIDWORD(v99);
          }
          swprintf(szText, L"%d", v22);
          v23 = sub_FC3290(szText, 0x104u);
          SetDlgItemTextW(hWnd_1, 1665, v23);
          swprintf(szText, L"%d", NumberOfThreads);
          v24 = sub_FC3290(szText, 0x104u);
          SetDlgItemTextW(hWnd_1, 1666, v24);
          CreateGraphWindow(hWnd_1, 1158, gpGraphInfoOfCPU);
          CreateGraphWindow(hWnd_1, 2000, gpGraphInfoOfCPU);
          v25 = operator new(0x40u);
          v100[1] = v25;
          v111 = 0;
          if ( v25 )
          {
            pResizer = CResizer::CResizer(v25, hWnd_1);
            NumberOfThreads = pResizer;
          }
          else
          {
            pResizer = 0;
            NumberOfThreads = 0;
          }
          v111 = -1;
          pResizer->m_nXRatio = 100;
          pResizer->m_nYRatio = 20;
          v27 = GetDlgItem(hWnd_1, 2000);
          if ( v27 )
          {
            v28 = CResizer::AddItem(pResizer, v27, 1);
            *&v28->m_rect1.left = 0i64;
            *&v28->m_rect1.right = db_one;
          }
          v29 = GetDlgItem(hWnd_1, 1114);
          if ( v29 )
          {
            v30 = CResizer::AddItem(pResizer, v29, 1);
            v31 = db_one;
            *&v30->m_rect1.left = 0i64;
            *&v30->m_rect1.right = db_one;
          }
          else
          {
            v31 = db_one;
          }
          SendMessageW = ::SendMessageW;
          if ( gSystemInfo.dwNumberOfProcessors <= 1 )
          {
            v39 = GetDlgItem(hWnd_1, 1301);
            ShowWindow(v39, 0);
          }
          else
          {
            *v100 = 0.0;
            v95 = 0.0;
            if ( gSystemInfo.dwNumberOfProcessors > 0 )
            {
              v33 = 2001;
              v92 = v31 / v103;
              v90 = v31 / pSystemProcessInfo;
              do
              {
                v34 = GetDlgItem(hWnd_1, v33);
                v101 = v90 + v95;
                if ( v90 + v95 >= 0.99999 )
                  v101 = db_one;
                v35 = CResizer::AddItem(NumberOfThreads, v34, 1);
                *&v35->m_rect2.left = v95;
                *&v35->m_rect2.right = v101;
                v36 = GetDlgItem(hWnd_1, v33);
                v37 = *v100 + v92;
                v99 = *v100 + v92;
                v101 = *v100 + v92;
                if ( *v100 + v92 >= 0.99999 )
                  v101 = db_one;
                if ( v36 )
                {
                  v38 = CResizer::AddItem(NumberOfThreads, v36, 1);
                  *v38 = *v100;
                  v38[1] = v101;
                  v37 = v99;
                }
                *v100 = v37;
                if ( !((v33 - 2000) % v103) )
                {
                  *v100 = 0.0;
                  v95 = v90 + v95;
                }
                ++v33;
              }
              while ( v33 - 2001 < gSystemInfo.dwNumberOfProcessors );
              SendMessageW = ::SendMessageW;
            }
            CheckDlgButton(hWnd_1, 1301, gConfig.bShowAllCpus != 0);
            SendMessageW(hWnd_1, 0x464u, 0, 0);
          }
          PropSheet_UpdateTab(hWnd_1);
          NtQuerySystemInformation(
            SystemPerformanceInformation,
            &gSystenPerformanceInfoInProcSecurity,
            offsetof(SYSTEM_PERFORMANCE_INFORMATION, CcTotalDirtyPages),
            &ReturnLength);
          SendMessageW(hWnd_1, WM_TIMER, 0, 0);
          result = 1;
          break;
        case WM_COMMAND:
          if ( wParam != 1301 || wParam >> 16 )
            return 0;
          gConfig.bShowAllCpus = gConfig.bShowAllCpus == 0;
          ::SendMessageW(hWnd, 0x464u, 0, 0);
          result = 0;
          break;
        case WM_TIMER:
          pSystemProcessInfo = 0;
          GetSystemProcessInfo(&pSystemProcessInfo, 0);
          NtQuerySystemInformation(SystemPerformanceInformation, SystemInformation, 0x138u, &ReturnLength);
          NtQuerySystemInformation(
            SystemProcessorPerformanceInformation,
            HIDWORD(gSystenPerformanceInfoInProcSecurity.CcDirtyPageThreshold),
            48 * gSystemInfo.dwNumberOfProcessors,
            &ReturnLength);
          NtQuerySystemInformation(
            SystemInterruptInformation,
            gSystenPerformanceInfoInProcSecurity.CcTotalDirtyPages,
            24 * gSystemInfo.dwNumberOfProcessors,
            &ReturnLength);
          nCount = 1;
          pSystemProcessInfo_1 = pSystemProcessInfo;
          HandleCount = pSystemProcessInfo->HandleCount;
          NumberOfThreads = pSystemProcessInfo->NumberOfThreads;
          HIDWORD(v101) = HandleCount;
          v44 = pSystemProcessInfo->NextEntryOffset;
          if ( pSystemProcessInfo->NextEntryOffset )
          {
            v45 = NumberOfThreads;
            do
            {
              HandleCount += *(&pSystemProcessInfo_1->HandleCount + v44);
              pSystemProcessInfo_1 = (pSystemProcessInfo_1 + v44);
              ++nCount;
              v45 = (v45 + pSystemProcessInfo_1->NumberOfThreads);
              v44 = pSystemProcessInfo_1->NextEntryOffset;
            }
            while ( pSystemProcessInfo_1->NextEntryOffset );
            NumberOfThreads = v45;
            hWnd_1 = hWnd_2;
            HIDWORD(v101) = HandleCount;
          }
          free(pSystemProcessInfo);
          swprintf(szText, L"%d", HIDWORD(v101));
          v46 = sub_FC3290(szText, MAX_PATH);
          SetDlgItemTextW(hWnd_1, 1096, v46);
          swprintf(szText, L"%d", NumberOfThreads);
          v47 = sub_FC3290(szText, MAX_PATH);
          SetDlgItemTextW(hWnd_1, 1097, v47);
          swprintf(szText, L"%d", nCount);
          v48 = sub_FC3290(szText, MAX_PATH);
          SetDlgItemTextW(hWnd_1, 1098, v48);
          v49 = 0;
          v103 = 0;
          v104 = 0;
          v50 = gSystemInfo.dwNumberOfProcessors;
          if ( gSystemInfo.dwNumberOfProcessors && gSystemInfo.dwNumberOfProcessors >= 8 )
          {
            v51 = 0i64;
            v52 = 0i64;
            v53 = LODWORD(gSystenPerformanceInfoInProcSecurity.CcTotalDirtyPages) + 52;
            v54 = 0i64;
            v55 = 0i64;
            v56 = HIDWORD(gSystenPerformanceInfoInProcSecurity.CcDirtyPageThreshold) + 136;
            do
            {
              v57 = _mm_cvtsi32_si128(*(v56 + 48));
              v56 += 384;
              v53 += 192;
              v49 += 8;
              v51 = _mm_add_epi32(
                      v51,
                      _mm_unpacklo_epi32(
                        _mm_unpacklo_epi32(_mm_cvtsi32_si128(*(v56 - 480)), _mm_cvtsi32_si128(*(v56 - 384))),
                        _mm_unpacklo_epi32(_mm_cvtsi32_si128(*(v56 - 432)), v57)));
              v52 = _mm_add_epi32(
                      v52,
                      _mm_unpacklo_epi32(
                        _mm_unpacklo_epi32(_mm_cvtsi32_si128(*(v53 - 240)), _mm_cvtsi32_si128(*(v53 - 192))),
                        _mm_unpacklo_epi32(_mm_cvtsi32_si128(*(v53 - 216)), _mm_cvtsi32_si128(*(v53 - 168)))));
              v54 = _mm_add_epi32(
                      v54,
                      _mm_unpacklo_epi32(
                        _mm_unpacklo_epi32(_mm_cvtsi32_si128(*(v56 - 288)), _mm_cvtsi32_si128(*(v56 - 192))),
                        _mm_unpacklo_epi32(_mm_cvtsi32_si128(*(v56 - 240)), _mm_cvtsi32_si128(*(v56 - 144)))));
              v55 = _mm_add_epi32(
                      v55,
                      _mm_unpacklo_epi32(
                        _mm_unpacklo_epi32(_mm_cvtsi32_si128(*(v53 - 144)), _mm_cvtsi32_si128(*(v53 - 96))),
                        _mm_unpacklo_epi32(_mm_cvtsi32_si128(*(v53 - 120)), _mm_cvtsi32_si128(*(v53 - 72)))));
            }
            while ( v49 < gSystemInfo.dwNumberOfProcessors - (gSystemInfo.dwNumberOfProcessors & 7) );
            v50 = gSystemInfo.dwNumberOfProcessors;
            v58 = _mm_add_epi32(v55, v52);
            v59 = _mm_add_epi32(v54, v51);
            v60 = _mm_add_epi32(v58, _mm_srli_si128(v58, 8));
            v61 = _mm_add_epi32(v59, _mm_srli_si128(v59, 8));
            v103 = _mm_cvtsi128_si32(_mm_add_epi32(v60, _mm_srli_si128(v60, 4)));
            v104 = _mm_cvtsi128_si32(_mm_add_epi32(v61, _mm_srli_si128(v61, 4)));
          }
          v62 = 0;
          v63 = 0;
          pSystemProcessInfo = 0;
          NumberOfThreads = 0;
          HIDWORD(v99) = 0;
          if ( v49 >= v50 )
          {
            v71 = v103;
          }
          else
          {
            if ( v50 - v49 >= 2 )
            {
              v64 = 0;
              v65 = LODWORD(gSystenPerformanceInfoInProcSecurity.CcTotalDirtyPages) + 24 * v49 + 4;
              v66 = (HIDWORD(gSystenPerformanceInfoInProcSecurity.CcDirtyPageThreshold) + 40 + 48 * v49);
              v67 = ((gSystemInfo.dwNumberOfProcessors - v49 - 2) >> 1) + 1;
              v100[1] = (v49 + 2 * v67);
              v68 = 0;
              do
              {
                v64 = (v64 + *v66);
                v66 += 24;
                v68 += *(v66 - 12);
                v65 += 48;
                pSystemProcessInfo = v64;
                NumberOfThreads = (NumberOfThreads + *(v65 - 48));
                HIDWORD(v99) += *(v65 - 24);
                --v67;
              }
              while ( v67 );
              hWnd_1 = hWnd_2;
              v62 = pSystemProcessInfo;
              v69 = v68;
              v49 = v100[1];
              v63 = v69;
            }
            if ( v49 >= gSystemInfo.dwNumberOfProcessors )
            {
              v70 = v103;
            }
            else
            {
              v104 += *(HIDWORD(gSystenPerformanceInfoInProcSecurity.CcDirtyPageThreshold) + 48 * v49 + 40);
              hWnd_1 = hWnd_2;
              v70 = *(LODWORD(gSystenPerformanceInfoInProcSecurity.CcTotalDirtyPages) + 24 * v49 + 4) + v103;
              v62 = pSystemProcessInfo;
            }
            v104 += v62 + v63;
            v71 = NumberOfThreads + HIDWORD(v99) + v70;
            v103 = v71;
          }
          swprintf(szText, L"%u", v108 - gSystenPerformanceInfoInProcSecurity.ContextSwitches);
          sub_FC3290(szText, 0x104u);
          SetDlgItemTextW(hWnd_1, 1082, szText);
          if ( HIDWORD(gSystenPerformanceInfoInProcSecurity.CcTotalDirtyPages) )
            v72 = &v71[-HIDWORD(gSystenPerformanceInfoInProcSecurity.CcTotalDirtyPages)];
          else
            v72 = 0;
          swprintf(szText, L"%u", v72);
          sub_FC3290(szText, 0x104u);
          SetDlgItemTextW(hWnd_1, 1084, szText);
          if ( LODWORD(gSystenPerformanceInfoInProcSecurity.CcDirtyPageThreshold) )
            v73 = v104 - LODWORD(gSystenPerformanceInfoInProcSecurity.CcDirtyPageThreshold);
          else
            v73 = 0;
          swprintf(szText, L"%u", v73);
          sub_FC3290(szText, 0x104u);
          SetDlgItemTextW(hWnd_1, 1083, szText);
          HIDWORD(gSystenPerformanceInfoInProcSecurity.CcTotalDirtyPages) = v103;
          qmemcpy(&gSystenPerformanceInfoInProcSecurity, SystemInformation, 0x138u);
          v74 = hWnd_2;
          LODWORD(gSystenPerformanceInfoInProcSecurity.CcDirtyPageThreshold) = v104;
          v75 = GetDlgItem(hWnd_2, 1158);
          ::SendMessageW(v75, 0x400u, 0, 0);
          v76 = GetDlgItem(v74, 2000);
          ::SendMessageW(v76, 0x400u, 0, 0);
          v77 = GetDlgItem(v74, 1161);
          ::SendMessageW(v77, 0x400u, 0, 0);
          v78 = GetDlgItem(v74, 1159);
          ::SendMessageW(v78, 0x400u, 0, 0);
          v79 = GetDlgItem(v74, 1637);
          ::SendMessageW(v79, 0x400u, 0, 0);
          v80 = GetDlgItem(v74, 1333);
          ::SendMessageW(v80, 0x400u, 0, 0);
          if ( gSystemInfo.dwNumberOfProcessors <= 1 )
            return 0;
          v81 = 0;
          if ( gSystemInfo.dwNumberOfProcessors <= 0 )
            return 0;
          do
          {
            v82 = GetDlgItem(v74, v81 + 2001);
            ::SendMessageW(v82, 0x400u, 0, 0);
            ++v81;
          }
          while ( v81 < gSystemInfo.dwNumberOfProcessors );
          result = 0;
          break;
        default:
          return 0;
      }
      return result;
    }
    return PE_FillControl(hWnd, wParam);
  }
  if ( uMsg == 310 || uMsg == 312 )
    return PE_FillControl(hWnd, wParam);
  if ( uMsg == 1124 )
  {
    v83 = 5;
    if ( gConfig.bShowAllCpus )
      v83 = 0;
    v84 = v83;
    v85 = GetDlgItem(hWnd, 2000);
    ShowWindow(v85, v84);
    for ( i = 1; i < (gSystemInfo.dwNumberOfProcessors + 1); ++i )
    {
      v87 = 0;
      if ( gConfig.bShowAllCpus )
        v87 = 5;
      v88 = v87;
      v89 = GetDlgItem(hWnd, i + 2000);
      ShowWindow(v89, v88);
    }
  }
  return 0;
}
// 1064E28: using guessed type int gdwVirtualScreenWidth;

//----- (00FF18B0) --------------------------------------------------------
int __stdcall PropSystemInfoGPU(HWND hDlg, UINT msg, WPARAM wParam, LPARAM lParam)
{
  LONG v4; // eax
  signed int v5; // eax
  int v6; // ST44_4
  HWND v7; // eax
  CResizer *v8; // eax
  CResizer *v9; // esi
  HWND v10; // eax
  struct tagResizerItem *v11; // eax
  HWND v12; // eax
  struct tagResizerItem *v13; // eax
  HWND v14; // eax
  struct tagResizerItem *v15; // eax
  HWND v16; // eax
  struct tagResizerItem *v17; // eax
  HWND v18; // eax
  struct tagResizerItem *v19; // eax
  HWND v20; // eax
  struct tagResizerItem *v21; // eax
  HWND v22; // ST44_4
  HWND v23; // ST40_4
  HWND v24; // eax
  HWND v25; // ST44_4
  HWND v26; // ST40_4
  HWND v27; // eax
  HWND v28; // ST44_4
  HWND v29; // ST40_4
  HWND v30; // eax
  HWND v31; // eax
  HWND v32; // eax
  HWND v33; // eax
  HWND v34; // eax
  HWND v35; // eax
  HWND v37; // eax
  HWND v38; // eax
  HWND v39; // eax
  HWND v40; // eax
  HWND v41; // eax
  HWND v42; // eax
  int j; // esi
  HWND v44; // eax
  const WCHAR *v45; // eax
  const WCHAR *v46; // eax
  const WCHAR *v47; // eax
  const WCHAR *v48; // eax
  signed int v49; // eax
  int v50; // ST44_4
  HWND v51; // eax
  int i; // esi
  signed int v53; // eax
  int v54; // ST44_4
  HWND v55; // eax
  int v56[2]; // [esp+14h] [ebp-218h]
  wchar_t Dst; // [esp+1Ch] [ebp-210h]
  int v58; // [esp+228h] [ebp-4h]

  if ( msg > 0x133 )
  {
    if ( msg != 310 && msg != 312 )
    {
      if ( msg == 1124 )
      {
        v49 = 5;
        if ( gConfig.bShowAllGpus )
          v49 = 0;
        v50 = v49;
        v51 = GetDlgItem(hDlg, 2501);
        ShowWindow(v51, v50);
        for ( i = 1; i < gdwAdapterRuntingTime + 1; ++i )
        {
          v53 = 0;
          if ( gConfig.bShowAllGpus )
            v53 = 5;
          v54 = v53;
          v55 = GetDlgItem(hDlg, i + 2501);
          ShowWindow(v55, v54);
        }
      }
      return 0;
    }
  }
  else if ( msg != 307 )
  {
    switch ( msg )
    {
      case 0x24u:
        *(lParam + 8) = 2 * gdwVirtualScreenWidth;
        return 0;
      case 0x110u:
        v4 = GetWindowLongW(hDlg, -16);
        SetWindowLongW(hDlg, -16, v4 | 0x2000000);
        v5 = 0;
        if ( gdwAdapterRuntingTime > 1 )
          v5 = 5;
        v6 = v5;
        v7 = GetDlgItem(hDlg, 1210);
        ShowWindow(v7, v6);
        CreateGraphWindow(hDlg, IDC_SYSINFO_GPU_STATIC_GPU_USAGE_GRAPH, gpGraphInfoOfGPU);
        CreateGraphWindow(hDlg, IDC_SYSINFO_GPU_NODES_STATIC_GRAPH, gpGraphInfoOfGPU);
        CreateGraphWindow(hDlg, IDC_SYSINFO_GPU_STATIC_GPU_DEDICATED_MEMORY_GRAPH, gpGraphInfoOfDedicatedMemory);
        CreateGraphWindow(hDlg, IDC_SYSINFO_GPU_STATIC_GPU_DEDICATED_MEMORY_CHART, gpGraphInfoOfDedicatedMemory);
        CreateGraphWindow(hDlg, IDC_SYSINFO_GPU_STATIC_GPU_SYSTEM_MEMORY_GRAPH, gpGraphInfoOfSystemMemory);
        CreateGraphWindow(hDlg, IDC_SYSINFO_GPU_STATIC_GPU_SYSTEM_MEMORY_CHART, gpGraphInfoOfSystemMemory);
        v8 = operator new(0x40u);
        v58 = 0;
        if ( v8 )
          v9 = CResizer::CResizer(v8, hDlg);
        else
          v9 = 0;
        v58 = -1;
        v9->m_nXRatio = 100;
        v9->m_nYRatio = 0;
        v10 = GetDlgItem(hDlg, 2501);
        if ( v10 )
        {
          v11 = CResizer::AddItem(v9, v10, 1);
          *&v11->m_rect1.left = 0i64;
          *&v11->m_rect1.right = db_one;
        }
        v12 = GetDlgItem(hDlg, 1649);
        if ( v12 )
        {
          v13 = CResizer::AddItem(v9, v12, 1);
          *&v13->m_rect1.left = 0i64;
          *&v13->m_rect1.right = db_one;
        }
        v14 = GetDlgItem(hDlg, 2601);
        if ( v14 )
        {
          v15 = CResizer::AddItem(v9, v14, 1);
          *&v15->m_rect1.left = 0i64;
          *&v15->m_rect1.right = db_one;
        }
        v16 = GetDlgItem(hDlg, 1115);
        if ( v16 )
        {
          v17 = CResizer::AddItem(v9, v16, 1);
          *&v17->m_rect1.left = 0i64;
          *&v17->m_rect1.right = db_one;
        }
        v18 = GetDlgItem(hDlg, 2602);
        if ( v18 )
        {
          v19 = CResizer::AddItem(v9, v18, 1);
          *&v19->m_rect1.left = 0i64;
          *&v19->m_rect1.right = db_one;
        }
        v20 = GetDlgItem(hDlg, 1116);
        if ( v20 )
        {
          v21 = CResizer::AddItem(v9, v20, 1);
          *&v21->m_rect1.left = 0i64;
          *&v21->m_rect1.right = db_one;
        }
        v22 = GetDlgItem(hDlg, 1161);
        v23 = GetDlgItem(hDlg, 1159);
        v24 = GetDlgItem(hDlg, 1157);
        sub_FF0510(v9, v24, v23, v22);
        v25 = GetDlgItem(hDlg, 1162);
        v26 = GetDlgItem(hDlg, 1160);
        v27 = GetDlgItem(hDlg, 1651);
        sub_FF0510(v9, v27, v26, v25);
        v28 = GetDlgItem(hDlg, 2602);
        v29 = GetDlgItem(hDlg, 2601);
        v30 = GetDlgItem(hDlg, 2501);
        sub_FF0510(v9, v30, v29, v28);
        v31 = GetDlgItem(hDlg, 1157);
        *&CResizer::AddItem(v9, v31, 1)->m_rect2.right = db_four;
        v32 = GetDlgItem(hDlg, 1159);
        *&CResizer::AddItem(v9, v32, 1)->m_rect2.right = db_four;
        v33 = GetDlgItem(hDlg, 1161);
        *&CResizer::AddItem(v9, v33, 1)->m_rect2.right = db_four;
        v34 = GetDlgItem(hDlg, 1210);
        if ( v34 )
          CResizer::AddItem(v9, v34, 1)->m_rect1 = 0i64;
        if ( gdwAdapterRuntingTime <= 1 )
        {
          v35 = GetDlgItem(hDlg, 1648);
          ShowWindow(v35, 0);
        }
        PropSheet_UpdateTab(hDlg);
        SendMessageW(hDlg, 0x113u, 0, 0);
        return 1;
      case 0x111u:
        if ( wParam == 1210 )
        {
          DialogBoxParamW(ghMainInstance, L"SYSTEMINFOGPUNODES", hDlg, DlgSystemInfoGPUNodes, 0);
          return 0;
        }
        if ( wParam == 1648 && !(wParam >> 16) )
        {
          gConfig.bShowAllGpus = gConfig.bShowAllGpus == 0;
          SendMessageW(hDlg, 0x464u, 0, 0);
          return 0;
        }
        break;
      case 0x113u:
        if ( !IsWindowVisible(hDlg) )
          return 0;
        v37 = GetDlgItem(hDlg, 1651);
        SendMessageW(v37, 0x400u, 0, 0);
        v38 = GetDlgItem(hDlg, 2501);
        SendMessageW(v38, 0x400u, 0, 0);
        v39 = GetDlgItem(hDlg, 1160);
        SendMessageW(v39, 0x400u, 0, 0);
        v40 = GetDlgItem(hDlg, 2601);
        SendMessageW(v40, 0x400u, 0, 0);
        v41 = GetDlgItem(hDlg, 1162);
        SendMessageW(v41, 0x400u, 0, 0);
        v42 = GetDlgItem(hDlg, 2602);
        SendMessageW(v42, 0x400u, 0, 0);
        if ( gdwAdapterRuntingTime > 1 )
        {
          for ( j = 0; j < gdwAdapterRuntingTime; ++j )
          {
            v44 = GetDlgItem(hDlg, j + 2502);
            SendMessageW(v44, 0x400u, 0, 0);
          }
        }
        GraphData_QueryData(gpGraphInfoOfSystemMemory, v56, 0);
        wsprintf(&Dst, L"%u", *v56);
        v45 = sub_FC3290(&Dst, 0x100u);
        SetDlgItemTextW(hDlg, 1104, v45);
        wsprintf(&Dst, L"%u", gpGraphInfoOfSystemMemory->m_dbMemorySize);
        v46 = sub_FC3290(&Dst, 0x100u);
        SetDlgItemTextW(hDlg, 1105, v46);
        GraphData_QueryData(gpGraphInfoOfDedicatedMemory, v56, 0);
        wsprintf(&Dst, L"%d", *v56);
        v47 = sub_FC3290(&Dst, 0x100u);
        SetDlgItemTextW(hDlg, 1660, v47);
        wsprintf(&Dst, L"%d", gpGraphInfoOfDedicatedMemory->m_dbMemorySize);
        v48 = sub_FC3290(&Dst, 0x100u);
        SetDlgItemTextW(hDlg, 1661, v48);
        return 0;
      default:
        return 0;
    }
    return 0;
  }
  return PE_FillControl(hDlg, wParam);
}
// 103CB38: using guessed type double db_four;
// 1064E28: using guessed type int gdwVirtualScreenWidth;

//----- (00FF2010) --------------------------------------------------------
int __stdcall PropSystemInfoIO(HWND hDlg, int a2, HDC hdc, int a4)
{
  HWND v4; // eax
  HWND v5; // eax
  HWND v6; // eax
  HWND v7; // eax
  HWND v8; // eax
  HWND v9; // eax
  LONG v11; // eax
  CResizer *v12; // eax
  CResizer *v13; // esi
  HWND v14; // edi
  HWND v15; // esi
  HWND v16; // edi
  HWND v17; // esi
  HWND v18; // edi
  HWND v19; // esi
  CResizer *v20; // esi
  HWND v21; // eax
  HWND v22; // eax
  HWND v23; // eax
  HWND v24; // eax
  ULONG ReturnLength; // [esp+10h] [ebp-15Ch]
  CResizer *v26; // [esp+14h] [ebp-158h]
  int SystemInformation; // [esp+18h] [ebp-154h]
  __int64 v28; // [esp+20h] [ebp-14Ch]
  __int64 v29; // [esp+28h] [ebp-144h]
  __int64 v30; // [esp+30h] [ebp-13Ch]
  int v31; // [esp+38h] [ebp-134h]
  int v32; // [esp+3Ch] [ebp-130h]
  int v33; // [esp+40h] [ebp-12Ch]
  HWND v34; // [esp+150h] [ebp-1Ch]
  HWND v35; // [esp+154h] [ebp-18h]
  HWND v36; // [esp+158h] [ebp-14h]
  int v37; // [esp+168h] [ebp-4h]

  if ( a2 > 0x133 )
  {
    if ( a2 != 310 && a2 != 312 )
      return 0;
    return PE_FillControl(hDlg, hdc);
  }
  if ( a2 == 307 )
    return PE_FillControl(hDlg, hdc);
  if ( a2 == 36 )
  {
    *(a4 + 8) = 2 * gdwVirtualScreenWidth;
    return 0;
  }
  if ( a2 != 272 )
  {
    if ( a2 == 275 )
    {
      NtQuerySystemInformation(SystemPerformanceInformation, &SystemInformation, 0x138u, &ReturnLength);
      sub_FF0400(hDlg, 1176, v31 - dword_10853A8, 0);
      sub_FF0460(hDlg, 1190, v28 - qword_1085390, (v28 - qword_1085390) >> 32);
      sub_FF0400(hDlg, 1177, v32 - dword_10853AC, 0);
      sub_FF0460(hDlg, 1192, v29 - qword_1085398, (v29 - qword_1085398) >> 32);
      sub_FF0400(hDlg, 1178, v33 - dword_10853B0, 0);
      sub_FF0460(hDlg, 1194, v30 - qword_10853A0, (v30 - qword_10853A0) >> 32);
      qmemcpy(&unk_1085388, &SystemInformation, 0x138u);
      sub_FF0400(hDlg, 1180, gTreeList_Item[1].field_10, 0);
      sub_FF0460(hDlg, 1196, gTreeList_Item[1].field_38, gTreeList_Item[1].field_3C);
      sub_FF0400(hDlg, 1181, gTreeList_Item[1].field_C, 0);
      sub_FF0460(hDlg, 1198, gTreeList_Item[1].field_30, gTreeList_Item[1].field_34);
      sub_FF0400(hDlg, 1182, gTreeList_Item[1].field_14, 0);
      sub_FF0460(hDlg, 1200, gTreeList_Item[1].field_40, gTreeList_Item[1].field_44);
      sub_FF0400(hDlg, 1186, gTreeList_Item[2].field_10, 0);
      sub_FF0460(hDlg, 1202, gTreeList_Item[2].field_38, gTreeList_Item[2].field_3C);
      sub_FF0400(hDlg, 1187, gTreeList_Item[2].field_C, 0);
      sub_FF0460(hDlg, 1204, gTreeList_Item[2].field_30, gTreeList_Item[2].field_34);
      sub_FF0400(hDlg, 1188, gTreeList_Item[2].field_14, 0);
      sub_FF0460(hDlg, 1206, gTreeList_Item[2].field_40, gTreeList_Item[2].field_44);
      if ( gIOGraphInfo.pGraphData )
      {
        v4 = GetDlgItem(hDlg, 1332);
        SendMessageW(v4, 0x400u, 0, 0);
        v5 = GetDlgItem(hDlg, 1330);
        SendMessageW(v5, 0x400u, 0, 0);
      }
      if ( gNetworkGraphInfo.pGraphData )
      {
        v6 = GetDlgItem(hDlg, 1351);
        SendMessageW(v6, 0x400u, 0, 0);
        v7 = GetDlgItem(hDlg, 1335);
        SendMessageW(v7, 0x400u, 0, 0);
      }
      if ( gDiskGraphInfo.pGraphData )
      {
        v8 = GetDlgItem(hDlg, 1337);
        SendMessageW(v8, 0x400u, 0, 0);
        v9 = GetDlgItem(hDlg, 1338);
        SendMessageW(v9, 0x400u, 0, 0);
        return 0;
      }
    }
    return 0;
  }
  v11 = GetWindowLongW(hDlg, -16);
  SetWindowLongW(hDlg, -16, v11 | 0x2000000);
  v12 = operator new(0x40u);
  v26 = v12;
  v37 = 0;
  if ( v12 )
  {
    v13 = CResizer::CResizer(v12, hDlg);
    v26 = v13;
  }
  else
  {
    v13 = 0;
    v26 = 0;
  }
  v37 = -1;
  if ( gIOGraphInfo.pGraphData )
  {
    CreateGraphWindow(hDlg, 1332, gIOGraphInfo.pGraphData);
    CreateGraphWindow(hDlg, 1330, gIOGraphInfo.pGraphData);
  }
  if ( IsBuiltinAdministrative() )
  {
    if ( gNetworkGraphInfo.pGraphData )
    {
      CreateGraphWindow(hDlg, 1351, gNetworkGraphInfo.pGraphData);
      CreateGraphWindow(hDlg, 1335, gNetworkGraphInfo.pGraphData);
    }
    if ( gDiskGraphInfo.pGraphData )
    {
      CreateGraphWindow(hDlg, 1337, gDiskGraphInfo.pGraphData);
      CreateGraphWindow(hDlg, 1338, gDiskGraphInfo.pGraphData);
    }
    v13->m_nXRatio = 93;
    v13->m_nYRatio = 20;
    v14 = GetDlgItem(hDlg, 1338);
    v15 = GetDlgItem(hDlg, 1335);
    v34 = GetDlgItem(hDlg, 1330);
    v35 = v15;
    v36 = v14;
    sub_FF0550(v26, 3, &v34);
    v16 = GetDlgItem(hDlg, 1336);
    v17 = GetDlgItem(hDlg, 1352);
    v34 = GetDlgItem(hDlg, 1331);
    v35 = v17;
    v36 = v16;
    sub_FF0550(v26, 3, &v34);
    v18 = GetDlgItem(hDlg, 1337);
    v19 = GetDlgItem(hDlg, 1351);
    v34 = GetDlgItem(hDlg, 1332);
    v35 = v19;
    v20 = v26;
    v36 = v18;
    sub_FF0550(v26, 3, &v34);
    v21 = GetDlgItem(hDlg, 1183);
    if ( v21 )
      CResizer::AddItem(v26, v21, 1)->m_rect1 = 0i64;
    v22 = GetDlgItem(hDlg, 1331);
    *&CResizer::AddItem(v20, v22, 1)->m_rect2.right = db_four;
    v23 = GetDlgItem(hDlg, 1352);
    *&CResizer::AddItem(v20, v23, 1)->m_rect2.right = db_four;
    v24 = GetDlgItem(hDlg, 1336);
    *&CResizer::AddItem(v20, v24, 1)->m_rect2.right = db_four;
  }
  else
  {
    v13->m_nXRatio = 93;
    v13->m_nYRatio = 20;
  }
  PropSheet_UpdateTab(hDlg);
  NtQuerySystemInformation(SystemPerformanceInformation, &unk_1085388, 0x138u, &ReturnLength);
  SendMessageW(hDlg, 0x113u, 0, 0);
  return 1;
}
// 103CB38: using guessed type double db_four;
// 1064E28: using guessed type int gdwVirtualScreenWidth;
// 1085390: using guessed type __int64 qword_1085390;
// 1085398: using guessed type __int64 qword_1085398;
// 10853A0: using guessed type __int64 qword_10853A0;
// 10853A8: using guessed type int dword_10853A8;
// 10853AC: using guessed type int dword_10853AC;
// 10853B0: using guessed type int dword_10853B0;

//----- (00FF25E0) --------------------------------------------------------
int __stdcall PropSystemInfoMem(HWND hWnd, int a2, HDC hdc, int a4)
{
  LONG v4; // eax
  signed int v5; // eax
  int ArgList_4; // ST34_4
  HWND v7; // eax
  signed int v8; // eax
  int v9; // ST34_4
  HWND v10; // eax
  CResizer *v11; // eax
  CResizer *v12; // esi
  HWND v13; // eax
  struct tagResizerItem *v14; // eax
  HWND v15; // eax
  struct tagResizerItem *v16; // eax
  HWND v17; // esi
  HWND v18; // esi
  HWND v19; // esi
  CResizer *v20; // esi
  HWND v21; // eax
  HWND v22; // eax
  const WCHAR *v24; // eax
  void (__stdcall *v25)(HWND, int, LPCWSTR); // esi
  const WCHAR *v26; // eax
  const WCHAR *v27; // eax
  const WCHAR *v28; // eax
  DWORD v29; // eax
  const WCHAR *v30; // eax
  const WCHAR *v31; // eax
  const WCHAR *v32; // eax
  const WCHAR *v33; // eax
  const WCHAR *v34; // eax
  const WCHAR *v35; // eax
  const WCHAR *v36; // eax
  const WCHAR *v37; // eax
  unsigned int v38; // esi
  const WCHAR *v39; // eax
  char *v40; // ecx
  const WCHAR *v41; // eax
  const WCHAR *v42; // ST34_4
  const WCHAR *v43; // ST34_4
  const WCHAR *v44; // eax
  const WCHAR *v45; // eax
  HWND v46; // eax
  HWND v47; // eax
  HWND v48; // eax
  HWND v49; // eax
  double ArgList; // [esp+30h] [ebp-450h]
  double ArgLista; // [esp+30h] [ebp-450h]
  ULONG ReturnLength; // [esp+44h] [ebp-43Ch]
  HWND v53; // [esp+48h] [ebp-438h]
  void *v54; // [esp+4Ch] [ebp-434h]
  HWND hDlg; // [esp+50h] [ebp-430h]
  int v56; // [esp+54h] [ebp-42Ch]
  unsigned __int64 v57; // [esp+5Ch] [ebp-424h]
  int SystemInformation; // [esp+94h] [ebp-3ECh]
  int v59; // [esp+C0h] [ebp-3C0h]
  unsigned int v60; // [esp+C4h] [ebp-3BCh]
  unsigned int v61; // [esp+C8h] [ebp-3B8h]
  unsigned int v62; // [esp+CCh] [ebp-3B4h]
  int v63; // [esp+D0h] [ebp-3B0h]
  int v64; // [esp+E8h] [ebp-398h]
  int v65; // [esp+F4h] [ebp-38Ch]
  int v66; // [esp+FCh] [ebp-384h]
  int v67; // [esp+104h] [ebp-37Ch]
  int v68; // [esp+108h] [ebp-378h]
  int v69; // [esp+120h] [ebp-360h]
  int v70; // [esp+138h] [ebp-348h]
  int v71; // [esp+13Ch] [ebp-344h]
  int v72; // [esp+140h] [ebp-340h]
  struct _MEMORYSTATUS Buffer; // [esp+1CCh] [ebp-2B4h]
  int v74; // [esp+1ECh] [ebp-294h]
  int v75; // [esp+1F0h] [ebp-290h]
  int v76; // [esp+1F4h] [ebp-28Ch]
  int v77; // [esp+1F8h] [ebp-288h]
  int v78[16]; // [esp+200h] [ebp-280h]
  int v79; // [esp+240h] [ebp-240h]
  _DWORD v80[4]; // [esp+244h] [ebp-23Ch]
  __int128 v81; // [esp+254h] [ebp-22Ch]
  int v82; // [esp+264h] [ebp-21Ch]
  WCHAR String; // [esp+268h] [ebp-218h]
  int v84; // [esp+47Ch] [ebp-4h]

  hDlg = hWnd;
  if ( a2 > 0x113 )
  {
    if ( a2 == 307 || a2 == 310 || a2 == 312 )
      return PE_FillControl(hWnd, hdc);
    return 0;
  }
  if ( a2 != 275 )
  {
    switch ( a2 )
    {
      case 36:
        *(a4 + 8) = 2 * gdwVirtualScreenWidth;
        return 0;
      case 256:
        if ( hdc == 116 )
        {
          PostMessageW(hWnd, 0x113u, 1u, 0);
          return 0;
        }
        break;
      case 272:
        v4 = GetWindowLongW(hWnd, -16);
        SetWindowLongW(hWnd, -16, v4 | 0x2000000);
        CreateGraphWindow(hWnd, 1161, gpGraphInfoOfMemory);
        CreateGraphWindow(hWnd, 1159, gpGraphInfoOfMemory);
        CreateGraphWindow(hWnd, 1333, gpGraphInfoOfPhysicalMemory);
        CreateGraphWindow(hWnd, 1637, gpGraphInfoOfPhysicalMemory);
        v5 = 0;
        if ( gdwVersion >= 3 )
          v5 = 5;
        ArgList_4 = v5;
        v7 = GetDlgItem(hWnd, 1662);
        ShowWindow(v7, ArgList_4);
        v8 = 0;
        if ( gdwVersion >= 3 )
          v8 = 5;
        v9 = v8;
        v10 = GetDlgItem(hWnd, 1663);
        ShowWindow(v10, v9);
        v11 = operator new(0x40u);
        v54 = v11;
        v84 = 0;
        if ( v11 )
        {
          v12 = CResizer::CResizer(v11, hWnd);
          hDlg = v12;
        }
        else
        {
          v12 = 0;
          hDlg = 0;
        }
        v84 = -1;
        v12->m_nXRatio = 100;
        v12->m_nYRatio = 20;
        v13 = GetDlgItem(hWnd, 1159);
        if ( v13 )
        {
          v14 = CResizer::AddItem(v12, v13, 1);
          *&v14->m_rect1.left = 0i64;
          *&v14->m_rect1.right = db_one;
        }
        v15 = GetDlgItem(hWnd, 1333);
        if ( v15 )
        {
          v16 = CResizer::AddItem(v12, v15, 1);
          *&v16->m_rect1.left = 0i64;
          *&v16->m_rect1.right = db_one;
        }
        v17 = GetDlgItem(hWnd, 1333);
        v53 = GetDlgItem(hWnd, 1159);
        v54 = v17;
        sub_FF0550(hDlg, 2, &v53);
        v18 = GetDlgItem(hWnd, 1334);
        v53 = GetDlgItem(hWnd, 1160);
        v54 = v18;
        sub_FF0550(hDlg, 2, &v53);
        v19 = GetDlgItem(hWnd, 1637);
        v53 = GetDlgItem(hWnd, 1161);
        v54 = v19;
        v20 = hDlg;
        sub_FF0550(hDlg, 2, &v53);
        v21 = GetDlgItem(hWnd, 1160);
        *&CResizer::AddItem(v20, v21, 1)->m_rect2.right = db_four;
        v22 = GetDlgItem(hWnd, 1334);
        *&CResizer::AddItem(v20, v22, 1)->m_rect2.right = db_four;
        PropSheet_UpdateTab(hWnd);
        NtQuerySystemInformation(
          SystemPerformanceInformation,
          &gSystenPerformanceInfoInProcSecurity.ResidentAvailablePages,
          0x138u,
          &ReturnLength);
        SendMessageW(hWnd, 0x113u, 0, 0);
        return 1;
    }
    return 0;
  }
  sub_FDCE20(&qword_1085378, &qword_1085380);
  NtQuerySystemInformation(SystemPerformanceInformation, &SystemInformation, 0x138u, &ReturnLength);
  v82 = 0;
  _mm_storeu_si128(v80, 0i64);
  _mm_storeu_si128(&v81, 0i64);
  NtQuerySystemInformation(SystemFileCacheInformation, v80, 0x24u, &ReturnLength);
  memset(&v74, 0, 0x58u);
  NtQuerySystemInformation(SystemMemoryListInformation, &v74, 0x58u, &ReturnLength);
  swprintf(&String, L"%d", v61 * (gSystemInfo.dwPageSize >> 10));
  v24 = sub_FC3290(&String, 0x104u);
  v25 = SetDlgItemTextW;
  SetDlgItemTextW(hWnd, 1103, v24);
  ArgList = v60 * 100.0 / v61;
  if ( gConfig.bShowCpuFractions )
    swprintf(&String, L"%02.2f%%", ArgList);
  else
    swprintf(&String, L"%0.0f%%", ArgList);
  SetDlgItemTextW(hWnd, 1110, &String);
  swprintf(&String, L"%u", v60 * (gSystemInfo.dwPageSize >> 10));
  v26 = sub_FC3290(&String, 0x104u);
  SetDlgItemTextW(hWnd, 1102, v26);
  swprintf(&String, L"%u", v62 * (gSystemInfo.dwPageSize >> 10));
  v27 = sub_FC3290(&String, 0x104u);
  SetDlgItemTextW(hWnd, 1104, v27);
  ArgLista = v62 * 100.0 / v61;
  if ( gConfig.bShowCpuFractions )
    swprintf(&String, L"%02.2f%%", ArgLista);
  else
    swprintf(&String, L"%0.0f%%", ArgLista);
  SetDlgItemTextW(hWnd, 1111, &String);
  swprintf(&String, L"%u", v59 * (gSystemInfo.dwPageSize >> 10));
  v28 = sub_FC3290(&String, 0x104u);
  SetDlgItemTextW(hWnd, 1100, v28);
  v29 = gSystemInfo.dwPageSize >> 10;
  if ( DWORD1(v81) )
    v54 = (DWORD1(v81) * v29);
  else
    v54 = (v29 * (v71 + v70 + v72 + v69));
  if ( GlobalMemoryStatusEx )
  {
    v56 = 64;
    GlobalMemoryStatusEx(&v56);
    swprintf(&String, L"%I64d", v57 >> 10);
  }
  else
  {
    Buffer.dwLength = 32;
    GlobalMemoryStatus(&Buffer);
    swprintf(&String, L"%d", Buffer.dwTotalPhys >> 10);
  }
  v30 = sub_FC3290(&String, 0x104u);
  SetDlgItemTextW(hWnd, 1099, v30);
  if ( gdwVersion < 1 )
  {
    swprintf(&String, L"%d", v54);
    v43 = sub_FC3290(&String, 0x104u);
    SetDlgItemTextW(hWnd, 1101, v43);
  }
  else
  {
    swprintf(&String, L"%u", v72 * (gSystemInfo.dwPageSize >> 10));
    v31 = sub_FC3290(&String, 0x104u);
    SetDlgItemTextW(hWnd, 1116, v31);
    swprintf(&String, L"%u", v69 * (gSystemInfo.dwPageSize >> 10));
    v32 = sub_FC3290(&String, 0x104u);
    SetDlgItemTextW(hWnd, 1114, v32);
    swprintf(&String, L"%u", v70 * (gSystemInfo.dwPageSize >> 10));
    v33 = sub_FC3290(&String, 0x104u);
    SetDlgItemTextW(hWnd, 1101, v33);
    swprintf(&String, L"%u", v74 * (gSystemInfo.dwPageSize >> 10));
    v34 = sub_FC3290(&String, 0x104u);
    SetDlgItemTextW(hWnd, 1112, v34);
    swprintf(&String, L"%u", v75 * (gSystemInfo.dwPageSize >> 10));
    v35 = sub_FC3290(&String, 0x104u);
    SetDlgItemTextW(hWnd, 1113, v35);
    swprintf(&String, L"%u", v76 * (gSystemInfo.dwPageSize >> 10));
    v36 = sub_FC3290(&String, 0x104u);
    SetDlgItemTextW(hWnd, 1118, v36);
    swprintf(&String, L"%u", v77 * (gSystemInfo.dwPageSize >> 10));
    v37 = sub_FC3290(&String, 0x104u);
    SetDlgItemTextW(hWnd, 1119, v37);
    v54 = 0;
    v38 = 0;
    do
    {
      swprintf(&String, L"%u", v78[v38] * (gSystemInfo.dwPageSize >> 10));
      v39 = sub_FC3290(&String, 0x104u);
      SetDlgItemTextW(hWnd, v38 + 1120, v39);
      v40 = v54 + v78[v38++];
      v54 = v40;
    }
    while ( v38 < 8 );
    swprintf(&String, L"%u", v40 * (gSystemInfo.dwPageSize >> 10));
    v41 = sub_FC3290(&String, 0x104u);
    v25 = SetDlgItemTextW;
    SetDlgItemTextW(hWnd, 1117, v41);
    if ( gdwVersion >= 3 )
    {
      swprintf(&String, L"%u", v79 * (gSystemInfo.dwPageSize >> 10));
      v42 = sub_FC3290(&String, 0x104u);
      SetDlgItemTextW(hWnd, 1663, v42);
    }
  }
  if ( qword_1085378 )
  {
    swprintf(&String, L"%I64u", qword_1085378 >> 10);
    sub_FC3290(&String, 0x104u);
    v25(hWnd, 1108, &String);
  }
  swprintf(&String, L"%u", v68 * (gSystemInfo.dwPageSize >> 10));
  sub_FC3290(&String, 0x104u);
  v25(hWnd, 1107, &String);
  swprintf(&String, L"%u", v71 * (gSystemInfo.dwPageSize >> 10));
  v44 = sub_FC3290(&String, 0x104u);
  v25(hWnd, 1105, v44);
  swprintf(&String, L"%u", v67 * (gSystemInfo.dwPageSize >> 10));
  v45 = sub_FC3290(&String, 0x104u);
  v25(hWnd, 1106, v45);
  if ( qword_1085380 )
  {
    swprintf(&String, L"%I64u", qword_1085380 >> 10);
    sub_FC3290(&String, 0x104u);
    v25(hWnd, 1664, &String);
  }
  swprintf(&String, L"%u", v63 - dword_108527C);
  sub_FC3290(&String, 0x104u);
  v25(hWnd, 1171, &String);
  swprintf(&String, L"%u", v64 - dword_1085294);
  sub_FC3290(&String, 0x104u);
  v25(hWnd, 1172, &String);
  swprintf(&String, L"%u", v65 - dword_10852A0);
  sub_FC3290(&String, 0x104u);
  v25(hWnd, 1173, &String);
  swprintf(&String, L"%u", v66 - dword_10852A8);
  sub_FC3290(&String, 0x104u);
  v25(hWnd, 1174, &String);
  qmemcpy(&gSystenPerformanceInfoInProcSecurity.ResidentAvailablePages, &SystemInformation, 0x138u);
  v46 = GetDlgItem(hDlg, 1161);
  SendMessageW(v46, 0x400u, 0, 0);
  v47 = GetDlgItem(hDlg, 1159);
  SendMessageW(v47, 0x400u, 0, 0);
  v48 = GetDlgItem(hDlg, 1637);
  SendMessageW(v48, 0x400u, 0, 0);
  v49 = GetDlgItem(hDlg, 1333);
  SendMessageW(v49, 0x400u, 0, 0);
  return 0;
}
// 103CB38: using guessed type double db_four;
// 103CDC0: using guessed type double db_onehundred;
// 10467B8: using guessed type wchar_t a022f_0[9];
// 1064E28: using guessed type int gdwVirtualScreenWidth;
// 1064E54: using guessed type int gdwVersion;
// 106F2E8: using guessed type int (__stdcall *GlobalMemoryStatusEx)(_DWORD);
// 108527C: using guessed type int dword_108527C;
// 1085294: using guessed type int dword_1085294;
// 10852A0: using guessed type int dword_10852A0;
// 10852A8: using guessed type int dword_10852A8;
// 1085378: using guessed type __int64 qword_1085378;
// 1085380: using guessed type __int64 qword_1085380;
// FF25E0: using guessed type int var_280[16];

//----- (00FF3260) --------------------------------------------------------
int __stdcall PropSummary(HWND hDlg, int a2, HDC hdc, int a4)
{
  HWND v4; // eax
  HWND v5; // eax
  HWND v6; // eax
  HWND v7; // eax
  HWND v8; // eax
  HWND v9; // eax
  HWND v10; // eax
  HWND v11; // eax
  HWND v12; // eax
  HWND v13; // eax
  HWND v14; // eax
  HWND v15; // eax
  HWND v16; // eax
  HWND v17; // eax
  HWND v18; // eax
  HWND v19; // eax
  LONG v21; // eax
  CResizer *v22; // eax
  CResizer *v23; // ebx
  HWND v24; // eax
  struct tagResizerItem *v25; // eax
  HWND v26; // eax
  struct tagResizerItem *v27; // eax
  HWND v28; // eax
  struct tagResizerItem *v29; // eax
  HWND v30; // eax
  struct tagResizerItem *v31; // eax
  HWND v32; // ST5C_4
  HWND v33; // ST58_4
  HWND v34; // ebx
  HWND v35; // edi
  HWND v36; // esi
  HWND v37; // ST58_4
  HWND v38; // ST5C_4
  HWND v39; // ebx
  HWND v40; // edi
  HWND v41; // esi
  HWND v42; // ST58_4
  HWND v43; // ST5C_4
  HWND v44; // ebx
  HWND v45; // edi
  HWND v46; // esi
  CResizer *v47; // edi
  HWND v48; // ebx
  HWND (__stdcall *v49)(HWND, int); // esi
  HWND v50; // eax
  HWND v51; // eax
  HWND v52; // ebx
  HWND v53; // edi
  HWND v54; // esi
  HWND v55; // ebx
  HWND v56; // edi
  HWND v57; // esi
  HWND v58; // ebx
  HWND v59; // edi
  HWND v60; // esi
  HWND v61; // eax
  HWND v62; // eax
  HWND v63; // eax
  HWND v64; // eax
  CResizer *v65; // [esp+18h] [ebp-30h]
  HWND v66; // [esp+20h] [ebp-28h]
  HWND v67; // [esp+24h] [ebp-24h]
  HWND v68; // [esp+28h] [ebp-20h]
  HWND v69; // [esp+2Ch] [ebp-1Ch]
  HWND v70; // [esp+30h] [ebp-18h]
  HWND v71; // [esp+34h] [ebp-14h]
  int v72; // [esp+44h] [ebp-4h]

  if ( a2 > 0x133 )
  {
    if ( a2 != 310 && a2 != 312 )
      return 0;
    return PE_FillControl(hDlg, hdc);
  }
  if ( a2 == 307 )
    return PE_FillControl(hDlg, hdc);
  if ( a2 == 36 )
  {
    *(a4 + 8) = 2 * gdwVirtualScreenWidth;
    return 0;
  }
  if ( a2 != 272 )
  {
    if ( a2 == 275 )
    {
      v4 = GetDlgItem(hDlg, 1158);
      SendMessageW(v4, 0x400u, 0, 0);
      v5 = GetDlgItem(hDlg, 2000);
      SendMessageW(v5, 0x400u, 0, 0);
      v6 = GetDlgItem(hDlg, 1161);
      SendMessageW(v6, 0x400u, 0, 0);
      v7 = GetDlgItem(hDlg, 1159);
      SendMessageW(v7, 0x400u, 0, 0);
      v8 = GetDlgItem(hDlg, 1637);
      SendMessageW(v8, 0x400u, 0, 0);
      v9 = GetDlgItem(hDlg, 1333);
      SendMessageW(v9, 0x400u, 0, 0);
      v10 = GetDlgItem(hDlg, 1161);
      SendMessageW(v10, 0x400u, 0, 0);
      v11 = GetDlgItem(hDlg, 1159);
      SendMessageW(v11, 0x400u, 0, 0);
      v12 = GetDlgItem(hDlg, 1637);
      SendMessageW(v12, 0x400u, 0, 0);
      v13 = GetDlgItem(hDlg, 1333);
      SendMessageW(v13, 0x400u, 0, 0);
      if ( gIOGraphInfo.pGraphData )
      {
        v14 = GetDlgItem(hDlg, 1332);
        SendMessageW(v14, 0x400u, 0, 0);
        v15 = GetDlgItem(hDlg, 1330);
        SendMessageW(v15, 0x400u, 0, 0);
      }
      if ( gNetworkGraphInfo.pGraphData )
      {
        v16 = GetDlgItem(hDlg, 1351);
        SendMessageW(v16, 0x400u, 0, 0);
        v17 = GetDlgItem(hDlg, 1335);
        SendMessageW(v17, 0x400u, 0, 0);
      }
      if ( gDiskGraphInfo.pGraphData )
      {
        v18 = GetDlgItem(hDlg, 1337);
        SendMessageW(v18, 0x400u, 0, 0);
        v19 = GetDlgItem(hDlg, 1338);
        SendMessageW(v19, 0x400u, 0, 0);
        return 0;
      }
    }
    return 0;
  }
  v21 = GetWindowLongW(hDlg, -16);
  SetWindowLongW(hDlg, -16, v21 | 0x2000000);
  v22 = operator new(0x40u);
  v72 = 0;
  if ( v22 )
  {
    v23 = CResizer::CResizer(v22, hDlg);
    v65 = v23;
  }
  else
  {
    v23 = 0;
    v65 = 0;
  }
  v72 = -1;
  CreateGraphWindow(hDlg, 1158, gpGraphInfoOfCPU);
  CreateGraphWindow(hDlg, 2000, gpGraphInfoOfCPU);
  CreateGraphWindow(hDlg, 1161, gpGraphInfoOfMemory);
  CreateGraphWindow(hDlg, 1159, gpGraphInfoOfMemory);
  CreateGraphWindow(hDlg, 1333, gpGraphInfoOfPhysicalMemory);
  CreateGraphWindow(hDlg, 1637, gpGraphInfoOfPhysicalMemory);
  v24 = GetDlgItem(hDlg, 2000);
  if ( v24 )
  {
    v25 = CResizer::AddItem(v23, v24, 1);
    *&v25->m_rect1.left = 0i64;
    *&v25->m_rect1.right = db_one;
  }
  v26 = GetDlgItem(hDlg, 1114);
  if ( v26 )
  {
    v27 = CResizer::AddItem(v23, v26, 1);
    *&v27->m_rect1.left = 0i64;
    *&v27->m_rect1.right = db_one;
  }
  v28 = GetDlgItem(hDlg, 1159);
  if ( v28 )
  {
    v29 = CResizer::AddItem(v23, v28, 1);
    *&v29->m_rect1.left = 0i64;
    *&v29->m_rect1.right = db_one;
  }
  v30 = GetDlgItem(hDlg, 1333);
  if ( v30 )
  {
    v31 = CResizer::AddItem(v23, v30, 1);
    *&v31->m_rect1.left = 0i64;
    *&v31->m_rect1.right = db_one;
  }
  if ( gIOGraphInfo.pGraphData )
  {
    CreateGraphWindow(hDlg, 1332, gIOGraphInfo.pGraphData);
    CreateGraphWindow(hDlg, 1330, gIOGraphInfo.pGraphData);
  }
  if ( IsBuiltinAdministrative() )
  {
    if ( gNetworkGraphInfo.pGraphData )
    {
      CreateGraphWindow(hDlg, 1351, gNetworkGraphInfo.pGraphData);
      CreateGraphWindow(hDlg, 1335, gNetworkGraphInfo.pGraphData);
    }
    if ( gDiskGraphInfo.pGraphData )
    {
      CreateGraphWindow(hDlg, 1337, gDiskGraphInfo.pGraphData);
      CreateGraphWindow(hDlg, 1338, gDiskGraphInfo.pGraphData);
    }
    v23->m_nXRatio = 93;
    v23->m_nYRatio = 10;
    v32 = GetDlgItem(hDlg, 1338);
    v33 = GetDlgItem(hDlg, 1335);
    v34 = GetDlgItem(hDlg, 1330);
    v35 = GetDlgItem(hDlg, 1333);
    v36 = GetDlgItem(hDlg, 1159);
    v66 = GetDlgItem(hDlg, 2000);
    v70 = v33;
    v71 = v32;
    v67 = v36;
    v68 = v35;
    v69 = v34;
    sub_FF0550(v65, 6, &v66);
    v37 = GetDlgItem(hDlg, 1336);
    v38 = GetDlgItem(hDlg, 1352);
    v39 = GetDlgItem(hDlg, 1331);
    v40 = GetDlgItem(hDlg, 1334);
    v41 = GetDlgItem(hDlg, 1160);
    v66 = GetDlgItem(hDlg, 1157);
    v70 = v38;
    v71 = v37;
    v67 = v41;
    v68 = v40;
    v69 = v39;
    sub_FF0550(v65, 6, &v66);
    v42 = GetDlgItem(hDlg, 1337);
    v43 = GetDlgItem(hDlg, 1351);
    v44 = GetDlgItem(hDlg, 1332);
    v45 = GetDlgItem(hDlg, 1637);
    v46 = GetDlgItem(hDlg, 1161);
    v66 = GetDlgItem(hDlg, 1158);
    v70 = v43;
    v71 = v42;
    v68 = v45;
    v47 = v65;
    v67 = v46;
    v69 = v44;
    sub_FF0550(v65, 6, &v66);
    v48 = hDlg;
    v49 = GetDlgItem;
    v50 = GetDlgItem(hDlg, 1352);
    *&CResizer::AddItem(v65, v50, 1)->m_rect2.right = db_four;
    v51 = GetDlgItem(hDlg, 1336);
    *&CResizer::AddItem(v65, v51, 1)->m_rect2.right = db_four;
  }
  else
  {
    v23->m_nXRatio = 93;
    v23->m_nYRatio = 10;
    v52 = GetDlgItem(hDlg, 1330);
    v53 = GetDlgItem(hDlg, 1333);
    v54 = GetDlgItem(hDlg, 1159);
    v68 = GetDlgItem(hDlg, 2000);
    v69 = v54;
    v70 = v53;
    v71 = v52;
    sub_FF0550(v65, 4, &v68);
    v55 = GetDlgItem(hDlg, 1331);
    v56 = GetDlgItem(hDlg, 1334);
    v57 = GetDlgItem(hDlg, 1160);
    v68 = GetDlgItem(hDlg, 1157);
    v69 = v57;
    v70 = v56;
    v71 = v55;
    sub_FF0550(v65, 4, &v68);
    v58 = GetDlgItem(hDlg, 1332);
    v59 = GetDlgItem(hDlg, 1637);
    v60 = GetDlgItem(hDlg, 1161);
    v68 = GetDlgItem(hDlg, 1158);
    v70 = v59;
    v47 = v65;
    v69 = v60;
    v71 = v58;
    sub_FF0550(v65, 4, &v68);
    v48 = hDlg;
    v49 = GetDlgItem;
  }
  v61 = v49(v48, 1157);
  *&CResizer::AddItem(v47, v61, 1)->m_rect2.right = db_four;
  v62 = v49(v48, 1160);
  *&CResizer::AddItem(v47, v62, 1)->m_rect2.right = db_four;
  v63 = v49(v48, 1334);
  *&CResizer::AddItem(v47, v63, 1)->m_rect2.right = db_four;
  v64 = v49(v48, 1331);
  *&CResizer::AddItem(v47, v64, 1)->m_rect2.right = db_four;
  PropSheet_UpdateTab(v48);
  SendMessageW(v48, 0x113u, 0, 0);
  return 1;
}
// 103CB38: using guessed type double db_four;
// 1064E28: using guessed type int gdwVirtualScreenWidth;

//----- (00FF39C0) --------------------------------------------------------
_DWORD *__cdecl sub_FF39C0(SYSTEM_HANDLE_INFORMATION *pSystemHandleInfo, int a2)
{
  int *v2; // esi
  int *v3; // ebx
  int *v4; // edi
  _DWORD *v5; // eax
  unsigned int v6; // edi
  int v8; // [esp+4h] [ebp-14h]
  int v9; // [esp+8h] [ebp-10h]
  int v10; // [esp+Ch] [ebp-Ch]
  int v11; // [esp+10h] [ebp-8h]
  _DWORD *v12; // [esp+14h] [ebp-4h]

  v12 = 0;
  v11 = 0;
  if ( sub_FDD9D0(pSystemHandleInfo) )
  {
    v2 = &pSystemHandleInfo->Handles[0].GrantedAccess;
    v3 = &pSystemHandleInfo->Handles[0].ObjectTypeIndex;
    do
    {
      if ( gbSupportExtendedSystemHandleInformation )
      {
        v4 = v3;
      }
      else
      {
        v4 = &dword_107BC0C;
        word_107BC1C = *(v2 - 5);
        dword_107BC18 = *v2;
        byte_107BC20 = *(v2 - 7);
        dword_107BC14 = *(v2 - 3);
        dword_107BC0C = *(v2 - 1);
        word_107BC1E = *(v2 - 8);
        dword_107BC10 = *(v2 - 6);
      }
      if ( v4[1] == a2 && !_wcsicmp(&gpszObjectTypeNames[64 * *(v4 + 9)], L"File") && sub_FDC4F0(v4, &v8, &v10, &v9) )
      {
        v5 = malloc(2192u);
        v5[11] = v10;
        v5[146] = v9;
        v5[10] = v8;
        v5[547] = v12;
        v12 = v5;
      }
      v3 += 7;
      v2 += 4;
      v6 = ++v11;
    }
    while ( v6 < sub_FDD9D0(pSystemHandleInfo) );
  }
  sub_FDC4F0(0, 0, 0, 0);
  return v12;
}
// 106ABA5: using guessed type char gbSupportExtendedSystemHandleInformation;
// 107BC0C: using guessed type int dword_107BC0C;
// 107BC10: using guessed type int dword_107BC10;
// 107BC14: using guessed type int dword_107BC14;
// 107BC18: using guessed type int dword_107BC18;
// 107BC1C: using guessed type __int16 word_107BC1C;
// 107BC1E: using guessed type __int16 word_107BC1E;
// 107BC20: using guessed type char byte_107BC20;

//----- (00FF3AF0) --------------------------------------------------------
BOOL __stdcall DlgThreadStack(HWND hWnd, UINT a2, WPARAM a3, LPARAM a4)
{
  HWND v4; // edi
  HICON v5; // eax
  CResizer *v6; // eax
  HWND v7; // ebx
  int v8; // ST14_4
  HWND v9; // eax
  POINT v10; // ST10_8
  int v12; // eax
  HWND v13; // eax
  HWND v14; // eax
  HWND v15; // eax
  int v16; // esi
  HWND v17; // eax
  LRESULT v18; // eax
  HGLOBAL v19; // ebx
  wchar_t *v20; // edi
  unsigned int v21; // esi
  rsize_t v22; // esi
  LRESULT v23; // esi
  HWND v24; // edi
  LPARAM lParam; // [esp+10h] [ebp-268h]
  int v26; // [esp+18h] [ebp-260h]
  int v27; // [esp+1Ch] [ebp-25Ch]
  int v28; // [esp+20h] [ebp-258h]
  wchar_t *v29; // [esp+24h] [ebp-254h]
  int v30; // [esp+28h] [ebp-250h]
  struct tagPOINT Point; // [esp+44h] [ebp-234h]
  UINT pnIDs; // [esp+4Ch] [ebp-22Ch]
  int v33; // [esp+50h] [ebp-228h]
  int v34; // [esp+54h] [ebp-224h]
  WORD pnWidths[2]; // [esp+58h] [ebp-220h]
  HWND v36; // [esp+5Ch] [ebp-21Ch]
  WPARAM wParam; // [esp+60h] [ebp-218h]
  HGLOBAL hMem; // [esp+64h] [ebp-214h]
  wchar_t Src; // [esp+68h] [ebp-210h]
  int v40; // [esp+274h] [ebp-4h]

  v4 = hWnd;
  hMem = hWnd;
  wParam = a4;
  pnIDs = 43;
  v33 = 44;
  pnWidths[0] = MulDiv(100, gLogPixelSize.x, 96);
  pnWidths[1] = MulDiv(100, gLogPixelSize.x, 96);
  if ( a2 > 0x111 )
  {
    if ( a2 == 2033 )
    {
      GetWindowRect(hWnd, &Rect);
      nWidth = Rect.right - Rect.left;
      nHeight = Rect.bottom - Rect.top;
      DestroyWindow(hWnd);
    }
    return 0;
  }
  if ( a2 == 273 )
  {
    if ( a3 > 40083 )
    {
      if ( a3 == 40631 )
      {
        v23 = 0;
        v24 = GetDlgItem(hWnd, 1087);
        if ( SendMessageW(v24, 0x1004u, 0, 0) > 0 )
        {
          do
          {
            v28 = 2;
            v27 = 2;
            SendMessageW(v24, 0x102Bu, v23++, &lParam);
          }
          while ( v23 < SendMessageW(v24, 0x1004u, 0, 0) );
        }
      }
    }
    else if ( a3 == 40083 )
    {
      v16 = 0;
      v17 = GetDlgItem(hWnd, 1087);
      v36 = v17;
      v18 = SendMessageW(v17, 0x100Cu, 0xFFFFFFFF, 2);
      v19 = hMem;
      wParam = v18;
      if ( v18 != -1 )
      {
        v20 = 0;
        do
        {
          v26 = 1;
          v29 = &Src;
          v30 = 256;
          SendMessageW(v36, 0x1073u, v18, &lParam);
          v21 = wcslen(&Src) + v16 + 2;
          v34 = v21;
          if ( v20 )
          {
            v19 = GlobalReAlloc(v19, 2 * v21 + 2, 0);
            v20 = GlobalLock(v19);
          }
          else
          {
            v19 = GlobalAlloc(0x2002u, 2 * v21 + 2);
            v20 = GlobalLock(v19);
            *v20 = 0;
          }
          v22 = v21 + 1;
          wcscat_s(v20, v22, &Src);
          wcscat_s(v20, v22, L"\r\n");
          GlobalUnlock(v19);
          v18 = SendMessageW(v36, 0x100Cu, wParam, 2);
          v16 = v34;
          wParam = v18;
        }
        while ( v18 != -1 );
        v4 = hMem;
      }
      if ( OpenClipboard(v4) )
      {
        EmptyClipboard();
        SetClipboardData(0xDu, v19);
        CloseClipboard();
      }
      SetFocus(v36);
    }
    else if ( a3 - 1 <= 1 )
    {
      ghWndThreadStack = 0;
      EndDialog(hWnd, 0);
    }
    return 0;
  }
  if ( a2 == 78 )
  {
    v12 = *(a4 + 8);
    if ( v12 == -101 || (v12 + 3) <= 1 )
    {
      v13 = GetDlgItem(hWnd, 1087);
      if ( SendMessageW(v13, 0x100Cu, 0xFFFFFFFF, 2) == -1 )
      {
        v15 = GetDlgItem(hWnd, 40083);
        EnableWindow(v15, 0);
      }
      else
      {
        v14 = GetDlgItem(hWnd, 40083);
        EnableWindow(v14, 1);
      }
    }
    return 0;
  }
  if ( a2 != 272 )
    return 0;
  v5 = LoadIconW(ghInstance, 0x65);
  SendMessageW(hWnd, 0x80u, 0, v5);
  v6 = operator new(0x40u);
  hMem = v6;
  v40 = 0;
  if ( v6 )
    CResizer::CResizer(v6, hWnd);
  v40 = -1;
  v7 = GetDlgItem(hWnd, 1087);
  sub_FB9BB0(v7, 2, &pnIDs, pnWidths, 0);
  v8 = wParam;
  v9 = GetDlgItem(hWnd, 1087);
  sub_FDB490(v9, v8);
  SendMessageW(v7, 0x101Eu, 0, 0xFFFF);
  SendMessageW(v7, 0x101Eu, 1u, 0xFFFF);
  v28 = 3;
  v27 = 3;
  SendMessageW(v7, 0x102Bu, 0, &lParam);
  SetFocus(v7);
  if ( nWidth )
  {
    MoveWindow(hWnd, Rect.left, Rect.top, nWidth, nHeight, 0);
  }
  else
  {
    GetCursorPos(&Point);
    v10.y = Point.y - 220;
    v10.x = Point.x - 350;
    PE_SetWindowPlacement(hWnd, v10);
  }
  ghWndThreadStack = hWnd;
  SetFocus(v7);
  ShowWindow(hWnd, 1);
  return 1;
}

//----- (00FF3FC0) --------------------------------------------------------
BOOL __stdcall DlgThreadStack(HWND hWnd, UINT a2, WPARAM a3, LPARAM dwNewLong)
{
  LONG v4; // edi
  HICON v5; // eax
  HWND v6; // esi
  CResizer *v7; // eax
  HWND v8; // esi
  LONG v9; // eax
  HWND v10; // eax
  HWND v11; // esi
  HWND v12; // eax
  int v14; // eax
  HWND v15; // ebx
  HWND v16; // eax
  HWND v17; // eax
  HWND v18; // eax
  HWND v19; // ebx
  HWND v20; // eax
  HWND v21; // ebx
  int v22; // esi
  wchar_t *v23; // ebx
  HWND v24; // eax
  LRESULT v25; // eax
  void *v26; // edi
  unsigned int v27; // esi
  rsize_t v28; // esi
  LRESULT v29; // esi
  HWND v30; // edi
  int v31; // esi
  wchar_t *v32; // ebx
  HWND v33; // eax
  LRESULT v34; // eax
  unsigned int v35; // esi
  rsize_t v36; // esi
  HANDLE v37; // ecx
  HWND v38; // ebx
  HWND v39; // eax
  HWND v40; // eax
  LPCONTEXT v41; // esi
  _DWORD *v42; // eax
  HWND v43; // ebx
  void *v44; // ecx
  int v45; // edx
  bool v46; // cf
  _DWORD *v47; // esi
  int v48; // eax
  char v49; // ST28_1
  HWND v50; // edi
  LRESULT v51; // eax
  int i; // eax
  int v53; // eax
  int v54; // ebx
  signed int v55; // edi
  PULONG *v56; // esi
  void *v57; // ecx
  ULONG *v58; // eax
  LPCONTEXT v59; // ecx
  PULONG v60; // eax
  CONTEXT *v61; // ebx
  signed int v62; // esi
  void *v63; // ecx
  ULONG *v64; // eax
  HWND v65; // esi
  HWND v66; // eax
  HWND v67; // eax
  DWORD v68; // eax
  char *v69; // esi
  unsigned int *v70; // ST20_4
  int v71; // eax
  int v72; // eax
  char v73; // ST20_1
  int v74; // eax
  HWND v75; // esi
  LRESULT v76; // eax
  HWND v77; // esi
  HWND v78; // eax
  HWND v79; // esi
  HWND v80; // edi
  HWND v81; // eax
  int v82; // [esp+0h] [ebp-EC0h]
  char v83; // [esp+10h] [ebp-EB0h]
  char v84; // [esp+44h] [ebp-E7Ch]
  DWORD BytesReturned; // [esp+2A0h] [ebp-C20h]
  LPARAM lParam; // [esp+2A4h] [ebp-C1Ch]
  int v87; // [esp+2ACh] [ebp-C14h]
  int v88; // [esp+2B0h] [ebp-C10h]
  int v89; // [esp+2B4h] [ebp-C0Ch]
  WCHAR *v90; // [esp+2B8h] [ebp-C08h]
  int v91; // [esp+2BCh] [ebp-C04h]
  UINT pnIDs; // [esp+2D8h] [ebp-BE8h]
  int v93; // [esp+2DCh] [ebp-BE4h]
  int v94; // [esp+2E0h] [ebp-BE0h]
  unsigned int v95; // [esp+2E4h] [ebp-BDCh]
  int v96; // [esp+2E8h] [ebp-BD8h]
  int v97; // [esp+2ECh] [ebp-BD4h]
  WORD pnWidths[2]; // [esp+2F0h] [ebp-BD0h]
  LPARAM v99; // [esp+2F4h] [ebp-BCCh]
  WPARAM wParam; // [esp+2F8h] [ebp-BC8h]
  int v101; // [esp+2FCh] [ebp-BC4h]
  int v102; // [esp+300h] [ebp-BC0h]
  int v103; // [esp+304h] [ebp-BBCh]
  WCHAR *v104; // [esp+308h] [ebp-BB8h]
  int v105; // [esp+310h] [ebp-BB0h]
  char *v106; // [esp+314h] [ebp-BACh]
  int v107; // [esp+328h] [ebp-B98h]
  PREAD_PROCESS_MEMORY_ROUTINE64 ReadMemoryRoutine; // [esp+32Ch] [ebp-B94h]
  char *v109; // [esp+330h] [ebp-B90h]
  char ArgList[4]; // [esp+334h] [ebp-B8Ch]
  void *v111; // [esp+338h] [ebp-B88h]
  char *v112; // [esp+33Ch] [ebp-B84h]
  int ThreadHandle; // [esp+340h] [ebp-B80h]
  LONG v114; // [esp+344h] [ebp-B7Ch]
  HWND v115; // [esp+348h] [ebp-B78h]
  char *v116; // [esp+34Ch] [ebp-B74h]
  LPCONTEXT lpContext; // [esp+350h] [ebp-B70h]
  HWND v118; // [esp+354h] [ebp-B6Ch]
  HWND v119; // [esp+358h] [ebp-B68h]
  HWND hDlg; // [esp+35Ch] [ebp-B64h]
  struct _tagSTACKFRAME64 StackFrame; // [esp+360h] [ebp-B60h]
  char v122; // [esp+468h] [ebp-A58h]
  char v123; // [esp+49Ch] [ebp-A24h]
  struct tagRECT Rect; // [esp+6F8h] [ebp-7C8h]
  DWORD OutBuffer; // [esp+708h] [ebp-7B8h]
  DWORD v126; // [esp+70Ch] [ebp-7B4h]
  DWORD v127; // [esp+710h] [ebp-7B0h]
  char v128; // [esp+723h] [ebp-79Dh]
  WCHAR String; // [esp+CACh] [ebp-214h]
  int *v130; // [esp+EB0h] [ebp-10h]
  int v131; // [esp+EBCh] [ebp-4h]

  v130 = &v82;
  hDlg = hWnd;
  v4 = GetWindowLongW(hWnd, -21);
  v109 = 0;
  v114 = v4;
  v116 = 0;
  lpContext = (&v128 & 0xFFFFFFF0);
  v99 = 0;
  memset(&wParam, 0, 0x30u);
  v118 = GetDlgItem(hWnd, 1087);
  pnIDs = 43;
  v93 = 44;
  pnWidths[0] = MulDiv(100, gLogPixelSize.x, 96);
  pnWidths[1] = MulDiv(100, gLogPixelSize.x, 96);
  ReadMemoryRoutine = 0;
  if ( a2 > 0x111 )
  {
    if ( a2 == 2033 )
    {
      DestroyWindow(hDlg);
      return 0;
    }
    if ( a2 != 2042 )
      return 0;
    memset(&v83, 0, 0x290u);
    if ( NtSuspendThread(v37, *(v4 + 8)) )
    {
      v38 = hDlg;
      EndDialog(hDlg, 0);
      MessageBoxW(v38, L"Error accessing thread.", L"Process Explorer", 0x10u);
      v39 = GetParent(v38);
      SetFocus(v39);
      v40 = GetDlgItem(v38, 1210);
      EnableWindow(v40, 0);
      return 0;
    }
    v41 = lpContext;
    GetThreadContext(*(v4 + 8), lpContext);
    EnterCriticalSection(&gProcThreadsLock);
    *ArgList = 0;
    v115 = 0;
    v131 = 1;
    v42 = operator new(0x28u);
    v111 = v42;
    LOBYTE(v131) = 2;
    if ( v42 )
      v43 = sub_FC75A0(v42);
    else
      v43 = 0;
    v119 = v43;
    LOBYTE(v131) = 1;
    v115 = v43;
    if ( sub_FC8940(v43, v4) == 1 && sub_FC8D10(v43, *(v4 + 4)) == 1 )
    {
      v94 = 0;
      v95 = 0;
      v96 = 0;
      v97 = 0;
      LOBYTE(v131) = 3;
      v112 = sub_FCB0A0(v43, *(v4 + 4), &v94);
      if ( v112 == 1 )
      {
        v45 = 0;
        v116 = 0;
        if ( v95 > 0 )
        {
          v46 = v95 > 0;
          while ( 1 )
          {
            if ( !v46 )
              ATL::AtlThrowImpl(-2147024809);
            v47 = *(v94 + 4 * v45);
            v111 = v47;
            if ( v47 )
              (*(*v47 + 4))(v47);
            LOBYTE(v131) = 4;
            v48 = wcscmp(sub_FC7F60(v47), L"0x0");
            if ( v48 )
              v48 = -(v48 < 0) | 1;
            if ( v48 )
            {
              v49 = ArgList[0];
              v99 = 5;
              wParam = 0x7FFFFFFF;
              v101 = 0;
              v103 = 0;
              v102 = 0;
              ++*ArgList;
              wsprintf(&String, L"%d", v49);
              v50 = v118;
              v104 = &String;
              v105 = 0;
              v106 = v116 + 1;
              v51 = SendMessageW(v118, 0x104Du, 0, &v99);
              if ( v51 == -1 )
              {
                LOBYTE(v131) = 3;
                if ( v47 )
                  (*(*v47 + 8))(v47);
                sub_FD9F20(&v94);
LABEL_77:
                v131 = -1;
                if ( v43 )
                  (*(*v43 + 8))(v43);
                return 0;
              }
              v99 = 1;
              wParam = v51;
              v101 = 1;
              v104 = sub_FC7F60(v47);
              SendMessageW(v50, 0x104Cu, 0, &v99);
            }
            LOBYTE(v131) = 3;
            if ( v47 )
              (*(*v47 + 8))(v47);
            v45 = (v116 + 1);
            v116 = v45;
            v46 = v45 < v95;
            if ( v45 >= v95 )
            {
              v4 = v114;
              v41 = lpContext;
              break;
            }
          }
        }
      }
      LOBYTE(v131) = 1;
      sub_FD9F20(&v94);
      if ( v112 )
      {
LABEL_104:
        NtResumeThread(v44, *(v4 + 8));
        LeaveCriticalSection(&gProcThreadsLock);
        if ( !&v116[v109] )
        {
          v77 = hDlg;
          EndDialog(hDlg, 0);
          MessageBoxW(
            0,
            L"Cannot access stack information. The stack may be swapped out, Process Explorer cannot access the support in"
             " the Windows Debugging Tools, or you previously ran an old version of Process Explorer and must reboot.",
            L"Process Explorer",
            0x10u);
          v78 = GetParent(v77);
          SetFocus(v78);
          goto LABEL_77;
        }
        v79 = v118;
        SendMessageW(v118, 0x101Eu, 0, 0xFFFF);
        SendMessageW(v79, 0x101Eu, 1u, 0xFFFF);
        v89 = 3;
        v88 = 3;
        SendMessageW(v79, 0x102Bu, 0, &lParam);
        SetFocus(v79);
        v80 = hDlg;
        if ( gConfig.WindowPlacement[5].rcNormalPosition.right == gConfig.WindowPlacement[5].rcNormalPosition.left )
          GetWindowRect(hDlg, &Rect);
        else
          _mm_storeu_si128(&Rect, _mm_loadu_si128(&gConfig.WindowPlacement[5].rcNormalPosition));
        v81 = GetDlgItem(v80, 1210);
        EnableWindow(v81, 1);
        ghWndThreadStack = v80;
        SetFocus(v118);
        ShowWindow(v80, 1);
        v131 = -1;
        if ( v43 )
          (*(*v43 + 8))(v43);
        return 1;
      }
    }
    for ( i = 0; ; i = v107 + 1 )
    {
LABEL_67:
      v107 = i;
      if ( i >= 2 )
        goto LABEL_104;
      v109 = v116;
      v111 = v116;
      memset(v41, 0, 0x2CCu);
      v53 = v107;
      v41->ContextFlags = 65537;
      if ( v53 )
      {
        if ( v53 != 1 )
          goto LABEL_87;
        v61 = lpContext;
        v62 = 0;
        do
        {
          if ( GetThreadContext(*(v4 + 8), v61) )
            break;
          NtResumeThread(v63, *(v4 + 8));
          CloseHandle(*(v4 + 8));
          v64 = Fake_OpenThread(*(v4 + 4), 0x4Au);
          *(v4 + 8) = v64;
          if ( !v64 )
            break;
          NtSuspendThread(&ThreadHandle, v64);
          ++v62;
        }
        while ( v62 < 2 );
        v41 = lpContext;
        ReadMemoryRoutine = 0;
      }
      else
      {
        v54 = v114;
        v55 = 0;
        v56 = (v114 + 8);
        do
        {
          if ( DeviceIoControl(ghDriverHandle, 0x83350028, v56, 4u, &OutBuffer, 0xCu, &BytesReturned, 0) )
            break;
          NtResumeThread(v57, *v56);
          CloseHandle(*v56);
          v58 = Fake_OpenThread(*(v54 + 4), 2u);
          *v56 = v58;
          if ( !v58 )
            break;
          NtSuspendThread(&ThreadHandle, v58);
          Sleep(0x64u);
          ++v55;
        }
        while ( v55 < 2 );
        v59 = lpContext;
        v4 = v114;
        ReadMemoryRoutine = sub_FF0640;
        lpContext->Eip = OutBuffer;
        v59->Esp = v126;
        v59->Ebp = v127;
        v60 = *v56;
        v41 = v59;
        dword_106AB88 = v60;
      }
      v43 = v119;
LABEL_87:
      if ( !*(v4 + 8) )
      {
        v65 = hDlg;
        EndDialog(hDlg, 0);
        MessageBoxW(0, L"Error opening thread for stack trace.", L"Process Explorer", 0x10u);
        v66 = GetParent(v65);
        SetFocus(v66);
        v67 = GetDlgItem(v65, 1210);
        EnableWindow(v67, 0);
        goto LABEL_77;
      }
      memset(&StackFrame, 0, 0x108u);
      v44 = v41->Eip;
      StackFrame.AddrStack.Offset = v41->Esp;
      v68 = v41->Ebp;
      v69 = 0;
      StackFrame.AddrPC.Offset = v44;
      StackFrame.AddrPC.Mode = 3;
      StackFrame.AddrStack.Mode = 3;
      StackFrame.AddrFrame.Offset = v68;
      StackFrame.AddrFrame.Mode = 3;
      StackFrame.AddrBStore.Offset = v68;
      StackFrame.AddrBStore.Mode = 3;
      while ( 1 )
      {
        v112 = v69;
        v116 = v69;
        if ( v69 >= 100 )
          break;
        v70 = *(v4 + 16);
        LOBYTE(v131) = 5;
        sub_FDDD60(1, v44, &v122, *(v4 + 12), 0, 0, *(v4 + 20), v70);
        if ( !StackWalk64(
                0x14Cu,
                *(v4 + 12),
                *(v4 + 8),
                &StackFrame,
                lpContext,
                ReadMemoryRoutine,
                SymFunctionTableAccess64,
                SymGetModuleBase64,
                0) )
        {
          v41 = lpContext;
          i = v107 + 1;
          LOBYTE(v131) = 1;
          goto LABEL_67;
        }
        v44 = StackFrame.AddrPC.Offset;
        v131 = 1;
        if ( !StackFrame.AddrPC.Offset )
          break;
        sub_FDDD60(1, StackFrame.AddrPC.Offset, &v122, *(v4 + 12), 0, 0, *(v4 + 20), *(v4 + 16));
        v71 = wcscmp(&v123, L"0x0");
        if ( v71 )
          v71 = -(v71 < 0) | 1;
        if ( v71 )
        {
          v72 = wcscmp(&v123, &v84);
          if ( v72 )
            v72 = -(v72 < 0) | 1;
          if ( v72 )
          {
            v73 = ArgList[0];
            v99 = 5;
            wParam = 0x7FFFFFFF;
            v101 = 0;
            v103 = 0;
            v102 = 0;
            ++*ArgList;
            wsprintf(&String, L"%d", v73);
            v104 = &String;
            v74 = (v69 + 1);
            v105 = 0;
            v75 = v118;
            v106 = v74;
            v76 = SendMessageW(v118, 0x104Du, 0, &v99);
            if ( v76 == -1 )
              goto LABEL_77;
            wParam = v76;
            v104 = &v123;
            v99 = 1;
            v101 = 1;
            SendMessageW(v75, 0x104Cu, 0, &v99);
            qmemcpy(&v83, &v122, 0x290u);
            v4 = v114;
            v69 = v116;
          }
        }
        v44 = StackFrame.AddrPC.Offset;
        ++v69;
      }
      v41 = lpContext;
    }
  }
  if ( a2 == 273 )
  {
    if ( a3 > 40083 )
    {
      if ( a3 != 40084 )
      {
        if ( a3 == 40631 )
        {
          v29 = 0;
          v30 = GetDlgItem(hDlg, 1087);
          if ( SendMessageW(v30, 0x1004u, 0, 0) > 0 )
          {
            do
            {
              v89 = 2;
              v88 = 2;
              SendMessageW(v30, 0x102Bu, v29++, &lParam);
            }
            while ( v29 < SendMessageW(v30, 0x1004u, 0, 0) );
          }
        }
        return 0;
      }
      v31 = 0;
      wParam = -1;
      v32 = 0;
      v33 = GetDlgItem(hDlg, 1087);
      v119 = v33;
      v34 = SendMessageW(v33, 0x100Cu, wParam, 0);
      v26 = v119;
      for ( wParam = v34; v34 != -1; wParam = v34 )
      {
        v87 = 1;
        v90 = &String;
        v91 = 256;
        SendMessageW(v119, 0x1073u, v34, &lParam);
        v35 = wcslen(&String) + v31 + 2;
        v115 = v35;
        if ( v32 )
        {
          v26 = GlobalReAlloc(v26, 2 * v35 + 2, 0);
          v32 = GlobalLock(v26);
        }
        else
        {
          v26 = GlobalAlloc(0x2002u, 2 * v35 + 2);
          v32 = GlobalLock(v26);
          *v32 = 0;
        }
        v36 = v35 + 1;
        wcscat_s(v32, v36, &String);
        wcscat_s(v32, v36, L"\r\n");
        GlobalUnlock(v26);
        v34 = SendMessageW(v119, 0x100Cu, wParam, 0);
        v31 = v115;
      }
    }
    else
    {
      if ( a3 != 40083 )
      {
        if ( a3 > 0 )
        {
          if ( a3 <= 2 )
          {
            v21 = hDlg;
            GetWindowPlacement(hDlg, &gConfig.WindowPlacement[5]);
            ghWndThreadStack = 0;
            EndDialog(v21, 0);
          }
          else if ( a3 == 1210 )
          {
            v19 = hDlg;
            v20 = GetDlgItem(hDlg, 1210);
            EnableWindow(v20, 0);
            SendMessageW(v118, 0x1009u, 0, 0);
            SendMessageW(v19, 0x7FAu, 0, 0);
          }
        }
        return 0;
      }
      v22 = 0;
      wParam = -1;
      v23 = 0;
      v24 = GetDlgItem(hDlg, 1087);
      v119 = v24;
      v25 = SendMessageW(v24, 0x100Cu, wParam, 2);
      v26 = v119;
      for ( wParam = v25; v25 != -1; wParam = v25 )
      {
        v87 = 1;
        v90 = &String;
        v91 = 256;
        SendMessageW(v119, 0x1073u, v25, &lParam);
        v27 = wcslen(&String) + v22 + 2;
        v115 = v27;
        if ( v23 )
        {
          v26 = GlobalReAlloc(v26, 2 * v27 + 2, 0);
          v23 = GlobalLock(v26);
        }
        else
        {
          v26 = GlobalAlloc(0x2002u, 2 * v27 + 2);
          v23 = GlobalLock(v26);
          *v23 = 0;
        }
        v28 = v27 + 1;
        wcscat_s(v23, v28, &String);
        wcscat_s(v23, v28, L"\r\n");
        GlobalUnlock(v26);
        v25 = SendMessageW(v119, 0x100Cu, wParam, 2);
        v22 = v115;
      }
    }
    if ( OpenClipboard(hDlg) )
    {
      EmptyClipboard();
      SetClipboardData(0xDu, v26);
      CloseClipboard();
    }
    SetFocus(v119);
    return 0;
  }
  if ( a2 == 78 )
  {
    v14 = *(dwNewLong + 8);
    if ( v14 == -101 || (v14 + 3) <= 1 )
    {
      v15 = hDlg;
      v16 = GetDlgItem(hDlg, 1087);
      if ( SendMessageW(v16, 0x100Cu, 0xFFFFFFFF, 2) == -1 )
      {
        v18 = GetDlgItem(v15, 40083);
        EnableWindow(v18, 0);
      }
      else
      {
        v17 = GetDlgItem(v15, 40083);
        EnableWindow(v17, 1);
      }
    }
    return 0;
  }
  if ( a2 != 272 )
    return 0;
  v5 = LoadIconW(ghInstance, 0x65);
  v6 = hDlg;
  SendMessageW(hDlg, 0x80u, 0, v5);
  v7 = operator new(0x40u);
  v111 = v7;
  v131 = 0;
  if ( v7 )
    CResizer::CResizer(v7, v6);
  v8 = v118;
  v9 = GetWindowLongW(v118, -16);
  SetWindowLongW(v8, -16, v9 & 0xFFFFFFFD | 1);
  SetWindowLongW(v118, -21, 2);
  SendMessageW(v118, 0x1036u, 0x4020u, 16416);
  v10 = SendMessageW(v118, 0x104Eu, 0, 0);
  CTreeList::InitToolTips(v10);
  gOldListWndProc = SetWindowLongW(v118, -4, Proxy_ListCtrlWndProc);
  SendMessageW(v118, 0x30u, ghConfigFont, 0);
  CTreeView::InitListHeader(v118, &pnIDs, pnWidths, 2u);
  SetWindowLongW(hDlg, -21, dwNewLong);
  wsprintf(&String, L"Stack for thread %d", *(dwNewLong + 4));
  v11 = hDlg;
  SetWindowTextW(hDlg, &String);
  gConfig.WindowPlacement[5].showCmd = 5;
  SetWindowPlacement(v11, &gConfig.WindowPlacement[5]);
  if ( GetCurrentProcessId() == *dwNewLong )
  {
    EndDialog(v11, 0);
    MessageBoxW(0, L"Thread stack not available for Process Explorer.", L"Process Explorer", 0x10u);
    v12 = GetParent(v11);
    SetFocus(v12);
    return 0;
  }
  SendMessageW(v11, 0x7FAu, 0, 0);
  return 1;
}
// 1045208: using guessed type wchar_t a0x0[4];
// 106AB88: using guessed type int dword_106AB88;

//----- (00FF5020) --------------------------------------------------------
void __noreturn ATL::CSimpleStringT<wchar_t,0>::ThrowMemoryException()
{
  ATL::AtlThrowImpl(E_OUTOFMEMORY);
}

//----- (00FF5030) --------------------------------------------------------
BOOL __stdcall EnumChildrenWindows(HWND hWnd, LPARAM dwPId)
{
  HWND v2; // eax
  DWORD dwProcessId; // [esp+8h] [ebp-208h]
  WCHAR szText[256]; // [esp+Ch] [ebp-204h]

  if ( GetParent(hWnd) )
  {
    if ( !GetParent(hWnd) )
      return 1;
    v2 = GetParent(hWnd);
    if ( IsWindowVisible(v2) )
      return 1;
  }
  if ( !IsWindowVisible(hWnd) )
    return 1;
  GetWindowThreadProcessId(hWnd, &dwProcessId);
  if ( dwProcessId != dwPId )
    return 1;
  GetWindowTextW(hWnd, szText, 256);
  if ( !szText[0] )
    return 1;
  if ( gbWindowTextFlags )
  {
    *gpszWindowText = 0;
  }
  else
  {
    gbWindowTextFlags = 1;
    wcsncpy_s(gpszWindowText, gdwWindowTextLength, szText, 0xFFFFFFFF);
    ghMainWndBackup = hWnd;
  }
  return 0;
}
// 107BA5C: using guessed type char gbWindowTextFlags;

//----- (00FF5140) --------------------------------------------------------
signed int __usercall sub_FF5140@<eax>(int a1@<ebx>, int a2, _BYTE *a3)
{
  HANDLE v3; // eax
  int v5; // [esp+4h] [ebp-234h]
  PROCESSENTRY32W pe; // [esp+8h] [ebp-230h]

  pe.dwSize = 0;
  memset(&pe.cntUsage, 0, 0x228u);
  if ( hSnapshot != -1 )
    CloseHandle(hSnapshot);
  v3 = CreateToolhelp32Snapshot_0(2u, 0);
  hSnapshot = v3;
  if ( v3 == -1 )
    return 0;
  pe.dwSize = 556;
  if ( !Process32FirstW_0(v3, &pe) )
    return 0;
  do
  {
    if ( a3 && *a3 == 1 )
      break;
    sub_FEF870(a1, a2, a3, 0, pe.th32ProcessID, 0, pe.szExeFile, &v5);
  }
  while ( Process32NextW_0(hSnapshot, &pe) );
  return 1;
}

//----- (00FF5230) --------------------------------------------------------
errno_t __cdecl sub_FF5230(wchar_t *Dst, rsize_t SizeInWords, int a3)
{
  return wcsncpy_s(Dst, SizeInWords, *(a3 + 4), *a3 >> 1);
}

//----- (00FF5250) --------------------------------------------------------
int __cdecl sub_FF5250(int *a1)
{
  int v1; // eax
  __m128i v2; // xmm0
  int v3; // ST0C_4
  _DWORD *v4; // ecx
  int v5; // eax
  unsigned __int8 v6; // cf
  int result; // eax
  int v8; // eax
  int v9; // [esp+0h] [ebp-70h]
  __int128 v10; // [esp+8h] [ebp-68h]
  __int128 v11; // [esp+18h] [ebp-58h]
  __int128 v12; // [esp+28h] [ebp-48h]
  __int128 v13; // [esp+38h] [ebp-38h]
  __int128 v14; // [esp+48h] [ebp-28h]
  __int128 v15; // [esp+58h] [ebp-18h]
  _DWORD *v16; // [esp+68h] [ebp-8h]

  *&v13 = 0i64;
  *(&v13 + 1) = 0i64;
  *&v14 = 0i64;
  v1 = *a1;
  *(&v14 + 1) = 0i64;
  *&v15 = 0i64;
  *(&v15 + 1) = 0i64;
  v2 = _mm_loadu_si128(&v13);
  v9 = v1;
  v3 = byte_107BC00;
  _mm_storeu_si128(&v10, v2);
  _mm_storeu_si128(&v11, _mm_loadu_si128(&v14));
  _mm_storeu_si128(&v12, _mm_loadu_si128(&v15));
  sub_FD9C10(&gMap2, &v16, 0, &v9, v3);
  v4 = v16;
  if ( a1[2] == 10 )
  {
    v8 = a1[8];
    v6 = __CFADD__(v8, v16[6]);
    v16[6] += v8;
    result = a1[9];
    v4[7] += result + v6;
    v6 = __CFADD__(v4[12]++, 1);
    v4[13] += v6;
  }
  else
  {
    v5 = a1[8];
    if ( a1[2] == 11 )
    {
      v6 = __CFADD__(v5, v16[8]);
      v16[8] += v5;
      result = a1[9];
      v4[9] += result + v6;
      v6 = __CFADD__(v4[14]++, 1);
      v4[15] += v6;
    }
    else
    {
      v6 = __CFADD__(v5, v16[10]);
      v16[10] += v5;
      result = a1[9];
      v4[11] += result + v6;
      v6 = __CFADD__(v4[16]++, 1);
      v4[17] += v6;
    }
  }
  return result;
}
// 107BC00: using guessed type char byte_107BC00;

//----- (00FF5310) --------------------------------------------------------
int __cdecl sub_FF5310(int *a1)
{
  int v1; // eax
  __m128i v2; // xmm0
  int v3; // ST0C_4
  _DWORD *v4; // ecx
  int result; // eax
  unsigned __int8 v6; // cf
  int v7; // [esp+0h] [ebp-70h]
  __int128 v8; // [esp+8h] [ebp-68h]
  __int128 v9; // [esp+18h] [ebp-58h]
  __int128 v10; // [esp+28h] [ebp-48h]
  __int128 v11; // [esp+38h] [ebp-38h]
  __int128 v12; // [esp+48h] [ebp-28h]
  __int128 v13; // [esp+58h] [ebp-18h]
  _DWORD *v14; // [esp+68h] [ebp-8h]

  *&v11 = 0i64;
  *(&v11 + 1) = 0i64;
  *&v12 = 0i64;
  v1 = *a1;
  *(&v12 + 1) = 0i64;
  *&v13 = 0i64;
  *(&v13 + 1) = 0i64;
  v2 = _mm_loadu_si128(&v11);
  v7 = v1;
  v3 = byte_107BC00;
  _mm_storeu_si128(&v8, v2);
  _mm_storeu_si128(&v9, _mm_loadu_si128(&v12));
  _mm_storeu_si128(&v10, _mm_loadu_si128(&v13));
  sub_FD9C10(&gMap3, &v14, 0, &v7, v3);
  v4 = v14;
  if ( a1[2] == 2 )
  {
    result = a1[7];
    v6 = __CFADD__(result, v14[8]);
    v14[8] += result;
    v4[9] += v6;
    ++*(v4 + 7);
  }
  else
  {
    result = a1[7];
    if ( a1[2] == 3 )
    {
      v6 = __CFADD__(result, v14[6]);
      v14[6] += result;
      v4[7] += v6;
      ++*(v4 + 6);
    }
    else
    {
      v6 = __CFADD__(result, v14[10]);
      v14[10] += result;
      v4[11] += v6;
      ++*(v4 + 8);
    }
  }
  return result;
}
// 107BC00: using guessed type char byte_107BC00;

//----- (00FF53D0) --------------------------------------------------------
void __cdecl sub_FF53D0(wchar_t *a1, int a2, wchar_t *a3)
{
  _DWORD *v3; // esi

  EnterCriticalSection(&gProcThreadsLock);
  if ( !sub_FE0D70(a1) )
  {
    v3 = malloc(0x10u);
    *v3 = _wcsdup(a1);
    v3[2] = a2;
    v3[1] = _wcsdup(a3);
    v3[3] = dword_106B1DC;
    dword_106B1DC = v3;
  }
  LeaveCriticalSection(&gProcThreadsLock);
}
// 106B1DC: using guessed type int dword_106B1DC;

//----- (00FF5440) --------------------------------------------------------
_DWORD *sub_FF5440()
{
  _DWORD *result; // eax

  result = operator new(0x48u);
  JUMPOUT(result, 0, std::_Xbad_alloc);
  *result = result;
  if ( result != -4 )
    result[1] = result;
  if ( result != -8 )
    result[2] = result;
  *(result + 6) = 257;
  return result;
}

//----- (00FF5470) --------------------------------------------------------
_DWORD *__thiscall sub_FF5470(_DWORD *this)
{
  _DWORD *v1; // esi
  _DWORD *v2; // edx

  v1 = this;
  v2 = operator new(0x48u);
  if ( !v2 )
    std::_Xbad_alloc();
  *v2 = *v1;
  if ( v2 != -4 )
    v2[1] = *v1;
  if ( v2 != -8 )
    v2[2] = *v1;
  return v2;
}

//----- (00FF54B0) --------------------------------------------------------
std__Tree_node *__thiscall sub_FF54B0(std__tree *this, std__Tree_node *_Node)
{
  std__Tree_node_For__bstr_t *_Right; // esi
  std__Tree_node *result; // eax

  _Right = _Node->_Right;
  _Node->_Right = _Right->_Left;
  if ( !_Right->_Left->_IsNil )
    _Right->_Left->_Parent = _Node;
  _Right->_Parent = _Node->_Parent;
  result = this->_Mypair._Myval2._Myhead;
  if ( _Node == this->_Mypair._Myval2._Myhead->_Parent )
  {
    result->_Parent = _Right;
    _Right->_Left = _Node;
    _Node->_Parent = _Right;
  }
  else
  {
    result = _Node->_Parent;
    if ( _Node == result->_Left )
      result->_Left = _Right;
    else
      result->_Right = _Right;
    _Right->_Left = _Node;
    _Node->_Parent = _Right;
  }
  return result;
}

//----- (00FF5510) --------------------------------------------------------
int **__thiscall sub_FF5510(CSystemProcessInfoMap *this, int **a2, CSystemProcessInfoMapNode *a3, int *a4)
{
  CSystemProcessInfoMapNode *v4; // eax
  CSystemProcessInfoMap *v5; // edi
  int **result; // eax
  CSystemProcessInfoMapNode *v7; // ecx
  CSystemProcessInfoMapNode *i; // edx
  CSystemProcessInfoMapNode *v9; // eax
  int a2a; // [esp+8h] [ebp-4h]

  v4 = a3;
  v5 = this;
  if ( a3 != this->_Header->_Left || a4 != this->_Header )
  {
    for ( ; a3 != a4; v4 = a3 )
    {
      v7 = v4;
      if ( !v4->baseclass._isnil )
      {
        i = v4->baseclass._Right;
        if ( i->baseclass._isnil )
        {
          for ( i = v4->baseclass._Parent; !i->baseclass._isnil; i = i->baseclass._Parent )
          {
            if ( v4 != i->baseclass._Right )
              break;
            v4 = i;
          }
        }
        else
        {
          v9 = i->baseclass._Left;
          if ( !i->baseclass._Left->baseclass._isnil )
          {
            do
            {
              i = v9;
              v9 = v9->baseclass._Left;
            }
            while ( !v9->baseclass._isnil );
          }
        }
        a3 = i;
      }
      sub_FF55B0(v5, &a2a, v7);
    }
    *a2 = v4;
    result = a2;
  }
  else
  {
    sub_FCE620(this);
    result = a2;
    *a2 = v5->_Header->_Left;
  }
  return result;
}

//----- (00FF55B0) --------------------------------------------------------
_DWORD *__thiscall sub_FF55B0(CSystemProcessInfoMap *this, _DWORD *a2, _DWORD *a3)
{
  std__tree *v3; // ebx
  _BYTE *v4; // ecx
  std__Tree_node *v5; // edi
  std__Tree_node *v6; // edx
  std__Tree_node *v7; // esi
  std__Tree_node *v8; // eax
  std__Tree_node *v9; // edx
  std__Tree_node *v10; // eax
  std__Tree_node_For__bstr_t *v11; // eax
  std__Tree_node_For__bstr_t *i; // edx
  std__Tree_node **v13; // eax
  bool v14; // cl
  std__Tree_node *v15; // ecx
  unsigned int v16; // eax
  _DWORD *v17; // ecx
  _DWORD *result; // eax
  _DWORD *v19; // [esp+10h] [ebp-4h]

  v3 = this;
  v19 = a3;
  sub_F94CE0(&a3);
  v4 = v19;
  if ( *(*v19 + 13) )
  {
    v5 = v19[2];
  }
  else if ( *(v19[2] + 13) )
  {
    v5 = *v19;
  }
  else
  {
    v6 = a3;
    v5 = a3[2];
    if ( a3 != v19 )
    {
      *(*v19 + 4) = a3;
      v6->_Left = *v19;
      if ( v6 == v19[2] )
      {
        v7 = v6;
      }
      else
      {
        v7 = v6->_Parent;
        if ( !v5->_IsNil )
          v5->_Parent = v7;
        v7->_Left = v5;
        v6->_Right = v19[2];
        *(v19[2] + 4) = v6;
      }
      if ( v3->_Mypair._Myval2._Myhead->_Parent == v19 )
      {
        v3->_Mypair._Myval2._Myhead->_Parent = v6;
      }
      else
      {
        v13 = v19[1];
        if ( *v13 == v19 )
          *v13 = v6;
        else
          v13[2] = v6;
      }
      v6->_Parent = v19[1];
      v14 = v6->_Color;
      v6->_Color = *(v19 + 12);
      *(v19 + 12) = v14;
      v4 = v19;
      goto LABEL_37;
    }
  }
  v7 = v19[1];
  if ( !v5->_IsNil )
    v5->_Parent = v7;
  if ( v3->_Mypair._Myval2._Myhead->_Parent == v19 )
  {
    v3->_Mypair._Myval2._Myhead->_Parent = v5;
  }
  else if ( v7->_Left == v19 )
  {
    v7->_Left = v5;
  }
  else
  {
    v7->_Right = v5;
  }
  v8 = v3->_Mypair._Myval2._Myhead;
  if ( &v3->_Mypair._Myval2._Myhead->_Left->_Left == v19 )
  {
    if ( v5->_IsNil )
    {
      v9 = v7;
    }
    else
    {
      v10 = v5->_Left;
      v9 = v5;
      if ( !v5->_Left->_IsNil )
      {
        do
        {
          v9 = v10;
          v10 = v10->_Left;
        }
        while ( !v10->_IsNil );
      }
      v8 = v3->_Mypair._Myval2._Myhead;
    }
    v8->_Left = v9;
  }
  if ( v3->_Mypair._Myval2._Myhead->_Right == v19 )
  {
    if ( v5->_IsNil )
    {
      v3->_Mypair._Myval2._Myhead->_Right = v7;
    }
    else
    {
      v11 = v5->_Right;
      for ( i = v5; !v11->_IsNil; v11 = v11->_Right )
        i = v11;
      v3->_Mypair._Myval2._Myhead->_Right = i;
    }
  }
LABEL_37:
  if ( v4[12] != 1 )
    goto LABEL_62;
  if ( v5 == v3->_Mypair._Myval2._Myhead->_Parent )
    goto LABEL_61;
  while ( v5->_Color == 1 )
  {
    v15 = v7->_Left;
    if ( v5 == v7->_Left )
    {
      v15 = v7->_Right;
      if ( !v15->_Color )
      {
        v15->_Color = 1;
        v7->_Color = 0;
        sub_FF54B0(v3, v7);
        v15 = v7->_Right;
      }
      if ( v15->_IsNil )
        goto LABEL_55;
      if ( v15->_Left->_Color != 1 || v15->_Right->_Color != 1 )
      {
        if ( v15->_Right->_Color == 1 )
        {
          v15->_Left->_Color = 1;
          v15->_Color = 0;
          sub_1002BB0(v3, v15);
          v15 = v7->_Right;
        }
        v15->_Color = v7->_Color;
        v7->_Color = 1;
        v15->_Right->_Color = 1;
        sub_FF54B0(v3, v7);
        break;
      }
    }
    else
    {
      if ( !v15->_Color )
      {
        v15->_Color = 1;
        v7->_Color = 0;
        sub_1002BB0(v3, v7);
        v15 = v7->_Left;
      }
      if ( v15->_IsNil )
        goto LABEL_55;
      if ( v15->_Right->_Color != 1 || v15->_Left->_Color != 1 )
      {
        if ( v15->_Left->_Color == 1 )
        {
          v15->_Right->_Color = 1;
          v15->_Color = 0;
          sub_FF54B0(v3, v15);
          v15 = v7->_Left;
        }
        v15->_Color = v7->_Color;
        v7->_Color = 1;
        v15->_Left->_Color = 1;
        sub_1002BB0(v3, v7);
        break;
      }
    }
    v15->_Color = 0;
LABEL_55:
    v5 = v7;
    v7 = v7->_Parent;
    if ( v5 == v3->_Mypair._Myval2._Myhead->_Parent )
      break;
  }
  v4 = v19;
LABEL_61:
  v5->_Color = 1;
LABEL_62:
  j__free(v4);
  v16 = v3->_Mypair._Myval2._Mysize;
  v17 = a3;
  if ( v16 )
    v3->_Mypair._Myval2._Mysize = v16 - 1;
  result = a2;
  *a2 = v17;
  return result;
}

//----- (00FF5820) --------------------------------------------------------
_DWORD *__thiscall sub_FF5820(int *this, _DWORD *a2, unsigned int *a3)
{
  int v3; // esi
  int v4; // ecx
  int v5; // eax
  unsigned int v6; // eax
  _DWORD *result; // eax
  int v8; // [esp+14h] [ebp+Ch]

  v3 = *this;
  v4 = v3;
  v5 = *(v3 + 4);
  while ( !*(v5 + 13) )
  {
    if ( *(v5 + 16) >= *a3 )
    {
      v4 = v5;
      v5 = *v5;
    }
    else
    {
      v5 = *(v5 + 8);
    }
  }
  if ( v4 == v3 || (v6 = *a3, v8 = v4, v6 < *(v4 + 16)) )
    v8 = v3;
  result = a2;
  *a2 = v8;
  return result;
}

//----- (00FF5870) --------------------------------------------------------
HANDLE __cdecl Fake_OpenThread(HANDLE ThreadHandle, ACCESS_MASK DesiredAccess)
{
  int v2; // eax
  HANDLE v3; // ecx
  struct _OBJECT_ATTRIBUTES ObjectAttributes; // [esp+0h] [ebp-20h]
  struct _CLIENT_ID ClientId; // [esp+18h] [ebp-8h]

  ClientId.UniqueThread = ThreadHandle;
  ClientId.UniqueProcess = 0;
  ObjectAttributes.Length = 24;
  ObjectAttributes.RootDirectory = 0;
  ObjectAttributes.Attributes = 0;
  ObjectAttributes.ObjectName = 0;
  ObjectAttributes.SecurityDescriptor = 0;
  ObjectAttributes.SecurityQualityOfService = 0;
  v2 = NtOpenThread(&ThreadHandle, DesiredAccess, &ObjectAttributes, &ClientId);
  v3 = 0;
  if ( !v2 )
    v3 = ThreadHandle;
  return v3;
}

//----- (00FF58D0) --------------------------------------------------------
char __usercall sub_FF58D0@<al>(signed int a1@<ebx>, HWND hWnd, LPARAM a3, LPARAM a4, int a5)
{
  DWORD v5; // ecx
  int v6; // eax
  signed int v7; // ecx
  int v8; // eax
  HWND v9; // ecx
  LRESULT v10; // eax
  int v11; // eax
  WPARAM v12; // eax
  char result; // al
  bool v14; // zf
  LPARAM v15; // [esp+Ch] [ebp-50h]
  int v16; // [esp+18h] [ebp-44h]
  int v17; // [esp+1Ch] [ebp-40h]
  LPARAM lParam; // [esp+40h] [ebp-1Ch]
  int v19; // [esp+48h] [ebp-14h]
  int v20; // [esp+58h] [ebp-4h]
  int v21; // [esp+70h] [ebp+14h]

  LOBYTE(a1) = 0;
  v20 = a1;
  *(a4 + 8) = gdwRefreshCount;
  *(a4 + 12) = *(a4 + 16);
  *a5 = 0;
  v5 = gConfig.dwHighlightDuration;
  if ( gConfig.dwRefreshRate )
    v5 = gConfig.dwRefreshRate;
  v6 = *(a4 + 16);
  *(a4 + 20) += v5;
  v7 = *(a4 + 20);
  if ( v6 == 2 )
  {
    a1 = 0;
    if ( v7 >= gConfig.dwHighlightDuration )
      a1 = 1;
    v20 = a1;
  }
  if ( v6 == 4 )
  {
LABEL_31:
    --*(a3 + 4);
    return a1;
  }
  if ( v6 == 1 )
  {
    if ( v7 >= gConfig.dwHighlightDuration )
    {
      v8 = *(a4 + 4);
      v9 = hWnd;
      *(a4 + 16) = 4;
      v21 = v8;
      if ( *(a3 + 4) != -1
        || (v19 = *(a3 + 32),
            lParam = 1,
            v10 = SendMessageW(hWnd, 0x1053u, 0xFFFFFFFF, &lParam),
            v9 = hWnd,
            *(a3 + 4) = v10,
            v10 != -1) )
      {
        SendMessageW(v9, 0xBu, 0, 0);
        LOBYTE(v20) = 1;
        *a3 = 8;
        SendMessageW(hWnd, 0x104Bu, 0, a3);
        SendMessageW(hWnd, 0x1008u, *(a3 + 4), 0);
        if ( *(a3 + 12) & 2 )
        {
          v11 = *(a3 + 4);
          v17 = 3;
          v16 = 3;
          if ( v11 )
            v12 = v11 - 1;
          else
            v12 = 0;
          SendMessageW(hWnd, 0x102Bu, v12, &v15);
        }
      }
      if ( !v21 )
      {
        SendMessageW(ghMainWnd, 0x7EFu, 0, a4);
        --*(a3 + 4);
        return 1;
      }
      LOBYTE(a1) = v20;
    }
    goto LABEL_31;
  }
  if ( v6 != 2 || v7 >= gConfig.dwHighlightDuration )
  {
    *(a4 + 24) = 0;
    *(a4 + 16) = 0;
  }
  else
  {
    *(a4 + 24) = 1;
    *(a4 + 28) = v7;
  }
  if ( *(a4 + 4) != 2 )
  {
    *(a4 + 16) = 1;
    *(a4 + 20) = 0;
    *a5 = 1;
    result = a1;
    --*(a3 + 4);
    return result;
  }
  if ( sub_FDF460(*(a3 + 32)) )
    goto LABEL_31;
  v14 = hWnd == ghWndHandlesListCtrl;
  *(a4 + 16) = 1;
  if ( v14 )
    LOBYTE(a1) = 1;
  *(a4 + 20) = 0;
  *a5 = 1;
  result = a1;
  --*(a3 + 4);
  return result;
}
// 106A11C: using guessed type int gdwRefreshCount;

//----- (00FF5AB0) --------------------------------------------------------
BOOL __cdecl CDriver::Control(DWORD dwIoControlCode, LPVOID lpInBuffer, DWORD nInBufferSize, LPVOID lpOutBuffer, DWORD nOutBufferSize)
{
  DWORD v5; // ecx
  DWORD BytesReturned; // [esp+0h] [ebp-4h]

  BytesReturned = v5;
  return DeviceIoControl(
           ghDriverHandle,
           dwIoControlCode,
           lpInBuffer,
           nInBufferSize,
           lpOutBuffer,
           nOutBufferSize,
           &BytesReturned,
           0) != 0;
}

//----- (00FF5AE0) --------------------------------------------------------
int __stdcall CGraphWnd::ChartWndProc(HWND hWnd, UINT Msg, WPARAM wParam, int lParam)
{
  CGraphData *pGraphData; // esi
  HWND hWndTooltips; // eax
  void (__stdcall *SendMessageW)(HWND, UINT, WPARAM, LPARAM); // ecx
  HWND hWndTooltips_1; // ebx
  UINT uMsg; // eax
  int v9; // eax
  int v10; // eax
  HDC hDC; // ebx
  int uID; // eax
  int result; // eax
  int v14; // eax
  HWND hWndTooltip; // esi
  int v16; // eax
  HWND v17; // eax
  wchar_t *v18; // esi
  __int32 v19; // eax
  int v20; // eax
  HWND v21; // eax
  __int16 v22; // ah^1
  struct tagPOINT Point; // [esp+14h] [ebp-890h]
  LPARAM lParam_2; // [esp+1Ch] [ebp-888h]
  HWND v25; // [esp+20h] [ebp-884h]
  wchar_t Src; // [esp+24h] [ebp-880h]
  __int16 v27; // [esp+824h] [ebp-80h]
  __int16 v28; // [esp+826h] [ebp-7Eh]
  CGraphData *v29; // [esp+828h] [ebp-7Ch]
  tagTOOLINFOW ToolInfo; // [esp+830h] [ebp-74h]
  int v31; // [esp+85Ch] [ebp-48h]
  struct tagPAINTSTRUCT Paint; // [esp+860h] [ebp-44h]

  lParam_2 = lParam;
  pGraphData = GetWindowLongW(hWnd, GWLP_USERDATA);
  hWndTooltips = GetPropW(hWnd, L"Balloon");
  SendMessageW = ::SendMessageW;
  hWndTooltips_1 = hWndTooltips;
  uMsg = Msg;
  if ( hWndTooltips_1 )
  {
    if ( Msg != WM_LBUTTONDOWN )
    {
      uMsg = Msg;
      if ( Msg - 512 <= 13 )
      {
        ToolInfo.rect.right = Msg;
        ToolInfo.rect.bottom = wParam;
        ToolInfo.hinst = lParam_2;
        ToolInfo.rect.top = hWnd;
        *&ToolInfo.lpszText = 0i64;
        v31 = 0;
        ::SendMessageW(hWndTooltips_1, TTM_RELAYEVENT, 0, &ToolInfo.rect.top);
        uMsg = Msg;
        SendMessageW = ::SendMessageW;
      }
    }
  }
  if ( uMsg > WM_NOTIFY )
  {
    v19 = uMsg - WM_MOUSEMOVE;
    if ( v19 )
    {
      v20 = v19 - 1;
      if ( v20 )
      {
        if ( v20 == 511 )
        {
          if ( !LOBYTE(pGraphData->field_854) )
            SendMessageW(hWndTooltips_1, TTM_UPDATE, 0, 0);
          InvalidateRect(hWnd, 0, 0);
          UpdateWindow(hWnd);
        }
      }
      else
      {
        KillTimer(hWnd, 0);
        LOBYTE(pGraphData->field_854) = LOBYTE(pGraphData->field_854) == 0;
        v21 = pGraphData->m_Item[1].nItemID;
        if ( v21 )
          ::SendMessageW(v21, RB_GETBANDBORDERS, 0, 0);
        if ( GetParent(hWnd) == ghWndReBar )
        {
          if ( hWnd == ghWndCPUGraph )
          {
            gConfig.dwDefaultSysInfoPage = 1;
          }
          else if ( hWnd == ghWndMemoryGraph || hWnd == ghWndPhysicalMemoryGraph )
          {
            gConfig.dwDefaultSysInfoPage = 2;
          }
          else
          {
            gConfig.dwDefaultSysInfoPage = (hWnd == ghWndGPUGraph) + 3;
          }
          Command_SystemInformation();
        }
      }
      return DefWindowProcW(hWnd, Msg, wParam, lParam_2);
    }
    if ( hWndTooltips_1 )
    {
      v22 = HIWORD(lParam_2);
      if ( lParam_2 == pGraphData->field_858 )
      {
        if ( SHIWORD(lParam_2) == pGraphData->field_85C )
          return DefWindowProcW(hWnd, Msg, wParam, lParam_2);
        v22 = HIWORD(lParam_2);
      }
      pGraphData->field_858 = lParam_2;
      pGraphData->field_85C = v22;
      SendMessageW(hWndTooltips_1, TTM_UPDATE, 0, 0);
      LOBYTE(pGraphData->field_854) = 0;
    }
    return DefWindowProcW(hWnd, Msg, wParam, lParam_2);
  }
  if ( uMsg == WM_NOTIFY )
  {
    if ( *lParam_2 == hWndTooltips_1 )
    {
      v16 = *(lParam_2 + 8);
      if ( v16 == -530 )
      {
        GetCursorPos(&Point);
        if ( WindowFromPoint(Point) == hWnd && (v17 = GetParent(hWnd), sub_FB2A70(v17)) )
        {
          v25 = hWnd;
          v29 = pGraphData;
          GetCursorPos(&Point);
          ScreenToClient(hWnd, &Point);
          v27 = Point.x;
          v28 = Point.y;
          sub_FB24C0(&v25);
          if ( Src )
          {
            v18 = &pGraphData->m_Item[1].dwValue;
            wcscpy_s(v18, 0x400u, &Src);
            *(lParam_2 + 12) = v18;
          }
        }
        else
        {
          ::SendMessageW(hWndTooltips_1, 0x41Cu, 0, 0);
        }
      }
      else if ( v16 == -521 )
      {
        return 0;
      }
    }
    return DefWindowProcW(hWnd, Msg, wParam, lParam_2);
  }
  v9 = uMsg - 1;
  if ( v9 )
  {
    v10 = v9 - 4;
    if ( v10 )
    {
      if ( v10 == 10 )
      {
        hDC = BeginPaint(hWnd, &Paint);
        GetClientRect(hWnd, &ToolInfo.hinst);
        uID = GetDlgCtrlID(hWnd);
        if ( uID == IDC_SYSINFO_IO_STATIC_IO_CHART
          || uID == IDC_SYSINFO_SUM_STATIC_SYSTEM_COMMIT_CHART
          || uID == IDC_SYSINFO_MEMORY_STATIC_PHYSICAL_MEMORY_CHART
          || uID == IDC_SYSINFO_IOETW_STATIC_NETWORK_CHART
          || uID == IDC_SYSINFO_IOETW_STATIC_DISK_CHART
          || uID == IDC_SYSINFO_GPU_STATIC_GPU_DEDICATED_MEMORY_CHART
          || uID == IDC_SYSINFO_GPU_STATIC_GPU_SYSTEM_MEMORY_CHART
          || uID == 2603
          || uID >= IDC_GRAPH_IN_REBAR && uID < 2500
          || uID >= IDC_SYSINFO_GPU_STATIC_GPU_USAGE_CHART && uID < 2600 )
        {
          GraphData_DrawChart(pGraphData, hDC, &ToolInfo.hinst, 0xFFFFFFFF, 0, 0.0);
          EndPaint(hWnd, &Paint);
          result = 0;
        }
        else
        {
          GraphData_DrawGraph(pGraphData, hDC, &ToolInfo.hinst);
          EndPaint(hWnd, &Paint);
          result = 0;
        }
        return result;
      }
    }
    else
    {
      ToolInfo.cbSize = 48;
      ToolInfo.uFlags = 0;
      _mm_storeu_si128(&ToolInfo.hwnd, 0i64);
      _mm_storeu_si128(&ToolInfo.rect.right, 0i64);
      ToolInfo.hwnd = hWnd;
      *&ToolInfo.lParam = 0i64;
      GetClientRect(hWnd, &ToolInfo.rect);
      ::SendMessageW(hWndTooltips_1, TTM_NEWTOOLRECTW, 0, &ToolInfo);
    }
    return DefWindowProcW(hWnd, Msg, wParam, lParam_2);
  }
  SetWindowLongW(hWnd, GWLP_USERDATA, *lParam_2);
  v14 = GetDlgCtrlID(hWnd);
  if ( v14 == 1159
    || v14 == 1330
    || v14 == 1333
    || v14 == 1335
    || v14 == 1338
    || v14 == 2601
    || v14 == 2602
    || v14 == 2603
    || v14 >= 2000 && v14 < 2500
    || (v14 - 2501) <= 0x62 )
  {
    hWndTooltip = CreateWindowExW(WS_EX_TOPMOST, L"tooltips_class32", 0, 0x80000033, 0, 0, 0, 0, hWnd, 0, ghInstance, 0);
    ToolInfo.cbSize = 48;
    ToolInfo.uFlags = 0x100;
    _mm_storeu_si128(&ToolInfo.hwnd, 0i64);
    _mm_storeu_si128(&ToolInfo.rect.right, 0i64);
    ToolInfo.hwnd = hWnd;
    *&ToolInfo.lParam = 0i64;
    ToolInfo.lpszText = -1;
    ::SendMessageW(hWndTooltip, TTM_ADDTOOLW, 0, &ToolInfo);
    SetPropW(hWnd, L"Balloon", hWndTooltip);
    CTreeList::InitToolTips(hWndTooltip);
  }
  return 1;
}

//----- (00FF6020) --------------------------------------------------------
char __cdecl sub_FF6020(int a1)
{
  int v1; // eax
  _DWORD *v2; // esi
  int v3; // edx
  bool v4; // zf
  int v5; // edi
  int v6; // ecx
  char i; // dl

  LOBYTE(v1) = SendMessageW(ghWndTreeListView, 0xBu, 0, 0);
  v2 = a1;
  v3 = a1;
  if ( a1 )
  {
    do
    {
      v4 = *(v3 + 68) == 0;
      *(v3 + 48) = 0;
      *(v3 + 84) = 0;
      if ( !v4 )
      {
        v1 = a1;
        while ( *(v1 + 68) != *(v3 + 76) || *(v1 + 624) > *(v3 + 624) )
        {
          v1 = *(v1 + 1456);
          if ( !v1 )
            goto LABEL_9;
        }
        *(v3 + 84) = v1;
      }
LABEL_9:
      v3 = *(v3 + 1456);
    }
    while ( v3 );
    if ( a1 )
    {
      do
      {
        v5 = 0;
        v6 = v2[21];
        for ( i = (v2[10] >> 1) & 1; v6; ++v5 )
        {
          LOBYTE(v1) = -((*(v6 + 40) & 4) != 0);
          ++*(v6 + 48);
          v6 = *(v6 + 84);
          i &= v1;
        }
        v2[20] = v5;
        if ( (!i || v2[10] & 1 && gConfig.byte_14012ADFE) && v2[11] != -1 )
        {
          if ( !i )
            v2[10] &= 0xFFFFFFFD;
          LOBYTE(v1) = sub_FB8570(ghWndTreeListView, v2);
        }
        v2 = v2[364];
      }
      while ( v2 );
    }
  }
  return v1;
}

//----- (00FF6110) --------------------------------------------------------
int *__cdecl FillHandleListParam(HWND hWndList, tagHANDLELISTITEMPARAM *pListParam)
{
  signed int v2; // edi
  IAtlStringMgr *v3; // ecx
  int v4; // eax
  HINSTANCE ghInstance; // ecx
  CString v6; // esi
  signed int nPage; // eax
  const PROPSHEETPAGEW *v8; // eax
  int nType; // edi
  int v10; // ecx
  tagHANDLELISTITEMPARAM *v11; // ecx
  __int16 v12; // ax
  int fIsObjDirectory; // ecx
  signed int nPages; // edi
  bool v15; // zf
  HWND v16; // edi
  const wchar_t *v17; // eax
  CStringData *v18; // esi
  int *result; // eax
  PE_PROPSHEETPAGEW Pages[2]; // [esp+Ch] [ebp-4C8h]
  PROPSHEETHEADERW PropSheet; // [esp+74h] [ebp-460h]
  int v22[2]; // [esp+A8h] [ebp-42Ch]
  char *v23; // [esp+B0h] [ebp-424h]
  HWND hWnd; // [esp+B4h] [ebp-420h]
  CString strName; // [esp+B8h] [ebp-41Ch]
  CObjSecurity *pObjSecurity; // [esp+BCh] [ebp-418h]
  WCHAR szCaption[520]; // [esp+C0h] [ebp-414h]

  hWnd = hWndList;
  v2 = 0;
  v3 = ATL::StrTraitATL<wchar_t,ATL::ChTraitsCRT<wchar_t>>::GetDefaultManager();
  if ( !v3 )
    ATL::AtlThrowImpl(E_FAIL);
  v4 = (v3->vtptr->GetNilData)();
  ghInstance = ::ghInstance;
  v6.pszData = (v4 + 16);
  strName.pszData = (v4 + 16);
  if ( pListParam[10].dwValue )
  {
    Pages[0].u2.hIcon = 0;
    Pages[0].pfnCallback = 0;
    v2 = 1;
    Pages[0].dwSize = sizeof(PE_PROPSHEETPAGEW);
    Pages[0].dwFlags = PSP_USETITLE;
    Pages[0].hInstance = ::ghInstance;
    Pages[0].u.pszTemplate = L"HANDLEINFO";
    Pages[0].pfnDlgProc = PropHandleInfo;
    Pages[0].pszTitle = L"Details";
    Pages[0].lParam = pListParam;
  }
  if ( *CreateSecurityPage )
  {
    if ( _wcsicmp(&pListParam[14], L"ObjDirectory") )
    {
      if ( _wcsicmp(&pListParam[14], L"Device") )
      {
        if ( _wcsicmp(&pListParam[14], L"Process") )
        {
          if ( _wcsicmp(&pListParam[14], L"Service") )
            nType = _wcsicmp(&pListParam[14], L"Thread") != 0 ? 1 : 5;
          else
            nType = 4;
        }
        else
        {
          nType = 3;
        }
      }
      else
      {
        nType = 2;
      }
    }
    else
    {
      nType = 0;
    }
    if ( pListParam == -184 )
    {
      v10 = 0;
    }
    else
    {
      v11 = pListParam + 46;
      v23 = &pListParam[46].dwValue + 2;
      do
      {
        v12 = v11->dwValue;
        v11 = (v11 + 2);
      }
      while ( v12 );
      v10 = (v11 - v23) >> 1;
    }
    ATL::CSimpleStringT<wchar_t,0>::SetString(&strName, &pListParam[46], v10);
    fIsObjDirectory = wcscmp(&pListParam[14], L"ObjDirectory");
    if ( fIsObjDirectory )
      fIsObjDirectory = -(fIsObjDirectory < 0) | 1;
    v6.pszData = strName.pszData;
    CObjSecurity::Create(pListParam, strName.pszData, &pObjSecurity, nType, fIsObjDirectory == 0);
    nPages = 0;
    PropSheet.dwFlags = PSH_NOAPPLYNOW;
    if ( pListParam[10].dwValue )
    {
      v22[0] = CreatePropertySheetPageW(Pages);
      nPages = 1;
    }
    v22[nPages] = CreateSecurityPage(pObjSecurity);
    PropSheet.nPages = nPages + 1;
    v8 = v22;
  }
  else
  {
    nPage = v2;
    PropSheet.dwFlags = 0x88;
    Pages[nPage].dwSize = sizeof(PE_PROPSHEETPAGEW);
    Pages[nPage].dwFlags = PSP_USETITLE;
    Pages[nPage].hInstance = ghInstance;
    Pages[nPage].u.pszTemplate = L"SECURITY";
    Pages[nPage].pfnDlgProc = PropSecurity;
    Pages[nPage].pszTitle = L"Security";
    Pages[nPage].lParam = pListParam;
    Pages[nPage].pfnCallback = 0;
    PropSheet.nPages = v2 + 1;
    v8 = Pages;
  }
  v15 = pListParam[10].dwValue == 0;
  v16 = hWnd;
  PropSheet.ppsp = v8;
  PropSheet.hInstance = ghMainInstance;
  v17 = L"Properties";
  if ( v15 )
    v17 = L"Permissions";
  PropSheet.dwSize = sizeof(PROPSHEETHEADERW);
  PropSheet.hwndParent = hWnd;
  MakeHandlePropSheetCaption(szCaption, L"%s %s", &pListParam[46], v17);
  PropSheet.nStartPage = 0;
  PropSheet.hwndParent = v16;
  PropSheet.pszCaption = szCaption;
  PropSheet.pfnCallback = 0;
  PropertySheetW(&PropSheet);
  if ( *CreateSecurityPage )
    CObjSecurity::~CObjSecurity(pObjSecurity);
  v18 = (v6.pszData - 16);
  result = &v18->nRefs;
  if ( _InterlockedDecrement(&v18->nRefs) <= 0 )
    result = (v18->pStringMgr->vtptr->Free)(v18);
  return result;
}
// 1042AE8: using guessed type wchar_t aSecurity_1[9];
// 1045140: using guessed type wchar_t aHandleinfo[11];
// 1045158: using guessed type wchar_t aDetails[8];
// 1045168: using guessed type wchar_t aSecurity_0[9];
// 10451A8: using guessed type wchar_t aProperties_0[11];
// 10451C0: using guessed type wchar_t aPermissions[12];
// FF6110: using guessed type int var_42C[2];

//----- (00FF6450) --------------------------------------------------------
HANDLE __cdecl CTreeList::FillTreeViewParam(tagTREEVIEWLISTITEMPARAM *pInfo)
{
  InterlockedIncrement(&pInfo->nRefCount);
  return _beginthread(CTreeList::BackendFillTreeViewParamThreadProc, 0, pInfo);
}

//----- (00FF6480) --------------------------------------------------------
BOOL __cdecl PropertiesThreadProc(HACCEL hAccTable)
{
  HCURSOR v1; // eax
  tagPropItem *propItem; // eax
  tagPropItem *PropItem; // esi
  HWND hDlgPropSheet; // ebx
  BOOL result; // eax
  int v6; // edi
  int v7; // eax
  HWND v8; // esi
  struct tagMSG msg; // [esp+8h] [ebp-20h]
  tagPropItem *v10; // [esp+24h] [ebp-4h]
  HACCEL hAccTablea; // [esp+30h] [ebp+8h]

  InterlockedIncrement(&gnRefCount);
  v1 = LoadCursorW(0, IDC_APPSTARTING);
  SetCursor(v1);
  propItem = malloc(sizeof(tagPropItem));
  PropItem = propItem;
  v10 = propItem;
  memset(propItem, 0, sizeof(tagPropItem));
  PropItem->pListItem = hAccTable;
  hDlgPropSheet = CreateDialogParamW(ghMainInstance, L"PROCPROPSHEET", ghMainWnd, ProcPropSheet, PropItem);
  hAccTablea = LoadAcceleratorsW(ghMainInstance, L"DLLPROPERTIES");
  for ( result = GetMessageW(&msg, 0, 0, 0); result; result = GetMessageW(&msg, 0, 0, 0) )
  {
    v6 = PropItem + sizeof(PROPPAGEDATA) * PropItem->nTabIndex;
    v7 = *(v6 + 8);
    if ( v7 && TranslateAcceleratorW(v7, hAccTablea, &msg) )
      continue;
    v8 = GetPropW(hDlgPropSheet, L"FindWindow");
    if ( !v8 )
    {
LABEL_8:
      if ( !IsDialogMessageW(*(v6 + 8), &msg) && !IsDialogMessageW(hDlgPropSheet, &msg) )
      {
        TranslateMessage(&msg);
        DispatchMessageW(&msg);
      }
      goto LABEL_11;
    }
    if ( IsDialogMessageW(v8, &msg) )
    {
      if ( msg.message != WM_COMMAND || LOWORD(msg.wParam) != 40014 )
        goto LABEL_11;
    }
    else if ( msg.message != WM_COMMAND || LOWORD(msg.wParam) != 40014 )
    {
      goto LABEL_8;
    }
    PostMessageW(v8, WM_COMMAND, IDC_DLG_DLLINFO_EDIT_COMPANY, 0);
    SetPropW(hDlgPropSheet, L"FindWindow", 0);
LABEL_11:
    PropItem = v10;
  }
  return result;
}

//----- (00FF6600) --------------------------------------------------------
HANDLE CDriver::Close()
{
  HANDLE result; // eax

  result = ghDriverHandle;
  if ( ghDriverHandle != INVALID_HANDLE_VALUE )
    result = CloseHandle(ghDriverHandle);
  return result;
}

//----- (00FF6620) --------------------------------------------------------
bool GetProcessDEPStatus()
{
  DWORD v1; // eax
  HANDLE v2; // esi
  HANDLE v3; // eax
  int v4; // edi
  int ProcessInformation; // [esp+0h] [ebp-8h]
  ULONG ReturnLength; // [esp+4h] [ebp-4h]

  if ( gdwVersion >= 3 || gdwVersion >= 2 )
    return 1;
  if ( gdwVersion >= 1 )
    return 0;
  v1 = GetCurrentProcessId();
  v2 = OpenProcess(0x400u, 0, v1);
  if ( !v2 )
    return 0;
  v3 = GetCurrentProcess();
  v4 = NtQueryInformationProcess(v3, ProcessExecuteFlags, &ProcessInformation, 4u, &ReturnLength);
  CloseHandle(v2);
  return !v4 || v4 == -1073741811;
}
// FF6620: using guessed type bool __cdecl GetProcessDEPStatus();
// 1064E54: using guessed type int gdwVersion;

//----- (00FF66B0) --------------------------------------------------------
BOOL __stdcall DlgFind(HWND hDlg, UINT uMsg, WPARAM wParamIn, LPARAM lParamIn)
{
  BOOL result; // eax
  HWND v5; // ecx
  char v6; // al
  HWND v7; // ST08_4
  tagTREEVIEWITEMPARAM *v8; // eax
  void *v9; // eax
  HWND v10; // ST08_4
  tagTREEVIEWLISTITEMPARAM *v11; // eax
  int v12; // eax
  int v13; // edx
  DLLLISTITEMPARAM *v14; // eax
  LPARAM v15; // eax
  CResizer *v16; // eax
  HWND v17; // eax
  LONG v18; // eax
  HWND v19; // eax
  struct _IMAGELIST *v20; // edi
  LONG v21; // eax
  HCURSOR v22; // esi
  HWND v23; // eax
  HWND v24; // eax
  HWND v25; // eax
  HWND v26; // eax
  HWND v27; // eax
  HWND v28; // eax
  HWND v29; // eax
  HWND v30; // eax
  HWND v31; // eax
  WPARAM v32; // esi
  int v33; // ST14_4
  int v34; // eax
  char nItemMatched; // al
  LPARAM v36; // [esp+Ch] [ebp-2A4h]
  int v37; // [esp+18h] [ebp-298h]
  int v38; // [esp+1Ch] [ebp-294h]
  tagLVITEMW lParam; // [esp+40h] [ebp-270h]
  LPARAM v40; // [esp+74h] [ebp-23Ch]
  void *v41; // [esp+7Ch] [ebp-234h]
  HCURSOR hCursor; // [esp+8Ch] [ebp-224h]
  tagTREEVIEWITEMPARAM *v43; // [esp+90h] [ebp-220h]
  int nIDs[4]; // [esp+94h] [ebp-21Ch]
  WCHAR String[256]; // [esp+A4h] [ebp-20Ch]
  int nWidths; // [esp+2A4h] [ebp-Ch]
  int v47; // [esp+2A8h] [ebp-8h]

  hCursor = hDlg;
  if ( !(dword_10854C8 & 1) )
  {
    dword_10854C8 |= 1u;
    gwWidthsOfListInFindDlg[0] = MulDiv(75, gLogPixelSize.x, 96);
    gwWidthsOfListInFindDlg[1] = MulDiv(-1, gLogPixelSize.x, 96);
    gwWidthsOfListInFindDlg[2] = MulDiv(50, gLogPixelSize.x, 96);
    gwWidthsOfListInFindDlg[3] = MulDiv(150, gLogPixelSize.x, 96);
  }
  lParam.mask = 0;
  memset(&lParam.iItem, 0, 0x30u);
  _mm_storeu_si128(nIDs, _mm_load_si128(&xmmword_1046C30));
  if ( uMsg > WM_INITDIALOG )
  {
    if ( uMsg > WM_CHOOSEFONT_SETLOGFONT )
    {
      if ( uMsg == WM_MSG_7F1 )
      {
        ghFindDlg = 0;
        ghWndListInFindDlg = 0;
        GetWindowRect(hDlg, &gRectFindDlg);
        gnWidthFindDlg = gRectFindDlg.right - gRectFindDlg.left;
        gnHeightFindDlg = gRectFindDlg.bottom - gRectFindDlg.top;
      }
      return 0;
    }
    if ( uMsg == WM_CHOOSEFONT_SETLOGFONT )
    {
      SendMessageW(ghWndListInFindDlg, LVM_SORTITEMS, gnColumnSortedInFindDlg, FindDlg_SortCallback);
      nItemMatched = SendMessageW(ghWndListInFindDlg, LVM_GETITEMCOUNT, 0, 0);
      wsprintf(String, L"%d matching items.", nItemMatched);
      SetDlgItemTextW(hDlg, IDC_FINDDLG_STATIC_RESULT, String);
      return 1;
    }
    if ( uMsg != WM_COMMAND )
    {
      if ( uMsg == 0x464 )
      {
        CloseHandle(ghThreadHandleInFindDlg);
        ghThreadHandleInFindDlg = 0;
        v23 = GetDlgItem(hDlg, IDC_FINDDLG_BUTTON_SEARCH);
        EnableWindow(v23, 1);
        v24 = GetDlgItem(hDlg, IDC_FINDDLG_EDIT);
        EnableWindow(v24, 1);
        v25 = GetDlgItem(hDlg, IDC_FINDDLG_BUTTON_CANCEL);
        EnableWindow(v25, 0);
        SendMessageW(hDlg, WM_CHOOSEFONT_SETLOGFONT, 0, 0);
        v26 = GetDlgItem(hDlg, IDC_FINDDLG_BUTTON_SEARCH);
        SetFocus(v26);
        return 1;
      }
      return 0;
    }
    if ( wParamIn == IDC_FINDDLG_BUTTON_CANCEL )
    {
      gbSearching = 1;
      return 0;
    }
    if ( wParamIn == 2 )
    {
      v31 = GetDlgItem(hDlg, IDC_FINDDLG_BUTTON_CANCEL);
      if ( IsWindowEnabled(v31) )
      {
        SendMessageW(hDlg, WM_COMMAND, IDC_FINDDLG_BUTTON_CANCEL, 0);
        return 1;
      }
    }
    else if ( wParamIn != 1 )
    {
      if ( wParamIn == IDC_FINDDLG_BUTTON_SEARCH )
      {
        dword_10854D0 = -1;
        GetDlgItemTextW(hDlg, IDC_FINDDLG_EDIT, gszStringToFindLast, 256);
        if ( wcslen(gszStringToFindLast) )
        {
          CTreeList::InitHeaderColumn(
            ghWndListInFindDlg,
            gnColumnSortedInFindDlg,
            gnColumnSortedInFindDlg,
            byte_105E8B0);
          v27 = GetDlgItem(hDlg, IDC_FINDDLG_BUTTON_SEARCH);
          EnableWindow(v27, 0);
          v28 = GetDlgItem(hDlg, IDC_FINDDLG_EDIT);
          EnableWindow(v28, 0);
          v29 = GetDlgItem(hDlg, IDC_FINDDLG_BUTTON_CANCEL);
          EnableWindow(v29, 1);
          v30 = GetDlgItem(hDlg, IDC_FINDDLG_BUTTON_CANCEL);
          SetFocus(v30);
          if ( ghThreadHandleInFindDlg )
          {
            WaitForSingleObject(ghThreadHandleInFindDlg, 0xFFFFFFFF);
            CloseHandle(ghThreadHandleInFindDlg);
          }
          gbSearching = 0;
          SendMessageW(ghWndListInFindDlg, LVM_DELETEALLITEMS, 0, 0);
          SetDlgItemTextW(hDlg, IDC_FINDDLG_STATIC_RESULT, L"Searching...");
          ghThreadHandleInFindDlg = _beginthreadex(0, 0, FindDlg_SearchThreadProc, &gbSearching, 0, 0);
        }
      }
      return 0;
    }
    ShowWindow(hDlg, 0);
    gbSearching = 1;
    SendMessageW(ghWndListInFindDlg, LVM_DELETEALLITEMS, 0, 0);
    v32 = 0;
    do
    {
      v33 = gLogPixelSize.x;
      v34 = SendMessageW(ghWndListInFindDlg, LVM_GETCOLUMNWIDTH, v32, 0);
      gwWidthsOfListInFindDlg[v32++] = MulDiv(v34, 96, v33);
    }
    while ( v32 < 4 );
    wcscpy_s(gszStringToFind, 256u, gszStringToFindLast);
    return 1;
  }
  if ( uMsg != WM_INITDIALOG )
  {
    switch ( uMsg )
    {
      case WM_CLOSE:
        SendMessageW(hDlg, WM_COMMAND, 2u, 0);
        return 1;
      case WM_SHOWWINDOW:
        if ( wParamIn == 1 )
        {
          SetDlgItemTextW(hDlg, IDC_FINDDLG_STATIC_RESULT, &gszNullString);
          InitTreeList(ghWndListInFindDlg, ghConfigFont);
          SendMessageW(ghWndListInFindDlg, 0x1009u, 0, 0);
          SetDlgItemTextW(hDlg, IDC_FINDDLG_STATIC_SUBSTRING, L"Handle or DLL substring:");
          gdwRefreshRateLast = gConfig.dwRefreshRate;
          gConfig.dwRefreshRate = 0;
          SendMessageW(ghWndStatusBar, SB_SETTEXTW, gnStatusBarItemCount - 1, L"Paused");
          return 1;
        }
        gConfig.dwRefreshRate = gdwRefreshRateLast;
        SetEvent(ghRefreshEventHandle);
        if ( !gdwRefreshRateLast )
          return 1;
        SendMessageW(ghWndStatusBar, SB_SETTEXTW, gnStatusBarItemCount - 1, &gszNullString);
        return 1;
      case WM_DRAWITEM:
        CMainWnd::DrawList(lParamIn);
        return 0;
      case WM_MEASUREITEM:
        return CMainWnd::HandleMeasureItem(hDlg, uMsg, wParamIn, lParamIn);
      case 0x4Eu:
        switch ( *(lParamIn + 8) )
        {
          case 0xFFFFFF94:
            v5 = *(lParamIn + 16);
            if ( v5 == gnColumnSortedInFindDlg )
            {
              v6 = byte_105E8B0 == 0;
              byte_105E8B0 = byte_105E8B0 == 0;
            }
            else
            {
              v6 = byte_105E8B0;
            }
            CTreeList::InitHeaderColumn(*lParamIn, gnColumnSortedInFindDlg, v5, v6);
            gnColumnSortedInFindDlg = *(lParamIn + 16);
            SendMessageW(*lParamIn, 0x1030u, gnColumnSortedInFindDlg, FindDlg_SortCallback);
            return 0;
          case 0xFFFFFF99:
            lParam.iItem = *(lParamIn + 12);
            v7 = *lParamIn;
            lParam.iSubItem = 0;
            lParam.mask = 4;
            SendMessageW(v7, 0x104Bu, 0, &lParam);
            v8 = lParam.lParam;
            if ( lParam.lParam->field_24 )
            {
              free(lParam.lParam->field_24);
              v8 = lParam.lParam;
            }
            v9 = v8[2].field_C;
            if ( v9 )
              free(v9);
            return 0;
          case 0xFFFFFF9B:
          case 0xFFFFFFFD:
          case 0xFFFFFFFE:
            if ( dword_10854D0 == SendMessageW(*lParamIn, LVM_GETNEXTITEM, 0xFFFFFFFF, 2) )
              return 0;
            dword_10854D0 = SendMessageW(*lParamIn, LVM_GETNEXTITEM, 0xFFFFFFFF, 2);
            if ( dword_10854D0 == -1 )
              return 0;
            hCursor = SetCursor(::hCursor);
            v10 = *lParamIn;
            lParam.iItem = dword_10854D0;
            lParam.iSubItem = 0;
            lParam.mask = 4;
            if ( SendMessageW(v10, LVM_GETITEMW, 0, &lParam) != 1 )
              goto LABEL_41;
            v11 = gpTreeViewListItemParam;
            v43 = lParam.lParam;
            if ( !gpTreeViewListItemParam )
              goto LABEL_27;
            while ( v11->dwProcessId != lParam.lParam[2].field_0 )
            {
              v11 = v11->m_Prev;
              if ( !v11 )
              {
LABEL_27:
                MessageBoxW(
                  hDlg,
                  L"The selected process is not in the displayed process list.",
                  L"Process Explorer",
                  0x30u);
                return 0;
              }
            }
            v41 = v11;
            v40 = 1;
            lParam.iItem = SendMessageW(ghWndTreeListView, LVM_FINDITEMW, 0xFFFFFFFF, &v40);
            v38 = 3;
            v37 = 3;
            SendMessageW(ghWndTreeListView, LVM_SETITEMSTATE, lParam.iItem, &v36);
            SendMessageW(ghWndTreeListView, LVM_ENSUREVISIBLE, lParam.iItem, 0);
            gdwProcessIdSelected = v43[2].field_0;
            if ( !gConfig.bShowLowerPane )
              Command_ShowLowerPane(0);
            v12 = v43;
            if ( v43[2].field_8 )
            {
              if ( gConfig.bShowDllView )
              {
                Command_ShowHandlesPane(0);
                v12 = v43;
              }
              CMainWnd::RefreshHandlesView(hDlg, ghWndHandlesListCtrl, *(v12 + 168), 0);
              SendMessageW(ghMainWnd, 0x7E8u, 0x66u, 0);
            }
            else
            {
              if ( !gConfig.bShowDllView )
              {
                Command_ShowDllsPane(0);
                v12 = v43;
              }
              CMainWnd::RefreshDllsView(hDlg, ghWndDllsListCtrl, *(v12 + 168), 0);
              SendMessageW(ghMainWnd, 0x7E8u, 0x68u, 0);
            }
            v13 = v43[2].field_8;
            if ( !v13 )
            {
              v14 = gpDllListItemParamHeader;
              if ( gpDllListItemParamHeader )
              {
                while ( v14->m_LoadAddress != v43[2].field_4 )
                {
                  v14 = v14->m_Prev;
                  if ( !v14 )
                    goto LABEL_41;
                }
                v41 = v14;
                v40 = 1;
                lParam.iItem = SendMessageW(ghWndDllsListCtrl, 0x1053u, 0xFFFFFFFF, &v40);
                v38 = 3;
                v37 = 3;
                SendMessageW(ghWndDllsListCtrl, 0x102Bu, lParam.iItem, &v36);
                SendMessageW(ghWndDllsListCtrl, 0x1013u, lParam.iItem, 0);
                if ( *(lParamIn + 8) == -3 )
                {
                  SetFocus(ghWndDllsListCtrl);
                  PostMessageW(hDlg, 0x111u, 2u, 0);
                  SetCursor(hCursor);
                  return 0;
                }
              }
              goto LABEL_41;
            }
            v15 = dword_106539C;
            if ( !dword_106539C )
              goto LABEL_41;
            while ( *(v15 + 44) != v13 )
            {
              v15 = *(v15 + 4280);
              if ( !v15 )
              {
                SetCursor(hCursor);
                return 0;
              }
            }
            v41 = v15;
            v40 = 1;
            lParam.iItem = SendMessageW(ghWndHandlesListCtrl, 0x1053u, 0xFFFFFFFF, &v40);
            v38 = 3;
            v37 = 3;
            SendMessageW(ghWndHandlesListCtrl, 0x102Bu, lParam.iItem, &v36);
            SendMessageW(ghWndHandlesListCtrl, 0x1013u, lParam.iItem, 0);
            if ( *(lParamIn + 8) != -3 )
            {
LABEL_41:
              SetCursor(hCursor);
              return 0;
            }
            PostMessageW(hDlg, 0x111u, 2u, 0);
            SetFocus(ghWndHandlesListCtrl);
            SetCursor(hCursor);
            break;
          default:
            return 0;
        }
        break;
      default:
        return 0;
    }
    return 0;
  }
  v16 = operator new(0x40u);
  if ( v16 )
    CResizer::CResizer(v16, hDlg);
  ghMainIcon = LoadIconW(ghInstance, 0x65);
  SendMessageW(hDlg, WM_SETICON, 0, ghMainIcon);
  v17 = GetDlgItem(hDlg, 1001);
  ghWndListInFindDlg = v17;
  v18 = GetWindowLongW(v17, -16);
  SetWindowLongW(ghWndListInFindDlg, GWL_STYLE, v18 & -3u | LVS_REPORT);
  SetWindowLongW(ghWndListInFindDlg, GWL_USERDATA, 3);
  SendMessageW(ghWndListInFindDlg, LVM_SETEXTENDEDLISTVIEWSTYLE, 0x4020u, 0x4020);
  v19 = SendMessageW(ghWndListInFindDlg, LVM_GETTOOLTIPS, 0, 0);
  CTreeList::InitToolTips(v19);
  gOldListWndProc = SetWindowLongW(ghWndListInFindDlg, GWLP_WNDPROC, Proxy_ListCtrlWndProc);
  SendMessageW(ghWndListInFindDlg, WM_SETFONT, ghConfigFont, 0);
  v20 = ImageList_Create(16, 16, 1u, 256, 256);
  ghMainIcon = LoadIconW(ghInstance, 0xCB);
  ImageList_ReplaceIcon(v20, -1, ghMainIcon);
  ghMainIcon = LoadIconW(ghInstance, 0x71);
  ImageList_ReplaceIcon(v20, -1, ghMainIcon);
  v21 = GetWindowLongW(ghWndListInFindDlg, -16);
  SetWindowLongW(ghWndListInFindDlg, -16, v21 | 0x40);
  SendMessageW(ghWndListInFindDlg, 0x1003u, 1u, v20);
  if ( gwWidthsOfListInFindDlg[1] == -1 )
    gwWidthsOfListInFindDlg[1] = MulDiv(40, gLogPixelSize.x, 96);
  nWidths = *gwWidthsOfListInFindDlg;
  v47 = *&gwWidthsOfListInFindDlg[2];
  CTreeView::InitListHeader(ghWndListInFindDlg, nIDs, &nWidths, 4u);
  SendMessageW(ghWndListInFindDlg, LVM_SETCOLUMNWIDTH, 3u, 65534);
  v22 = hCursor;
  SetDlgItemTextW(hCursor, 1002, gszStringToFind);
  if ( gnWidthFindDlg )
  {
    MoveWindow(v22, gRectFindDlg.left, gRectFindDlg.top, gnWidthFindDlg, gnHeightFindDlg, 0);
    ShowWindow(v22, 1);
    result = 1;
  }
  else
  {
    if ( gConfig.WindowPlacement[1].rcNormalPosition.right )
      SetWindowPlacement(v22, &gConfig.WindowPlacement[1]);
    ShowWindow(v22, 1);
    result = 1;
  }
  return result;
}
// FDBBC0: using guessed type int __stdcall FindDlg_SortCallback(int, int, int);
// 1040D80: using guessed type wchar_t aPaused[7];
// 1046C30: using guessed type __int128 xmmword_1046C30;
// 105E8B0: using guessed type char byte_105E8B0;
// 10854C0: using guessed type __int16 gwWidthsOfListInFindDlg[4];
// 10854C8: using guessed type int dword_10854C8;
// 10854D0: using guessed type int dword_10854D0;
// 10854D4: using guessed type int gdwRefreshRateLast;
// 10854F0: using guessed type int ghMainIcon;
// 10854F4: using guessed type char gbSearching;
// 1085720: using guessed type int gnStatusBarItemCount;

//----- (00FF7400) --------------------------------------------------------
void __cdecl sub_FF7400(signed __int64 a1, double *a2, double *a3, double *a4)
{
  double v4; // xmm0_8
  double v5; // xmm1_8
  double v6; // xmm3_8
  DWORD v7; // ecx
  double dbMemorySize; // xmm4_8
  double v9; // xmm5_8
  double v10; // xmm1_8
  double v11; // xmm1_8
  struct _FILETIME SystemTimeAsFileTime; // [esp+28h] [ebp-84h]
  double v13; // [esp+30h] [ebp-7Ch]
  double v14; // [esp+38h] [ebp-74h]
  double v15; // [esp+40h] [ebp-6Ch]
  int v16; // [esp+48h] [ebp-64h]
  __int64 v17; // [esp+50h] [ebp-5Ch]
  __int64 v18; // [esp+58h] [ebp-54h]
  __int64 v19; // [esp+60h] [ebp-4Ch]
  __int64 v20; // [esp+68h] [ebp-44h]
  struct _MEMORYSTATUS Buffer; // [esp+88h] [ebp-24h]

  v13 = 0.0;
  Buffer.dwLength = 32;
  GlobalMemoryStatus(&Buffer);
  GetSystemTimeAsFileTime(&SystemTimeAsFileTime);
  if ( GlobalMemoryStatusEx )
  {
    v16 = 64;
    GlobalMemoryStatusEx(&v16);
    if ( a1 )
    {
      v14 = a1;
      v15 = a1 / v19 * 100.0;
      goto LABEL_11;
    }
    gpGraphInfoOfMemory->m_dbMemorySize = v19 * 0.0009765625;
    gpGraphInfoOfPhysicalMemory->m_dbMemorySize = v17 * 0.0009765625;
    v14 = (v17 - v18) * 0.0009765625;
    v13 = (v19 - v20);
    v15 = v13 * 100.0;
    v4 = v19;
    v5 = v13 * 100.0;
    v6 = v13 * 0.0009765625;
    v7 = Buffer.dwTotalPageFile;
    dbMemorySize = (v17 - v18) * 0.0009765625;
    v9 = db_onehundred;
  }
  else
  {
    if ( a1 )
    {
      v15 = a1 / Buffer.dwTotalPageFile * 100.0;
      goto LABEL_11;
    }
    v9 = db_onehundred;
    gpGraphInfoOfMemory->m_dbMemorySize = Buffer.dwTotalPageFile * 0.0009765625;
    gpGraphInfoOfPhysicalMemory->m_dbMemorySize = Buffer.dwTotalPhys * 0.0009765625;
    v7 = Buffer.dwTotalPageFile;
    dbMemorySize = (Buffer.dwTotalPhys - Buffer.dwAvailPhys) * 0.0009765625;
    v14 = (Buffer.dwTotalPhys - Buffer.dwAvailPhys) * 0.0009765625;
    v10 = (Buffer.dwTotalPageFile - Buffer.dwAvailPageFile);
    v6 = v10 * 0.0009765625;
    v4 = Buffer.dwTotalPageFile;
    v5 = v10 * 100.0;
  }
  v13 = v6;
  v15 = v5 / v4;
  if ( v6 < 0.0 )
  {
    v15 = v9;
    v13 = (v7 >> 10);
  }
  CGraphData_Update(gpGraphInfoOfPhysicalMemory, SystemTimeAsFileTime, dbMemorySize, 0.0, 0);
  CGraphData_Update(gpGraphInfoOfMemory, SystemTimeAsFileTime, v13, 0.0, 0);
LABEL_11:
  v11 = v14;
  if ( a2 )
    *a2 = v13;
  if ( a3 )
    *a3 = v11;
  if ( a4 )
    *a4 = gpGraphInfoOfPhysicalMemory->m_dbMemorySize;
}
// 103CDC0: using guessed type double db_onehundred;
// 106F2E8: using guessed type int (__stdcall *GlobalMemoryStatusEx)(_DWORD);

//----- (00FF7720) --------------------------------------------------------
int __cdecl sub_FF7720(int a1, wchar_t *Dst, rsize_t SizeInWords)
{
  int v3; // eax
  int result; // eax
  int v5; // [esp+8h] [ebp+8h]

  v3 = *(a1 + 636);
  v5 = v3;
  if ( v3 == -1 )
    return wcscpy_s(Dst, SizeInWords, L"n/a");
  if ( v3 & 1 )
    result = wcscpy_s(Dst, SizeInWords, L"Enabled");
  else
    result = wcscpy_s(Dst, SizeInWords, L"Disabled");
  if ( v5 & 8 )
    result = wcscat_s(Dst, SizeInWords, L" (permanent)");
  return result;
}

//----- (00FF7790) --------------------------------------------------------
int __cdecl sub_FF7790(int a1, wchar_t *Dst, size_t SizeInWords)
{
  int result; // eax

  if ( a1 == -1 )
    return swprintf_s(Dst, SizeInWords, &gszNullString);
  switch ( a1 )
  {
    case 0:
      result = swprintf_s(Dst, SizeInWords, L"Very Low");
      break;
    case 1:
      result = swprintf_s(Dst, SizeInWords, L"Low");
      break;
    case 2:
      result = swprintf_s(Dst, SizeInWords, L"Normal");
      break;
    case 3:
      result = swprintf_s(Dst, SizeInWords, L"High");
      break;
    case 4:
      result = swprintf_s(Dst, SizeInWords, L"Critical");
      break;
    default:
      result = swprintf_s(Dst, SizeInWords, L"%d", a1);
      break;
  }
  return result;
}

//----- (00FF7850) --------------------------------------------------------
void *__cdecl QuerySystemHandleInfo(ULONG ReturnLength)
{
  int v1; // eax
  ULONG v2; // esi
  SYSTEM_HANDLE_INFORMATION *v3; // eax
  _SYSTEM_INFORMATION_CLASS v4; // eax
  void *result; // eax
  ULONG v6; // esi
  SYSTEM_HANDLE_INFORMATION *v7; // eax
  _SYSTEM_INFORMATION_CLASS v8; // eax
  size_t v9; // esi
  ULONG v10; // esi
  SYSTEM_HANDLE_INFORMATION *v11; // eax
  _SYSTEM_INFORMATION_CLASS ClassInfo; // eax
  size_t v13; // esi
  _SYSTEM_INFORMATION_CLASS v14; // eax
  SYSTEM_HANDLE_INFORMATION *v15; // [esp-Ch] [ebp-14h]
  SYSTEM_HANDLE_INFORMATION *v16; // [esp-Ch] [ebp-14h]
  SYSTEM_HANDLE_INFORMATION *v17; // [esp-Ch] [ebp-14h]

  if ( ReturnLength )
  {
    if ( gpSystemHandleInfo )
      free(gpSystemHandleInfo);
    v10 = gdwSystemHandleInfoLength;
    v11 = malloc(gdwSystemHandleInfoLength);
    gpSystemHandleInfo = v11;
    v17 = v11;
    ClassInfo = SystemHandleInformation;
    if ( gbSupportExtendedSystemHandleInformation )
      ClassInfo = SystemExtendedHandleInformation;
    result = NtQuerySystemInformation(ClassInfo, v17, v10, &ReturnLength);
    if ( result )
    {
      while ( result != STATUS_ACCESS_DENIED )
      {
        free(gpSystemHandleInfo);
        gdwSystemHandleInfoLength *= 2;
        v13 = gdwSystemHandleInfoLength;
        gpSystemHandleInfo = malloc(gdwSystemHandleInfoLength);
        memset(gpSystemHandleInfo, 0, v13);
        v14 = 16;
        if ( gbSupportExtendedSystemHandleInformation )
          v14 = SystemExtendedHandleInformation;
        result = NtQuerySystemInformation(v14, gpSystemHandleInfo, v13, &ReturnLength);
        if ( !result )
          return result;
      }
      result = memset(gpSystemHandleInfo, 0, gdwSystemHandleInfoLength);
    }
  }
  else
  {
    if ( gpSystemHandleInfo3 )
      free(gpSystemHandleInfo3);
    v1 = gdwProcessIdSelected;
    gpSystemHandleInfo3 = 0;
    if ( gdwValue_4F10B8[2] == gdwProcessIdSelected )
    {
      gpSystemHandleInfo3 = gpSystemHandleInfo2;
    }
    else
    {
      if ( gpSystemHandleInfo2 )
      {
        free(gpSystemHandleInfo2);
        v1 = gdwProcessIdSelected;
      }
      gdwValue_4F10B8[2] = v1;
    }
    v2 = gdwSystemHandleInfoLength;
    v3 = malloc(gdwSystemHandleInfoLength);
    gpSystemHandleInfo2 = v3;
    v15 = v3;
    v4 = SystemHandleInformation;
    if ( gbSupportExtendedSystemHandleInformation )
      v4 = SystemExtendedHandleInformation;
    result = NtQuerySystemInformation(v4, v15, v2, &ReturnLength);
    if ( result )
    {
      while ( result != STATUS_ACCESS_DENIED )
      {
        if ( result == STATUS_INSUFFICIENT_RESOURCES )
        {
          MessageBoxW(
            NULL,
            L"Insufficient system resources to get handle information.",
            L"Process Explorer",
            MB_ICONERROR);
          v9 = gdwSystemHandleInfoLength;
          memset(gpSystemHandleInfo2, 0, gdwSystemHandleInfoLength);
          return memset(gpSystemHandleInfo2, 0, v9);
        }
        free(gpSystemHandleInfo2);
        gdwSystemHandleInfoLength *= 2;
        v6 = gdwSystemHandleInfoLength;
        v7 = malloc(gdwSystemHandleInfoLength);
        gpSystemHandleInfo2 = v7;
        v16 = v7;
        v8 = 16;
        if ( gbSupportExtendedSystemHandleInformation )
          v8 = SystemExtendedHandleInformation;
        result = NtQuerySystemInformation(v8, v16, v6, &ReturnLength);
        if ( !result )
          return result;
      }
      result = memset(gpSystemHandleInfo2, 0, gdwSystemHandleInfoLength);
    }
  }
  return result;
}
// 10610B8: using guessed type int gdwValue_4F10B8[3];
// 106ABA5: using guessed type char gbSupportExtendedSystemHandleInformation;

//----- (00FF7A70) --------------------------------------------------------
signed int OnBeforeInit()
{
  int v0; // eax
  HMODULE v1; // eax
  int dwNumberOfProcessors; // esi
  signed int result; // eax
  int Status; // eax
  HMODULE v5; // eax
  HMODULE v6; // eax
  HMODULE v7; // eax
  char v8; // cl
  HMODULE v9; // eax
  HMODULE v10; // eax
  HMODULE v11; // eax
  HMODULE v12; // eax
  unsigned int nIndex; // edx
  RegItem *pItem; // ecx
  __int16 v15; // ax
  unsigned int nIndex_1; // edx
  RegItem *v17; // ecx
  __int16 v18; // ax
  double dwTotalPageFile; // xmm0_8
  void (__stdcall *GlobalMemoryStatusEx)(LPMEMORYSTATUS); // esi
  CGraphData *v21; // eax
  DWORD dwVersion; // [esp+10h] [ebp-80h]
  _MEMORYSTATUSEX MemoryStatusEx; // [esp+14h] [ebp-7Ch]
  struct _MEMORYSTATUS MemoryStatus; // [esp+54h] [ebp-3Ch]
  CPPEH_RECORD ms_exc; // [esp+78h] [ebp-18h]

  dwVersion = 152;
  ghMainInstance = ghInstance;
  v0 = GetSystemMetrics(SM_CXVIRTUALSCREEN);
  gdwVirtualScreenWidth = v0;
  if ( !v0 )
    v0 = GetSystemMetrics(SM_CXSCREEN);
  gdwVirtualScreenWidth = v0 / 2;
  v1 = GetModuleHandleW(L"kernel32.dll");
  *GetLongPathNameW = GetProcAddress(v1, "GetLongPathNameW");
  dwNumberOfProcessors = gSystemInfo.dwNumberOfProcessors;
  gpSystemPerformanceInfo = malloc(sizeof(SYSTEM_PROCESSOR_PERFORMANCE_INFORMATION) * gSystemInfo.dwNumberOfProcessors);
  gpSystemInterruptInfo = malloc(sizeof(SYSTEM_INTERRUPT_INFORMATION) * dwNumberOfProcessors);
  gpSystemProcessorCycleTimeInfo = malloc(8 * dwNumberOfProcessors);
  TmAdjustPrivilege(L"SeDebugPrivilege");
  TmAdjustPrivilege(L"SeBackupPrivilege");
  TmAdjustPrivilege(L"SeSecurityPrivilege");
  if ( !CDriver::Load() )
    goto LABEL_7;
  dwNumberOfProcessors = VirtualAlloc(NULL, 4u, MEM_COMMIT, PAGE_READWRITE);
  ms_exc.registration.TryLevel = 0;
  if ( !CDriver::Control(0x83350008, &dwVersion, 4u, dwNumberOfProcessors, 4u) || *dwNumberOfProcessors < dwVersion )
  {
    CDriver::Close();
    if ( CDriver::Load() )
    {
      if ( CDriver::Control(0x83350008, &dwVersion, 4u, dwNumberOfProcessors, 4u) && *dwNumberOfProcessors >= dwVersion )
        goto LABEL_16;
      MessageBoxW(
        0,
        L"Driver version mismatch. You must reboot before you can run this version of Process Explorer.",
        L"Process Explorer",
        MB_ICONERROR);
    }
    CDriver::Close();
LABEL_16:
    ms_exc.registration.TryLevel = -2;
    return 0;
  }
  ms_exc.registration.TryLevel = -2;
  VirtualFree(dwNumberOfProcessors, 4u, MEM_DECOMMIT);
LABEL_7:
  if ( LoadSystemApis() )
  {
    Status = NtQuerySystemInformation(SystemExtendedHandleInformation, 0, 0, 0);
    if ( Status == STATUS_INVALID_INFO_CLASS
      || (gbSupportExtendedSystemHandleInformation = 1, Status == STATUS_NOT_IMPLEMENTED) )
    {
      gbSupportExtendedSystemHandleInformation = 0;
    }
    ghSCManagerHandle = OpenSCManagerW(NULL, NULL, SC_MANAGER_ENUMERATE_SERVICE);
    *EnumServicesStatusExW = 0;
    if ( ghSCManagerHandle )
    {
      v5 = GetModuleHandleW(L"advapi32.dll");
      *EnumServicesStatusExW = GetProcAddress(v5, "EnumServicesStatusExW");
      v6 = GetModuleHandleW(L"advapi32.dll");
      *QueryServiceConfig2W = GetProcAddress(v6, "QueryServiceConfig2W");
    }
    if ( IsWinServer(GetModuleHandleW, dwNumberOfProcessors) )
    {
      v7 = GetModuleHandleW(L"kernel32.dll");
      gpfnProcessIdToSessionId = GetProcAddress(v7, "ProcessIdToSessionId");
      v8 = gbProcessIdToSessionIdValid;
      if ( gpfnProcessIdToSessionId )
        v8 = 1;
      gbProcessIdToSessionIdValid = v8;
    }
    v9 = LoadLibraryW(L"winsta.dll");
    WinStationGetProcessSid = GetProcAddress(v9, "WinStationGetProcessSid");
    v10 = GetModuleHandleW(L"kernel32.dll");
    *IsProcessInJob = GetProcAddress(v10, "IsProcessInJob");
    v11 = GetModuleHandleW(L"kernel32.dll");
    *QueryInformationJobObject = GetProcAddress(v11, "QueryInformationJobObject");
    v12 = GetModuleHandleW(L"kernel32.dll");
    *SetProcessAffinityMask = GetProcAddress(v12, "SetProcessAffinityMask");
    InitializeCriticalSection(&gServiceLock);
    GetDriverNameAndLinkInfo();
    nIndex = 0;
    do
    {
      pItem = &stru_1060320[nIndex + 2];
      do
      {
        v15 = pItem->field_0;
        pItem = (pItem + 2);
      }
      while ( v15 );
      stru_1060320[nIndex + 2].field_240 = (pItem - (&stru_1060320[nIndex + 2].field_0 + 2)) >> 1;
      ++nIndex;
    }
    while ( nIndex < 4 );
    nIndex_1 = 0;
    do
    {
      v17 = &stru_1060320[nIndex_1];
      do
      {
        v18 = v17->field_0;
        v17 = (v17 + 2);
      }
      while ( v18 );
      stru_1060320[nIndex_1].field_240 = (v17 - (&stru_1060320[nIndex_1].field_0 + 2)) >> 1;
      ++nIndex_1;
    }
    while ( nIndex_1 < 2 );
    LoadNetClrMemoryPerformanceInfo();
    if ( gdwVersion >= 1 )
      QueryTagInformationEx(&ppv, 0, &pdwValue3, &pdwValue4);
    gpGraphInfoOfCPU = InitGraphData(1, 2, 1);
    gpGraphInfoOfCPU->m_nItemID = 0;
    gpGraphInfoOfCPU->m_Color = 0x3C943C;
    gpGraphInfoOfCPU->m_dbMemorySize = db_onehundred;
    if ( gpGraphInfoOfCPU->m_nChildID == 2 )
    {
      gpGraphInfoOfCPU->m_Item[0].Color = 255;
      gpGraphInfoOfCPU->m_Item[0].dbMemorySize = db_onehundred;
    }
    gpGraphInfoOfMemory = InitGraphData(1, 1, 0);
    gpGraphInfoOfMemory->m_nItemID = 1;
    gpGraphInfoOfMemory->m_Color = 0xAAAA;
    if ( ::GlobalMemoryStatusEx )
    {
      MemoryStatusEx.dwLength = 64;
      ::GlobalMemoryStatusEx(&MemoryStatusEx);
      dwTotalPageFile = MemoryStatusEx.ullTotalPageFile;
      GlobalMemoryStatusEx = GlobalMemoryStatus;
    }
    else
    {
      MemoryStatus.dwLength = sizeof(_MEMORYSTATUS);
      GlobalMemoryStatusEx = GlobalMemoryStatus;
      GlobalMemoryStatus(&MemoryStatus);
      dwTotalPageFile = MemoryStatus.dwTotalPageFile;
    }
    gpGraphInfoOfMemory->m_dbMemorySize = dwTotalPageFile * 0.0009765625;
    MemoryStatus.dwLength = 32;
    GlobalMemoryStatusEx(&MemoryStatus);
    v21 = InitGraphData(2, 1, 0);
    gpGraphInfoOfPhysicalMemory = v21;
    v21->m_nItemID = 3;
    gpGraphInfoOfPhysicalMemory->m_Color = 0x4080FF;
    gpGraphInfoOfPhysicalMemory->m_dbMemorySize = MemoryStatus.dwTotalPhys;
    sub_FB43A0(&gIOGraphInfo);
    sub_FB43A0(&gNetworkGraphInfo);
    sub_FB43A0(&gDiskGraphInfo);
    sub_FDE920();
    result = 1;
  }
  else
  {
    if ( ghDriverHandle != -1 )
      CloseHandle(ghDriverHandle);
    result = 0;
  }
  return result;
}
// 103CDC0: using guessed type double db_onehundred;
// 1060320: using guessed type RegItem stru_1060320[4];
// 1064E28: using guessed type int gdwVirtualScreenWidth;
// 1064E54: using guessed type int gdwVersion;
// 106A38A: using guessed type char gbProcessIdToSessionIdValid;
// 106ABA5: using guessed type char gbSupportExtendedSystemHandleInformation;
// 106F280: using guessed type int (__stdcall *gpfnProcessIdToSessionId)(_DWORD, _DWORD);
// 106F2E8: using guessed type int (__stdcall *GlobalMemoryStatusEx)(_DWORD);

//----- (00FF7F90) --------------------------------------------------------
LRESULT __cdecl sub_FF7F90(HWND hWnd, int a2, int a3)
{
  LRESULT result; // eax
  LPARAM lParam; // [esp+0h] [ebp-34h]
  LRESULT v5; // [esp+4h] [ebp-30h]
  int v6; // [esp+8h] [ebp-2Ch]
  int v7; // [esp+Ch] [ebp-28h]
  int v8; // [esp+10h] [ebp-24h]
  int v9; // [esp+14h] [ebp-20h]
  int v10; // [esp+1Ch] [ebp-18h]
  int v11; // [esp+20h] [ebp-14h]

  memset(&v5, 0, 0x30u);
  v9 = a2;
  lParam = 5;
  v5 = 0x7FFFFFFF;
  v6 = 0;
  v8 = 0;
  v7 = 0;
  v10 = 0;
  v11 = 1;
  result = SendMessageW(hWnd, 0x104Du, 0, &lParam);
  if ( result != -1 )
  {
    v5 = result;
    v9 = a3;
    lParam = 1;
    v6 = 1;
    result = SendMessageW(hWnd, 0x104Cu, 0, &lParam);
  }
  return result;
}

//----- (00FF8030) --------------------------------------------------------
char __cdecl sub_FF8030(int ArgList, DWORD dwProcessId)
{
  char result; // al
  HANDLE v3; // eax
  void *v4; // esi
  WCHAR Text; // [esp+4h] [ebp-804h]

  if ( gConfig.bConfirmKill
    && (wsprintfW(&Text, L"Are you sure you want to kill %s?", ArgList),
        MessageBoxW(ghMainWnd, &Text, L"Process Explorer", 0x31u) == 2) )
  {
    SetFocus(ghWndTreeListView);
    result = 0;
  }
  else
  {
    v3 = OpenProcess(1u, 0, dwProcessId);
    v4 = v3;
    if ( v3 )
    {
      if ( TerminateProcess(v3, 1u) )
      {
        CloseHandle(v4);
        Sleep(0xFAu);
        result = 1;
      }
      else
      {
        ReportMsg(L"Error terminating process", ghMainWnd);
        CloseHandle(v4);
        result = 0;
      }
    }
    else
    {
      ReportMsg(L"Error opening process", ghMainWnd);
      result = 0;
    }
  }
  return result;
}
// 1042088: using guessed type wchar_t aErrorOpeningPr[22];
// 1042C34: using guessed type wchar_t aErrorTerminati[26];

//----- (00FF8140) --------------------------------------------------------
void __cdecl sub_FF8140(int ArgList, int a2)
{
  tagTREEVIEWLISTITEMPARAM *i; // esi
  tagTREEVIEWLISTITEMPARAM *v3; // eax
  HANDLE v4; // eax
  void *v5; // edi
  HWND v6; // edi
  DWORD v7; // eax
  WCHAR Buffer[2]; // [esp+0h] [ebp-A08h]
  WCHAR Text; // [esp+4h] [ebp-A04h]
  WCHAR Dst; // [esp+804h] [ebp-204h]

  if ( gConfig.bConfirmKill
    && (wsprintfW(&Text, L"Are you sure you want to kill %s and its descendants?", ArgList),
        MessageBoxW(ghMainWnd, &Text, L"Process Explorer", 0x31u) == 2) )
  {
    SetFocus(ghWndTreeListView);
  }
  else
  {
    for ( i = gpTreeViewListItemParam; i; i = i->m_Prev )
    {
      v3 = i;
      if ( i )
      {
        while ( v3->dwProcessId != a2 )
        {
          v3 = v3->pItemParam;
          if ( !v3 )
            goto LABEL_17;
        }
        v4 = OpenProcess(1u, 0, i->dwProcessId);
        v5 = v4;
        if ( v4 )
        {
          if ( !TerminateProcess(v4, 1u) )
          {
            wsprintfW(&Text, L"Error terminating %s", i->szProcessName2);
            ReportMsg(&Text, ghMainWnd);
          }
          CloseHandle(v5);
        }
        else
        {
          wsprintfW(&Text, L"Error opening %s", i->szProcessName2);
          v6 = ghMainWnd;
          v7 = GetLastError();
          if ( v7 )
          {
            FormatMessageW(0x1100u, 0, v7, 0x400u, Buffer, 0, 0);
            wsprintf(&Dst, L"%s: %s", &Text, *Buffer);
            LocalFree(*Buffer);
          }
          else
          {
            wsprintf(&Dst, L"%s.", &Text);
          }
          MessageBoxW(v6, &Dst, L"Process Explorer", 0x10u);
        }
      }
LABEL_17:
      ;
    }
    Sleep(0xFAu);
  }
}

//----- (00FF8310) --------------------------------------------------------
int __cdecl SystemProcessInfo_GetSystemProcessName(DWORD dwProcessId, LARGE_INTEGER *FileTime, WCHAR *pszText, DWORD dwSize)
{
  int result; // eax
  SYSTEM_PROCESS_INFORMATION *i; // ecx

  if ( dwProcessId == -10 )
    return wcscpy_s(pszText, dwSize, L"Hardware Interrupts and DPCs");
  for ( i = gpSystemProcessInfo;
        dwProcessId != i->UniqueProcessId || FileTime && i->CreateTime.QuadPart > *FileTime;
        i = (i + i->NextEntryOffset) )
  {
    if ( !i->NextEntryOffset )
      return wcscpy_s(pszText, dwSize, L"<Non-existent Process>");
  }
  if ( i->ImageName.Length )
    result = wcsncpy_s(pszText, dwSize, i->ImageName.Buffer, i->ImageName.Length >> 1);
  else
    result = wcscpy_s(pszText, dwSize, L"System Idle Process");
  return result;
}

//----- (00FF83C0) --------------------------------------------------------
bool __cdecl QueryProcessUsers(HANDLE ProcessHandle, DWORD dwProcessId, int LowTime, wchar_t *pszUserName, DWORD cbUserName, WCHAR *szDomainName, DWORD cbDomainName, LPWSTR pszText, DWORD cbText, BOOL *pbVirtualizationEnabled, BOOL *pbUIAccess)
{
  BOOL Status; // eax
  BOOL (__stdcall *GetTokenInformation)(HANDLE, TOKEN_INFORMATION_CLASS, LPVOID, DWORD, PDWORD); // eax
  BOOL (__stdcall *GetTokenInformation_1)(HANDLE, TOKEN_INFORMATION_CLASS, LPVOID, DWORD, PDWORD); // ebx
  const wchar_t *v14; // eax
  FILETIME FileTime; // [esp+10h] [ebp-A24h]
  HANDLE ProcessHandle_1; // [esp+18h] [ebp-A1Ch]
  LPWSTR pszDomainName; // [esp+1Ch] [ebp-A18h]
  DWORD dwProcessId_1; // [esp+20h] [ebp-A14h]
  void *TokenHandle; // [esp+24h] [ebp-A10h]
  DWORD cbRet; // [esp+28h] [ebp-A0Ch]
  int fOK; // [esp+2Ch] [ebp-A08h]
  WCHAR ReferencedDomainName[256]; // [esp+30h] [ebp-A04h]
  char SidBuf[2048]; // [esp+230h] [ebp-804h]

  ProcessHandle_1 = ProcessHandle;
  dwProcessId_1 = dwProcessId;
  FileTime.dwLowDateTime = LowTime;
  pszDomainName = szDomainName;
  FileTime.dwHighDateTime = pbVirtualizationEnabled;
  TokenHandle = 0;
  HIBYTE(fOK) = 0;
  wcscpy_s(pszUserName, cbUserName, &gszNullString);
  wcscpy_s(szDomainName, cbDomainName, &gszNullString);
  LOBYTE(Status) = pbVirtualizationEnabled;
  if ( pbVirtualizationEnabled )
    *FileTime.dwHighDateTime = 0;
  if ( !WinStationGetProcessSid
    || (LOBYTE(Status) = FileTime.dwLowDateTime, !FileTime.dwLowDateTime)
    || (cbRet = 2048,
        LOBYTE(Status) = WinStationGetProcessSid(0, dwProcessId_1, *FileTime.dwLowDateTime, SidBuf, &cbRet),
        !Status) )
  {
LABEL_8:
    if ( !pszText )
      goto LABEL_10;
    goto LABEL_9;
  }
  LOBYTE(Status) = UserInfoWithSIDList_Find(SidBuf, pszUserName, cbUserName, pszDomainName, cbDomainName);
  if ( !Status )
  {
    LOBYTE(Status) = wcscpy_s(pszUserName, cbUserName, L"<unknown owner>");
    goto LABEL_8;
  }
  HIBYTE(fOK) = 1;
  if ( gdwVersion < WINDOWS_VISTA || !pszText )
    return Status;
LABEL_9:
  LOBYTE(Status) = wcscpy_s(pszText, cbText, &gszNullString);
LABEL_10:
  if ( ProcessHandle_1 )
  {
    Status = DeviceIoControl(
               ghDriverHandle,
               0x8335000C,
               &ProcessHandle_1,
               4u,
               &TokenHandle,
               4u,
               &FileTime.dwLowDateTime,
               0);
    if ( !Status )
    {
      Status = OpenProcessToken(ProcessHandle_1, TOKEN_QUERY, &TokenHandle);
      if ( !Status )
        LOBYTE(Status) = wcscpy_s(pszUserName, cbUserName, L"<unable to open token>");
    }
    if ( TokenHandle )
    {
      GetTokenInformation = ::GetTokenInformation;
      if ( gdwVersion < WINDOWS_VISTA )
        goto LABEL_37;
      if ( !pszText )
      {
LABEL_29:
        if ( gdwVersion >= WINDOWS_VISTA )
        {
          if ( pbUIAccess && !GetTokenInformation(TokenHandle, TokenUIAccess, pbUIAccess, 4u, &cbRet) )
            *pbUIAccess = 0;
          if ( gdwVersion >= WINDOWS_VISTA )
          {
            GetTokenInformation_1 = ::GetTokenInformation;
            if ( FileTime.dwHighDateTime
              && !::GetTokenInformation(TokenHandle, TokenVirtualizationEnabled, FileTime.dwHighDateTime, 4u, &cbRet) )
            {
              *FileTime.dwHighDateTime = -1;
            }
            goto LABEL_38;
          }
        }
LABEL_37:
        GetTokenInformation_1 = ::GetTokenInformation;
LABEL_38:
        if ( !HIBYTE(fOK) )
        {
          cbRet = 2048;
          if ( GetTokenInformation_1(TokenHandle, TokenUser, SidBuf, 0x800u, &cbRet) )
          {
            if ( !UserInfoWithSIDList_Find(*SidBuf, pszUserName, cbUserName, pszDomainName, cbDomainName) )
              wcscpy_s(pszUserName, cbUserName, L"<unknown owner>");
          }
          else
          {
            wcscpy_s(pszUserName, cbUserName, L"<unable to query owner>");
          }
        }
        LOBYTE(Status) = CloseHandle(TokenHandle);
        return Status;
      }
      dwProcessId_1 = 0;
      cbRet = 4;
      if ( gdwVersion >= WINDOWS_8 )
      {
        if ( ::GetTokenInformation(TokenHandle, MaxTokenInfoClass, &dwProcessId_1, 4u, &cbRet) && dwProcessId_1 )
        {
          wcscat_s(pszText, cbText, L"AppContainer");
LABEL_28:
          GetTokenInformation = ::GetTokenInformation;
          goto LABEL_29;
        }
        GetTokenInformation = ::GetTokenInformation;
      }
      cbRet = 2048;
      if ( GetTokenInformation(TokenHandle, TokenIntegrityLevel, SidBuf, 0x800u, &cbRet) )
      {
        UserInfoWithSIDList_Find(*SidBuf, pszText, cbText, ReferencedDomainName, 0x100u);
        if ( wcsstr(pszText, L" Mandatory Level") )
          *wcsstr(pszText, L" Mandatory Level") = 0;
      }
      goto LABEL_28;
    }
  }
  else if ( !HIBYTE(fOK) )
  {
    v14 = L"NT AUTHORITY\\SYSTEM";
    if ( dwProcessId_1 )
      v14 = L"<access denied>";
    LOBYTE(Status) = wcscpy_s(pszUserName, cbUserName, v14);
  }
  return Status;
}
// 102D238: using guessed type wchar_t aNtAuthoritySys[20];
// 1064E54: using guessed type int gdwVersion;

//----- (00FF8790) --------------------------------------------------------
int GetDriverNameAndLinkInfo()
{
  unsigned __int16 iChar; // si
  WCHAR *pszDriverName; // ebx
  signed int chDriver; // edi
  int RtlInitUnicodeString; // eax
  HMODULE v4; // eax
  FARPROC RtlInitUnicodeString_1; // eax
  HMODULE v6; // eax
  int nDriverCount; // eax
  int result; // eax
  struct _UNICODE_STRING DestinationString; // [esp+Ch] [ebp-2E0h]
  struct _UNICODE_STRING strDeviceName; // [esp+14h] [ebp-2D8h]
  PCWSTR SourceString; // [esp+1Ch] [ebp-2D0h]
  ULONG ReturnedLength; // [esp+20h] [ebp-2CCh]
  OBJECT_ATTRIBUTES ObjectAttributes; // [esp+24h] [ebp-2C8h]
  int iDriver; // [esp+3Ch] [ebp-2B0h]
  HANDLE hLinkObject; // [esp+40h] [ebp-2ACh]
  WCHAR szDeviceName[64]; // [esp+44h] [ebp-2A8h]
  UNICODE_STRING strLinkTarget; // [esp+C4h] [ebp-228h]
  WCHAR szLinkNameBuffer[260]; // [esp+CCh] [ebp-220h]
  WCHAR szDriverName[10]; // [esp+2D4h] [ebp-18h]

  iDriver = 0;
  iChar = 0;
  pszDriverName = gszDriverName;
  chDriver = 'A';
  do
  {
    MakeDriverName(szDriverName, L"%c:\\", chDriver);
    if ( GetDriveTypeW(szDriverName) != FILE_TYPE_PIPE && GetDriveTypeW(szDriverName) != FILE_TYPE_CHAR )
      goto LABEL_17;
    MakeDeviceName(szDeviceName, L"\\DosDevices\\%c:", chDriver);
    RtlInitUnicodeString = *gpfnRtlInitUnicodeString;
    ObjectAttributes.Length = sizeof(OBJECT_ATTRIBUTES);
    ObjectAttributes.RootDirectory = 0;
    ObjectAttributes.Attributes = OBJ_CASE_INSENSITIVE;
    if ( !*gpfnRtlInitUnicodeString )
    {
      v4 = GetModuleHandleW(L"ntdll.dll");
      RtlInitUnicodeString = GetProcAddress(v4, "RtlInitUnicodeString");
      *gpfnRtlInitUnicodeString = RtlInitUnicodeString;
    }
    (RtlInitUnicodeString)(&strDeviceName, szDeviceName);
    ObjectAttributes.SecurityDescriptor = 0;
    ObjectAttributes.ObjectName = &strDeviceName;
    ObjectAttributes.SecurityQualityOfService = 0;
    if ( gpfn_NtOpenSymbolicLinkObject(&hLinkObject, 0x20001u, &ObjectAttributes) )
    {
LABEL_17:
      nDriverCount = iDriver;
    }
    else
    {
      strLinkTarget.Length = MAX_PATH;
      strLinkTarget.Buffer = szLinkNameBuffer;
      gpfn_NtQuerySymbolicLinkObject(hLinkObject, &strLinkTarget, &ReturnedLength);
      CloseHandle(hLinkObject);
      SourceString = strLinkTarget.Buffer;
      RtlInitUnicodeString_1 = *gpfnRtlInitUnicodeString;
      ObjectAttributes.Length = sizeof(OBJECT_ATTRIBUTES);
      ObjectAttributes.RootDirectory = 0;
      ObjectAttributes.Attributes = OBJ_CASE_INSENSITIVE;
      if ( !*gpfnRtlInitUnicodeString )
      {
        v6 = GetModuleHandleW(L"ntdll.dll");
        RtlInitUnicodeString_1 = GetProcAddress(v6, "RtlInitUnicodeString");
        *gpfnRtlInitUnicodeString = RtlInitUnicodeString_1;
      }
      (RtlInitUnicodeString_1)(&DestinationString, SourceString);
      ObjectAttributes.SecurityDescriptor = 0;
      ObjectAttributes.ObjectName = &DestinationString;
      ObjectAttributes.SecurityQualityOfService = 0;
      if ( !gpfn_NtOpenSymbolicLinkObject(&hLinkObject, 0x20001u, &ObjectAttributes) )
      {
        strLinkTarget.MaximumLength = MAX_PATH;
        strLinkTarget.Buffer = szLinkNameBuffer;
        gpfn_NtQuerySymbolicLinkObject(hLinkObject, &strLinkTarget, &ReturnedLength);
        CloseHandle(hLinkObject);
      }
      wcscpy_s(pszDriverName - 256, 0x100u, strLinkTarget.Buffer);
      *pszDriverName = iChar + 'A';
      nDriverCount = iDriver + 1;
      pszDriverName += 257;
      ++iDriver;
    }
    ++iChar;
    ++chDriver;
  }
  while ( iChar < 26u );
  result = 257 * nDriverCount;
  gszDriverLinkName[result] = 0;
  return result * 2;
}

//----- (00FF8A20) --------------------------------------------------------
char __cdecl sub_FF8A20(int a1)
{
  char result; // al
  char v2; // dl
  signed int v3; // esi

  result = 0;
  v2 = *(a1 + 24);
  if ( v2 )
  {
    v3 = *(a1 + 28);
    if ( v3 < gConfig.dwHighlightDuration )
    {
      *(a1 + 20) = v3;
      *(a1 + 16) = 2;
      return result;
    }
    if ( v2 )
    {
      result = 1;
      *(a1 + 24) = 0;
    }
  }
  *(a1 + 16) = 0;
  return result;
}

//----- (00FF8A60) --------------------------------------------------------
int __cdecl ReportMsg(int ArgList, HWND hWnd)
{
  DWORD v2; // eax
  WCHAR Buffer[2]; // [esp+8h] [ebp-208h]
  WCHAR Text; // [esp+Ch] [ebp-204h]

  v2 = GetLastError();
  if ( v2 )
  {
    FormatMessageW(0x1100u, 0, v2, 0x400u, Buffer, 0, 0);
    wsprintf(&Text, L"%s: %s", ArgList, *Buffer);
    LocalFree(*Buffer);
  }
  else
  {
    wsprintf(&Text, L"%s.", ArgList);
  }
  return MessageBoxW(hWnd, &Text, L"Process Explorer", 0x10u);
}

//----- (00FF8B10) --------------------------------------------------------
int __stdcall PageProcStrings(HWND hWnd, UINT msg, WPARAM wParam, LPARAM lParam)
{
  tagTREEVIEWLISTITEMPARAM *pTreeItem; // esi
  HWND hWndList; // ebx
  CResizer *v7; // eax
  LONG v8; // eax
  HWND v9; // ST14_4
  HWND v10; // eax
  LRESULT v11; // ST14_4
  HWND v12; // eax
  LRESULT v13; // ST14_4
  HWND v14; // eax
  void *dwProcessId; // eax
  WCHAR *pszClassName; // ecx
  HANDLE ProcessHandle; // eax
  char v18; // al
  HANDLE v19; // esi
  void (__stdcall *SendMessageW)(HWND, UINT, WPARAM, LPARAM); // esi
  LRESULT v21; // ST14_4
  HWND v22; // eax
  LRESULT v23; // ST14_4
  HWND v24; // eax
  wchar_t *v25; // eax
  HWND v26; // eax
  HANDLE v27; // esi
  LRESULT v28; // eax
  HGLOBAL v29; // edi
  _WORD *v30; // eax
  HGLOBAL v31; // eax
  char *v32; // esi
  rsize_t v33; // ST04_4
  LRESULT i; // esi
  HCURSOR v35; // esi
  int v36; // eax
  HCURSOR v37; // esi
  char v38; // bl
  HWND v39; // esi
  HWND v40; // eax
  HWND hWndFindWindow; // eax
  HWND v42; // eax
  WPARAM v43; // [esp-8h] [ebp-29Ch]
  LVITEMW Item; // [esp+Ch] [ebp-288h]
  tagLVITEMW ItemInfo; // [esp+40h] [ebp-254h]
  LPCVOID lpBaseAddress; // [esp+74h] [ebp-220h]
  DWORD dwSize; // [esp+78h] [ebp-21Ch]
  UINT nIDs; // [esp+7Ch] [ebp-218h]
  WORD nWidths[2]; // [esp+80h] [ebp-214h]
  HANDLE dwPid; // [esp+84h] [ebp-210h]
  HANDLE hDlg; // [esp+88h] [ebp-20Ch]
  tagTREEVIEWLISTITEMPARAM *dwNewLong; // [esp+8Ch] [ebp-208h]
  WCHAR szText[256]; // [esp+90h] [ebp-204h]

  hDlg = hWnd;
  dwNewLong = lParam;
  pTreeItem = GetWindowLongW(hWnd, GWLP_USERDATA);
  ItemInfo.mask = 0;
  memset(&ItemInfo.iItem, 0, 0x30u);
  hWndList = GetDlgItem(hWnd, IDC_PROCSTRINGS_LISTCTRL);
  nIDs = IDS_VALUE;
  nWidths[0] = MulDiv(100, gLogPixelSize.x, 96);
  if ( msg > WM_INITDIALOG )
  {
    switch ( msg )
    {
      case WM_COMMAND:
        if ( wParam > IDC_PROCSTRINGS_BUTTON_SAVE )
        {
          if ( wParam > IDM_LISTCTRL_SELECTALL )
          {
            if ( wParam == IDM_PROCSTRINGS_FINDITEM && sbFound )
            {
              v35 = SetCursor(ghWaitCursor);
              ProcStrings_FindItem(hDlg, hWndList, &gFindReplaceItem, sstrFindWhat, &sbFound, sstrFindResult);
              SetCursor(v35);
              ReleaseCapture();
            }
          }
          else if ( wParam == IDM_LISTCTRL_SELECTALL )
          {
            for ( i = 0; i < ::SendMessageW(hWndList, LVM_GETITEMCOUNT, 0, 0); ++i )
            {
              Item.stateMask = LVIS_SELECTED;
              Item.state = LVIS_SELECTED;
              ::SendMessageW(hWndList, LVM_SETITEMSTATE, i, &Item);
            }
          }
          else
          {
            if ( wParam != IDM_LISTCTRL_COPY )
            {
              if ( wParam - 40092 > 1 )
                return 0;
              v43 = wParam;
              goto LABEL_50;
            }
            // 执行复制到剪贴板
            v27 = 0;
            dwNewLong = 0;
            v28 = ::SendMessageW(hWndList, LVM_GETNEXTITEM, ItemInfo.iItem, 2);
            ItemInfo.iItem = v28;
            if ( v28 != -1 )
            {
              v29 = 0;
              do
              {
                Item.iSubItem = 0;
                Item.pszText = szText;
                Item.cchTextMax = 256;
                ::SendMessageW(hWndList, LVM_GETITEMTEXTW, v28, &Item);
                dwNewLong = (dwNewLong + wcslen(szText) + 2);
                if ( v27 )
                {
                  v29 = GlobalReAlloc(v29, 2 * dwNewLong + 2, 0);
                  v30 = GlobalLock(v29);
                }
                else
                {
                  v31 = GlobalAlloc(0x2002u, 2 * dwNewLong + 2);
                  v29 = v31;
                  v30 = GlobalLock(v31);
                  *v30 = 0;
                }
                v32 = &dwNewLong->field_0 + 1;
                dwPid = v30;
                wcscat_s(v30, &dwNewLong->field_0 + 1, szText);
                v33 = v32;
                v27 = dwPid;
                wcscat_s(dwPid, v33, L"\r\n");
                GlobalUnlock(v29);
                v28 = ::SendMessageW(hWndList, LVM_GETNEXTITEM, ItemInfo.iItem, 2);
                ItemInfo.iItem = v28;
              }
              while ( v28 != -1 );
              dwPid = v29;
              if ( v29 )
              {
                if ( OpenClipboard(hDlg) )
                {
                  EmptyClipboard();
                  SetClipboardData(0xDu, dwPid);
                  CloseClipboard();
                }
              }
            }
          }
        }
        else if ( wParam == IDC_PROCSTRINGS_BUTTON_SAVE )
        {
          if ( pTreeItem->nListType )
          {
            v25 = wcsrchr(*&pTreeItem->gap154[4], 0x5Cu);
            SaveProcessStrings(hWndList, v25 + 1);
          }
          else
          {
            SaveProcessStrings(hWndList, pTreeItem->szProcessName2);
          }
        }
        else
        {
          // 镜像模式
          if ( wParam <= IDC_PROCSTRINGS_BUTTON_IMAGE )
          {
            switch ( wParam )
            {
              case IDC_PROCSTRINGS_BUTTON_IMAGE:
                ::SendMessageW(hWndList, WM_SETREDRAW, 0, 0);
                ::SendMessageW(hWndList, LVM_DELETEALLITEMS, 0, 0);
                if ( pTreeItem->nListType )
                  ImportStringsToListFromFile(hWndList, *&pTreeItem->gap154[4]);
                else
                  ImportStringsToListFromFile(hWndList, pTreeItem->szProcessName);
                ::SendMessageW(hWndList, LVM_SETCOLUMNWIDTH, 0, 0xFFFF);
                ::SendMessageW(hWndList, WM_SETREDRAW, 1u, 0);
                v11 = ::SendMessageW(hWndList, LVM_GETITEMCOUNT, 0, 0);
                v12 = GetDlgItem(hWnd, IDC_PROCSTRINGS_BUTTON_SAVE);
                EnableWindow(v12, v11);
                v13 = ::SendMessageW(hWndList, LVM_GETITEMCOUNT, 0, 0);
                v14 = GetDlgItem(hWnd, IDC_PROCSTRINGS_BUTTON_FIND);
                EnableWindow(v14, v13);
                break;
              case IDC_MYICON:
                EndDialog(hWnd, 0);
                return 1;
              case IDC_PROCSTRINGS_BUTTON_FIND:
                wcscpy_s(sstrFindWhat, 8192u, sstrFindResult);
                gFindReplaceItem.hInstance = ghInstance;
                gFindReplaceItem.lStructSize = sizeof(tagFINDREPLACEW);
                gFindReplaceItem.hwndOwner = hWnd;
                gFindReplaceItem.lpstrFindWhat = sstrFindWhat;
                gFindReplaceItem.lpstrReplaceWith = 0;
                *&gFindReplaceItem.wFindWhatLen = 8192;
                gFindReplaceItem.lCustData = 0;
                gFindReplaceItem.Flags = gdwFindReplaceFlags;
                gFindReplaceItem.lpfnHook = 0;
                gFindReplaceItem.lpTemplateName = 0;
                v9 = FindTextW(&gFindReplaceItem);
                v10 = GetParent(hWnd);
                SetPropW(v10, L"FindWindow", v9);
                break;
            }
            return 0;
          }
          // 内存模式
          if ( wParam != IDC_PROCSTRINGS_BUTTON_MEMORY )
          {
            if ( wParam != 40001 )
              return 0;
            v43 = 40014;
LABEL_50:
            v26 = GetParent(hWnd);
            PostMessageW(v26, WM_COMMAND, v43, 0);
            return 0;
          }
          ::SendMessageW(hWndList, 0xBu, 0, 0);
          ::SendMessageW(hWndList, LVM_DELETEALLITEMS, 0, 0);
          if ( pTreeItem->nListType )
          {
            dwProcessId = pTreeItem->dwStyle;
            pszClassName = *&pTreeItem->gap154[4];
          }
          else
          {
            dwProcessId = pTreeItem->dwProcessId;
            pszClassName = pTreeItem->szProcessName;
          }
          dwNewLong = pszClassName;
          dwPid = dwProcessId;
          ProcessHandle = OpenProcess(0x410u, 0, dwProcessId);
          hDlg = ProcessHandle;
          if ( ProcessHandle )
          {
            if ( pTreeItem->nListType )
            {
              LoadProcessStringsToList(hWndList, ProcessHandle, pTreeItem->nRefCount, pTreeItem->hFileIcon);
              v19 = hDlg;
            }
            else
            {
              v18 = QueryProcessImageBase(ProcessHandle, dwPid, dwNewLong, &lpBaseAddress, &dwSize);
              v19 = hDlg;
              if ( v18 )
                LoadProcessStringsToList(hWndList, hDlg, lpBaseAddress, dwSize);
            }
            CloseHandle(v19);
            SendMessageW = ::SendMessageW;
          }
          else
          {
            SendMessageW = ::SendMessageW;
            ItemInfo.mask = 5;
            ItemInfo.iItem = 0x7FFFFFFF;
            ItemInfo.pszText = L"<Error opening process>";
            ItemInfo.lParam = 1;
            ::SendMessageW(hWndList, LVM_INSERTITEMW, 0, &ItemInfo);
          }
          SendMessageW(hWndList, LVM_SETCOLUMNWIDTH, 0, 0xFFFF);
          SendMessageW(hWndList, WM_SETREDRAW, 1u, 0);
          v21 = (SendMessageW)(hWndList, LVM_GETITEMCOUNT, 0, 0);
          v22 = GetDlgItem(hWnd, IDC_PROCSTRINGS_BUTTON_SAVE);
          EnableWindow(v22, v21);
          v23 = ::SendMessageW(hWndList, LVM_GETITEMCOUNT, 0, 0);
          v24 = GetDlgItem(hWnd, IDC_PROCSTRINGS_BUTTON_FIND);
          EnableWindow(v24, v23);
        }
        return 0;
      case WM_CTLCOLOREDIT:
      case WM_CTLCOLORDLG:
      case WM_CTLCOLORSTATIC:
        return PE_FillControl(hWnd, wParam);
      default:
        goto LABEL_67;
    }
  }
  if ( msg != WM_INITDIALOG )
  {
    switch ( msg )
    {
      case WM_ALTTABACTIVE|WM_DESTROY:
        CMainWnd::DrawList(dwNewLong);
        return 0;
      case 0x2Cu:
        return CMainWnd::HandleMeasureItem(hWnd, msg, wParam, dwNewLong);
      case WM_KEYUP:
        if ( wParam == VK_F3 )
          ::SendMessageW(hWnd, WM_COMMAND, IDM_PROCSTRINGS_FINDITEM, 0);
        return 0;
      case WM_CHAR:
        if ( wParam == 'F' || wParam == 'f' )
        {
          if ( GetKeyState(VK_CONTROL) )
            ::SendMessageW(hWnd, WM_COMMAND, IDC_PROCSTRINGS_BUTTON_FIND, 0);
        }
        return 0;
      default:
        break;
    }
LABEL_67:
    if ( msg == gdwComdlg_FindReplaceMessageID )
    {
      v36 = dwNewLong->field_C;
      if ( v36 & 0x40 )
      {
        // FR_DOWN|FR_WHOLEWORD|FR_MATCHCASE
        gdwFindReplaceFlags = gFindReplaceItem.Flags & 7;
      }
      else if ( v36 & 8 )
      {
        v37 = SetCursor(ghWaitCursor);
        v38 = ProcStrings_FindItem(hDlg, hWndList, dwNewLong, sstrFindWhat, &sbFound, sstrFindResult);
        SetCursor(v37);
        ReleaseCapture();
        v39 = hDlg;
        v40 = GetParent(hDlg);
        hWndFindWindow = GetPropW(v40, L"FindWindow");
        if ( v38 && hWndFindWindow )
        {
          PostMessageW(hWndFindWindow, WM_COMMAND, IDC_DLG_DLLINFO_EDIT_COMPANY, 0);
          v42 = GetParent(v39);
          SetPropW(v42, L"FindWindow", 0);
        }
        else
        {
          SetFocus(hWndFindWindow);
        }
      }
    }
    return 0;
  }
  // WM_INITDIALOG，对话框初始化
  v7 = operator new(0x40u);
  if ( v7 )
    CResizer::CResizer(v7, hWnd);
  GetWindowTextW(hWnd, szText, 256);
  PropSheet_UpdateTab(hWnd);
  SetWindowLongW(hWnd, GWLP_USERDATA, dwNewLong);
  CheckRadioButton(hWnd, IDC_PROCSTRINGS_BUTTON_IMAGE, IDC_PROCSTRINGS_BUTTON_MEMORY, IDC_PROCSTRINGS_BUTTON_IMAGE);
  v8 = GetWindowLongW(hWndList, GWL_STYLE);
  SetWindowLongW(hWndList, -16, v8 & -3u | LVS_REPORT);
  SetWindowLongW(hWndList, -4, Proxy_ListCtrlWndProc);
  ::SendMessageW(hWndList, WM_SETFONT, ghConfigFont, 0);
  CTreeView::InitListHeader(hWndList, &nIDs, nWidths, 1u);
  PostMessageW(hWnd, WM_COMMAND, IDC_PROCSTRINGS_BUTTON_IMAGE, 0);
  return 1;
}
// 104606C: using guessed type wchar_t aErrorOpeningPr_1[24];
// 10610E0: using guessed type int gdwFindReplaceFlags;
// 106A32C: using guessed type int gdwComdlg_FindReplaceMessageID;

//----- (00FF9520) --------------------------------------------------------
char __usercall CMainWnd::RefreshDllsView@<al>(signed int a1@<ebx>, HWND hWnd, DWORD dwProcessId, WPARAM wParam)
{
  DWORD v4; // esi
  HWND v5; // edi
  _BYTE *v6; // eax
  tagTREEVIEWLISTITEMPARAM *v7; // ecx
  DLLLISTITEMPARAM *v8; // eax
  DLLLISTITEMPARAM *v9; // esi
  char v10; // al
  _DWORD *v11; // edi
  ULONG v12; // esi
  bool v13; // zf
  int v14; // ebx
  DLLLISTITEMPARAM *v15; // ecx
  wchar_t *v16; // eax
  CHAR *v17; // edx
  int v18; // ecx
  HANDLE v19; // esi
  char v20; // dl
  char v21; // dh
  signed int v22; // eax
  void *v23; // esi
  DLLLISTITEMPARAM *v25; // eax
  DLLLISTITEMPARAM *v26; // esi
  char v27; // al
  SYSTEM_PROCESS_INFORMATION *v28; // edi
  tagTREEVIEWLISTITEMPARAM *v29; // esi
  CHAR *v30; // eax
  DWORD v31; // ecx
  void *v32; // edi
  unsigned int *v33; // eax
  IAtlStringMgr *v34; // eax
  const WCHAR *v35; // esi
  wchar_t *v36; // edi
  DWORD v37; // eax
  WCHAR *v38; // esi
  signed int v39; // edi
  int v40; // eax
  const wchar_t *v41; // ebx
  int v42; // eax
  DLLLISTITEMPARAM *v43; // edi
  char v44; // cl
  char v45; // dl
  signed int v46; // eax
  char v47; // al
  char v48; // al
  char v49; // cl
  HANDLE v50; // edi
  PIMAGE_NT_HEADERS v51; // eax
  HANDLE v52; // edi
  int v53; // edi
  int v54; // esi
  int v55; // ecx
  DLLLISTITEMPARAM *v56; // eax
  char v57; // dl
  signed int v58; // ecx
  char v59; // al
  char v60; // [esp-188h] [ebp-29A0h]
  DWORD v61; // [esp-20h] [ebp-2838h]
  void *v62; // [esp-1Ch] [ebp-2834h]
  wchar_t *v63; // [esp-18h] [ebp-2830h]
  int *v64; // [esp-14h] [ebp-282Ch]
  const void *v65; // [esp-10h] [ebp-2828h]
  char *v66; // [esp-Ch] [ebp-2824h]
  WCHAR *v67; // [esp-8h] [ebp-2820h]
  wchar_t *v68; // [esp-4h] [ebp-281Ch]
  LPARAM v69; // [esp+Ch] [ebp-280Ch]
  int v70; // [esp+10h] [ebp-2808h]
  DLLLISTITEMPARAM *v71; // [esp+2Ch] [ebp-27ECh]
  struct _FILETIME v72; // [esp+40h] [ebp-27D8h]
  DWORD ThreadId; // [esp+48h] [ebp-27D0h]
  struct _FILETIME LastAccessTime; // [esp+4Ch] [ebp-27CCh]
  unsigned int *v75; // [esp+54h] [ebp-27C4h]
  DWORD ExitCode; // [esp+58h] [ebp-27C0h]
  struct _FILETIME LocalFileTime; // [esp+5Ch] [ebp-27BCh]
  struct _FILETIME CreationTime; // [esp+64h] [ebp-27B4h]
  struct _FILETIME LastWriteTime; // [esp+6Ch] [ebp-27ACh]
  int v80; // [esp+74h] [ebp-27A4h]
  unsigned int v81; // [esp+78h] [ebp-27A0h]
  ULONG ReturnLength; // [esp+7Ch] [ebp-279Ch]
  CString v83; // [esp+80h] [ebp-2798h]
  DWORD v84; // [esp+84h] [ebp-2794h]
  LPCWSTR lptstrFilename; // [esp+88h] [ebp-2790h]
  int v86; // [esp+8Ch] [ebp-278Ch]
  int v87; // [esp+90h] [ebp-2788h]
  _DWORD *v88; // [esp+94h] [ebp-2784h]
  void *v89; // [esp+98h] [ebp-2780h]
  HWND v90; // [esp+9Ch] [ebp-277Ch]
  SYSTEM_PROCESS_INFORMATION *v91; // [esp+A0h] [ebp-2778h]
  DWORD v92; // [esp+A4h] [ebp-2774h]
  int v93; // [esp+A8h] [ebp-2770h]
  DLLLISTITEMPARAM *v94; // [esp+ACh] [ebp-276Ch]
  char v95; // [esp+B2h] [ebp-2766h]
  int v96; // [esp+B3h] [ebp-2765h]
  int v97; // [esp+C4h] [ebp-2754h]
  wchar_t *v98; // [esp+D8h] [ebp-2740h]
  wchar_t v99; // [esp+DCh] [ebp-273Ch]
  int v100; // [esp+15Ch] [ebp-26BCh]
  int v101; // [esp+160h] [ebp-26B8h]
  int v102; // [esp+164h] [ebp-26B4h]
  wchar_t *v103; // [esp+168h] [ebp-26B0h]
  char v104; // [esp+16Ch] [ebp-26ACh]
  int v105; // [esp+17Ch] [ebp-269Ch]
  int v106; // [esp+180h] [ebp-2698h]
  char v107; // [esp+184h] [ebp-2694h]
  int v108; // [esp+190h] [ebp-2688h]
  int v109; // [esp+198h] [ebp-2680h]
  DWORD v110; // [esp+19Ch] [ebp-267Ch]
  char hObject; // [esp+1A0h] [ebp-2678h]
  char BaseAddress; // [esp+1A2h] [ebp-2676h]
  int v113; // [esp+1A4h] [ebp-2674h]
  __int16 v114; // [esp+1A8h] [ebp-2670h]
  struct _FILETIME v115; // [esp+1ACh] [ebp-266Ch]
  int v116; // [esp+1B4h] [ebp-2664h]
  wchar_t Dst; // [esp+1B8h] [ebp-2660h]
  wchar_t v118; // [esp+23Ah] [ebp-25DEh]
  DWORD dwLen; // [esp+2BCh] [ebp-255Ch]
  int v120; // [esp+2C0h] [ebp-2558h]
  LPCWSTR lpFileName; // [esp+2C4h] [ebp-2554h]
  wchar_t *v122; // [esp+2C8h] [ebp-2550h]
  SYSTEMTIME Date; // [esp+2F4h] [ebp-2524h]
  struct _SYSTEMTIME SystemTime; // [esp+304h] [ebp-2514h]
  char Buffer; // [esp+314h] [ebp-2504h]
  wchar_t v126; // [esp+2314h] [ebp-504h]
  LPARAM lParam; // [esp+2514h] [ebp-304h]
  WCHAR TimeStr; // [esp+2714h] [ebp-104h]
  WCHAR DateStr; // [esp+2794h] [ebp-84h]

  v87 = 0;
  v4 = dwProcessId;
  LOBYTE(a1) = 0;
  v5 = hWnd;
  v93 = 0;
  v95 = 0;
  v86 = 0;
  v89 = 0;
  LOWORD(lParam) = 1;
  v90 = hWnd;
  v92 = dwProcessId;
  v94 = a1;
  memset(&lParam + 2, 0, 0x1FEu);
  v6 = wParam;
  if ( !wParam )
  {
    if ( gConfig.dwDllColumnCount == wParam || !gConfig.bShowLowerPane )
      return 0;
    v89 = sub_FEDE60(dwProcessId);
    v6 = 0;
  }
  if ( dwProcessId )
  {
    v7 = gpTreeViewListItemParam;
    v86 = gpTreeViewListItemParam;
    if ( gpTreeViewListItemParam )
    {
      do
      {
        if ( v7->dwProcessId == dwProcessId )
          break;
        v7 = v7->m_Prev;
      }
      while ( v7 );
      v86 = v7;
    }
  }
  if ( !*CreateToolhelp32Snapshot_0 )
  {
    if ( !v6 )
    {
      if ( dwProcessId != gdwValue_4F10B8[1] )
      {
        v95 = 1;
        SendMessageW(hWnd, 0xBu, 0, 0);
        SendMessageW(hWnd, 0x1009u, 0, 0);
        SendMessageW(ghWndStatusBar, 0x40Du, gnStatusBarItemCount - 1, &lParam);
        SendMessageW(ghWndStatusBar, 0x40Bu, gnStatusBarItemCount - 1, L"Refreshing DLLs...");
        UpdateMenuStatus(0, 5);
      }
      v25 = gpDllListItemParamHeader;
      if ( gpDllListItemParamHeader )
      {
        do
        {
          v26 = v25->m_Prev;
          v71 = v25;
          v70 = -1;
          v27 = sub_FF58D0(a1, hWnd, &v69, v25, &v96);
          a1 = a1;
          if ( v27 )
            a1 = 1;
          if ( v96 )
            ++v87;
          v25 = v26;
        }
        while ( v26 );
        v4 = v92;
        v94 = a1;
      }
      v6 = wParam;
    }
    v28 = gpSystemProcessInfo;
    while ( 1 )
    {
      v91 = v28;
      if ( !v6 && v28->UniqueProcessId != v4 )
      {
        v23 = v89;
        goto LABEL_165;
      }
      v29 = gpTreeViewListItemParam;
      LOBYTE(v80) = 0;
      if ( !gpTreeViewListItemParam )
        goto LABEL_79;
      while ( v29->dwProcessId != v28->UniqueProcessId )
      {
        v29 = v29->m_Prev;
        if ( !v29 )
          goto LABEL_79;
      }
      a1 = v29->dwStyle >> 4;
      LOBYTE(a1) = a1 & 1;
      v80 = a1;
      if ( !a1 )
      {
LABEL_79:
        v30 = RtlCreateQueryDebugBuffer(0, 0);
        v83.pszData = v30;
        if ( !v30 )
          return 0;
        v31 = v28->UniqueProcessId;
        LocalFileTime.dwHighDateTime = v30;
        LocalFileTime.dwLowDateTime = v31;
        v32 = _beginthreadex(0, 0, QueryProcessDebugInforThreadProc, &LocalFileTime, 0, &ThreadId);
        if ( WaitForSingleObject(v32, 0xFA0u) == 258 )
          TerminateThread(v32, 1u);
        GetExitCodeThread(v32, &ExitCode);
        CloseHandle(v32);
        if ( !ExitCode )
        {
          v81 = 0;
          v33 = *(v83.pszData + 12);
          v75 = v33;
          if ( *v33 )
          {
            a1 = (v33 + 8);
            v88 = v33 + 8;
            while ( 1 )
            {
              memset(&v104, 0, 0x188u);
              v110 = 0;
              v108 = *(a1 - 20);
              v113 = *(a1 - 16);
              v114 = *(a1 - 4);
              if ( *a1 == 92 && *(a1 + 1) == 63 )
                strcpy_s(a1, 0x100u, (a1 + 4));
              v34 = ATL::StrTraitATL<wchar_t,ATL::ChTraitsCRT<wchar_t>>::GetDefaultManager();
              if ( !v34 )
                ATL::AtlThrowImpl(-2147467259);
              lptstrFilename = ((v34->vtptr->GetNilData)(v34) + 16);
              ATL::CStringT<wchar_t,ATL::StrTraitATL<wchar_t,ATL::ChTraitsCRT<wchar_t>>>::operator=(&lptstrFilename, a1);
              v35 = lptstrFilename;
              v36 = _wcsdup(lptstrFilename);
              if ( *GetLongPathNameW )
              {
                v37 = GetLongPathNameW(v36, 0, 0);
                v84 = v37;
                if ( v37 )
                {
                  v38 = malloc(2 * v37 + 2);
                  GetLongPathNameW(v36, v38, v84 + 1);
                  free(v36);
                  v36 = v38;
                  j__free(0);
                  v35 = lptstrFilename;
                }
              }
              lpFileName = v36;
              wcscpy_s(&v118, 0x41u, &gszNullString);
              if ( !wParam )
                break;
              v39 = wcslen(gszStringToFindLast);
              v40 = *(v35 - 3);
              if ( v40 >= v39 )
              {
                v84 = 0;
                if ( v40 - v39 + 1 > 0 )
                {
                  v41 = v35;
                  while ( _wcsnicmp(v41, gszStringToFindLast, v39) )
                  {
                    ++v41;
                    v42 = *(v35 - 3) - v39 + 1;
                    if ( ++v84 >= v42 )
                    {
                      a1 = v88;
                      goto LABEL_134;
                    }
                  }
                  a1 = v88;
LABEL_117:
                  sub_FC43C0(v35, &v118, 0x41u, &dwLen, &v120);
                  if ( !wParam )
                  {
                    v68 = v91->UniqueProcessId;
                    v50 = OpenProcess(0x410u, 0, v68);
                    if ( v50 )
                    {
                      v68 = &LastWriteTime.dwHighDateTime;
                      v67 = 0x2000;
                      v66 = &Buffer;
                      v65 = *(a1 - 20);
                      if ( ReadProcessMemory(v50, v65, &Buffer, 0x2000u, &LastWriteTime.dwHighDateTime) )
                      {
                        v51 = ImageNtHeader(&Buffer);
                        if ( v51 )
                        {
                          v110 = v51->OptionalHeader.ImageBase;
                          if ( v51->OptionalHeader.ImageBase != *(a1 - 20) )
                            v109 |= 1u;
                        }
                      }
                      CloseHandle(v50);
                    }
                  }
                  wcscpy_s(&Dst, 0x41u, &gszNullString);
                  v115 = 0i64;
                  v52 = CreateFileW(v35, 0x80000000, 7u, 0, 3u, 0, 0);
                  if ( v52 != -1 )
                  {
                    GetFileTime(v52, &SystemTime.wHour, &v72, &CreationTime);
                    CloseHandle(v52);
                    v115 = CreationTime;
                    FileTimeToLocalFileTime(&CreationTime, &LastAccessTime);
                    FileTimeToSystemTime(&LastAccessTime, &Date);
                    GetDateFormatW(0x400u, 1u, &Date, 0, &TimeStr, 64);
                    GetTimeFormatW(0x400u, 2u, &Date, 0, &DateStr, 64);
                    v68 = &DateStr;
                    v67 = &TimeStr;
                    sub_FD9DE0(&Dst, L"%s %s", &TimeStr, &DateStr);
                  }
                  if ( wParam )
                  {
                    v53 = v91;
                    wcsncpy_s(&v126, 0x100u, v91->ImageName.Buffer, v91->ImageName.Length >> 1);
                    v102 = 0;
                    v98 = _wcsdup(&v126);
                    v103 = _wcsdup(v35);
                    v100 = *(v53 + 68);
                    v97 = 0;
                    v101 = *(a1 - 20);
                    wcscpy_s(&v99, 0x40u, L"DLL");
                    sub_FB78D0(v90, (&v96 + 1));
                  }
                  else
                  {
                    sub_FDC400(v89, &v104);
                    v106 = 0;
                    if ( gdwValue_4F10B8[1] == v92 )
                    {
                      v105 = 2;
                    }
                    else
                    {
                      v107 = 0;
                      v105 = 0;
                    }
                    if ( sub_FCE970(lpFileName, &v116, &hObject, &BaseAddress) )
                      v109 |= 4u;
                    qmemcpy(&v60, &v104, 0x188u);
                    sub_FB7790(v90, v60);
                    v35 = lptstrFilename;
                    LOBYTE(v94) = 1;
                  }
                  goto LABEL_134;
                }
              }
LABEL_134:
              v54 = (v35 - 8);
              if ( _InterlockedDecrement((v54 + 12)) <= 0 )
              {
                v55 = *v54;
                v68 = v54;
                (*(*v55 + 4))(v54);
              }
              a1 += 284;
              ++v81;
              v88 = a1;
              if ( v81 >= *v75 )
                goto LABEL_160;
            }
            v43 = gpDllListItemParamHeader;
            if ( gpDllListItemParamHeader )
            {
              while ( 1 )
              {
                if ( v43->m_LoadAddress == *(a1 - 20) && v43->m_MappedSize == *(a1 - 16) )
                {
                  v68 = v35;
                  v67 = v43->m_strPath.pszData;
                  if ( !_wcsicmp(v67, v35) )
                    break;
                }
                v43 = v43->m_Prev;
                if ( !v43 )
                  goto LABEL_104;
              }
              v44 = v43->field_18;
              v45 = 0;
              ++v93;
              if ( v44 )
              {
                v46 = v43->field_1C;
                if ( v46 < gConfig.dwHighlightDuration )
                {
                  v43->field_10 = 2;
                  v43->field_14 = v46;
LABEL_113:
                  v48 = sub_FDC400(v89, v43);
                  v49 = v94;
                  if ( v48 )
                    v49 = 1;
                  LOBYTE(v94) = v49;
                  goto LABEL_134;
                }
                if ( v44 )
                {
                  v45 = 1;
                  LOBYTE(v43->field_18) = 0;
                }
              }
              v47 = v94;
              if ( v45 )
                v47 = 1;
              v43->field_10 = 0;
              LOBYTE(v94) = v47;
              goto LABEL_113;
            }
LABEL_104:
            sub_FDC400(v89, &v104);
            goto LABEL_117;
          }
LABEL_160:
          RtlDestroyQueryDebugBuffer(v83.pszData);
          goto LABEL_161;
        }
      }
      if ( !wParam )
      {
        v29->dwStyle |= 0x10u;
        v56 = gpDllListItemParamHeader;
        if ( !gpDllListItemParamHeader )
        {
LABEL_143:
          memset(&v104, 0, 0x188u);
          v108 = 0;
          v114 = 0;
          v113 = 0;
          if ( sub_FCE970(lpFileName, &v116, &hObject, &BaseAddress) )
            v109 |= 4u;
          lpFileName = _wcsdup(L"<Unable to query process module information>");
          wcscpy_s(&v118, 0x41u, &gszNullString);
          wcscpy_s(&Dst, 0x41u, &gszNullString);
          v106 = 0;
          v115 = 0i64;
          if ( gdwValue_4F10B8[1] == v92 )
          {
            v105 = 2;
          }
          else
          {
            v107 = 0;
            v105 = 0;
          }
          if ( sub_FCE970(lpFileName, &v116, &hObject, &BaseAddress) )
            v109 |= 4u;
          qmemcpy(&v60, &v104, 0x188u);
          sub_FB7790(v90, v60);
LABEL_158:
          LOBYTE(v94) = 1;
          goto LABEL_159;
        }
        while ( v56->m_LoadAddress || v56->m_MappedSize )
        {
          v56 = v56->m_Prev;
          if ( !v56 )
            goto LABEL_143;
        }
        LOBYTE(a1) = v56->field_18;
        v57 = 0;
        ++v93;
        if ( a1 )
        {
          v58 = v56->field_1C;
          if ( v58 < gConfig.dwHighlightDuration )
          {
            v56->field_10 = 2;
            v56->field_14 = v58;
            goto LABEL_159;
          }
          if ( a1 )
          {
            v57 = 1;
            LOBYTE(v56->field_18) = 0;
          }
        }
        v56->field_10 = 0;
        if ( v57 )
          goto LABEL_158;
      }
LABEL_159:
      if ( !v80 )
        goto LABEL_160;
LABEL_161:
      v28 = v91;
      wcsncpy_s(&v126, 0x100u, v91->ImageName.Buffer, v91->ImageName.Length >> 1);
      v23 = v89;
      v64 = &v93;
      v63 = &v126;
      v62 = v89;
      v61 = v28->UniqueProcessId;
      v59 = sub_FEF870(a1, v90, wParam, v86, v61, v89, &v126, &v93);
      a1 = v94;
      if ( v59 )
        a1 = 1;
      v94 = a1;
LABEL_165:
      if ( !v28->NextEntryOffset )
      {
        v5 = v90;
        goto LABEL_168;
      }
      v4 = v92;
      v28 = (v28 + v28->NextEntryOffset);
      v6 = wParam;
    }
  }
  if ( v6 )
  {
    sub_FF5140(a1, hWnd, v6);
    return 0;
  }
  if ( dwProcessId != gdwValue_4F10B8[1] )
  {
    v95 = 1;
    SendMessageW(hWnd, 0xBu, 0, 0);
    SendMessageW(hWnd, 0x1009u, 0, 0);
    SendMessageW(ghWndStatusBar, 0x40Du, gnStatusBarItemCount - 1, &lParam);
    SendMessageW(ghWndStatusBar, 0x40Bu, gnStatusBarItemCount - 1, L"Refreshing DLLs...");
    UpdateMenuStatus(0, 5);
  }
  v8 = gpDllListItemParamHeader;
  if ( gpDllListItemParamHeader )
  {
    do
    {
      v9 = v8->m_Prev;
      v71 = v8;
      v70 = -1;
      v10 = sub_FF58D0(a1, hWnd, &v69, v8, &v96);
      a1 = a1;
      if ( v10 )
        a1 = 1;
      if ( v96 )
        ++v87;
      v8 = v9;
    }
    while ( v9 );
    v4 = v92;
    v94 = a1;
  }
  if ( v4 == 8 || v4 == 4 )
  {
    ReturnLength = 1000;
    v88 = malloc(0x3E8u);
    v11 = v88;
    if ( NtQuerySystemInformation(SystemModuleInformation, v88, 0x3E8u, &ReturnLength) )
    {
      do
      {
        free(v11);
        ReturnLength += 1000;
        v12 = ReturnLength;
        v11 = malloc(ReturnLength);
      }
      while ( NtQuerySystemInformation(SystemModuleInformation, v11, v12, &ReturnLength) );
      v88 = v11;
    }
    v13 = *v11 == 0;
    v91 = 0;
    if ( !v13 )
    {
      v14 = (v11 + 4);
      while ( 1 )
      {
        v15 = gpDllListItemParamHeader;
        if ( gpDllListItemParamHeader )
        {
          while ( v15->m_LoadAddress != *(v14 - 4) || v15->m_MappedSize != *v14 )
          {
            v15 = v15->m_Prev;
            if ( !v15 )
              goto LABEL_32;
          }
          v20 = v15->field_18;
          v21 = 0;
          ++v93;
          if ( v20 )
          {
            v22 = v15->field_1C;
            if ( v22 < gConfig.dwHighlightDuration )
            {
              v15->field_10 = 2;
              v15->field_14 = v22;
              goto LABEL_53;
            }
            if ( v20 )
            {
              v21 = 1;
              LOBYTE(v15->field_18) = 0;
            }
          }
          v15->field_10 = 0;
          if ( v21 )
          {
            LOBYTE(v15) = 1;
LABEL_52:
            v94 = v15;
            goto LABEL_53;
          }
        }
        else
        {
LABEL_32:
          if ( *(v14 - 4) > gSystemInfo.lpMaximumApplicationAddress )
          {
            memset(&v104, 0, 0x188u);
            v68 = ATL::CStringT<wchar_t,ATL::StrTraitATL<wchar_t,ATL::ChTraitsCRT<wchar_t>>>::CStringT<wchar_t,ATL::StrTraitATL<wchar_t,ATL::ChTraitsCRT<wchar_t>>>(
                    &v83,
                    (v14 + 16))->pszData;
            v16 = sub_FC4280(v68);
            v17 = v83.pszData - 16;
            lpFileName = v16;
            if ( _InterlockedDecrement(v83.pszData - 1) <= 0 )
            {
              v18 = *v17;
              v68 = v17;
              (*(*v18 + 4))(v17);
            }
            v108 = *(v14 - 4);
            v113 = *v14;
            v110 = *(v14 - 4);
            sub_FC43C0(lpFileName, &v118, 0x41u, &dwLen, &v120);
            wcscpy_s(&Dst, 0x41u, &gszNullString);
            v115 = 0i64;
            v19 = CreateFileW(lpFileName, 0x80000000, 3u, 0, 3u, 0, 0);
            if ( v19 != -1 )
            {
              GetFileTime(v19, &CreationTime, &LastAccessTime, &LastWriteTime);
              CloseHandle(v19);
              v115 = LastWriteTime;
              FileTimeToLocalFileTime(&LastWriteTime, &LocalFileTime);
              FileTimeToSystemTime(&LocalFileTime, &SystemTime);
              GetDateFormatW(0x400u, 1u, &SystemTime, 0, &DateStr, 64);
              GetTimeFormatW(0x400u, 2u, &SystemTime, 0, &TimeStr, 64);
              v68 = &TimeStr;
              v67 = &DateStr;
              sub_FD9DE0(&Dst, L"%s %s", &DateStr, &TimeStr);
            }
            v110 = 0;
            v106 = 0;
            if ( gdwValue_4F10B8[1] == v92 )
            {
              v105 = 2;
            }
            else
            {
              v107 = 0;
              v105 = 0;
            }
            if ( sub_FCE970(lpFileName, &v116, &hObject, &BaseAddress) )
              v109 |= 4u;
            if ( v86 )
            {
              v68 = lpFileName;
              v67 = *(v86 + 88);
              v122 = sub_FABB70(v67, lpFileName);
            }
            qmemcpy(&v60, &v104, 0x188u);
            sub_FB7790(v90, v60);
            v11 = v88;
            v15 = 1;
            goto LABEL_52;
          }
        }
LABEL_53:
        v14 += 284;
        v91 = (v91 + 1);
        if ( v91 >= *v11 )
        {
          a1 = v94;
          break;
        }
      }
    }
    free(v11);
    v5 = v90;
  }
  v23 = v89;
  if ( !sub_FEF870(a1, v5, 0, v86, v92, v89, 0, &v93) )
  {
LABEL_168:
    if ( !a1 && v93 == v87 || wParam )
      goto LABEL_172;
  }
  LOBYTE(a1) = 1;
LABEL_172:
  gdwValue_4F10B8[1] = v92;
  if ( lParam != 1 )
    SendMessageW(ghWndStatusBar, 0x40Bu, gnStatusBarItemCount - 1, &lParam);
  if ( !a1 && v95 == 1 )
    SendMessageW(v5, 0xBu, 1u, 0);
  if ( v23 )
    free(v23);
  return a1;
}
// 10443D4: using guessed type wchar_t aRefreshingDlls[19];
// 10610B8: using guessed type int gdwValue_4F10B8[3];
// 106F264: using guessed type int (__stdcall *RtlDestroyQueryDebugBuffer)(_DWORD);
// 1085720: using guessed type int gnStatusBarItemCount;

//----- (00FFA540) --------------------------------------------------------
char __usercall CMainWnd::RefreshHandlesView@<al>(signed int a1@<ebx>, HWND a2, int a3, _BYTE *a4)
{
  HWND v5; // esi
  unsigned int v6; // edi
  int *v7; // ebx
  SYSTEM_HANDLE_INFORMATION *v8; // ecx
  unsigned int i; // esi
  LPARAM v10; // eax
  HWND v11; // edi
  LPARAM v12; // esi
  char v13; // al
  LPARAM v14; // edx
  signed int v15; // eax
  unsigned int j; // esi
  char v17; // bl
  char v18; // cl
  unsigned int v19; // kr00_4
  size_t v20; // ecx
  int v21; // edi
  const wchar_t *v22; // esi
  unsigned int v23; // kr04_4
  int v24; // esi
  wchar_t *v25; // ecx
  int v26; // edx
  wchar_t v27; // ax
  unsigned int v28; // ecx
  unsigned int v29; // edx
  int v30; // edi
  wchar_t *v31; // eax
  int v32; // edx
  wchar_t v33; // cx
  int v34; // eax
  WCHAR *v35; // edx
  int v36; // eax
  WCHAR v37; // cx
  void *v38; // esp
  SYSTEM_HANDLE_INFORMATION *v39; // eax
  int v40; // eax
  char v41; // [esp-10C0h] [ebp-36A4h]
  const wchar_t *v42; // [esp-Ch] [ebp-25F0h]
  WCHAR *v43; // [esp-8h] [ebp-25ECh]
  signed int v44; // [esp-4h] [ebp-25E8h]
  LPARAM v45; // [esp+Ch] [ebp-25D8h]
  int v46; // [esp+10h] [ebp-25D4h]
  int v47; // [esp+14h] [ebp-25D0h]
  LPARAM v48; // [esp+2Ch] [ebp-25B8h]
  int v49; // [esp+40h] [ebp-25A4h]
  void *pEntry; // [esp+44h] [ebp-25A0h]
  unsigned int v51; // [esp+48h] [ebp-259Ch]
  void *v52; // [esp+4Fh] [ebp-2595h]
  WCHAR *v53; // [esp+54h] [ebp-2590h]
  int v54; // [esp+58h] [ebp-258Ch]
  SYSTEM_HANDLE_INFORMATION *a1a; // [esp+5Ch] [ebp-2588h]
  HWND hWnd; // [esp+60h] [ebp-2584h]
  char v57; // [esp+67h] [ebp-257Dh]
  char v58; // [esp+68h] [ebp-257Ch]
  int v59; // [esp+78h] [ebp-256Ch]
  int v60; // [esp+7Ch] [ebp-2568h]
  char v61; // [esp+80h] [ebp-2564h]
  int v62; // [esp+8Ch] [ebp-2558h]
  int v63; // [esp+90h] [ebp-2554h]
  int v64; // [esp+94h] [ebp-2550h]
  int v65; // [esp+98h] [ebp-254Ch]
  int v66; // [esp+9Ch] [ebp-2548h]
  wchar_t v67[64]; // [esp+A0h] [ebp-2544h]
  wchar_t v68[1024]; // [esp+120h] [ebp-24C4h]
  wchar_t v69[1028]; // [esp+920h] [ebp-1CC4h]
  char v70; // [esp+1128h] [ebp-14BCh]
  int v71; // [esp+1138h] [ebp-14ACh]
  wchar_t *v72; // [esp+114Ch] [ebp-1498h]
  wchar_t v73[64]; // [esp+1150h] [ebp-1494h]
  int v74; // [esp+11D0h] [ebp-1414h]
  int v75; // [esp+11D8h] [ebp-140Ch]
  wchar_t *v76; // [esp+11DCh] [ebp-1408h]
  __int16 Dst[1024]; // [esp+11E0h] [ebp-1404h]
  WCHAR pszText[256]; // [esp+19E0h] [ebp-C04h]
  __int16 Src[1024]; // [esp+1BE0h] [ebp-A04h]
  int lParam[128]; // [esp+23E0h] [ebp-204h]

  hWnd = a2;
  LOBYTE(a1) = 0;
  v54 = a1;
  LOWORD(lParam[0]) = 1;
  v57 = 0;
  memset(lParam + 2, 0, 0x1FEu);
  if ( !a4 && (!gConfig.dwHandleColumnCount || !gConfig.bShowLowerPane) )
    return 0;
  QuerySystemHandleInfo(a4 != 0);
  if ( a4 )
  {
    a1a = gpSystemHandleInfo;
LABEL_7:
    v5 = hWnd;
    goto LABEL_8;
  }
  a1a = gpSystemHandleInfo2;
  if ( a3 == gdwValue_4F10B8[0] )
  {
    v10 = dword_106539C;
    if ( !dword_106539C )
      goto LABEL_7;
    v11 = hWnd;
    do
    {
      v12 = *(v10 + 0x10B8);
      v48 = v10;
      v46 = -1;
      v13 = sub_FF58D0(a1, v11, &v45, v10, &v52);
      a1 = a1;
      if ( v13 )
        a1 = 1;
      v10 = v12;
    }
    while ( v12 );
    v54 = a1;
    v5 = v11;
  }
  else
  {
    v5 = hWnd;
    v57 = 1;
    SendMessageW(hWnd, 0xBu, 0, 0);
    SendMessageW(hWnd, LVM_DELETEALLITEMS, 0, 0);
    SendMessageW(ghWndStatusBar, SB_GETTEXTW, gnStatusBarItemCount - 1, lParam);
    SendMessageW(ghWndStatusBar, SB_SETTEXTW, gnStatusBarItemCount - 1, L"Refreshing handles...");
    UpdateMenuStatus(0, 5);
  }
LABEL_8:
  v6 = 0;
  v51 = 0;
  if ( !sub_FDD9D0(a1a) )
    goto LABEL_80;
  do
  {
    GetHandleTableEntry(a1a, v6, &pEntry);
    v7 = pEntry;
    if ( a4 )
      goto LABEL_46;
    if ( *(pEntry + 1) != a3 )
      goto LABEL_78;
    if ( !SendMessageW(v5, LVM_GETITEMCOUNT, 0, 0) )
      goto LABEL_46;
    v8 = gpSystemHandleInfo3;
    if ( gpSystemHandleInfo3 )
    {
      for ( i = 0; v8 && i < v8->NumberOfHandles; ++i )
      {
        GetHandleTableEntry(v8, i, (&v52 + 1));
        if ( **(&v52 + 1) == *v7 && (*(&v52 + 1))[2] == v7[2] )
          goto LABEL_78;
        v8 = gpSystemHandleInfo3;
      }
    }
    v14 = dword_106539C;
    v45 = 4;
    v47 = 0;
    if ( !dword_106539C )
    {
LABEL_31:
      if ( !gConfig.bShowUnnamedHandles && v8 )
      {
        for ( j = 0; v8 && j < v8->NumberOfHandles; ++j )
        {
          GetHandleTableEntry(v8, j, (&v52 + 1));
          if ( (*(&v52 + 1))[2] == v7[2] && **(&v52 + 1) == *v7 )
            goto LABEL_78;
          v8 = gpSystemHandleInfo3;
        }
      }
LABEL_46:
      Src[0] = 0;
      sub_FDC750(&gpszObjectTypeNames[64 * *(v7 + 9)], v7, Src, 0x400u, &v49);
      if ( !gConfig.bShowUnnamedHandles && !Src[0] )
        goto LABEL_78;
      wcscpy_s(Dst, 0x400u, Src);
      if ( _wcsicmp(&gpszObjectTypeNames[64 * *(v7 + 9)], L"Key") )
      {
        if ( !_wcsicmp(&gpszObjectTypeNames[64 * *(v7 + 9)], L"File")
          || !_wcsicmp(&gpszObjectTypeNames[64 * *(v7 + 9)], L"Section") )
        {
          sub_FE0DD0(Src);
        }
      }
      else
      {
        sub_FE0EE0(Src);
      }
      if ( !a4 )
      {
        v62 = v7[1];
        v64 = v7[2];
        v65 = v7[3];
        v63 = *v7;
        v66 = v49;
        wcscpy_s(v67, 0x40u, &gpszObjectTypeNames[64 * *(v7 + 9)]);
        wcscpy_s(v68, 0x400u, Dst);
        wcscpy_s(v69, 0x400u, Src);
        v60 = 0;
        if ( gdwValue_4F10B8[0] == a3 )
        {
          v59 = 2;
        }
        else
        {
          v61 = 0;
          v59 = 0;
        }
        v38 = alloca(4288);
        qmemcpy(&v41, &v58, 0x10C0u);
        sub_FB7A90(hWnd);
        v54 = 1;
        goto LABEL_76;
      }
      if ( *a4 == 1 )
        break;
      v19 = wcslen(Src);
      v20 = wcslen(gszStringToFindLast);
      if ( v19 < v20 || (v21 = 0, (v19 - v20 + 1) <= 0) )
      {
LABEL_60:
        v24 = *(v7 + 9);
        v25 = &gpszObjectTypeNames[64 * v24];
        v26 = (v25 + 1);
        do
        {
          v27 = *v25;
          ++v25;
        }
        while ( v27 );
        v28 = (v25 - v26) >> 1;
        v29 = wcslen(gszStringToFindLast);
        if ( v28 < v29 )
          goto LABEL_76;
        v30 = 0;
        if ( (v28 - v29 + 1) <= 0 )
          goto LABEL_76;
        while ( 1 )
        {
          v42 = &gpszObjectTypeNames[v30 + (v24 << 6)];
          if ( !_wcsnicmp(v42, gszStringToFindLast, v29) )
            break;
          v24 = *(v7 + 9);
          ++v30;
          v31 = &gpszObjectTypeNames[64 * v24];
          v32 = (v31 + 1);
          do
          {
            v33 = *v31;
            ++v31;
          }
          while ( v33 );
          v34 = v31 - v32;
          v35 = gszStringToFindLast;
          v36 = v34 >> 1;
          v53 = &gszStringToFindLast[1];
          do
          {
            v37 = *v35;
            ++v35;
          }
          while ( v37 );
          v29 = v35 - v53;
          if ( v30 >= (v36 - v29 + 1) )
            goto LABEL_76;
        }
      }
      else
      {
        v22 = Src;
        while ( _wcsnicmp(v22, gszStringToFindLast, v20) )
        {
          ++v22;
          v23 = wcslen(Src);
          v20 = wcslen(gszStringToFindLast);
          v53 = ++v21;
          if ( v21 >= (v23 - v20 + 1) )
            goto LABEL_60;
        }
      }
      v44 = 256;
      v43 = pszText;
      v42 = 0;
      SystemProcessInfo_GetSystemProcessName(v7[1], 0, pszText, 0x100u);
      v72 = _wcsdup(pszText);
      v76 = _wcsdup(Src);
      wcscpy_s(v73, 0x40u, &gpszObjectTypeNames[64 * *(v7 + 9)]);
      v74 = v7[1];
      v71 = 0;
      v75 = v7[2];
      sub_FB78D0(hWnd, &v70);
LABEL_76:
      if ( SendMessageW(hWnd, LVM_GETITEMCOUNT, 0, 0) == 10000 )
        break;
      v6 = v51;
      goto LABEL_78;
    }
    while ( 1 )
    {
      if ( *(v14 + 44) == v7[2] )
      {
        v15 = *(v14 + 40);
        if ( v15 == *v7 )
          break;
      }
      v14 = *(v14 + 4280);
      if ( !v14 )
        goto LABEL_31;
    }
    v17 = *(v14 + 24);
    v18 = 0;
    if ( v17 )
    {
      v15 = *(v14 + 28);
      if ( v15 < gConfig.dwHighlightDuration )
      {
        *(v14 + 16) = 2;
        *(v14 + 20) = v15;
        goto LABEL_78;
      }
      if ( v17 )
      {
        v18 = 1;
        *(v14 + 24) = 0;
      }
    }
    *(v14 + 16) = 0;
    if ( v18 )
    {
      LOBYTE(v15) = 1;
      v54 = v15;
    }
LABEL_78:
    v51 = ++v6;
    v39 = sub_FDD9D0(a1a);
    v5 = hWnd;
  }
  while ( v6 < v39 );
  LOBYTE(a1) = v54;
LABEL_80:
  v40 = gdwValue_4F10B8[0];
  if ( !a4 )
    v40 = a3;
  gdwValue_4F10B8[0] = v40;
  if ( LOWORD(lParam[0]) != 1 )
    SendMessageW(ghWndStatusBar, SB_SETTEXTW, gnStatusBarItemCount - 1, lParam);
  if ( !a1 && v57 == 1 )
    SendMessageW(hWnd, WM_SETREDRAW, 1u, 0);
  return a1;
}
// 104445C: using guessed type wchar_t aRefreshingHand[22];
// 10610B8: using guessed type int gdwValue_4F10B8[3];
// 1085720: using guessed type int gnStatusBarItemCount;

//----- (00FFAD00) --------------------------------------------------------
char __usercall CTreeList::InitTreeList@<al>(HWND hWndListCtrl, char flags)
{
  int v2; // ebp
  char v3; // di
  double v4; // st6
  double v5; // st7
  void *v6; // esp
  signed int v7; // ecx
  SYSTEM_PROCESS_INFORMATION *pSystemProcessInfoLast; // ecx
  int nSystemProcessInfoLengthLast; // edx
  std__Tree_node *Tree_node_8; // esi
  int v11; // edi
  FILETIME TimeRet; // rax
  SYSTEM_PROCESS_INFORMATION *pSystemProcessInfo_11; // eax
  unsigned int v14; // ecx
  DWORD dwNumberOfProcessors; // edx
  signed int nProcessorIndex; // esi
  int nIndex; // edi
  DWORD v18; // ecx
  DWORD v19; // edx
  LONG v20; // edx
  unsigned __int64 v21; // kr20_8
  float v22; // xmm0_4
  float v23; // xmm0_4
  double v24; // xmm1_8
  float v25; // xmm0_4
  CGraphData *v26; // eax
  float v27; // xmm0_4
  float v28; // xmm0_4
  double v29; // xmm1_8
  float v30; // xmm0_4
  CGraphData *v31; // eax
  unsigned __int64 v32; // rax
  tagTREEVIEWLISTITEMPARAM *gTreeViewListItemParam; // esi
  tagTREEVIEWLISTITEMPARAM *TreeViewListItemParam_32; // edi
  int v35; // eax
  signed int dwProcessorIdx; // edx
  __m128i v37; // xmm7
  SYSTEM_INTERRUPT_INFORMATION *gpSystemInterruptInf; // ecx
  SYSTEM_PROCESSOR_IDLE_CYCLE_TIME_INFORMATION *pSystemProcessorIdleCycleTimeInfo_37; // edi
  LARGE_INTEGER *v40; // eax
  __m128i v41; // xmm6
  __m128i v42; // xmm4
  __m128i v43; // xmm3
  __m128i v44; // xmm5
  int v45; // ecx
  __m128i v46; // xmm0
  __m128i v47; // xmm2
  __m128i v48; // xmm1
  __m128i v49; // xmm2
  __m128i v50; // xmm1
  __m128i v51; // xmm2
  __m128i v52; // xmm0
  __m128i v53; // xmm1
  __m128i v54; // xmm0
  __m128i v55; // xmm2
  __m128i v56; // xmm0
  __m128i v57; // xmm1
  __m128i v58; // xmm5
  __m128i v59; // xmm6
  __m128i v60; // xmm3
  __m128i v61; // xmm4
  __m128i v62; // xmm5
  __m128i v63; // xmm3
  __m128i v64; // xmm4
  __m128i v65; // xmm6
  int v66; // edi
  unsigned int v67; // esi
  LARGE_INTEGER *v68; // edi
  __int64 v69; // kr28_8
  LONGLONG v70; // kr30_8
  signed __int64 v71; // kr38_8
  unsigned __int64 v72; // kr10_8
  unsigned int v73; // eax
  SYSTEM_PROCESS_INFORMATION *pSystemProcessInfo_72; // eax
  int v75; // eax
  int v76; // ecx
  unsigned __int8 v77; // of
  bool v78; // dl
  char v79; // al
  bool v80; // cl
  char v81; // al
  unsigned int v82; // edi
  bool v83; // dl
  char v84; // al
  bool v85; // cl
  char v86; // al
  unsigned int v87; // edi
  float v88; // xmm0_4
  float v89; // xmm0_4
  float v90; // xmm1_4
  float v91; // xmm0_4
  float v92; // xmm0_4
  unsigned int v93; // edx
  tagTREEVIEWLISTITEMPARAM *TreeViewListItemParam_92; // ecx
  int v95; // eax
  float v96; // xmm0_4
  float v97; // xmm0_4
  float v98; // xmm1_4
  double v99; // ST2C_8
  CGraphData *v100; // eax
  bool v101; // cl
  char v102; // al
  char v103; // al
  signed int v104; // ecx
  char v105; // al
  signed int v106; // ecx
  char v107; // al
  char v108; // cl
  char v109; // al
  tagTREEVIEWLISTITEMPARAM *TreeViewListItemParam_108; // eax
  int v111; // esi
  tagTREEVIEWLISTITEMPARAM **TreeViewListItemParam_110; // edi
  char v113; // al
  tagTREEVIEWLISTITEMPARAM *TreeViewListItemParam_112; // edi
  int v115; // eax
  int v116; // eax
  char v117; // al
  char v118; // cl
  int v119; // edi
  SYSTEM_PROCESS_INFORMATION *pSystemProcessInfo_118; // esi
  DWORD UniqueProcessId; // eax
  DWORD v122; // edx
  LONG v123; // esi
  unsigned __int64 v124; // kr60_8
  tagTREEVIEWLISTITEMPARAM *gTreeViewListItemParam_123; // edi
  DWORD v126; // ecx
  LONG v127; // edx
  int nItemFound; // eax
  int v129; // ecx
  char v130; // al
  unsigned int v131; // edx
  DWORD v132; // kr00_4
  DWORD v133; // kr04_4
  unsigned __int64 v134; // kr68_8
  int v135; // ecx
  int v136; // edx
  float v137; // xmm0_4
  float v138; // xmm0_4
  float v139; // xmm1_4
  double v140; // xmm0_8
  float v141; // xmm0_4
  float v142; // xmm0_4
  float v143; // xmm0_4
  float v144; // xmm0_4
  float v145; // xmm1_4
  double v146; // xmm0_8
  double v147; // xmm2_8
  __m128d v148; // xmm1
  double v149; // xmm1_8
  bool v150; // al
  char v151; // al
  double v152; // xmm0_8
  char v153; // al
  tagTREEVIEWLISTITEMPARAM **ppTreeViewListItemParam_152; // esi
  char v155; // al
  tagTREEVIEWLISTITEMPARAM *TreeViewListItemParam_154; // esi
  char v157; // al
  unsigned int v158; // eax
  int v159; // ecx
  LONG v160; // esi
  int v161; // edx
  _DWORD *v162; // eax
  _DWORD *v163; // ecx
  _WORD *v164; // esi
  _WORD *v165; // eax
  char v166; // al
  unsigned __int8 v167; // al
  int v168; // eax
  bool v169; // cf
  unsigned __int8 v170; // al
  unsigned __int8 v171; // al
  unsigned __int8 v172; // al
  int v173; // ecx
  char v174; // al
  unsigned __int8 v175; // al
  int v176; // esi
  int v177; // eax
  char v178; // al
  int v179; // eax
  int ArgList_16; // ST3C_4
  HMENU v181; // eax
  int v182; // ecx
  bool v183; // al
  char v184; // al
  char v185; // al
  SYSTEM_PROCESS_INFORMATION *pSystemProcessInfo_184; // esi
  int v187; // eax
  char v188; // al
  int v189; // eax
  char v190; // al
  int v191; // eax
  char v192; // al
  int v193; // eax
  char v194; // al
  int v195; // eax
  char v196; // al
  int v197; // eax
  char v198; // al
  int v199; // eax
  char v200; // al
  int v201; // eax
  char v202; // al
  int v203; // eax
  char v204; // al
  unsigned int v205; // ecx
  int v206; // esi
  char v207; // al
  char v208; // al
  CGraphData *pGraphData_207; // edx
  int v210; // eax
  char v211; // al
  LPARAM UniqueProcessId_2; // esi
  HWND hMainWndBackup; // esi
  int v214; // eax
  char v215; // al
  int v216; // esi
  char v217; // al
  char v218; // al
  int v219; // eax
  char v220; // al
  unsigned int v221; // ecx
  int v222; // kr08_4
  unsigned int v223; // kr0C_4
  signed __int64 v224; // rax
  float v225; // xmm0_4
  unsigned int v226; // edx
  unsigned int v227; // ecx
  float v228; // xmm0_4
  double ArgList_8; // ST34_8
  double v230; // xmm0_8
  unsigned int v231; // edx
  unsigned int v232; // ecx
  char v233; // al
  char v234; // al
  unsigned __int64 v235; // kr90_8
  signed __int64 v236; // kr98_8
  signed __int64 v237; // krA0_8
  char v238; // cl
  char v239; // dl
  signed int v240; // eax
  char v241; // al
  const WCHAR **pszText; // eax
  int dwStyle; // eax
  DWORD InheritedFromUniqueProcessId; // eax
  HANDLE UniqueProcessId_1; // eax
  DWORD pGraphData_244; // ecx
  WCHAR **ppszText_245; // eax
  WCHAR *szProcessName; // eax
  HICON hIcon; // ecx
  HICON hIcon_1; // ecx
  DWORD *pGraphData_249; // ecx
  int v252; // ecx
  unsigned int v253; // edx
  unsigned int *v254; // eax
  signed int v255; // ecx
  unsigned __int64 v256; // krA8_8
  int v257; // ecx
  ULONG v258; // eax
  int v259; // edx
  _DWORD *v260; // eax
  _DWORD *v261; // ecx
  int v262; // eax
  signed int v263; // ecx
  float v264; // xmm0_4
  float v265; // xmm0_4
  float v266; // xmm1_4
  float v267; // xmm0_4
  float v268; // xmm0_4
  double v269; // xmm0_8
  wchar_t *v270; // eax
  int dwItemStyle; // eax
  int ItemStyle_270; // eax
  tagNetCclrInfo *NetCclrInfo_271; // eax
  tagTREEVIEWLISTITEMPARAM *TreeViewListItemParam_272; // ecx
  tagTREEVIEWLISTITEMPARAM *TreeViewListItemParam_273; // edx
  wchar_t *v276; // eax
  DLLLISTITEMPARAM *TreeViewListItemParam_275; // ecx
  int v278; // eax
  signed __int64 v279; // krC0_8
  signed __int64 v280; // krC8_8
  signed int dwProcessorIndex; // esi
  LARGE_INTEGER *v282; // edx
  ULONG *v283; // edi
  LONGLONG v284; // krE0_8
  int v285; // eax
  LRESULT (__stdcall *SendMessageW)(HWND, UINT, WPARAM, LPARAM); // esi
  tagTREEVIEWLISTITEMPARAM *TreeViewListItemParam_285; // eax
  double v288; // xmm0_8
  bool v289; // cf
  bool v290; // zf
  double v291; // xmm0_8
  unsigned int v292; // esi
  unsigned int v293; // edi
  float v294; // xmm0_4
  float v295; // xmm0_4
  bool v296; // al
  char v297; // al
  double v298; // xmm0_8
  char v299; // al
  char v300; // al
  LRESULT v301; // edi
  signed int i; // esi
  double v303; // xmm0_8
  int v304; // eax
  signed int ret; // eax
  int v306; // eax
  double ArgList; // [esp+Ch] [ebp-2740h]
  char v309; // [esp+20h] [ebp-272Ch]
  LVITEMW ItemState; // [esp+2Ch] [ebp-2720h]
  LVITEMW item; // [esp+60h] [ebp-26ECh]
  int v312; // [esp+94h] [ebp-26B8h]
  double v313; // [esp+98h] [ebp-26B4h]
  LVFINDINFOW FindInfo; // [esp+A0h] [ebp-26ACh]
  __int64 v315; // [esp+B8h] [ebp-2694h]
  double v316; // [esp+C0h] [ebp-268Ch]
  __int64 v317; // [esp+C8h] [ebp-2684h]
  __int64 v318; // [esp+D0h] [ebp-267Ch]
  int bVirtualizationEnabled; // [esp+DCh] [ebp-2670h]
  int fbUIAccess; // [esp+E0h] [ebp-266Ch]
  unsigned int v321; // [esp+E4h] [ebp-2668h]
  __int64 v322; // [esp+E8h] [ebp-2664h]
  __m128i v323; // [esp+F0h] [ebp-265Ch]
  double v324; // [esp+F8h] [ebp-2654h]
  __m128i v325; // [esp+100h] [ebp-264Ch]
  __int64 v326; // [esp+108h] [ebp-2644h]
  int cbPackageFullNameLength; // [esp+110h] [ebp-263Ch]
  int v328; // [esp+114h] [ebp-2638h]
  tagTREEVIEWLISTITEMPARAM *OutBuffer; // [esp+118h] [ebp-2634h]
  tagTREEVIEWLISTITEMPARAM *TreeViewListItemParam_327; // [esp+11Ch] [ebp-2630h]
  tagTREEVIEWLISTITEMPARAM *TreeViewListItemParam_328; // [esp+120h] [ebp-262Ch]
  tagTREEVIEWLISTITEMPARAM *TreeViewListItemParam_329; // [esp+124h] [ebp-2628h]
  __int64 v333; // [esp+128h] [ebp-2624h]
  float v334; // [esp+134h] [ebp-2618h]
  double v335; // [esp+138h] [ebp-2614h]
  unsigned int v336; // [esp+140h] [ebp-260Ch]
  unsigned int v337; // [esp+144h] [ebp-2608h]
  LVITEMW Item; // [esp+148h] [ebp-2604h]
  tagTREEVIEWLISTITEMPARAM *TreeViewListItemParam_336; // [esp+17Ch] [ebp-25D0h]
  tagTREEVIEWLISTITEMPARAM *TreeViewListItemParam_337; // [esp+180h] [ebp-25CCh]
  tagTREEVIEWLISTITEMPARAM *TreeViewListItemParam_338; // [esp+184h] [ebp-25C8h]
  __int64 v342; // [esp+188h] [ebp-25C4h]
  __int64 v343; // [esp+190h] [ebp-25BCh]
  HWND hWndListCtrl_1; // [esp+198h] [ebp-25B4h]
  unsigned int v345; // [esp+19Ch] [ebp-25B0h]
  int v346; // [esp+1A0h] [ebp-25ACh]
  unsigned int v347; // [esp+1A4h] [ebp-25A8h]
  double v348; // [esp+1A8h] [ebp-25A4h]
  char bFlagsInExtendedProcessBasicInfo; // [esp+1B7h] [ebp-2595h]
  tagTREEVIEWLISTITEMPARAM *TreeViewListItemParam_347; // [esp+1B8h] [ebp-2594h]
  ULONG *v351; // [esp+1BCh] [ebp-2590h]
  unsigned int v352; // [esp+1C0h] [ebp-258Ch]
  unsigned int v353; // [esp+1C4h] [ebp-2588h]
  unsigned int v354; // [esp+1C8h] [ebp-2584h]
  char sbQueryServiceNamesInited; // [esp+1CFh] [ebp-257Dh]
  __m128i v356; // [esp+1D0h] [ebp-257Ch]
  double v357; // [esp+1D8h] [ebp-2574h]
  LARGE_INTEGER liParam; // [esp+1E8h] [ebp-2564h]
  unsigned int v359; // [esp+1F4h] [ebp-2558h]
  tagTREEVIEWLISTITEMPARAM *pItemFound; // [esp+1F8h] [ebp-2554h]
  unsigned int v361; // [esp+1FCh] [ebp-2550h]
  unsigned int v362; // [esp+200h] [ebp-254Ch]
  unsigned int variable_360; // [esp+204h] [ebp-2548h]
  wchar_t *packageFullName; // [esp+208h] [ebp-2544h]
  int v365; // [esp+20Ch] [ebp-2540h]
  unsigned int v366; // [esp+210h] [ebp-253Ch]
  unsigned int v367; // [esp+214h] [ebp-2538h]
  unsigned __int8 v368; // [esp+21Bh] [ebp-2531h]
  SYSTEM_PROCESS_INFORMATION *pSystemProcessInfo_1; // [esp+21Ch] [ebp-2530h]
  char v370; // [esp+223h] [ebp-2529h]
  tagTREEVIEWLISTITEMPARAM *ProcessHandle; // [esp+224h] [ebp-2528h]
  int v372; // [esp+228h] [ebp-2524h]
  unsigned __int8 fHungFlags; // [esp+22Fh] [ebp-251Dh]
  SHFILEINFOW FileInfo; // [esp+230h] [ebp-251Ch]
  tagTREEVIEWLISTITEMPARAM ItemParam; // [esp+4E8h] [ebp-2264h]
  tagItemWithSizeIs50H ItemWithSizeIs50H; // [esp+AA8h] [ebp-1CA4h]
  WCHAR szFullName[1024]; // [esp+AF8h] [ebp-1C54h]
  WCHAR szBuffer[1024]; // [esp+12F8h] [ebp-1454h]
  WCHAR szText[256]; // [esp+1AF8h] [ebp-C54h]
  WCHAR szDomainName[256]; // [esp+1CF8h] [ebp-A54h]
  WCHAR szUserName[256]; // [esp+1EF8h] [ebp-854h]
  WCHAR szText3[256]; // [esp+20F8h] [ebp-654h]
  WCHAR szText4[256]; // [esp+22F8h] [ebp-454h]
  WCHAR szText5[256]; // [esp+24F8h] [ebp-254h]
  WCHAR Buffer_382[34]; // [esp+26F8h] [ebp-54h]
  unsigned int v386; // [esp+273Ch] [ebp-10h]
  int v387; // [esp+2740h] [ebp-Ch]
  int v388; // [esp+2744h] [ebp-8h]
  int v389; // [esp+2748h] [ebp-4h]
  int retaddr; // [esp+274Ch] [ebp+0h]

  v387 = v2;
  v388 = retaddr;
  v6 = alloca(10008);
  v386 = &v387 ^ __security_cookie;
  v309 = v3;
  hWndListCtrl_1 = hWndListCtrl;
  fHungFlags = 0;
  v346 = 0;
  TreeViewListItemParam_327 = 0;
  szText3[0] = 0;
  TreeViewListItemParam_337 = 0;
  v335 = 0.0;
  v348 = 0.0;
  *&v342 = 0.0;
  TreeViewListItemParam_338 = 0;
  v316 = 0.0;
  v333 = 0i64;
  v326 = 0i64;
  v317 = 0i64;
  v343 = 0i64;
  liParam.QuadPart = 0i64;
  memset(&szText3[1], 0, 510u);
  v368 = 0;
  TreeViewListItemParam_336 = 0;
  v370 = 0;
  bVirtualizationEnabled = 0;
  fbUIAccess = 0;
  sbQueryServiceNamesInited = 0;
  v318 = 0i64;
  v357 = 0.0;
  PE_FlushTrace(&gProperties);
  TreeList_Item1::Reset(gTreeList_Item);
  TreeList_Item1::Reset(&gTreeList_Item[1]);
  TreeList_Item1::Reset(&gTreeList_Item[2]);
  v7 = 0;
  if ( gbShowProcessTreeLast != gConfig.bShowProcessTree )
    v7 = 1;
  gbShowProcessTreeLast = gConfig.bShowProcessTree;
  v372 = v7;
  szBuffer[0] = 0;
  memset(&ItemWithSizeIs50H, 0, 0x50u);
  pSystemProcessInfoLast = gpSystemProcessInfoLast;
  nSystemProcessInfoLengthLast = gnSystemProcessInfoLengthLast;
  Tree_node_8 = gSystemProcessInfoMap._Header;
  v11 = gSystemProcessInfoMap._Size;
  gpSystemProcessInfoLast = gpSystemProcessInfo;
  gnSystemProcessInfoLengthLast = gnSystemProcessInfoLength;
  gTimeQuerySystemInfoLast = gTimeQuerySystemInfo;
  gpSystemProcessInfo = pSystemProcessInfoLast;
  gnSystemProcessInfoLength = nSystemProcessInfoLengthLast;
  TimeRet = RequerySystemStatus(
              &gpSystemProcessInfo,
              &gnSystemProcessInfoLength,
              gpSystemPerformanceInfo,
              gpSystemInterruptInfo,
              gpSystemProcessorCycleTimeInfo,
              &gSystemProcessInfoMap,
              &v357);
  gTimeQuerySystemInfo.dwLowDateTime = TimeRet.dwLowDateTime;
  gTimeQuerySystemInfo.dwHighDateTime = TimeRet.dwHighDateTime;
  v14 = (*&TimeRet - *&gTimeQuerySystemInfoLast) >> 32;
  pSystemProcessInfo_11 = (TimeRet.dwLowDateTime - gTimeQuerySystemInfoLast.dwLowDateTime);
  pSystemProcessInfo_1 = pSystemProcessInfo_11;
  v345 = LODWORD(v357) + gSystemProcessInfoMap._Header - Tree_node_8;
  dwNumberOfProcessors = gSystemInfo.dwNumberOfProcessors;
  v367 = v14;
  v347 = (*&v357 + *&gSystemProcessInfoMap - __PAIR__(v11, Tree_node_8)) >> 32;
  if ( gSystemInfo.dwNumberOfProcessors <= 1 || (nProcessorIndex = 0, gSystemInfo.dwNumberOfProcessors <= 0) )
  {
    v357 = v313;
  }
  else
  {
    nIndex = 0;
    do
    {
      v18 = gpSystemPerformanceInfo[nIndex].IdleTime.LowPart;
      v366 = gpSystemPerformanceInfo[nIndex].KernelTime.LowPart;
      v359 = gpSystemPerformanceInfo[nIndex].KernelTime.HighPart;
      v19 = gpSystemPerformanceInfo[nIndex].UserTime.LowPart;
      v169 = v19 < v18;
      v362 = v19 - v18;
      v361 = gpSystemPerformanceInfo[nIndex].UserTime.HighPart;
      v20 = gpSystemPerformanceInfo[nIndex].IdleTime.HighPart;
      v361 -= v169 + v20;
      v169 = __CFADD__(v366, v362);
      v362 += v366;
      v361 += v359 + v169;
      v21 = __PAIR__(v359, v366) - __PAIR__(v20, v18);
      v359 = (__PAIR__(v359, v366) - __PAIR__(v20, v18)) >> 32;
      v366 = v21;
      if ( v367 | pSystemProcessInfo_1 )
      {
        v22 = (__PAIR__(v361, v362) - *&gppGraphInfo[nProcessorIndex]->field_888);
        v357 = v22 * 100.0;
        v23 = __PAIR__(v367, pSystemProcessInfo_1);
        v24 = v357 / v23;
      }
      else
      {
        v24 = 0.0;
      }
      v25 = v24;
      v26 = gppGraphInfo[nProcessorIndex];
      v26->field_888 = v362;
      v26->field_88C = v361;
      v357 = v25;
      if ( v367 | pSystemProcessInfo_1 )
      {
        v27 = (__PAIR__(v359, v366) - *&gppGraphInfo[nProcessorIndex]->field_890);
        v324 = v27 * 100.0;
        v28 = __PAIR__(v367, pSystemProcessInfo_1);
        v29 = v324 / v28;
      }
      else
      {
        v29 = 0.0;
      }
      v30 = v29;
      v31 = gppGraphInfo[nProcessorIndex];
      v31->field_890 = v366;
      v31->field_894 = v359;
      CGraphData_Update(gppGraphInfo[nProcessorIndex], gTimeQuerySystemInfo, v357, v30, 0);
      dwNumberOfProcessors = gSystemInfo.dwNumberOfProcessors;
      ++nProcessorIndex;
      ++nIndex;
    }
    while ( nProcessorIndex < gSystemInfo.dwNumberOfProcessors );
    pSystemProcessInfo_11 = pSystemProcessInfo_1;
    v14 = v367;
  }
  v32 = dwNumberOfProcessors * __PAIR__(v14, pSystemProcessInfo_11);
  gTreeViewListItemParam = gpTreeViewListItemParam;
  variable_360 = v32;
  v361 = HIDWORD(v326);
  v367 = HIDWORD(v32);
  TreeViewListItemParam_347 = gpTreeViewListItemParam;
  v334 = 0.0;
  v359 = v326;
  if ( gpTreeViewListItemParam )
  {
    while ( 1 )
    {
      if ( gTreeViewListItemParam->InheritedFromUniqueProcessId != -1 || !gTreeViewListItemParam->dwProcessId )
        *&gTreeViewListItemParam->m_CPUUsage = 0i64;
      v290 = gTreeViewListItemParam->dwProcessId == -10;
      TreeViewListItemParam_32 = gTreeViewListItemParam->m_Prev;
      v336 = gTreeViewListItemParam->m_Prev;
      if ( v290 )
        break;
      v116 = gTreeViewListItemParam->dwStyle;
      if ( (!(v116 & 2) || v116 & 1 && gConfig.byte_14012ADFE) && gTreeViewListItemParam->field_2C != -1 )
      {
        sub_FB8570(ghWndTreeListView, gTreeViewListItemParam);
        Item.lParam = gTreeViewListItemParam;
        Item.iItem = -1;
        sub_FF58D0(&v389, hWndListCtrl_1, &Item, gTreeViewListItemParam, &fHungFlags);
        LOBYTE(v372) = 1;
      }
      else
      {
        Item.lParam = gTreeViewListItemParam;
        Item.iItem = -1;
        v117 = sub_FF58D0(&v389, hWndListCtrl_1, &Item, gTreeViewListItemParam, &fHungFlags);
        v118 = v372;
        if ( v117 )
          v118 = 1;
        LOBYTE(v372) = v118;
      }
      if ( !fHungFlags )
        goto LABEL_98;
      v115 = v346;
LABEL_97:
      v346 = v115 + 1;
      gTreeViewListItemParam->m_SelectedItem = TreeViewListItemParam_337;
      TreeViewListItemParam_337 = gTreeViewListItemParam;
LABEL_98:
      TreeViewListItemParam_347 = TreeViewListItemParam_32;
      gTreeViewListItemParam = TreeViewListItemParam_32;
      if ( !TreeViewListItemParam_32 )
        goto LABEL_99;
    }
    v368 = 1;
    FindInfo.flags = 1;
    FindInfo.lParam = gTreeViewListItemParam;
    Item.mask = ::SendMessageW(ghWndTreeListView, LVM_FINDITEMW, 0xFFFFFFFF, &FindInfo);
    if ( Item.iItem == -1 )
    {
      v35 = gTreeViewListItemParam->dwStyle;
      if ( v35 & 2 )
      {
        if ( !(v35 & 1) || !gConfig.byte_14012ADFE )
          sub_FB7F20(ghWndTreeListView, gTreeViewListItemParam);
      }
    }
    dwProcessorIdx = 0;
    Item.lParam = gTreeViewListItemParam;
    v326 = 0i64;
    v324 = 0.0;
    v322 = 0i64;
    v357 = 0.0;
    if ( gSystemInfo.dwNumberOfProcessors <= 0 )
    {
      v66 = HIDWORD(v322);
      v353 = HIDWORD(v357);
      ProcessHandle = LODWORD(v357);
      v352 = HIDWORD(v326);
      v366 = v326;
      pItemFound = HIDWORD(v324);
      v354 = LODWORD(v324);
      pSystemProcessInfo_72 = v322;
      pSystemProcessInfo_1 = v322;
    }
    else
    {
      if ( gSystemInfo.dwNumberOfProcessors < 4 )
      {
        v66 = HIDWORD(v322);
        v353 = HIDWORD(v357);
        ProcessHandle = LODWORD(v357);
        v352 = HIDWORD(v326);
        v366 = v326;
        pItemFound = HIDWORD(v324);
        v354 = LODWORD(v324);
        pSystemProcessInfo_1 = v322;
      }
      else
      {
        v37 = 0i64;
        v365 = gSystemInfo.dwNumberOfProcessors - gSystemInfo.dwNumberOfProcessors % 4;
        gpSystemInterruptInf = gpSystemInterruptInfo;
        pSystemProcessorIdleCycleTimeInfo_37 = gpSystemProcessorCycleTimeInfo + 2;
        v40 = &gpSystemPerformanceInfo->DpcTime;
        _mm_store_si128(&v323, 0i64);
        v41 = 0i64;
        _mm_store_si128(&v325, 0i64);
        v42 = 0i64;
        _mm_store_si128(&v356, 0i64);
        v43 = 0i64;
        v44 = 0i64;
        v45 = &gpSystemInterruptInf[1].DpcCount;
        do
        {
          v46 = _mm_cvtsi32_si128(v40[8].LowPart);
          pSystemProcessorIdleCycleTimeInfo_37 += 4;
          v47 = _mm_cvtsi32_si128(v40[2].LowPart);
          v45 += 96;
          v40 += 24;
          dwProcessorIdx += 4;
          *v48.m128i_i8 = v40[-23];
          v48.m128i_i64[1] = v40[-17].QuadPart;
          v49 = _mm_unpacklo_epi32(
                  _mm_add_epi32(
                    _mm_unpacklo_epi32(v47, v46),
                    _mm_unpacklo_epi32(_mm_cvtsi32_si128(*(v45 - 120)), _mm_cvtsi32_si128(*(v45 - 96)))),
                  0i64);
          *v46.m128i_i8 = v40[-24];
          v46.m128i_i64[1] = v40[-18].QuadPart;
          v50 = _mm_add_epi64(v48, v46);
          v51 = _mm_add_epi64(v49, v356);
          v52 = v50;
          v53 = _mm_add_epi64(v50, v325);
          _mm_store_si128(&v323, _mm_add_epi64(v52, v323));
          *v52.m128i_i8 = pSystemProcessorIdleCycleTimeInfo_37[-6];
          v52.m128i_i64[1] = pSystemProcessorIdleCycleTimeInfo_37[-5].CycleTime;
          v37 = _mm_add_epi64(v37, v52);
          v54 = _mm_cvtsi32_si128(v40[-4].LowPart);
          _mm_store_si128(&v356, v51);
          v55 = _mm_unpacklo_epi32(_mm_cvtsi32_si128(v40[-10].LowPart), v54);
          v56 = _mm_cvtsi32_si128(*(v45 - 48));
          _mm_store_si128(&v325, v53);
          *v53.m128i_i8 = v40[-11];
          v53.m128i_i64[1] = v40[-5].QuadPart;
          v44 = _mm_add_epi64(
                  v44,
                  _mm_unpacklo_epi32(_mm_add_epi32(v55, _mm_unpacklo_epi32(_mm_cvtsi32_si128(*(v45 - 72)), v56)), 0i64));
          *v56.m128i_i8 = v40[-12];
          v56.m128i_i64[1] = v40[-6].QuadPart;
          v57 = _mm_add_epi64(v53, v56);
          *v56.m128i_i8 = pSystemProcessorIdleCycleTimeInfo_37[-4];
          v42 = _mm_add_epi64(v42, v57);
          v56.m128i_i64[1] = pSystemProcessorIdleCycleTimeInfo_37[-3].CycleTime;
          v43 = _mm_add_epi64(v43, v57);
          v41 = _mm_add_epi64(v41, v56);
        }
        while ( dwProcessorIdx < v365 );
        v58 = _mm_add_epi64(v44, v356);
        v59 = _mm_add_epi64(v41, v37);
        v60 = _mm_add_epi64(v43, v325);
        v61 = _mm_add_epi64(v42, v323);
        v62 = _mm_add_epi64(v58, _mm_srli_si128(v58, 8));
        v63 = _mm_add_epi64(v60, _mm_srli_si128(v60, 8));
        pSystemProcessInfo_1 = _mm_cvtsi128_si32(v62);
        v354 = _mm_cvtsi128_si32(v63);
        v64 = _mm_add_epi64(v61, _mm_srli_si128(v61, 8));
        v366 = _mm_cvtsi128_si32(v64);
        v65 = _mm_add_epi64(v59, _mm_srli_si128(v59, 8));
        ProcessHandle = _mm_cvtsi128_si32(v65);
        v66 = _mm_cvtsi128_si32(_mm_srli_si128(v62, 4));
        pItemFound = _mm_cvtsi128_si32(_mm_srli_si128(v63, 4));
        v352 = _mm_cvtsi128_si32(_mm_srli_si128(v64, 4));
        v353 = _mm_cvtsi128_si32(_mm_srli_si128(v65, 4));
      }
      v362 = v66;
      if ( dwProcessorIdx < gSystemInfo.dwNumberOfProcessors )
      {
        v67 = v362;
        v68 = &gpSystemPerformanceInfo[dwProcessorIdx].InterruptTime;
        v351 = &gpSystemInterruptInfo[dwProcessorIdx].DpcCount;
        do
        {
          v69 = (pSystemProcessInfo_1 + __PAIR__(v67, *v351 + v68[1].LowPart));
          v67 = (pSystemProcessInfo_1 + __PAIR__(v67, *v351 + v68[1].LowPart)) >> 32;
          pSystemProcessInfo_1 = v69;
          v70 = *v68 + v68[-1].QuadPart;
          v68 += 6;
          v71 = v70 + __PAIR__(v352, v366);
          v352 = (v70 + __PAIR__(v352, v366)) >> 32;
          v366 = v71;
          v72 = v70 + __PAIR__(pItemFound, v354);
          pItemFound = (v72 >> 32);
          v354 = v72;
          v73 = (gpSystemProcessorCycleTimeInfo[dwProcessorIdx].CycleTime + __PAIR__(v353, ProcessHandle)) >> 32;
          ProcessHandle = (ProcessHandle + LODWORD(gpSystemProcessorCycleTimeInfo[dwProcessorIdx++].CycleTime));
          v351 += 6;
          v353 = v73;
        }
        while ( dwProcessorIdx < gSystemInfo.dwNumberOfProcessors );
        v362 = v67;
        gTreeViewListItemParam = TreeViewListItemParam_347;
        v66 = v362;
      }
      pSystemProcessInfo_72 = pSystemProcessInfo_1;
    }
    v77 = __OFSUB__(
            v66,
            (pSystemProcessInfo_72 < LODWORD(gTreeViewListItemParam->ContextSwtiches))
          + HIDWORD(gTreeViewListItemParam->ContextSwtiches));
    v76 = (__PAIR__(v66, pSystemProcessInfo_72) - gTreeViewListItemParam->ContextSwtiches) >> 32;
    v75 = pSystemProcessInfo_72 - LODWORD(gTreeViewListItemParam->ContextSwtiches);
    if ( v76 < 0 || ((v76 < 0) ^ v77) | (v76 == 0) && !v75 )
    {
      v357 = 0.0;
      v76 = 0;
      v75 = 0;
    }
    v78 = v75 != LODWORD(gTreeViewListItemParam->ContextSwtichDelta)
       || v76 != HIDWORD(gTreeViewListItemParam->ContextSwtichDelta);
    LODWORD(gTreeViewListItemParam->ContextSwtichDelta) = v75;
    HIDWORD(gTreeViewListItemParam->ContextSwtichDelta) = v76;
    v79 = RedrawColumn(v78, ghWndTreeListView, 1092, Item.iItem);
    LOBYTE(v372) = v79 | v372;
    v80 = pSystemProcessInfo_1 != LODWORD(gTreeViewListItemParam->ContextSwtiches)
       || v66 != HIDWORD(gTreeViewListItemParam->ContextSwtiches);
    LODWORD(gTreeViewListItemParam->ContextSwtiches) = pSystemProcessInfo_1;
    HIDWORD(gTreeViewListItemParam->ContextSwtiches) = v66;
    v81 = RedrawColumn(v80, ghWndTreeListView, 1091, Item.iItem);
    LOBYTE(v372) = v81 | v372;
    v82 = v353;
    v83 = __PAIR__(v353, ProcessHandle) - gTreeViewListItemParam->Cycles != gTreeViewListItemParam->CyclesDelta;
    gTreeViewListItemParam->CyclesDelta = __PAIR__(v353, ProcessHandle) - gTreeViewListItemParam->Cycles;
    v84 = RedrawColumn(v83, ghWndTreeListView, 1200, Item.iItem);
    LOBYTE(v372) = v84 | v372;
    v85 = ProcessHandle != LODWORD(gTreeViewListItemParam->Cycles) || v82 != HIDWORD(gTreeViewListItemParam->Cycles);
    LODWORD(gTreeViewListItemParam->Cycles) = ProcessHandle;
    HIDWORD(gTreeViewListItemParam->Cycles) = v82;
    v86 = RedrawColumn(v85, ghWndTreeListView, 1195, Item.iItem);
    LOBYTE(v372) = v86 | v372;
    v87 = v352;
    if ( GetProcessorSystemCycleTime )
    {
      if ( v347 | v345 )
      {
        v88 = gTreeViewListItemParam->CyclesDelta;
        *&v365 = v88 * 100.0;
        v89 = __PAIR__(v347, v345);
        v90 = *&v365 / v89;
LABEL_59:
        v357 = v90;
        if ( v90 > 100.0 )
          v357 = db_onehundred;
        TreeViewListItemParam_92 = pItemFound;
        v93 = (__PAIR__(pItemFound, v354) - *&gTreeViewListItemParam->KernelTime) >> 32;
        v365 = v354 - gTreeViewListItemParam->KernelTime.dwLowDateTime;
        v169 = __CFADD__(v354, v359);
        v359 += v354;
        gTreeViewListItemParam->KernelTime.dwLowDateTime = v354;
        v361 += TreeViewListItemParam_92 + v169;
        v95 = v367 | variable_360;
        gTreeViewListItemParam->KernelTime.dwHighDateTime = TreeViewListItemParam_92;
        if ( v95 )
        {
          v96 = __PAIR__(v93, v365);
          *&v365 = v96 * 100.0;
          v97 = __PAIR__(v367, variable_360);
          v98 = *&v365 / v97;
        }
        else
        {
          v98 = 0.0;
        }
        CGraphData_Update(gTreeViewListItemParam->pGraphData1, gTimeQuerySystemInfo, v357, v98, 0);
        CGraphData_Update(gTreeViewListItemParam->pGraphData2, gTimeQuerySystemInfo, v99, COERCE_DOUBLE(0i64 >> 63), 0);
        v100 = gTreeViewListItemParam->pGraphDataPROCCPU;
        if ( v100 )
          CGraphData_Update(v100, gTimeQuerySystemInfo, ArgList, COERCE_DOUBLE(0i64 >> 63), 0);
        if ( gTreeViewListItemParam->dwStyle & 0x40 )
          v348 = v357 + v348;
        if ( gTreeViewListItemParam->dwProcessId )
          v335 = v357 + v335;
        if ( v357 > *&v342 )
        {
          *&v342 = v357;
          TreeViewListItemParam_338 = gTreeViewListItemParam;
        }
        v101 = v366 != gTreeViewListItemParam->m_CPUTime || v87 != gTreeViewListItemParam->field_52C;
        gTreeViewListItemParam->m_CPUTime = v366;
        gTreeViewListItemParam->field_52C = v87;
        v102 = RedrawColumn(v101, ghWndTreeListView, 1087, Item.iItem);
        LOBYTE(v372) = v102 | v372;
        Item.lParam->field_10 = 0;
        v103 = RedrawColumn(1, ghWndTreeListView, 1191, Item.iItem);
        v104 = v372;
        if ( v103 )
          v104 = 1;
        v365 = v104;
        v105 = RedrawColumn(1, ghWndTreeListView, 1193, Item.iItem);
        v106 = v365;
        if ( v105 )
          v106 = 1;
        v365 = v106;
        v107 = RedrawColumn(1, ghWndTreeListView, 1330, Item.iItem);
        v108 = v365;
        if ( v107 )
          v108 = 1;
        v290 = v357 == *&gTreeViewListItemParam->m_CPU;
        LOBYTE(v372) = v108;
        *&gTreeViewListItemParam->m_CPU = v357;
        RedrawColumn(v290 == 0, ghWndTreeListView, 1055, Item.iItem);
        *&gTreeViewListItemParam->m_CPUUsage = v357 + *&gTreeViewListItemParam->m_CPUUsage;
        v109 = RedrawColumn(1, ghWndTreeListView, 1637, Item.iItem);
        LOBYTE(v372) = v109 | v372;
        v365 = &gTreeViewListItemParam->pItemParam;
        TreeViewListItemParam_108 = gTreeViewListItemParam->pItemParam;
        if ( TreeViewListItemParam_108 )
        {
          v111 = v365;
          TreeViewListItemParam_110 = v365;
          do
          {
            *&TreeViewListItemParam_108->m_CPUUsage = v357;
            v113 = RedrawColumn(1, ghWndTreeListView, 1637, *(*v111 + 44));
            TreeViewListItemParam_112 = *TreeViewListItemParam_110;
            LOBYTE(v372) = v113 | v372;
            TreeViewListItemParam_110 = &TreeViewListItemParam_112->pItemParam;
            TreeViewListItemParam_108 = *TreeViewListItemParam_110;
          }
          while ( *TreeViewListItemParam_110 );
          gTreeViewListItemParam = TreeViewListItemParam_347;
        }
        TreeViewListItemParam_32 = v336;
        v115 = v346 - 1;
        --Item.iItem;
        fHungFlags = 1;
        goto LABEL_97;
      }
    }
    else if ( v367 | variable_360 )
    {
      v91 = (__PAIR__(v352, v366) - *&gTreeViewListItemParam->m_CPUTime);
      *&v365 = v91 * 100.0;
      v92 = __PAIR__(v367, variable_360);
      v90 = *&v365 / v92;
      goto LABEL_59;
    }
    v90 = 0.0;
    goto LABEL_59;
  }
LABEL_99:
  v119 = HIDWORD(v333);
  pSystemProcessInfo_118 = gpSystemProcessInfo;
  v321 = v333;
  v365 = HIDWORD(v317);
  v336 = v317;
  v354 = HIDWORD(v343);
  v352 = v343;
  v353 = liParam.HighPart;
  v366 = liParam.LowPart;
  v362 = HIDWORD(v318);
  v328 = HIDWORD(v333);
  v351 = v318;
  while ( 1 )
  {
    ++ItemWithSizeIs50H.nRefCount;
    ItemWithSizeIs50H.NumberOfThreads += pSystemProcessInfo_118->NumberOfThreads;
    ItemWithSizeIs50H.HandleCount += pSystemProcessInfo_118->HandleCount;
    UniqueProcessId = pSystemProcessInfo_118->UniqueProcessId;
    pSystemProcessInfo_1 = pSystemProcessInfo_118;
    packageFullName = UniqueProcessId;
    if ( UniqueProcessId )
    {
      v122 = pSystemProcessInfo_118->KernelTime.LowPart;
      v123 = pSystemProcessInfo_118->KernelTime.HighPart;
      v124 = __PAIR__(v123, v122) + pSystemProcessInfo_1->UserTime.QuadPart + __PAIR__(v119, v321);
      v321 += v122 + pSystemProcessInfo_1->UserTime.LowPart;
      v169 = __CFADD__(v122, v359);
      v359 += v122;
      UniqueProcessId = packageFullName;
      v361 += v123 + v169;
      pSystemProcessInfo_118 = pSystemProcessInfo_1;
      v328 = HIDWORD(v124);
    }
    gTreeViewListItemParam_123 = gpTreeViewListItemParam;
    TreeViewListItemParam_328 = gpTreeViewListItemParam;
    if ( !gpTreeViewListItemParam )
    {
LABEL_108:
      HIDWORD(v343) = UniqueProcessId;
      ProcessHandle = OpenProcess(0x410u, 0, UniqueProcessId);
      OutBuffer = ProcessHandle;
      if ( !ProcessHandle )
      {
        if ( GetLastError() == ERROR_ACCESS_DENIED )
          DeviceIoControl(ghDriverHandle, 0x8335003C, &v343 + 4, 4u, &OutBuffer, 4u, &v324 + 1, 0);
        ProcessHandle = OutBuffer;
        if ( !OutBuffer )
        {
          HIDWORD(v333) = pSystemProcessInfo_118->UniqueProcessId;
          ProcessHandle = OpenProcess(PROCESS_QUERY_LIMITED_INFORMATION, 0, HIDWORD(v333));
          TreeViewListItemParam_329 = ProcessHandle;
          if ( !ProcessHandle )
          {
            if ( GetLastError() == ERROR_ACCESS_DENIED )
              DeviceIoControl(ghDriverHandle, 0x8335003C, &v333 + 4, 4u, &TreeViewListItemParam_329, 4u, &v326 + 1, 0);
            ProcessHandle = TreeViewListItemParam_329;
          }
        }
      }
      memset(&ItemParam, 0, sizeof(tagTREEVIEWLISTITEMPARAM));
      ItemParam.dwProcessId = pSystemProcessInfo_118->UniqueProcessId;
      if ( pSystemProcessInfo_118->ImageName.Length )
        wcsncpy_s(szText, 256u, pSystemProcessInfo_118->ImageName.Buffer, pSystemProcessInfo_118->ImageName.Length >> 1);
      else
        wcscpy_s(szText, 256u, L"System Idle Process");
      QueryProcessUsers(
        ProcessHandle,
        pSystemProcessInfo_118->UniqueProcessId,
        &pSystemProcessInfo_118->CreateTime,
        szUserName,
        256u,
        szDomainName,
        256u,
        szText3,
        256u,
        &bVirtualizationEnabled,
        &fbUIAccess);
      if ( !szDomainName[0] || (pszText = L"\\", !szUserName[0]) )
        pszText = &gszNullString;
      wsprintfW(szFullName, L"%s%s%s", szDomainName, pszText, szUserName);
      ItemParam.pszFullUserName = _wcsdup(szText3);
      dwStyle = ItemParam.dwStyle;
      if ( bVirtualizationEnabled )
      {
        dwStyle = ItemParam.dwStyle | TVLS_VirtualizationEnabled;
        ItemParam.dwStyle |= TVLS_VirtualizationEnabled;
      }
      if ( fbUIAccess )
        ItemParam.dwStyle = dwStyle | TVLS_UIAccess;
      NtQueryInformationProcess(ProcessHandle, ProcessProtectionInformation, &ItemParam.field_288 + 1, 1u, &v312);
      if ( IsImmersiveProcess && IsImmersiveProcess(ProcessHandle) )
      {
        if ( GetPackageFullName )
        {
          cbPackageFullNameLength = 0;
          if ( GetPackageFullName(ProcessHandle, &cbPackageFullNameLength, 0) == ERROR_INSUFFICIENT_BUFFER )
          {
            packageFullName = malloc(2 * cbPackageFullNameLength);
            if ( !GetPackageFullName(ProcessHandle, &cbPackageFullNameLength, packageFullName) )
              ItemParam.pszPackageFullName = _wcsdup(packageFullName);
            free(packageFullName);
          }
        }
        ItemParam.dwStyle |= TVLS_ProcessIsImmersive;
      }
      ItemParam.m_ProcessMemoryPriority = -1;
      ItemParam.m_ProcessIoPriority = -1;
      TreeViewListItemParam_GetSystemInfo(
        pSystemProcessInfo_118,
        ProcessHandle,
        variable_360,
        v367,
        gTimeQuerySystemInfo.dwLowDateTime,
        gTimeQuerySystemInfo.dwHighDateTime,
        &ItemParam,
        0xFFFFFFFF);
      InheritedFromUniqueProcessId = pSystemProcessInfo_118->InheritedFromUniqueProcessId;
      if ( InheritedFromUniqueProcessId )
      {
        SystemProcessInfo_GetSystemProcessName(
          InheritedFromUniqueProcessId,
          &pSystemProcessInfo_118->CreateTime,
          szText4,
          0x100u);
        wsprintf_s(Buffer_382, L"(%d)", pSystemProcessInfo_118->InheritedFromUniqueProcessId);
        wcscat_s(szText4, 0x100u, Buffer_382);
      }
      else
      {
        wsprintf(szText4, L"<None>", v309);
      }
      QueryProcessArguments(
        ProcessHandle,
        pSystemProcessInfo_118->UniqueProcessId,
        &ItemParam.pszCommandLine,
        &ItemParam.pszCurrentDirectory,
        &ItemParam.pszEnvBlock,
        &bFlagsInExtendedProcessBasicInfo);
      if ( bFlagsInExtendedProcessBasicInfo )
        ItemParam.dwStyle |= TVLS_SupportExtendedProcessBasicInfo;
      liParam.HighPart = pSystemProcessInfo_118->UniqueProcessId;
      wcscpy_s(szText5, 0x100u, &gszNullString);
      ghMainWndBackup = 0;
      if ( liParam.HighPart == GetCurrentProcessId() )
      {
        ghMainWndBackup = ghMainWnd;
        GetWindowTextW(ghMainWnd, gpszWindowText, 256);
      }
      else
      {
        gbWindowTextFlags = 0;
        gpszWindowText = szText5;
        gdwWindowTextLength = 256;
        EnumWindows(EnumChildrenWindows, liParam.HighPart);
      }
      ItemParam.hMainWndBackup = ghMainWndBackup;
      if ( ghMainWndBackup )
        ItemParam.bMainWndIsHung = IsHungAppWindow(ghMainWndBackup);
      if ( !sbQueryServiceNamesInited )
      {
        QueryServiceNames();
        sbQueryServiceNamesInited = 1;
      }
      UniqueProcessId_1 = pSystemProcessInfo_118->UniqueProcessId;
      liParam.HighPart = pSystemProcessInfo_118->UniqueProcessId;
      if ( *EnumServicesStatusExW && UniqueProcessId_1 && (pGraphData_244 = 0, gdwServiceReturned) )
      {
        ppszText_245 = gpszServiceNames + 9;
        while ( 1 )
        {
          pSystemProcessInfo_118 = pSystemProcessInfo_1;
          if ( *ppszText_245 == liParam.HighPart )
            break;
          ++pGraphData_244;
          ppszText_245 += 11;
          if ( pGraphData_244 >= gdwServiceReturned )
            goto LABEL_297;
        }
        ItemParam.dwStyle |= TVLS_SHOWSERVICE;
      }
      else
      {
LABEL_297:
        ItemParam.dwStyle &= -0x21u;
      }
      wcscpy_s(&ItemParam.field_28C + 1, 0x41u, &gszNullString);
      ItemParam.szProcessName2 = _wcsdup(szText);
      if ( !sub_FDD0C0(ProcessHandle, &ItemParam) )
      {
        szProcessName = ItemParam.szProcessName;
        hIcon = 0;
        FileInfo.hIcon = 0;
        if ( ItemParam.szProcessName )
        {
          SHGetFileInfoW(ItemParam.szProcessName, 0, &FileInfo, sizeof(SHFILEINFOW), 0x101u);// SHGFI_ICON | SHGFI_SMALLICON 
          szProcessName = ItemParam.szProcessName;
          hIcon = FileInfo.hIcon;
        }
        ItemParam.hIcon = hIcon;
        hIcon_1 = 0;
        FileInfo.hIcon = 0;
        if ( szProcessName )
        {
          SHGetFileInfoW(szProcessName, 0, &FileInfo, sizeof(SHFILEINFOW), SHGFI_ICON);
          hIcon_1 = FileInfo.hIcon;
        }
        ItemParam.hFileIcon = hIcon_1;
      }
      pGraphData_249 = &pSystemProcessInfo_118->CreateTime.LowPart;
      ItemParam.ProcessBasePriority = pSystemProcessInfo_118->BasePriority;
      if ( !pSystemProcessInfo_118->InheritedFromUniqueProcessId && ItemParam.dwProcessId )
      {
        gdwProcessIdLast = ItemParam.dwProcessId;
        gCreateTimeLast.dwLowDateTime = *pGraphData_249;
        gCreateTimeLast.dwHighDateTime = pSystemProcessInfo_118->CreateTime.HighPart;
        pSystemProcessInfo_118->InheritedFromUniqueProcessId = -1;
      }
      ItemParam.InheritedFromUniqueProcessId = pSystemProcessInfo_118->InheritedFromUniqueProcessId;
      ItemParam.pItemParam = 0;
      ItemParam.HandleCount = pSystemProcessInfo_118->HandleCount;
      ItemParam.CreateTime.dwLowDateTime = *pGraphData_249;
      ItemParam.CreateTime.dwHighDateTime = pSystemProcessInfo_118->CreateTime.HighPart;
      v357 = 0.0;
      fHungFlags = 0;
      if ( GetVersion() <= 4u )
      {
        fHungFlags = 1;
        v252 = &pSystemProcessInfo_118->ReadOperationCount;
      }
      else
      {
        v252 = &pSystemProcessInfo_118[1];
      }
      packageFullName = pSystemProcessInfo_118->NumberOfThreads;
      if ( !packageFullName )
        goto LABEL_455;
      v253 = LODWORD(v357);
      v254 = (v252 + 48);
      v255 = HIDWORD(v357);
      do
      {
        v256 = *v254 + __PAIR__(v255, v253);
        v255 = v256 >> 32;
        v253 = v256;
        v254 += 16;
        packageFullName = (packageFullName - 1);
      }
      while ( packageFullName );
      if ( v255 >= 0 && (v255 > 0 || v256) )
        ItemParam.ContextSwtiches = __PAIR__(v255, v256);
      else
LABEL_455:
        ItemParam.ContextSwtiches = 0i64;
      ItemParam.m_SelectedItem = 0;
      fHungFlags = 0;
      if ( GetVersion() <= 4u )
      {
        fHungFlags = 1;
        v257 = &pSystemProcessInfo_118->ReadOperationCount;
      }
      else
      {
        v257 = &pSystemProcessInfo_118[1];
      }
      v258 = pSystemProcessInfo_118->NumberOfThreads;
      v259 = 0;
      if ( v258 )
      {
        v260 = (v257 + 56);
        packageFullName = pSystemProcessInfo_118->NumberOfThreads;
        v261 = (v257 + 52);
        gTreeViewListItemParam_123 = TreeViewListItemParam_328;
        do
        {
          if ( *v261 == 5 && *v260 == 5 )
            ++v259;
          v261 += 16;
          v260 += 16;
          packageFullName = (packageFullName - 1);
        }
        while ( packageFullName );
        v258 = pSystemProcessInfo_118->NumberOfThreads;
      }
      if ( v258 == v259 )
        ItemParam.dwStyle |= 0x80u;
      if ( PE_IsProcessInJob(ProcessHandle, ItemParam.dwProcessId, 0, 0) )
        ItemParam.dwStyle |= 0x800u;
      else
        ItemParam.dwStyle &= 0xFFFFF7FF;
      ItemParam.ProcessMitigationPolicy = Fake_GetProcessMitigationPolicy(&ItemParam, ProcessHandle);
      ItemParam.field_50 = 0;
      *&ItemParam.m_CPUTime = pSystemProcessInfo_118->KernelTime.QuadPart + pSystemProcessInfo_118->UserTime.QuadPart;
      ItemParam.KernelTime.dwLowDateTime = pSystemProcessInfo_118->KernelTime.LowPart;
      ItemParam.KernelTime.dwHighDateTime = pSystemProcessInfo_118->KernelTime.HighPart;
      ItemParam.field_64 = 0;
      ItemParam.PageFaultCount = pSystemProcessInfo_118->PageFaultCount;
      ItemParam.PagefileUsage = pSystemProcessInfo_118->PagefileUsage;
      ItemParam.VirtualSize = pSystemProcessInfo_118->VirtualSize;
      ItemParam.PeakPagefileUsage = pSystemProcessInfo_118->PeakPagefileUsage;
      ItemParam.WorkingSetSize = pSystemProcessInfo_118->WorkingSetSize;
      ItemParam.PeakWorkingSetSize = pSystemProcessInfo_118->PeakWorkingSetSize;
      if ( !_wcsicmp(ItemParam.szProcessName2, L"wmiprvse.exe") )
        sub_1003A00(ItemParam.dwProcessId, &ItemParam.bSupportWMIProviders);
      ItemParam.m_DPIAwareness = -1;
      if ( GetProcessDpiAwareness )
        GetProcessDpiAwareness(ProcessHandle, &ItemParam.m_DPIAwareness);
      if ( v362 <= 0 && pSystemProcessInfo_118->PagefileUsage > v351 )
      {
        v351 = pSystemProcessInfo_118->PagefileUsage;
        v362 = 0;
      }
      if ( gpfnProcessIdToSessionId )
      {
        v262 = gpfnProcessIdToSessionId(pSystemProcessInfo_118->UniqueProcessId, &ItemParam.field_64);
        v263 = ItemParam.field_64;
        if ( !v262 )
          v263 = -1;
        ItemParam.field_64 = v263;
      }
      if ( dword_10610C8 )
      {
        *&ItemParam.m_CPU = 0i64;
        v357 = 0.0;
LABEL_360:
        ItemParam.pszSystemName = _wcsdup(szText4);
        v270 = _wcsdup(szFullName);
        ItemParam.dwStyle |= 4u;
        ItemParam.pszName = v270;
        v290 = _wcsicmp(v270, gszMainTitle) == 0;
        dwItemStyle = ItemParam.dwStyle;
        if ( v290 )
        {
          dwItemStyle = ItemParam.dwStyle | 0x40;
          ItemParam.dwStyle |= 0x40u;
        }
        if ( gConfig.bShowAllUsers || ItemParam.dwStyle & 0x40 )
          ItemStyle_270 = dwItemStyle | 2;
        else
          ItemStyle_270 = dwItemStyle & 0xFFFFFFFD;
        ItemParam.dwStyle = ItemStyle_270;
        wcscpy_s(&ItemParam.field_68, 0x100u, szText5);
        if ( dword_10610C8 )
        {
          ItemParam.field_10 = 0;
        }
        else
        {
          if ( *&gTimeQuerySystemInfoLast <= *&ItemParam.CreateTime )
          {
            ItemParam.field_10 = 2;
          }
          else
          {
            ItemParam.field_10 = 0;
            *&ItemParam.m_CPU = 0i64;
          }
          ItemParam.field_14 = 0;
          LOBYTE(ItemParam.field_18) = 0;
        }
        LOBYTE(ItemParam.field_500) = 0;
        ItemParam.pNetCclrInfo = sub_FCB9D0(ItemParam.dwProcessId);
        LOBYTE(ItemParam.field_508) = ProcessIsNetCclr_0(&ItemParam);
        NetCclrInfo_271 = ItemParam.pNetCclrInfo;
        if ( ItemParam.pNetCclrInfo )
        {
          if ( !v370 )
          {
            dynamic_initializer_for_gPerformanceInfoInMemory__();
            NetCclrInfo_271 = ItemParam.pNetCclrInfo;
            v370 = 1;
          }
          if ( NetCclrInfo_271 )
            ++ItemWithSizeIs50H.field_48;
        }
        sub_FCC540(&ItemParam, 0xFFFFFFFF);
        ItemParam.m_GdiObjects = 0;
        ItemParam.m_UserObjects = 0;
        ItemParam.field_14 = 0;
        pItemFound = ::SendMessageW(
                       ghMainWnd,
                       WM_MSG_7EE,
                       gdwProcessIdSelected == pSystemProcessInfo_118->UniqueProcessId,
                       &ItemParam);
        TreeViewListItemParam_GetSystemInfo(
          pSystemProcessInfo_118,
          ProcessHandle,
          variable_360,
          v367,
          gTimeQuerySystemInfo.dwLowDateTime,
          gTimeQuerySystemInfo.dwHighDateTime,
          pItemFound,
          0xFFFFFFFF);
        TreeViewListItemParam_272 = pItemFound;
        TreeViewListItemParam_273 = TreeViewListItemParam_337;
        TreeViewListItemParam_337 = pItemFound;
        LOBYTE(v372) = 1;
        LODWORD(TreeViewListItemParam_337->ContextSwtichDelta) = TreeViewListItemParam_337->ContextSwtiches;
        HIDWORD(TreeViewListItemParam_272->ContextSwtichDelta) = HIDWORD(TreeViewListItemParam_272->ContextSwtiches);
        LODWORD(TreeViewListItemParam_272->CyclesDelta) = TreeViewListItemParam_272->Cycles;
        HIDWORD(TreeViewListItemParam_272->CyclesDelta) = HIDWORD(TreeViewListItemParam_272->Cycles);
        TreeViewListItemParam_272->m_SelectedItem = TreeViewListItemParam_273;
        if ( ItemParam.szProcessName && *ItemParam.szProcessName != 91 )
        {
          if ( gConfig.bVerifySignatures )
          {
            InterlockedIncrement(&TreeViewListItemParam_272->nRefCount);
            _beginthread(VerifyImageThreadProc, 0, pItemFound);
            TreeViewListItemParam_272 = pItemFound;
          }
          v276 = sub_FABB70(TreeViewListItemParam_272->pszName, TreeViewListItemParam_272->szProcessName);
          TreeViewListItemParam_275 = pItemFound;
          pItemFound->field_33C = v276;
          v278 = 2;
          if ( gConfig.bCheckVirusTotal )
            v278 = 0;
          sub_1001C30(TreeViewListItemParam_275, 1, v278);
          TreeViewListItemParam_272 = pItemFound;
        }
        if ( TreeViewListItemParam_272->dwProcessId && v357 > *&v342 )
        {
          *&v342 = v357;
          TreeViewListItemParam_338 = TreeViewListItemParam_272;
        }
        if ( ItemParam.dwStyle & 0x40 )
        {
          v279 = __PAIR__(v354, pSystemProcessInfo_118->PagefileUsage) + v352;
          v354 = (__PAIR__(v354, pSystemProcessInfo_118->PagefileUsage) + v352) >> 32;
          v352 = v279;
          v280 = __PAIR__(v353, pSystemProcessInfo_118->WorkingSetSize) + v366;
          v353 = (__PAIR__(v353, pSystemProcessInfo_118->WorkingSetSize) + v366) >> 32;
          v366 = v280;
          ++ItemWithSizeIs50H.field_34;
          ItemWithSizeIs50H.field_3C += pSystemProcessInfo_118->NumberOfThreads;
          ItemWithSizeIs50H.field_44 += pSystemProcessInfo_118->HandleCount;
          if ( ItemParam.pNetCclrInfo )
            ++ItemWithSizeIs50H.field_4C;
        }
        goto LABEL_259;
      }
      if ( GetProcessorSystemCycleTime && gdwVersion >= 2 )
      {
        if ( v347 | v345 )
        {
          v264 = pSystemProcessInfo_118->SpareLi3.QuadPart;
          *&liParam.HighPart = v264 * 100.0;
          v265 = __PAIR__(v347, v345);
          v266 = *&liParam.HighPart / v265;
LABEL_354:
          v269 = v266;
          v357 = v266;
          if ( v266 > 100.0 )
          {
            v269 = db_onehundred;
            v357 = db_onehundred;
          }
          *&ItemParam.m_CPU = v269;
          if ( ItemParam.dwStyle & 0x40 )
          {
            v348 = v269 + v348;
            v269 = v357;
          }
          if ( ItemParam.dwProcessId )
            v335 = v269 + v335;
          goto LABEL_360;
        }
      }
      else if ( v367 | variable_360 )
      {
        v267 = (pSystemProcessInfo_118->KernelTime.QuadPart + pSystemProcessInfo_118->UserTime.QuadPart);
        *&liParam.HighPart = v267 * 100.0;
        v268 = __PAIR__(v367, variable_360);
        v266 = *&liParam.HighPart / v268;
        goto LABEL_354;
      }
      v266 = 0.0;
      goto LABEL_354;
    }
    v126 = pSystemProcessInfo_118->CreateTime.LowPart;
    v127 = pSystemProcessInfo_118->CreateTime.HighPart;
    while ( gTreeViewListItemParam_123->CreateTime.dwLowDateTime != v126
         || gTreeViewListItemParam_123->CreateTime.dwHighDateTime != v127
         || gTreeViewListItemParam_123->dwProcessId != UniqueProcessId )
    {
      gTreeViewListItemParam_123 = gTreeViewListItemParam_123->m_Prev;
      TreeViewListItemParam_328 = gTreeViewListItemParam_123;
      if ( !gTreeViewListItemParam_123 )
        goto LABEL_108;
    }
    HIDWORD(v318) = UniqueProcessId;
    ProcessHandle = OpenProcess(0x2000000u, 0, UniqueProcessId);
    TreeViewListItemParam_347 = ProcessHandle;
    if ( !ProcessHandle )
    {
      if ( GetLastError() == ERROR_ACCESS_DENIED )
        DeviceIoControl(ghDriverHandle, 0x8335003C, &v318 + 4, 4u, &TreeViewListItemParam_347, 4u, &v322 + 1, 0);
      ProcessHandle = TreeViewListItemParam_347;
    }
    if ( (FindInfo.flags = 1,
          FindInfo.lParam = gTreeViewListItemParam_123,
          nItemFound = ::SendMessageW(hWndListCtrl_1, LVM_FINDITEMW, 0xFFFFFFFF, &FindInfo),
          Item.iItem = nItemFound,
          v129 = gTreeViewListItemParam_123->dwStyle,
          !(v129 & 2))
      || v129 & 1 && gConfig.byte_14012ADFE
      || nItemFound != -1 )
    {
      gTreeViewListItemParam_123->field_2C = nItemFound;
    }
    else
    {
      sub_FB7F20(ghWndTreeListView, gTreeViewListItemParam_123);
    }
    v130 = TreeViewListItemParam_GetSystemInfo(
             pSystemProcessInfo_118,
             ProcessHandle,
             variable_360,
             v367,
             gTimeQuerySystemInfo.dwLowDateTime,
             gTimeQuerySystemInfo.dwHighDateTime,
             gTreeViewListItemParam_123,
             Item.iItem);
    LOBYTE(v372) = v130 | v372;
    v132 = pSystemProcessInfo_118->KernelTime.LowPart;
    v133 = pSystemProcessInfo_118->UserTime.LowPart;
    v131 = pSystemProcessInfo_118->UserTime.LowPart + pSystemProcessInfo_118->KernelTime.LowPart;
    v337 = pSystemProcessInfo_118->KernelTime.HighPart;
    v134 = __PAIR__(v337, v133) + __PAIR__(pSystemProcessInfo_118->UserTime.HighPart, v132);
    v169 = v131 < gTreeViewListItemParam_123->m_CPUTime;
    v135 = v131 - gTreeViewListItemParam_123->m_CPUTime;
    HIDWORD(v343) = v133 + v132;
    v136 = HIDWORD(v134) - (v169 + gTreeViewListItemParam_123->field_52C);
    packageFullName = HIDWORD(v134);
    if ( GetProcessorSystemCycleTime )
    {
      if ( !(v347 | v345) )
        goto LABEL_135;
      v137 = gTreeViewListItemParam_123->CyclesDelta;
      *&liParam.HighPart = v137 * 100.0;
      v138 = __PAIR__(v347, v345);
      v139 = *&liParam.HighPart / v138;
    }
    else
    {
      if ( !gTreeViewListItemParam_123->dwProcessId )
      {
        v140 = v357;
        TreeViewListItemParam_336 = gTreeViewListItemParam_123;
        goto LABEL_137;
      }
      if ( !(v367 | variable_360) )
      {
LABEL_135:
        v139 = 0.0;
        goto LABEL_136;
      }
      v141 = __PAIR__(v136, v135);
      *&liParam.HighPart = v141 * 100.0;
      v142 = __PAIR__(v367, variable_360);
      v139 = *&liParam.HighPart / v142;
    }
LABEL_136:
    v140 = v139;
    v357 = v139;
LABEL_137:
    if ( v140 > 100.0 )
      v357 = db_onehundred;
    if ( v367 | variable_360 )
    {
      v143 = (__PAIR__(v337, pSystemProcessInfo_118->KernelTime.LowPart) - *&gTreeViewListItemParam_123->KernelTime);
      *&liParam.HighPart = v143 * 100.0;
      v144 = __PAIR__(v367, variable_360);
      v145 = *&liParam.HighPart / v144;
    }
    else
    {
      v145 = 0.0;
    }
    v146 = *&gTreeViewListItemParam_123->field_568;
    v169 = v146 < v316;
    v290 = v146 == v316;
    gTreeViewListItemParam_123->KernelTime.dwLowDateTime = pSystemProcessInfo_118->KernelTime.LowPart;
    gTreeViewListItemParam_123->KernelTime.dwHighDateTime = v337;
    v147 = v145;
    if ( !v169 && !v290 )
    {
      TreeViewListItemParam_327 = gTreeViewListItemParam_123;
      v316 = v146;
    }
    if ( gTreeViewListItemParam_123->dwStyle & 0x40 )
      v348 = v357 + v348;
    v148 = _mm_unpckl_pd(*&v357, *&v357);
    if ( gTreeViewListItemParam_123->dwProcessId )
    {
      if ( pSystemProcessInfo_118->UserTime.QuadPart )
        CGraphData_Update(gTreeViewListItemParam_123->pGraphData1, gTimeQuerySystemInfo, v148.m128d_f64[0], v147, 0);
      else
        CGraphData_Update(
          gTreeViewListItemParam_123->pGraphData1,
          gTimeQuerySystemInfo,
          v148.m128d_f64[0],
          v148.m128d_f64[1],
          0);
      v149 = v357;
      v335 = v357 + v335;
      if ( v357 > *&v342 )
      {
        *&v342 = v357;
        TreeViewListItemParam_338 = gTreeViewListItemParam_123;
      }
    }
    else
    {
      CGraphData_Update(gTreeViewListItemParam_123->pGraphData1, gTimeQuerySystemInfo, 0.0, v148.m128d_f64[0], 0);
      v149 = v357;
    }
    v150 = v149 != *&gTreeViewListItemParam_123->m_CPU;
    *&gTreeViewListItemParam_123->m_CPU = v149;
    v151 = RedrawColumn(v150, ghWndTreeListView, IDS_CPU, Item.iItem);
    v152 = *&gTreeViewListItemParam_123->m_CPUUsage + v357;
    LOBYTE(v372) = v151 | v372;
    fHungFlags = 1;
    if ( v152 == *&gTreeViewListItemParam_123->m_CPUUsage )
      fHungFlags = 0;
    *&gTreeViewListItemParam_123->m_CPUUsage = v152;
    v153 = RedrawColumn(1, ghWndTreeListView, IDS_TREE_CPU_USAGE, Item.iItem);
    LOBYTE(v372) = v153 | v372;
    v290 = gTreeViewListItemParam_123->pItemParam == 0;
    liParam.HighPart = &gTreeViewListItemParam_123->pItemParam;
    if ( !v290 )
    {
      ppTreeViewListItemParam_152 = &gTreeViewListItemParam_123->pItemParam;
      do
      {
        *&(*ppTreeViewListItemParam_152)->m_CPUUsage = *&(*ppTreeViewListItemParam_152)->m_CPUUsage + v357;
        v155 = RedrawColumn(1, ghWndTreeListView, IDS_TREE_CPU_USAGE, (*ppTreeViewListItemParam_152)->field_2C);
        TreeViewListItemParam_154 = *ppTreeViewListItemParam_152;
        LOBYTE(v372) = v155 | v372;
        ppTreeViewListItemParam_152 = &TreeViewListItemParam_154->pItemParam;
      }
      while ( *ppTreeViewListItemParam_152 );
      pSystemProcessInfo_118 = pSystemProcessInfo_1;
    }
    v157 = RedrawColumn(fHungFlags, ghWndTreeListView, IDS_CPU_HISTORY, Item.iItem);
    LOBYTE(v372) = v157 | v372;
    --v346;
    if ( sub_FDD0C0(ProcessHandle, gTreeViewListItemParam_123) )
    {
      PostMessageW(ghMainWnd, WM_MSG_7EB, Item.iItem, -1);
      RefreshTreeView();
    }
    v158 = (gTreeViewListItemParam_123->dwStyle >> 7) & 0xFFFFFF01;
    fHungFlags = 0;
    v337 = v158;
    if ( GetVersion() <= 4u )
    {
      fHungFlags = 1;
      v159 = &pSystemProcessInfo_118->ReadOperationCount;
    }
    else
    {
      v159 = &pSystemProcessInfo_118[1];
    }
    v160 = pSystemProcessInfo_118->NumberOfThreads;
    v161 = 0;
    liParam.HighPart = v160;
    if ( v160 )
    {
      v162 = (v159 + 56);
      v163 = (v159 + 52);
      do
      {
        if ( *v163 == 5 && *v162 == 5 )
          ++v161;
        v163 += 16;
        v162 += 16;
        --v160;
      }
      while ( v160 );
      v160 = liParam.HighPart;
    }
    if ( v160 == v161 )
      gTreeViewListItemParam_123->dwStyle |= 0x80u;
    else
      gTreeViewListItemParam_123->dwStyle &= -0x81u;
    if ( ((gTreeViewListItemParam_123->dwStyle >> 7) & 1) != v337 )
    {
      PostMessageW(ghMainWnd, WM_MSG_7EB, Item.iItem, -1);
      RefreshTreeView();
    }
    v164 = gTreeViewListItemParam_123->pszCommandLine;
    if ( (!v164 || !*v164) && BYTE1(gTreeViewListItemParam_123->field_28C) < 2u )
    {
      QueryProcessArguments(
        ProcessHandle,
        gTreeViewListItemParam_123->dwProcessId,
        &gTreeViewListItemParam_123->pszCommandLine,
        &gTreeViewListItemParam_123->pszCurrentDirectory,
        &gTreeViewListItemParam_123->pszEnvBlock,
        0);
      free(v164);
      ++BYTE1(gTreeViewListItemParam_123->field_28C);
      v165 = gTreeViewListItemParam_123->pszCommandLine;
      if ( v165 )
      {
        if ( *v165 )
        {
          v166 = RedrawColumn(1, ghWndTreeListView, IDS_COMMAND_LINE, Item.iItem);
          LOBYTE(v372) = v166 | v372;
        }
      }
    }
    v167 = gTreeViewListItemParam_123->field_28C;
    if ( v167 < 2u )
    {
      if ( !flags )
        LOBYTE(gTreeViewListItemParam_123->field_28C) = v167 + 1;
    }
    else if ( !flags )
    {
      goto LABEL_190;
    }
    if ( PE_IsProcessInJob(ProcessHandle, gTreeViewListItemParam_123->dwProcessId, 0, 0) )
      gTreeViewListItemParam_123->dwStyle |= TVLS_ENABLEJOBS;
    else
      gTreeViewListItemParam_123->dwStyle &= -0x801u;
LABEL_190:
    if ( ProcessHandle )
    {
      liParam.HighPart = gTreeViewListItemParam_123->ProcessMitigationPolicy;
      v168 = Fake_GetProcessMitigationPolicy(gTreeViewListItemParam_123, ProcessHandle);
      gTreeViewListItemParam_123->ProcessMitigationPolicy = v168;
      if ( v168 != liParam.HighPart
        && ((v169 = v168 < BYTE4(liParam.QuadPart), v168 != BYTE4(liParam.QuadPart))
         || (v170 = BYTE1(gTreeViewListItemParam_123->ProcessMitigationPolicy),
             v169 = v170 < BYTE5(liParam.QuadPart),
             v170 != BYTE5(liParam.QuadPart))
         || (v171 = BYTE2(gTreeViewListItemParam_123->ProcessMitigationPolicy),
             v169 = v171 < BYTE6(liParam.QuadPart),
             v171 != BYTE6(liParam.QuadPart))
         || (v172 = HIBYTE(gTreeViewListItemParam_123->ProcessMitigationPolicy),
             v169 = v172 < HIBYTE(liParam.QuadPart),
             v172 != HIBYTE(liParam.QuadPart))) )
      {
        v173 = -v169 | 1;
      }
      else
      {
        v173 = 0;
      }
      v174 = RedrawColumn(v173 == 0, ghWndTreeListView, 1199, Item.iItem);
      LOBYTE(v372) = v174 | v372;
    }
    if ( gTreeViewListItemParam_123->pNetCclrInfo )
    {
LABEL_210:
      ++ItemWithSizeIs50H.field_48;
      goto LABEL_211;
    }
    v175 = gTreeViewListItemParam_123->field_500;
    if ( v175 < 2u )
    {
      if ( !flags )
        LOBYTE(gTreeViewListItemParam_123->field_500) = v175 + 1;
    }
    else if ( !flags )
    {
      goto LABEL_209;
    }
    gTreeViewListItemParam_123->pNetCclrInfo = sub_FCB9D0(gTreeViewListItemParam_123->dwProcessId);
    LOBYTE(gTreeViewListItemParam_123->field_508) = ProcessIsNetCclr_0(gTreeViewListItemParam_123);
    if ( !gTreeViewListItemParam_123->pNetCclrInfo )
      goto LABEL_211;
    if ( !v370 )
    {
      dynamic_initializer_for_gPerformanceInfoInMemory__();
      v370 = 1;
    }
    PostMessageW(ghMainWnd, WM_MSG_7EB, Item.iItem, -1);
    RefreshTreeView();
LABEL_209:
    if ( gTreeViewListItemParam_123->pNetCclrInfo )
      goto LABEL_210;
LABEL_211:
    v176 = gTreeViewListItemParam_123->ProcessBasePriority;
    v177 = pSystemProcessInfo_1->BasePriority;
    gTreeViewListItemParam_123->ProcessBasePriority = v177;
    v178 = RedrawColumn(v177 != v176, ghWndTreeListView, IDS_PRIORITY, Item.iItem);
    LOBYTE(v372) = v178 | v372;
    if ( gTreeViewListItemParam_123->ProcessBasePriority != v176 )
    {
      v179 = Item.lParam[16].field_18;
      if ( v179 == 4 && !Item.lParam[11].field_1C )
        v179 = 0;
      ArgList_16 = v179;
      v181 = GetMenu(ghMainWnd);
      sub_FFEF00(v181, ArgList_16);
    }
    v182 = packageFullName;
    v183 = HIDWORD(v343) != gTreeViewListItemParam_123->m_CPUTime
        || packageFullName != gTreeViewListItemParam_123->field_52C;
    gTreeViewListItemParam_123->m_CPUTime = HIDWORD(v343);
    gTreeViewListItemParam_123->field_52C = v182;
    v184 = RedrawColumn(v183, ghWndTreeListView, IDS_CPU_TIME, Item.iItem);
    LOBYTE(v372) = v184 | v372;
    if ( GetProcessDpiAwareness )
    {
      GetProcessDpiAwareness(ProcessHandle, &v317 + 4);
      v290 = HIDWORD(v317) == gTreeViewListItemParam_123->m_DPIAwareness;
      gTreeViewListItemParam_123->m_DPIAwareness = HIDWORD(v317);
      v185 = RedrawColumn(!v290, ghWndTreeListView, IDS_DPI_AWARENESS, Item.iItem);
      LOBYTE(v372) = v185 | v372;
    }
    pSystemProcessInfo_184 = pSystemProcessInfo_1;
    v187 = pSystemProcessInfo_1->HandleCount;
    v290 = v187 == gTreeViewListItemParam_123->HandleCount;
    gTreeViewListItemParam_123->HandleCount = v187;
    v188 = RedrawColumn(!v290, ghWndTreeListView, IDS_HANDLES, Item.iItem);
    LOBYTE(v372) = v188 | v372;
    v189 = pSystemProcessInfo_184->PageFaultCount - gTreeViewListItemParam_123->PageFaultCount;
    v290 = v189 == gTreeViewListItemParam_123->m_PFDelta;
    gTreeViewListItemParam_123->m_PFDelta = v189;
    v190 = RedrawColumn(!v290, ghWndTreeListView, IDS_PF_DELTA, Item.iItem);
    LOBYTE(v372) = v190 | v372;
    v191 = pSystemProcessInfo_184->PageFaultCount;
    v290 = v191 == gTreeViewListItemParam_123->PageFaultCount;
    gTreeViewListItemParam_123->PageFaultCount = v191;
    v192 = RedrawColumn(!v290, ghWndTreeListView, IDS_PAGE_FAULTS, Item.iItem);
    LOBYTE(v372) = v192 | v372;
    v193 = pSystemProcessInfo_184->WorkingSetSize;
    v290 = v193 == gTreeViewListItemParam_123->WorkingSetSize;
    gTreeViewListItemParam_123->WorkingSetSize = v193;
    v194 = RedrawColumn(!v290, ghWndTreeListView, IDS_WORKING_SET, Item.iItem);
    LOBYTE(v372) = v194 | v372;
    v195 = pSystemProcessInfo_184->PeakWorkingSetSize;
    v290 = v195 == gTreeViewListItemParam_123->PeakWorkingSetSize;
    gTreeViewListItemParam_123->PeakWorkingSetSize = v195;
    v196 = RedrawColumn(!v290, ghWndTreeListView, IDS_PEAK_WORKING_SET, Item.iItem);
    LOBYTE(v372) = v196 | v372;
    v197 = pSystemProcessInfo_184->QuotaPagedPoolUsage;
    v290 = v197 == gTreeViewListItemParam_123->m_PagedPool;
    gTreeViewListItemParam_123->m_PagedPool = v197;
    v198 = RedrawColumn(!v290, ghWndTreeListView, IDS_PAGEDPOOL, Item.iItem);
    LOBYTE(v372) = v198 | v372;
    v199 = pSystemProcessInfo_184->QuotaNonPagedPoolUsage;
    v290 = v199 == gTreeViewListItemParam_123->m_NonpagedPool;
    gTreeViewListItemParam_123->m_NonpagedPool = v199;
    v200 = RedrawColumn(!v290, ghWndTreeListView, IDS_NONPAGEDPOOL, Item.iItem);
    LOBYTE(v372) = v200 | v372;
    v201 = pSystemProcessInfo_184->PeakPagefileUsage;
    v290 = v201 == gTreeViewListItemParam_123->PeakPagefileUsage;
    gTreeViewListItemParam_123->PeakPagefileUsage = v201;
    v202 = RedrawColumn(!v290, ghWndTreeListView, IDS_PEAK_PRIVATE_BYTES, Item.iItem);
    LOBYTE(v372) = v202 | v372;
    v203 = pSystemProcessInfo_184->PagefileUsage - gTreeViewListItemParam_123->PagefileUsage;
    v290 = v203 == gTreeViewListItemParam_123->m_PrivatedDeltaBytes;
    gTreeViewListItemParam_123->m_PrivatedDeltaBytes = v203;
    v204 = RedrawColumn(!v290, ghWndTreeListView, IDS_PRIVATE_DELTA_BYTES, Item.iItem);
    LOBYTE(v372) = v204 | v372;
    v205 = pSystemProcessInfo_184->PagefileUsage;
    if ( v362 <= 0 && v205 > v351 )
    {
      v351 = pSystemProcessInfo_184->PagefileUsage;
      v362 = 0;
    }
    v290 = v205 == gTreeViewListItemParam_123->PagefileUsage;
    gTreeViewListItemParam_123->PagefileUsage = v205;
    v206 = !v290;
    v207 = RedrawColumn(v206, ghWndTreeListView, IDS_PRIVATE_BYTES, Item.iItem);
    LOBYTE(v372) = v207 | v372;
    v208 = RedrawColumn(v206, ghWndTreeListView, IDS_PRIVATE_BYTES_HISTORY, Item.iItem);
    LOBYTE(v372) = v208 | v372;
    pGraphData_207 = gTreeViewListItemParam_123->pGraphData2;
    if ( pGraphData_207
      && (gTreeViewListItemParam_123->PeakPagefileUsage >> 10)
       + qword_103D110[gTreeViewListItemParam_123->PeakPagefileUsage >> 41] >= pGraphData_207->m_dbMemorySize )
    {
      pGraphData_207->m_dbMemorySize = (((gTreeViewListItemParam_123->PeakPagefileUsage >> 10)
                                       + qword_103D110[gTreeViewListItemParam_123->PeakPagefileUsage >> 41])
                                      * 1.2);
    }
    CGraphData_Update(
      gTreeViewListItemParam_123->pGraphData2,
      gTimeQuerySystemInfo,
      (gTreeViewListItemParam_123->PagefileUsage * 0.0009765625),
      0.0,
      0);
    pSystemProcessInfo_118 = pSystemProcessInfo_1;
    v210 = pSystemProcessInfo_1->VirtualSize;
    v290 = v210 == gTreeViewListItemParam_123->VirtualSize;
    gTreeViewListItemParam_123->VirtualSize = v210;
    v211 = RedrawColumn(!v290, ghWndTreeListView, IDS_VIRTUAL_SIZE, Item.iItem);
    LOBYTE(v372) = v211 | v372;
    if ( IsColumnIDValid(ghWndTreeListView, IDS_WINDOW_TITLE) || IsColumnIDValid(ghWndTreeListView, IDS_WINDOW_STATUS) )
    {
      UniqueProcessId_2 = pSystemProcessInfo_118->UniqueProcessId;
      wcscpy_s(szText5, 0x100u, &gszNullString);
      ghMainWndBackup = 0;
      if ( UniqueProcessId_2 == GetCurrentProcessId() )
      {
        ghMainWndBackup = ghMainWnd;
        GetWindowTextW(ghMainWnd, gpszWindowText, 256);
      }
      else
      {
        gbWindowTextFlags = 0;
        gpszWindowText = szText5;
        gdwWindowTextLength = 256;
        EnumWindows(EnumChildrenWindows, UniqueProcessId_2);
      }
      hMainWndBackup = ghMainWndBackup;
      fHungFlags = gTreeViewListItemParam_123->bMainWndIsHung;
      if ( IsColumnIDValid(ghWndTreeListView, IDS_WINDOW_STATUS) && hMainWndBackup )
        fHungFlags = IsHungAppWindow(hMainWndBackup);
      v214 = wcscmp(szText5, &gTreeViewListItemParam_123->field_68);
      if ( v214 )
        v214 = -(v214 < 0) | 1;
      v290 = v214 == 0;
      v215 = fHungFlags;
      if ( !v290 || (fHungFlags = 0, v215 != gTreeViewListItemParam_123->bMainWndIsHung) )
        fHungFlags = 1;
      gTreeViewListItemParam_123->bMainWndIsHung = v215;
      wcscpy_s(&gTreeViewListItemParam_123->field_68, 0x100u, szText5);
      gTreeViewListItemParam_123->hMainWndBackup = hMainWndBackup;
      v216 = fHungFlags;
      v217 = RedrawColumn(fHungFlags, ghWndTreeListView, IDS_WINDOW_TITLE, Item.iItem);
      LOBYTE(v372) = v217 | v372;
      v218 = RedrawColumn(v216, ghWndTreeListView, IDS_WINDOW_STATUS, Item.iItem);
      pSystemProcessInfo_118 = pSystemProcessInfo_1;
      LOBYTE(v372) = v218 | v372;
    }
    v219 = pSystemProcessInfo_118->NumberOfThreads;
    v290 = v219 == gTreeViewListItemParam_123->m_NumberOfThreads;
    gTreeViewListItemParam_123->m_NumberOfThreads = v219;
    v220 = RedrawColumn(!v290, ghWndTreeListView, IDS_THREADS2, Item.iItem);
    LOBYTE(v372) = v220 | v372;
    if ( gTreeViewListItemParam_123->pGraphDataPROCCPU )
    {
      v221 = (gTreeViewListItemParam_123->DeltaWriteBytes + gTreeViewListItemParam_123->DeltaOtherBytes) >> 32;
      v222 = LODWORD(gTreeViewListItemParam_123->DeltaWriteBytes) + LODWORD(gTreeViewListItemParam_123->DeltaOtherBytes);
      v223 = gTreeViewListItemParam_123->DeltaReadBytes;
      liParam.HighPart = LODWORD(gTreeViewListItemParam_123->DeltaReadBytes) + v222;
      LODWORD(v224) = v223 + v222;
      HIDWORD(v343) = (__PAIR__(v221, v223) + __PAIR__(HIDWORD(gTreeViewListItemParam_123->DeltaReadBytes), v222)) >> 32;
      HIDWORD(v224) = HIDWORD(v343);
      if ( v224 >= gTreeViewListItemParam_123->pGraphDataPROCCPU->m_dbMemorySize )
      {
        v225 = __PAIR__(HIDWORD(v343), liParam.HighPart);
        gTreeViewListItemParam_123->pGraphDataPROCCPU->m_dbMemorySize = (v225 * 1.2);
        gTreeViewListItemParam_123->pGraphDataPROCCPU->m_Item[0].dbMemorySize = gTreeViewListItemParam_123->pGraphDataPROCCPU->m_dbMemorySize;
      }
    }
    v226 = HIDWORD(gTreeViewListItemParam_123->DeltaReadBytes);
    v227 = gTreeViewListItemParam_123->DeltaReadBytes;
    v228 = gTreeViewListItemParam_123->DeltaWriteBytes;
    *(&v343 + 1) = v228;
    ArgList_8 = v228;
    v230 = __PAIR__(v226, v227);
    v231 = HIDWORD(gTreeViewListItemParam_123->DeltaOtherBytes);
    v232 = gTreeViewListItemParam_123->DeltaOtherBytes;
    *&v230 = v230;
    *(&v343 + 1) = *&v230 + *(&v343 + 1);
    *&v230 = __PAIR__(v231, v232);
    CGraphData_Update(
      gTreeViewListItemParam_123->pGraphDataPROCCPU,
      gTimeQuerySystemInfo,
      (*(&v343 + 1) + *&v230),
      ArgList_8,
      0);
    sub_FB47C0(gTreeList_Item, gTreeViewListItemParam_123, &gTreeViewListItemParam_123->ReadOperationCount);
    sub_FB47C0(&gTreeList_Item[1].field_0, gTreeViewListItemParam_123, &gTreeViewListItemParam_123->field_430);
    sub_FB47C0(&gTreeList_Item[2].field_0, gTreeViewListItemParam_123, &gTreeViewListItemParam_123->field_498);
    v233 = RedrawColumn(1, ghWndTreeListView, IDS_IO_HISTORY, Item.iItem);
    LOBYTE(v372) = v233 | v372;
    if ( gTreeViewListItemParam_123->pNetCclrInfo && !v370 )
    {
      dynamic_initializer_for_gPerformanceInfoInMemory__();
      v370 = 1;
    }
    v234 = sub_FCC540(gTreeViewListItemParam_123, Item.iItem);
    LOBYTE(v372) = v234 | v372;
    if ( gTreeViewListItemParam_123->dwStyle & 0x40 )
    {
      v235 = pSystemProcessInfo_118->KernelTime.QuadPart
           + pSystemProcessInfo_118->UserTime.QuadPart
           + __PAIR__(v365, v336);
      v365 = v235 >> 32;
      v336 = v235;
      v236 = __PAIR__(v354, pSystemProcessInfo_118->PagefileUsage) + v352;
      v354 = (__PAIR__(v354, pSystemProcessInfo_118->PagefileUsage) + v352) >> 32;
      v352 = v236;
      v237 = __PAIR__(v353, pSystemProcessInfo_118->WorkingSetSize) + v366;
      v353 = (__PAIR__(v353, pSystemProcessInfo_118->WorkingSetSize) + v366) >> 32;
      v366 = v237;
      ++ItemWithSizeIs50H.field_34;
      ItemWithSizeIs50H.field_3C += pSystemProcessInfo_118->NumberOfThreads;
      ItemWithSizeIs50H.field_44 += pSystemProcessInfo_118->HandleCount;
      if ( gTreeViewListItemParam_123->pNetCclrInfo )
        ++ItemWithSizeIs50H.field_4C;
    }
    RedrawColumn(1, ghWndTreeListView, IDS_PRIVATE_BYTES_HISTORY, Item.iItem);
    RedrawColumn(1, ghWndTreeListView, IDS_IO_HISTORY, Item.iItem);
    RedrawColumn(1, ghWndTreeListView, IDS_CPU_HISTORY, Item.iItem);
    v238 = gTreeViewListItemParam_123->field_18;
    v239 = 0;
    if ( v238 )
    {
      v240 = gTreeViewListItemParam_123->field_1C;
      if ( v240 < gConfig.dwHighlightDuration )
      {
        gTreeViewListItemParam_123->field_10 = 2;
        gTreeViewListItemParam_123->field_14 = v240;
        goto LABEL_259;
      }
      if ( v238 )
      {
        v239 = 1;
        LOBYTE(gTreeViewListItemParam_123->field_18) = 0;
      }
    }
    v241 = v372;
    if ( v239 )
      v241 = 1;
    gTreeViewListItemParam_123->field_10 = 0;
    LOBYTE(v372) = v241;
LABEL_259:
    if ( ProcessHandle )
      CloseHandle(ProcessHandle);
    if ( !pSystemProcessInfo_118->NextEntryOffset )
      break;
    v119 = v328;
    pSystemProcessInfo_118 = (pSystemProcessInfo_118 + pSystemProcessInfo_118->NextEntryOffset);
  }
  if ( v368 || !gConfig.bShowAllUsers )
  {
    SendMessageW = ::SendMessageW;
  }
  else
  {
    // 初始化tagTREEVIEWLISTITEMPARAM
    memset(&ItemParam, 0, sizeof(tagTREEVIEWLISTITEMPARAM));
    ItemParam.dwStyle |= 6u;
    dwProcessorIndex = 0;
    LOBYTE(ItemParam.ProcessMitigationPolicy) = -1;
    ItemParam.pNetCclrInfo = 0;
    ItemParam.m_ProcessIoPriority = -1;
    ItemParam.m_ProcessMemoryPriority = -1;
    ItemParam.m_SelectedItem = 0;
    ItemParam.field_10 = 0;
    ItemParam.dwProcessId = -10;
    if ( gSystemInfo.dwNumberOfProcessors > 0 )
    {
      v282 = &gpSystemPerformanceInfo->InterruptTime;
      v283 = &gpSystemInterruptInfo->DpcCount;
      do
      {
        v283 += 6;
        ItemParam.ContextSwtiches += *(v283 - 6) + v282[1].LowPart;
        *&ItemParam.m_CPUTime += *v282 + v282[-1].QuadPart;
        v284 = *v282 + v282[-1].QuadPart;
        v282 += 6;
        *&ItemParam.KernelTime += v284;
        v285 = (gpSystemProcessorCycleTimeInfo[dwProcessorIndex].CycleTime + ItemParam.Cycles) >> 32;
        LODWORD(ItemParam.Cycles) += LODWORD(gpSystemProcessorCycleTimeInfo[dwProcessorIndex++].CycleTime);
        HIDWORD(ItemParam.Cycles) = v285;
      }
      while ( dwProcessorIndex < gSystemInfo.dwNumberOfProcessors );
      gTreeViewListItemParam_123 = TreeViewListItemParam_328;
    }
    ItemParam.pszTitle = _wcsdup(L"Hardware Interrupts and DPCs");
    ItemParam.szProcessName2 = _wcsdup(L"Interrupts");
    ItemParam.CreateTime = gCreateTimeLast;
    ItemParam.InheritedFromUniqueProcessId = gdwProcessIdLast;
    SendMessageW = ::SendMessageW;
    ItemParam.pszSystemName = _wcsdup(L"System");
    TreeViewListItemParam_285 = ::SendMessageW(ghMainWnd, WM_MSG_7EE, gdwProcessIdSelected == 0, &ItemParam);
    TreeViewListItemParam_285->m_SelectedItem = TreeViewListItemParam_337;
  }
  if ( !gbShowProcessTreeLast
    && gConfig.dwProcessSortColumn != 1000
    && !v372
    && gConfig.dwProcessColumnMap[gConfig.dwProcessSortColumn] == 1055 )
  {
    Item.mask = LVIF_PARAM;
    Item.iItem = 1;
    Item.iSubItem = 0;
    if ( SendMessageW(hWndListCtrl_1, LVM_GETITEMW, 0, &Item) )
    {
      while ( 1 )
      {
        if ( gConfig.bProcessSortDirection )
        {
          v288 = *&gTreeViewListItemParam_123->m_CPU;
          v289 = v288 < *&Item.lParam[15].field_24;
          v290 = v288 == *&Item.lParam[15].field_24;
        }
        else
        {
          v291 = *&Item.lParam[15].field_24;
          v289 = v291 < *&gTreeViewListItemParam_123->m_CPU;
          v290 = v291 == *&gTreeViewListItemParam_123->m_CPU;
        }
        if ( !v289 && !v290 )
          break;
        ++Item.iItem;
        gTreeViewListItemParam_123 = Item.lParam;
        if ( !SendMessageW(hWndListCtrl_1, LVM_GETITEMW, 0, &Item) )
          goto LABEL_410;
      }
      LOBYTE(v372) = 1;
    }
  }
LABEL_410:
  v292 = variable_360;
  v293 = v367;
  if ( v367 | variable_360 )
  {
    v294 = (__PAIR__(v361, v359) - qword_107BC30);
    v334 = v294 * 100.0;
    v295 = __PAIR__(v367, variable_360);
    v334 = v334 / v295;
  }
  LODWORD(qword_107BC30) = v359;
  HIDWORD(qword_107BC30) = v361;
  *&ItemWithSizeIs50H.field_8 = v348;
  sub_FF7400(__PAIR__(v354, v352), 0, &v315, &v348);
  *&ItemWithSizeIs50H.field_18 = v5;
  LODWORD(qword_107BA40) = v351;
  HIDWORD(qword_107BA40) = v362;
  *&ItemWithSizeIs50H.field_28 = (__PAIR__(v353, v366) / 1024) / v348 * 100.0;
  if ( TreeViewListItemParam_336 )
  {
    v348 = 100.0 - v335;
    if ( 100.0 - v335 < 0.0 )
      v348 = 0.0;
    FindInfo.lParam = TreeViewListItemParam_336;
    FindInfo.flags = 1;
    Item.iItem = ::SendMessageW(hWndListCtrl_1, LVM_FINDITEMW, 0xFFFFFFFF, &FindInfo);
    v296 = v348 != *&TreeViewListItemParam_336->m_CPU;
    *&TreeViewListItemParam_336->m_CPU = v348;
    v297 = RedrawColumn(v296, ghWndTreeListView, IDS_CPU, Item.iItem);
    LOBYTE(v372) = v297 | v372;
    v368 = 1;
    v298 = *&TreeViewListItemParam_336->m_CPUUsage + v348;
    if ( v298 == *&TreeViewListItemParam_336->m_CPUUsage )
      v368 = 0;
    *&TreeViewListItemParam_336->m_CPUUsage = v298;
    v299 = RedrawColumn(1, ghWndTreeListView, IDS_TREE_CPU_USAGE, Item.iItem);
    LOBYTE(v372) = v299 | v372;
    v300 = RedrawColumn(v368, ghWndTreeListView, IDS_CPU_HISTORY, Item.iItem);
    LOBYTE(v372) = v300 | v372;
    CGraphData_Update(TreeViewListItemParam_336->pGraphData1, gTimeQuerySystemInfo, 0.0, v348, 0);
  }
  if ( !v372 && v346 )
  {
    v301 = ::SendMessageW(ghWndTreeListView, LVM_GETITEMCOUNT, 0, 0);
    for ( i = 0; i < v301; ++i )
      PostMessageW(ghMainWnd, WM_MSG_7EB, i, -1);
    v293 = v367;
    v292 = variable_360;
  }
  v303 = db_onehundred;
  if ( v335 <= 100.0 )
    v303 = v335;
  *&ItemWithSizeIs50H.field_0 = v303;
  sub_1000410(v5, v4, ghWndStatusBar, &ItemWithSizeIs50H, &v313, &v315);
  if ( TreeViewListItemParam_338 )
  {
    v304 = TreeViewListItemParam_338->dwProcessId;
    if ( gConfig.bShowCpuFractions )
    {
      if ( v304 <= 0 )
        wsprintfW(szBuffer, L"%02.02f%% %s", v342, TreeViewListItemParam_338->szProcessName2);
      else
        wsprintfW(
          szBuffer,
          L"%02.02f%% %s:%d",
          v342,
          TreeViewListItemParam_338->szProcessName2,
          TreeViewListItemParam_338->dwProcessId);
    }
    else if ( v304 <= 0 )
    {
      wsprintfW(szBuffer, L"%02.0f%% %s", v342, TreeViewListItemParam_338->szProcessName2);
    }
    else
    {
      wsprintfW(
        szBuffer,
        L"%02.0f%% %s:%d",
        v342,
        TreeViewListItemParam_338->szProcessName2,
        TreeViewListItemParam_338->dwProcessId);
    }
  }
  CGraphData_Update(gpGraphInfoOfCPU, gTimeQuerySystemInfo, *&ItemWithSizeIs50H.field_0, v334, szBuffer);
  if ( gdwAdapterRuntingTime )
  {
    sub_FB38F0(
      gTimeQuerySystemInfo,
      __PAIR__(v293, v292) / gSystemInfo.dwNumberOfProcessors,
      gpGraphInfoOfGPU,
      TreeViewListItemParam_327,
      dword_107BA1C,
      gpGraphInfoOfSystemMemory,
      gpGraphInfoOfDedicatedMemory);
    *(&v333 + 1) = v5;
    sub_FFFD50(gpGraphInfoOfGPU, *(&v333 + 1), TreeViewListItemParam_327, v316);
  }
  if ( gIOGraphInfo.pGraphData )
    sub_FB44A0(&gIOGraphInfo, gTreeList_Item);
  if ( gNetworkGraphInfo.pGraphData )
    sub_FB44A0(&gNetworkGraphInfo, &gTreeList_Item[1]);
  if ( gDiskGraphInfo.pGraphData )
    sub_FB44A0(&gDiskGraphInfo, &gTreeList_Item[2]);
  RedrawColumn(1, ghWndTreeListView, IDS_CPU, 0xFFFFFFFE);
  RedrawColumn(1, ghWndTreeListView, IDS_PRIVATE_BYTES, 0xFFFFFFFE);
  RedrawColumn(1, ghWndTreeListView, IDS_WORKING_SET, 0xFFFFFFFE);
  RedrawColumn(1, ghWndTreeListView, IDS_GPU2, 0xFFFFFFFE);
  sub_FFFD50(gpGraphInfoOfCPU, *&ItemWithSizeIs50H.field_0, TreeViewListItemParam_338, *&v342);
  sub_FFFCA0(gpGraphInfoOfMemory, *&v313);
  sub_1000360(gpGraphInfoOfPhysicalMemory, v315);
  ret = v372;
  if ( flags )
    ret = 1;
  HIDWORD(v333) = ret;
  if ( dword_10610C8 )
  {
    if ( gdwProcessId_0 == -1 )
    {
      ItemState.stateMask = 3;
      ItemState.state = 3;
      ::SendMessageW(ghWndTreeListView, LVM_SETITEMSTATE, 0, &ItemState);
    }
    else
    {
      item.iItem = 0;
      item.mask = LVIF_PARAM;
      item.iSubItem = 0;
      if ( ::SendMessageW(ghWndTreeListView, LVM_GETITEMCOUNT, 0, 0) > 0 )
      {
        while ( 1 )
        {
          ::SendMessageW(ghWndTreeListView, LVM_GETITEMW, 0, &item);
          if ( item.lParam->dwProcessId == gdwProcessId_0 )
            break;
          ++item.iItem;
          item.mask = 4;
          item.iSubItem = 0;
          v306 = ::SendMessageW(ghWndTreeListView, LVM_GETITEMCOUNT, 0, 0);
          if ( item.iItem >= v306 )
            goto LABEL_451;
        }
        ItemState.mask = 3;
        ItemState.state = 3;
        ::SendMessageW(ghWndTreeListView, LVM_SETITEMSTATE, item.iItem, &ItemState);
      }
    }
LABEL_451:
    LOBYTE(ret) = BYTE4(v333);
    dword_10610C8 = 0;
  }
  return ret;
}
// FFAD00: could not find valid save-restore pair for ebp
// FFAD00: could not find valid save-restore pair for edi
// 103CDC0: using guessed type double db_onehundred;
// 10444C8: using guessed type wchar_t a0202fS[13];
// 105E100: using guessed type int gdwProcessId_0;
// 10610C8: using guessed type int dword_10610C8;
// 1064E54: using guessed type int gdwVersion;
// 106B1BC: using guessed type int gdwProcessIdLast;
// 106F280: using guessed type int (__stdcall *gpfnProcessIdToSessionId)(_DWORD, _DWORD);
// 106F2F4: using guessed type int GetProcessorSystemCycleTime;
// 106F36C: using guessed type int (__stdcall *GetProcessDpiAwareness)(_DWORD, _DWORD);
// 106F374: using guessed type int gnSystemProcessInfoLengthLast;
// 106F378: using guessed type FILETIME gTimeQuerySystemInfoLast;
// 107BA1C: using guessed type int dword_107BA1C;
// 107BA40: using guessed type __int64 qword_107BA40;
// 107BA4C: using guessed type int (__stdcall *IsImmersiveProcess)(_DWORD);
// 107BA5C: using guessed type char gbWindowTextFlags;
// 107BC28: using guessed type int gbShowProcessTreeLast;
// 107BC30: using guessed type __int64 qword_107BC30;

//----- (00FFE3B0) --------------------------------------------------------
HCURSOR __cdecl sub_FFE3B0(int a1)
{
  DWORD v1; // ebx
  HWND v2; // eax
  HCURSOR result; // eax
  HCURSOR v4; // eax
  HCURSOR v5; // eax
  int v6; // ebx
  LRESULT (__stdcall *v7)(HWND, UINT, WPARAM, LPARAM); // edi
  signed int v8; // ecx
  __m128i v9; // xmm1
  char *v10; // edx
  unsigned int v11; // eax
  __m128i v12; // xmm0
  int v13; // esi
  const wchar_t *v14; // eax
  signed int v15; // esi
  int i; // edi
  int j; // esi
  const wchar_t *v18; // eax
  signed int v19; // esi
  signed int v20; // ecx
  __m128i v21; // xmm1
  char *v22; // edx
  unsigned int v23; // eax
  __m128i v24; // xmm0
  signed int k; // edi
  const wchar_t *v26; // eax
  void (__stdcall *v27)(HWND, UINT, WPARAM, LPARAM); // edi
  signed int v28; // ebx
  signed int l; // edi
  const wchar_t *v30; // eax
  LPARAM v31; // [esp+4h] [ebp-2684h]
  int v32; // [esp+Ch] [ebp-267Ch]
  wchar_t *v33; // [esp+18h] [ebp-2670h]
  int v34; // [esp+1Ch] [ebp-266Ch]
  LPARAM v35; // [esp+38h] [ebp-2650h]
  int v36; // [esp+3Ch] [ebp-264Ch]
  int v37; // [esp+40h] [ebp-2648h]
  int v38; // [esp+58h] [ebp-2630h]
  struct tagOFNW v39; // [esp+6Ch] [ebp-261Ch]
  LPARAM v40; // [esp+C4h] [ebp-25C4h]
  wchar_t *v41; // [esp+D0h] [ebp-25B8h]
  int v42; // [esp+D4h] [ebp-25B4h]
  LRESULT v43; // [esp+E4h] [ebp-25A4h]
  HCURSOR hCursor; // [esp+E8h] [ebp-25A0h]
  int v45; // [esp+ECh] [ebp-259Ch]
  LRESULT v46; // [esp+F0h] [ebp-2598h]
  HWND hWnd; // [esp+F4h] [ebp-2594h]
  FILE *File; // [esp+F8h] [ebp-2590h]
  int lParam[4]; // [esp+FCh] [ebp-258Ch]
  char v50; // [esp+10Ch] [ebp-257Ch]
  wchar_t v51; // [esp+27Ch] [ebp-240Ch]
  __int16 v52; // [esp+227Ah] [ebp-40Eh]
  wchar_t pszText; // [esp+227Ch] [ebp-40Ch]
  wchar_t Dst; // [esp+247Ch] [ebp-20Ch]
  char v55; // [esp+247Eh] [ebp-20Ah]

  Dst = 0;
  memset(&v55, 0, 0x206u);
  v1 = gdwProcessIdSelected;
  v46 = gdwProcessIdSelected;
  SystemProcessInfo_GetSystemProcessName(gdwProcessIdSelected, 0, &pszText, 0x100u);
  v2 = ghWndHandlesListCtrl;
  if ( gConfig.bShowDllView )
    v2 = ghWndDllsListCtrl;
  hWnd = v2;
  if ( !a1 && dword_10854FC )
  {
    wcscpy_s(&Dst, 0x104u, &word_1085500);
LABEL_12:
    if ( v1 != gdwProcessIdSelected )
      return MessageBoxW(ghMainWnd, L"The process has exited", L"Process Explorer", 0x10u);
    if ( _wfopen_s(&File, &Dst, L"w, ccs=UTF-8") )
    {
      wsprintfW(&v51, L"Error saving %s", &Dst);
      result = ReportMsg(&v51, ghMainWnd);
    }
    else
    {
      v4 = hInstance;
      if ( !hInstance )
      {
        v4 = LoadCursorW(hInstance, 0x7F02);
        hInstance = v4;
      }
      v5 = SetCursor(v4);
      v6 = gConfig.dwProcessColumnCount;
      v7 = SendMessageW;
      hCursor = v5;
      v41 = &v51;
      v40 = 4;
      v42 = 4096;
      if ( !SendMessageW(ghWndTreeListView, 0x103Bu, gConfig.dwProcessColumnCount, lParam) )
      {
        v8 = 0;
        if ( v6 > 0 )
        {
          if ( v6 >= 8 )
          {
            v9 = _mm_load_si128(&gIntArray);
            v10 = &v50;
            do
            {
              v11 = v8 + 4;
              v10 += 32;
              v12 = _mm_add_epi32(_mm_shuffle_epi32(_mm_cvtsi32_si128(v8), 0), v9);
              v8 += 8;
              _mm_storeu_si128(v10 - 3, v12);
              _mm_storeu_si128(v10 - 2, _mm_add_epi32(_mm_shuffle_epi32(_mm_cvtsi32_si128(v11), 0), v9));
            }
            while ( v8 < v6 - v6 % 8 );
          }
          for ( ; v8 < v6; ++v8 )
            lParam[v8] = v8;
        }
      }
      v13 = 0;
      if ( v6 > 0 )
      {
        do
        {
          SendMessageW(ghWndTreeListView, 0x105Fu, lParam[v13], &v40);
          v14 = L"\t";
          if ( v13 == v6 - 1 )
            v14 = L"\n";
          fwprintf(File, L"%s%s", v41, v14);
          ++v13;
        }
        while ( v13 < v6 );
        v7 = SendMessageW;
      }
      v15 = 0;
      v43 = v7(ghWndTreeListView, 0x1004u, 0, 0);
      v45 = 0;
      if ( v43 > 0 )
      {
        do
        {
          v35 = 4;
          v51 = 0;
          v37 = 0;
          v36 = v15;
          v7(ghWndTreeListView, 0x104Bu, 0, &v35);
          for ( i = 0; i < v6; ++i )
          {
            v34 = 4096;
            v51 = 0;
            v32 = lParam[i];
            v33 = &v51;
            SendMessageW(ghWndTreeListView, 0x1073u, v15, &v31);
            v52 = 0;
            if ( !i && gConfig.bShowProcessTree )
            {
              for ( j = 0; j < *(v38 + 80); ++j )
                fwprintf(File, L" ");
              v15 = v45;
            }
            v18 = L"\t";
            if ( i == v6 - 1 )
              v18 = L"\n";
            fwprintf(File, L"%s%s", &v51, v18);
          }
          v7 = SendMessageW;
          v45 = ++v15;
        }
        while ( v15 < v43 );
      }
      fwprintf(File, L"\n");
      if ( v46 == gdwProcessIdSelected )
      {
        if ( gConfig.bShowLowerPane && (gdwProcessIdSelected & 0x80000000) == 0 )
        {
          fwprintf(File, L"Process: %s Pid: %d\n\n", &pszText, gdwProcessIdSelected);
          v19 = gConfig.dwHandleColumnCount;
          if ( gConfig.bShowDllView )
            v19 = gConfig.dwDllColumnCount;
          if ( !v7(hWnd, 0x103Bu, v19, lParam) )
          {
            v20 = 0;
            if ( v19 > 0 )
            {
              if ( v19 >= 8 )
              {
                v21 = _mm_load_si128(&gIntArray);
                v22 = &v50;
                do
                {
                  v23 = v20 + 4;
                  v22 += 32;
                  v24 = _mm_add_epi32(_mm_shuffle_epi32(_mm_cvtsi32_si128(v20), 0), v21);
                  v20 += 8;
                  _mm_storeu_si128(v22 - 3, v24);
                  _mm_storeu_si128(v22 - 2, _mm_add_epi32(_mm_shuffle_epi32(_mm_cvtsi32_si128(v23), 0), v21));
                }
                while ( v20 < v19 - v19 % 8 );
              }
              for ( ; v20 < v19; ++v20 )
                lParam[v20] = v20;
            }
          }
          for ( k = 0; k < v19; ++k )
          {
            SendMessageW(hWnd, 0x105Fu, lParam[k], &v40);
            v26 = L"\t";
            if ( k == v19 - 1 )
              v26 = L"\n";
            fwprintf(File, L"%s%s", v41, v26);
          }
          v27 = SendMessageW;
          v28 = 0;
          v46 = SendMessageW(hWnd, 0x1004u, 0, 0);
          if ( v46 > 0 )
          {
            do
            {
              v35 = 4;
              v51 = 0;
              v37 = 0;
              v36 = v28;
              v27(hWnd, 0x104Bu, 0, &v35);
              for ( l = 0; l < v19; ++l )
              {
                v34 = 4096;
                v51 = 0;
                v32 = lParam[l];
                v33 = &v51;
                SendMessageW(hWnd, 0x1073u, v28, &v31);
                v52 = 0;
                v30 = L"\t";
                if ( l == v19 - 1 )
                  v30 = L"\n";
                fwprintf(File, L"%s%s", &v51, v30);
              }
              v27 = SendMessageW;
              ++v28;
            }
            while ( v28 < v46 );
          }
        }
      }
      else
      {
        MessageBoxW(ghMainWnd, L"The process has exited", L"Process Explorer", 0x10u);
      }
      fclose(File);
      wcscpy_s(&word_1085500, 0x104u, &Dst);
      dword_10854FC = 1;
      result = SetCursor(hCursor);
    }
    return result;
  }
  if ( pszText == 60 )
    wcscpy_s(&pszText, 0x100u, L"Procexp");
  if ( word_1085500 )
    wcscpy_s(&Dst, 0x104u, &word_1085500);
  else
    swprintf(&Dst, L"%s.txt", &pszText);
  v39.hwndOwner = ghMainWnd;
  v39.hInstance = ghInstance;
  v39.lpstrFile = &Dst;
  *&v39.nFileOffset = 0;
  v39.lpfnHook = 0;
  v39.lStructSize = 76;
  v39.lpstrCustomFilter = 0;
  v39.nMaxCustFilter = 0;
  v39.nFilterIndex = 1;
  v39.nMaxFile = 256;
  v39.lpstrFileTitle = 0;
  v39.nMaxFileTitle = 0;
  v39.lpstrInitialDir = 0;
  v39.Flags = 2097156;
  v39.lpstrTitle = L"Save Process Explorer Data...";
  v39.lpstrDefExt = L"*.txt";
  v39.lpstrFilter = L"Process Explorer Data (*.TXT)";
  result = GetSaveFileNameW(&v39);
  if ( result )
    goto LABEL_12;
  return result;
}
// 103EA50: using guessed type RECT gIntArray;
// 1046A18: using guessed type wchar_t aSaveProcessExp[30];
// 1046A54: using guessed type wchar_t aTxt[6];
// 1046A60: using guessed type wchar_t aProcessExplore_11[30];
// 10854FC: using guessed type int dword_10854FC;
// FFE3B0: using guessed type LPARAM lParam[4];

//----- (00FFEB40) --------------------------------------------------------
HCURSOR __cdecl SaveProcessStrings(HWND hWnd, LPCWSTR lpszFileName)
{
  HCURSOR result; // eax
  HCURSOR v3; // eax
  LRESULT nCount; // ebx
  signed int i; // esi
  LVITEMW ItemText; // [esp+8h] [ebp-22D8h]
  LVITEMW Item; // [esp+3Ch] [ebp-22A4h]
  struct tagOFNW OpenFileName; // [esp+70h] [ebp-2270h]
  HWND hWndIn; // [esp+C8h] [ebp-2218h]
  HCURSOR hCursor; // [esp+CCh] [ebp-2214h]
  FILE *pFile; // [esp+D0h] [ebp-2210h]
  WCHAR szBuffer[4096]; // [esp+D4h] [ebp-220Ch]
  WCHAR szFileName[260]; // [esp+20D4h] [ebp-20Ch]

  szFileName[0] = 0;
  hWndIn = hWnd;
  memset(&szFileName[1], 0, 0x206u);
  swprintf(szFileName, L"%s.txt", lpszFileName);
  OpenFileName.hwndOwner = ghMainWnd;
  OpenFileName.hInstance = ghInstance;
  OpenFileName.lpstrFile = szFileName;
  *&OpenFileName.nFileOffset = 0;
  OpenFileName.lpfnHook = 0;
  OpenFileName.lStructSize = sizeof(tagOFNW);
  OpenFileName.lpstrCustomFilter = 0;
  OpenFileName.nMaxCustFilter = 0;
  OpenFileName.nFilterIndex = 1;
  OpenFileName.nMaxFile = 256;
  OpenFileName.lpstrFileTitle = 0;
  OpenFileName.nMaxFileTitle = 0;
  OpenFileName.lpstrInitialDir = 0;
  OpenFileName.Flags = 0x200004;
  OpenFileName.lpstrTitle = L"Save Process Explorer Strings...";
  OpenFileName.lpstrDefExt = L"*.txt";
  OpenFileName.lpstrFilter = L"Process Explorer Strings (*.TXT)";
  result = GetSaveFileNameW(&OpenFileName);
  if ( result )
  {
    if ( _wfopen_s(&pFile, szFileName, L"w, ccs=UTF-8") )
    {
      wsprintfW(szBuffer, L"Error saving %s", szFileName);
      result = ReportMsg(szBuffer, ghMainWnd);
    }
    else
    {
      v3 = shWaitCursor;
      if ( !shWaitCursor )
      {
        v3 = LoadCursorW(shWaitCursor, IDC_WAIT);
        shWaitCursor = v3;
      }
      hCursor = SetCursor(v3);
      nCount = SendMessageW(hWnd, LVM_GETITEMCOUNT, 0, 0);
      for ( i = 0; i < nCount; ++i )
      {
        Item.mask = 4;
        szBuffer[0] = 0;
        Item.iSubItem = 0;
        Item.iItem = i;
        SendMessageW(ghWndTreeListView, LVM_GETITEMW, 0, &Item);
        ItemText.cchTextMax = 4096;
        szBuffer[0] = 0;
        ItemText.iSubItem = 0;
        ItemText.pszText = szBuffer;
        SendMessageW(hWndIn, LVM_GETITEMTEXTW, i, &ItemText);
        szBuffer[4095] = 0;
        fwprintf(pFile, L"%s\n", szBuffer);
      }
      fclose(pFile);
      result = SetCursor(hCursor);
    }
  }
  return result;
}
// 1046A54: using guessed type wchar_t aTxt[6];
// 1046B60: using guessed type wchar_t aSaveProcessExp_0[33];
// 1046BA8: using guessed type wchar_t aProcessExplore_12[33];

//----- (00FFEDC0) --------------------------------------------------------
BOOL __stdcall sub_FFEDC0(HWND hDlg, UINT ProcessAffinityMask, WPARAM SystemAffinityMask, LPARAM hProcess)
{
  unsigned int v5; // edi
  signed int v6; // esi
  unsigned int v7; // edi
  signed int v8; // esi
  DWORD v9; // esi
  HWND v10; // eax

  if ( ProcessAffinityMask == 272 )
  {
    ghProcess = hProcess;
    if ( GetProcessAffinityMask(hProcess, &ProcessAffinityMask, &SystemAffinityMask) )
    {
      v7 = 0;
      v8 = 1;
      do
      {
        if ( v8 & ProcessAffinityMask )
          CheckDlgButton(hDlg, v7 + 2000, 1u);
        ++v7;
        v8 = __ROL4__(v8, 1);
      }
      while ( v7 < 0x3F );
      v9 = 63;
      if ( gSystemInfo.dwNumberOfProcessors <= 0x3F )
      {
        do
        {
          v10 = GetDlgItem(hDlg, v9 + 2000);
          EnableWindow(v10, 0);
          --v9;
        }
        while ( v9 >= gSystemInfo.dwNumberOfProcessors );
      }
      return 1;
    }
    ReportMsg(L"Error retrieving process affinity", hDlg);
    EndDialog(hDlg, 0);
    return 0;
  }
  if ( ProcessAffinityMask != 273 )
    return 0;
  if ( SystemAffinityMask == 1 )
  {
    v5 = 0;
    ProcessAffinityMask = 0;
    v6 = 1;
    do
    {
      if ( IsDlgButtonChecked(hDlg, v5 + 2000) == 1 )
        ProcessAffinityMask |= v6;
      ++v5;
      v6 = __ROL4__(v6, 1);
    }
    while ( v5 < 0x1F );
    if ( !SetProcessAffinityMask(ghProcess, ProcessAffinityMask) )
      ReportMsg(L"Error setting affinity", hDlg);
  }
  else if ( SystemAffinityMask != 2 )
  {
    return 0;
  }
  EndDialog(hDlg, 0);
  return 1;
}
// 1046708: using guessed type wchar_t aErrorRetrievin[34];
// 104674C: using guessed type wchar_t aErrorSettingAf[23];

//----- (00FFEF00) --------------------------------------------------------
int __cdecl sub_FFEF00(HMENU hmenu, int a2)
{
  int result; // eax

  result = a2;
  switch ( a2 )
  {
    case 0:
      result = CheckMenuRadioItem(hmenu, 0x9CBBu, 0x9CC1u, 0x9CBCu, 0);
      break;
    case 1:
    case 2:
    case 3:
    case 4:
      result = CheckMenuRadioItem(hmenu, 0x9CBBu, 0x9CC1u, 0x9CBBu, 0);
      break;
    case 5:
    case 6:
      result = CheckMenuRadioItem(hmenu, 0x9CBBu, 0x9CC1u, 0x9CBDu, 0);
      break;
    case 7:
    case 8:
    case 9:
      result = CheckMenuRadioItem(hmenu, 0x9CBBu, 0x9CC1u, 0x9CBEu, 0);
      break;
    case 10:
    case 11:
      result = CheckMenuRadioItem(hmenu, 0x9CBBu, 0x9CC1u, 0x9CBFu, 0);
      break;
    case 12:
    case 13:
    case 14:
    case 15:
      result = CheckMenuRadioItem(hmenu, 0x9CBBu, 0x9CC1u, 0x9CC0u, 0);
      break;
    case 24:
      result = CheckMenuRadioItem(hmenu, 0x9CBBu, 0x9CC1u, 0x9CC1u, 0);
      break;
    default:
      return result;
  }
  return result;
}

//----- (00FFEFB0) --------------------------------------------------------
int __cdecl sub_FFEFB0(int a1)
{
  int v1; // ebx
  DWORD v3; // eax
  unsigned int v4; // ecx
  int v5; // ecx
  DWORD v6; // edi
  DWORD v7; // edx
  int v8; // ecx
  DWORD v9; // edi
  DWORD v10; // edx

  v1 = pdwValue3;
  if ( a1 > pdwValue3 )
  {
    QueryTagInformationEx(&ppv, 0, &pdwValue3, &pdwValue4);
    v1 = pdwValue3;
    if ( a1 > pdwValue3 )
      return 0;
  }
  if ( gdwVersion < 2 )
    v3 = pdwValue4 + 12 * (a1 - 1);
  else
    v3 = pdwValue4 + 16 * a1 - 16;
  v4 = *(v3 + 4);
  if ( v4 <= a1 )
  {
    if ( v4 < a1 )
    {
      v8 = a1 - 1;
      if ( a1 - 1 < v1 )
      {
        v9 = pdwValue4 + 12 * v8;
        v10 = pdwValue4 + 16 * v8;
        do
        {
          v3 = v9;
          if ( gdwVersion >= 2 )
            v3 = v10;
          if ( *(v3 + 4) == a1 )
            break;
          ++v8;
          v10 += 16;
          v9 += 12;
        }
        while ( v8 < v1 );
      }
    }
  }
  else
  {
    v5 = a1 - 1;
    if ( a1 - 1 > 0 )
    {
      v6 = pdwValue4 + 12 * v5;
      v7 = pdwValue4 + 16 * v5;
      while ( 1 )
      {
        v3 = v6;
        if ( gdwVersion >= 2 )
          v3 = v7;
        if ( *(v3 + 4) == a1 )
          break;
        --v5;
        v7 -= 16;
        v6 -= 12;
        if ( v5 <= 0 )
          return *(v3 + 8);
      }
    }
  }
  return *(v3 + 8);
}
// 1064E54: using guessed type int gdwVersion;

//----- (00FFF0A0) --------------------------------------------------------
_DWORD *__cdecl sub_FFF0A0(unsigned __int8 a1, int a2, _DWORD *a3)
{
  _DWORD *v3; // edi
  int i; // esi
  signed int v5; // eax
  SYSTEM_PROCESS_INFORMATION *v6; // eax
  DWORD v7; // eax
  SYSTEM_PROCESS_INFORMATION *ppSystemProcessInfo; // [esp+Ch] [ebp-4h]

  *a3 = 0;
  ppSystemProcessInfo = 0;
  GetSystemProcessInfo(&ppSystemProcessInfo, 0);
  v3 = a3;
  for ( i = 0; ; ++i )
  {
    v5 = NtSuspendProcess ? 1 : a1 + 1;
    if ( i >= v5 )
      break;
    v3 = 87;
    v6 = ppSystemProcessInfo;
    if ( ppSystemProcessInfo->UniqueProcessId == a2 )
    {
LABEL_9:
      v7 = sub_FF06C0(a1, v6, i);
      v3 = v7;
      if ( !v7 || !i && v7 == 1904 )
      {
        *a3 = 1;
        goto LABEL_17;
      }
    }
    else
    {
      while ( v6->NextEntryOffset )
      {
        v6 = (v6 + v6->NextEntryOffset);
        if ( v6->UniqueProcessId == a2 )
          goto LABEL_9;
      }
    }
    if ( !*a3 )
      break;
LABEL_17:
    if ( a1 )
      Sleep(0x64u);
  }
  free(ppSystemProcessInfo);
  if ( *a3 )
    v3 = 0;
  return v3;
}

//----- (00FFF170) --------------------------------------------------------
bool __cdecl LoadDbgHelp(LPCWSTR lpLibFileName)
{
  HMODULE v1; // esi
  FARPROC v2; // eax
  int (__stdcall *v3)(HANDLE, HANDLE, PCWSTR, PCWSTR, DWORD64, DWORD, PMODLOAD_DATA, DWORD); // ecx
  int (__stdcall *v4)(HANDLE, PCSTR, BOOL); // eax
  bool v5; // zf

  v1 = LoadLibraryW(lpLibFileName);
  SymInitialize = GetProcAddress(v1, "SymInitialize");
  *EnumerateLoadedModulesW64 = GetProcAddress(v1, "EnumerateLoadedModulesW64");
  *SymRegisterCallback64 = GetProcAddress(v1, "SymRegisterCallback64");
  *SymGetModuleInfoW64 = GetProcAddress(v1, "SymGetModuleInfoW64");
  SymCleanup = GetProcAddress(v1, "SymCleanup");
  *SymFromAddrW = GetProcAddress(v1, "SymFromAddrW");
  SymGetSymFromName = GetProcAddress(v1, "SymGetSymFromName");
  MiniDumpWriteDump = GetProcAddress(v1, "MiniDumpWriteDump");
  SymSetOptions = GetProcAddress(v1, "SymSetOptions");
  *SymGetOptions = GetProcAddress(v1, "SymGetOptions");
  *SymLoadModuleExW = GetProcAddress(v1, "SymLoadModuleExW");
  if ( *SymLoadModuleExW )
  {
    SymLoadModuleExW_1 = SymLoadModuleExW_0;
  }
  else
  {
    v2 = GetProcAddress(v1, "SymLoadModule64");
    v3 = 0;
    *SymLoadModule64 = v2;
    if ( v2 )
      v3 = sub_FF08E0;
    SymLoadModuleExW_1 = v3;
  }
  *SymUnloadModule64 = GetProcAddress(v1, "SymUnloadModule64");
  *ImageNtHeader = GetProcAddress(v1, "ImageNtHeader");
  *StackWalk64 = GetProcAddress(v1, "StackWalk64");
  *SymGetModuleBase64 = GetProcAddress(v1, "SymGetModuleBase64");
  *SymFunctionTableAccess64 = GetProcAddress(v1, "SymFunctionTableAccess64");
  if ( LOBYTE(gConfig.bSymbolWarningShown) )
    goto LABEL_9;
  v4 = SymInitialize;
  v5 = SymInitialize == 0;
  if ( SymInitialize )
  {
    if ( !gConfig.strNtSymbolPath[0] )
    {
LABEL_10:
      v5 = v4 == 0;
      return !v5;
    }
LABEL_9:
    SetEnvironmentVariableW(L"_NT_SYMBOL_PATH", gConfig.strNtSymbolPath);
    v4 = SymInitialize;
    goto LABEL_10;
  }
  return !v5;
}

//----- (00FFF2C0) --------------------------------------------------------
BOOL __stdcall SysinfoPropSheet(HWND hDlg, UINT uMsg, WPARAM wParamIn, LPARAM lParamIn)
{
  HWND v4; // eax
  LRESULT v5; // ST14_4
  HWND v6; // eax
  int v7; // eax
  HWND v8; // eax
  CResizer *v9; // eax
  CResizer *v10; // esi
  HWND v11; // eax
  char v12; // al
  const wchar_t *TemplateName1; // ecx
  const wchar_t *v14; // eax
  bool v15; // zf
  const wchar_t *v16; // ecx
  const wchar_t *v17; // eax
  HWND v18; // eax
  HWND v19; // ebx
  LONG v20; // eax
  LONG v21; // eax
  HWND hWndTab_1; // edi
  void (__stdcall *SendMessageW)(HWND, UINT, WPARAM, LPARAM); // ecx
  const WCHAR **v24; // ebx
  WPARAM nTab; // edx
  LPARAM v26; // eax
  const WCHAR *v27; // esi
  WCHAR *v28; // eax
  HWND v29; // edi
  HWND v30; // ebx
  HWND v32; // eax
  signed int v33; // esi
  HWND v34; // eax
  HWND v35; // eax
  LRESULT nTabCount; // esi
  HWND v37; // eax
  LRESULT nCurTab; // edi
  HWND hWndTab; // eax
  HWND v40; // eax
  HWND v41; // eax
  NMHDR nmhdr; // [esp+Ch] [ebp-98h]
  HWND hWnd; // [esp+18h] [ebp-8Ch]
  TCITEMW Item; // [esp+1Ch] [ebp-88h]
  WPARAM wParam; // [esp+38h] [ebp-6Ch]
  HWND hDlg_1; // [esp+3Ch] [ebp-68h]
  LPARAM lParam_1; // [esp+40h] [ebp-64h]
  struct tagRECT Rect; // [esp+44h] [ebp-60h]
  struct tagRECT rcTab; // [esp+54h] [ebp-50h]
  SYSINFOPAGEITEM Pages[5]; // [esp+64h] [ebp-40h]

  lParam_1 = lParamIn;
  hDlg_1 = hDlg;
  if ( uMsg > WM_INITDIALOG )
  {
    if ( uMsg == WM_COMMAND )
    {
      if ( wParamIn > IDM_VIEW_REFRESH_NOW )
      {
        switch ( wParamIn )
        {
          case 40018u:
          case 40019u:
          case 40020u:
          case 40021u:
          case 40022u:
          case 40023u:
            PostMessageW(ghMainWnd, WM_COMMAND, wParamIn, lParamIn);
            break;
          case 40092u:
          case 40093u:
            v35 = GetDlgItem(hDlg, IDC_SYSINFO_PROPSHEET_TAB);
            nTabCount = ::SendMessageW(v35, TCM_GETITEMCOUNT, 0, 0);
            v37 = GetDlgItem(hDlg_1, IDC_SYSINFO_PROPSHEET_TAB);
            nCurTab = ::SendMessageW(v37, TCM_GETCURSEL, 0, 0);
            hWndTab = GetDlgItem(hDlg_1, IDC_SYSINFO_PROPSHEET_TAB);
            ::SendMessageW(hWndTab, TCM_SETCURSEL, (nTabCount + nCurTab + 2 * (wParamIn == 40092) - 1) % nTabCount, 0);
            Item.mask = TCIF_PARAM;
            Item.lParam = 0;
            v40 = GetDlgItem(hDlg_1, IDC_SYSINFO_PROPSHEET_TAB);
            ::SendMessageW(v40, TCM_GETITEMW, nCurTab, &Item);
            ShowWindow(Item.lParam, 0);
            v41 = GetDlgItem(hDlg_1, IDC_SYSINFO_PROPSHEET_TAB);
            ::SendMessageW(v41, TCM_GETITEMW, (nTabCount + nCurTab + 2 * (wParamIn == 40092) - 1) % nTabCount, &Item);
            ShowWindow(Item.lParam, SW_SHOW);
            break;
          default:
            return 0;
        }
      }
      else if ( wParamIn == IDM_VIEW_REFRESH_NOW )
      {
        SetEvent(ghRefreshEventHandle);
      }
      else if ( wParamIn > 0 && (wParamIn <= 2 || wParamIn == IDM_FILE_EXIT) )
      {
        ::SendMessageW(hDlg, WM_CLOSE, 0, 0);
      }
    }
    else if ( uMsg == WM_TIMER )
    {
      v32 = GetDlgItem(hDlg, IDC_SYSINFO_PROPSHEET_TAB);
      v33 = 0;
      lParam_1 = ::SendMessageW(v32, TCM_GETITEMCOUNT, 0, 0);
      if ( lParam_1 > 0 )
      {
        do
        {
          Item.mask = TCIF_PARAM;
          Item.lParam = 0;
          v34 = GetDlgItem(hDlg, IDC_SYSINFO_PROPSHEET_TAB);
          ::SendMessageW(v34, TCM_GETITEMW, v33, &Item);
          ::SendMessageW(Item.lParam, WM_TIMER, 0, 0);
          ++v33;
        }
        while ( v33 < lParam_1 );
      }
    }
    return 0;
  }
  if ( uMsg != WM_INITDIALOG )
  {
    if ( uMsg == WM_DESTROY )
    {
      GetWindowPlacement(hDlg, &gConfig.WindowPlacement[4]);
      v8 = GetDlgItem(hDlg, IDC_SYSINFO_PROPSHEET_TAB);
      gConfig.dwDefaultSysInfoPage = ::SendMessageW(v8, TCM_GETCURSEL, 0, 0);
      EnterCriticalSection(&gSysInfoPropSheetLock);
      ghWndSysinfoPropSheet = 0;
      LeaveCriticalSection(&gSysInfoPropSheetLock);
      _endthread();
    }
    if ( uMsg == WM_CLOSE )
    {
      DestroyWindow(hDlg);
    }
    else if ( uMsg == WM_NOTIFY && (*(lParamIn + 8) + 552) <= 1 )
    {
      v4 = GetDlgItem(hDlg, IDC_SYSINFO_PROPSHEET_TAB);
      Item.mask = 8;
      v5 = ::SendMessageW(v4, TCM_GETCURSEL, 0, 0);
      Item.lParam = 0;
      v6 = GetDlgItem(hDlg, IDC_SYSINFO_PROPSHEET_TAB);
      ::SendMessageW(v6, TCM_GETITEMW, v5, &Item);
      v7 = 0;
      if ( *(lParam_1 + 8) == -551 )
        v7 = 5;
      ShowWindow(Item.lParam, v7);
    }
    return 0;
  }
  v9 = operator new(0x40u);
  if ( v9 )
    CResizer::CResizer(v9, hDlg);
  v10 = operator new(0x40u);
  if ( v10 )
  {
    v11 = GetDlgItem(hDlg, IDC_SYSINFO_PROPSHEET_TAB);
    CResizer::CResizer(v10, v11);
  }
  Pages[0].szText = L"Summary";
  Pages[0].DlgProc = PropSummary;
  v12 = IsBuiltinAdministrative();
  Pages[1].szText = L"CPU";
  Pages[1].DlgProc = PropSystemInfoSumETW;
  TemplateName1 = L"SYSTEMINFOSUMETW";
  Pages[1].szTemplateName = L"SYSTEMINFOCPU";
  if ( !v12 )
    TemplateName1 = L"SYSTEMINFOSUM";
  Pages[2].szText = L"Memory";
  v14 = L"SYSTEMINFOMEM";
  Pages[0].szTemplateName = TemplateName1;
  if ( gdwVersion < 1 )
    v14 = L"SYSTEMINFOMEMXP";
  Pages[2].DlgProc = PropSystemInfoMem;
  Pages[2].szTemplateName = v14;
  Pages[3].szText = L"I/O";
  Pages[3].DlgProc = PropSystemInfoIO;
  v15 = IsBuiltinAdministrative() == 0;
  Pages[4].szText = L"GPU";
  Pages[4].DlgProc = PropSystemInfoGPU;
  v16 = L"SYSTEMINFOIOETW";
  v17 = L"SYSTEMINFOGPU";
  if ( v15 )
    v16 = L"SYSTEMINFOIO";
  Pages[3].szTemplateName = v16;
  if ( gdwAdapterRuntingTime <= 0 )
    v17 = 0;
  Pages[4].szTemplateName = v17;
  v18 = GetDlgItem(hDlg, IDC_SYSINFO_PROPSHEET_TAB);
  v19 = v18;
  hWnd = v18;
  v20 = GetWindowLongW(v18, -20);
  SetWindowLongW(v19, -20, v20 | 0x10000);
  v21 = GetWindowLongW(v19, -16);
  hWndTab_1 = v19;
  SetWindowLongW(v19, -16, v21 | 0x2000000);
  SendMessageW = ::SendMessageW;
  v24 = &Pages[0].szTemplateName;
  nTab = 0;
  v26 = 5;
  wParam = 0;
  lParam_1 = 5;
  do
  {
    v27 = *v24;
    if ( *v24 )
    {
      v28 = *(v24 - 2);
      _mm_storeu_si128(&Item.dwState, 0i64);
      Item.pszText = v28;
      *&Item.iImage = 0i64;
      Item.mask = 1;
      SendMessageW(hWndTab_1, TCM_INSERTITEMW, nTab, &Item);
      GetClientRect(hWndTab_1, &rcTab);
      ::SendMessageW(hWndTab_1, TCM_ADJUSTRECT, 0, &rcTab);
      v29 = CreateDialogParamW(ghInstance, v27, hWndTab_1, *(v24 - 1), 0);
      MoveWindow(v29, rcTab.left, rcTab.top, rcTab.right - rcTab.left, rcTab.bottom - rcTab.top, 1);
      ShowWindow(v29, 0);
      Item.lParam = v29;
      hWndTab_1 = hWnd;
      Item.mask = TCIF_PARAM;
      ::SendMessageW(hWnd, TCM_SETITEMW, wParam, &Item);
      v26 = lParam_1;
      nTab = wParam + 1;
      SendMessageW = ::SendMessageW;
      ++wParam;
    }
    v24 += 3;
    lParam_1 = --v26;
  }
  while ( v26 );
  SendMessageW(hWndTab_1, TCM_SETCURSEL, gConfig.dwDefaultSysInfoPage, 0);
  v30 = hDlg_1;
  nmhdr.idFrom = IDC_SYSINFO_PROPSHEET_TAB;
  nmhdr.code = TCN_SELCHANGE;
  ::SendMessageW(hDlg_1, WM_NOTIFY, 0, &nmhdr);
  if ( gConfig.WindowPlacement[4].rcNormalPosition.right )
    _mm_storeu_si128(&Rect, _mm_loadu_si128(&gConfig.WindowPlacement[4].rcNormalPosition));
  else
    GetWindowRect(v30, &Rect);
  gConfig.WindowPlacement[4].showCmd = 5;
  SetWindowPlacement(v30, &gConfig.WindowPlacement[4]);
  if ( gConfig.bAlwaysOntop )
    SetWindowPos(v30, HWND_MESSAGE|0x2, 0, 0, 0, 0, SWP_NOMOVE|SWP_NOSIZE);
  return 1;
}
// 100A009: using guessed type int _endthread(void);
// 10467DC: using guessed type wchar_t aSummary[8];
// 10467EC: using guessed type wchar_t aSysteminfosume[17];
// 1046810: using guessed type wchar_t aSysteminfosum[14];
// 104682C: using guessed type wchar_t aCpu_0[4];
// 1046834: using guessed type wchar_t aSysteminfocpu[14];
// 1046850: using guessed type wchar_t aMemory[7];
// 1046860: using guessed type wchar_t aSysteminfomem[14];
// 104687C: using guessed type wchar_t aSysteminfomemx[16];
// 104689C: using guessed type wchar_t aIO_0[4];
// 10468A4: using guessed type wchar_t aSysteminfoioet[16];
// 10468C4: using guessed type wchar_t aSysteminfoio[13];
// 10468E0: using guessed type wchar_t aGpu_0[4];
// 10468E8: using guessed type wchar_t aSysteminfogpu[14];
// 1064E54: using guessed type int gdwVersion;

//----- (00FFF8F0) --------------------------------------------------------
bool __cdecl sub_FFF8F0(double a1, double *a2)
{
  bool result; // al

  result = a1 != *a2;
  *a2 = a1;
  return result;
}

//----- (00FFF920) --------------------------------------------------------
char __cdecl sub_FFF920(int a1, int a2, _DWORD *a3)
{
  char result; // al

  if ( a1 != *a3 || a2 != a3[1] )
  {
    *a3 = a1;
    a3[1] = a2;
    result = 1;
  }
  else
  {
    *a3 = a1;
    a3[1] = a2;
    result = 0;
  }
  return result;
}

//----- (00FFF950) --------------------------------------------------------
void __cdecl VerifyImageThreadProc(tagTREEVIEWLISTITEMPARAM *pItemParam)
{
  VerifyImage(pItemParam, 1);
  if ( pItemParam->nListType )
    DLLLISTITEMPARAM_Release(pItemParam);
  else
    TreeViewListItemParam_Release(pItemParam);
}

//----- (00FFF980) --------------------------------------------------------
int __thiscall ATL::CComCriticalSection::Init(LPCRITICAL_SECTION lpCriticalSection)
{
  int result; // eax

  if ( InitializeCriticalSectionAndSpinCount(lpCriticalSection, 0) )
    return 0;
  result = GetLastError();
  if ( result > 0 )
    result = result | 0x80070000;
  return result;
}

//----- (00FFF9B0) --------------------------------------------------------
int sub_FFF9B0(wchar_t *DstBuf, size_t MaxCount, wchar_t *Format, ...)
{
  va_list ArgList; // [esp+14h] [ebp+14h]

  va_start(ArgList, Format);
  return _vsnwprintf_s(DstBuf, 0x100u, MaxCount, Format, ArgList);
}

//----- (00FFF9D0) --------------------------------------------------------
LRESULT __cdecl CMainWnd::InitStatusBar(HWND hWnd)
{
  HWND v1; // edx
  WPARAM wParam; // ecx
  signed int dwMaxCount; // edi
  signed int dwFlags; // esi
  int v5; // eax
  int nID[32]; // [esp+10h] [ebp-84h]

  v1 = hWnd;
  wParam = 0;
  dwMaxCount = 32;
  gnStatusBarItemCount = 0;
  dwFlags = 1;
  do
  {
    if ( dwFlags & gConfig.dwStatusBarColumns )
    {
      nID[wParam] = 10 * (wParam + 1);
      SendMessageW(v1, SB_SETTEXTW, wParam, gszStatusBarText);
      v1 = hWnd;
      wParam = gnStatusBarItemCount++ + 1;
    }
    dwFlags = __ROL4__(dwFlags, 1);
    --dwMaxCount;
  }
  while ( dwMaxCount );
  SendMessageW(v1, SB_SETTEXTW, wParam, gszStatusBarText);
  v5 = gnStatusBarItemCount;
  nID[gnStatusBarItemCount] = -1;
  gnStatusBarItemCount = v5 + 1;
  return SendMessageW(ghWndStatusBar, SB_SETPARTS, v5 + 1, nID);
}
// 1085720: using guessed type int gnStatusBarItemCount;
// FFF9D0: using guessed type LPARAM nID[32];

//----- (00FFFA90) --------------------------------------------------------
int __cdecl sub_FFFA90(int a1, int a2)
{
  unsigned int v2; // eax
  WCHAR Buffer; // [esp+4h] [ebp-804h]

  v2 = *(a2 + 4);
  if ( v2 <= 0x9EC3 )
  {
    if ( v2 == 40643 )
    {
      LoadStringW(ghInstance, 0x25u, &Buffer, 1024);
    }
    else
    {
      switch ( v2 )
      {
        case 0x9C42u:
          LoadStringW(ghInstance, 0x29u, &Buffer, 1024);
          break;
        case 0x9C47u:
          LoadStringW(ghInstance, 0x1Bu, &Buffer, 1024);
          break;
        case 0x9C49u:
          LoadStringW(ghInstance, 0x1Fu, &Buffer, 1024);
          break;
        case 0x9C4Du:
          LoadStringW(ghInstance, 0x24u, &Buffer, 1024);
          break;
        case 0x9C5Eu:
          if ( gConfig.bShowDllView )
            LoadStringW(ghInstance, 0x1Du, &Buffer, 1024);
          else
            LoadStringW(ghInstance, 0x20u, &Buffer, 1024);
          break;
        case 0x9C67u:
          LoadStringW(ghInstance, 0x41Eu, &Buffer, 1024);
          break;
        case 0x9C6Eu:
          if ( gConfig.bShowLowerPane )
            LoadStringW(ghInstance, 0x441u, &Buffer, 1024);
          else
            LoadStringW(ghInstance, 0x440u, &Buffer, 1024);
          break;
        case 0x9C7Cu:
          LoadStringW(ghInstance, 0x4AEu, &Buffer, 1024);
          break;
        case 0x9C7Eu:
          LoadStringW(ghInstance, 0x458u, &Buffer, 1024);
          break;
        case 0x9C7Fu:
          LoadStringW(ghInstance, 0x459u, &Buffer, 1024);
          break;
        case 0x9CADu:
          LoadStringW(ghInstance, 0x4ADu, &Buffer, 1024);
          break;
        default:
          break;
      }
    }
  }
  *(a2 + 12) = &Buffer;
  return 0;
}

//----- (00FFFCA0) --------------------------------------------------------
void __cdecl sub_FFFCA0(CGraphData *pGraphData, __int64 a2)
{
  bool v2; // zf
  HICON v3; // esi
  RECT rc; // [esp+Ch] [ebp-21Ch]
  wchar_t Src; // [esp+1Ch] [ebp-20Ch]

  v2 = dword_106A3C4 == 0;
  _mm_storeu_si128(&rc, _mm_load_si128(&xmmword_1047010));
  if ( !v2 )
  {
    sub_FB2410(&Src, 0x104u, L"Current Commit: ", a2);
    v3 = GraphData_DrawChart(pGraphData, 0, &rc, gConfig.ColorGraphBk, 0, 0.0);
    sub_FC6910(ghMainWnd, dword_106A3C4, v3, &Src);
    DestroyIcon(v3);
  }
}
// 1046CEC: using guessed type wchar_t aCurrentCommit[17];
// 1047010: using guessed type __int128 xmmword_1047010;

//----- (00FFFD50) --------------------------------------------------------
char __cdecl sub_FFFD50(CGraphData *pGraphData, double a2, int a3, double a4)
{
  int v4; // eax
  CGraphData *v5; // edi
  bool v6; // zf
  double v7; // xmm0_8
  signed int v8; // ebx
  HICON v9; // eax
  unsigned int v10; // esi
  unsigned int v11; // eax
  HICON v12; // esi
  ICONINFO piconinfo; // [esp+14h] [ebp-234h]
  CGraphData *v15; // [esp+28h] [ebp-220h]
  RECT rc; // [esp+2Ch] [ebp-21Ch]
  __int16 Dst[260]; // [esp+3Ch] [ebp-20Ch]

  LOBYTE(v4) = dword_1085738;
  v5 = pGraphData;
  v15 = pGraphData;
  if ( !(dword_1085738 & 1) )
  {
    dword_1085728 = 0;
    dword_1085738 |= 1u;
    dword_108572C = 0;
    hdc = 0;
    dword_1085724 = 0;
    LOBYTE(v4) = atexit(sub_102ADC0);
  }
  v6 = byte_108573C == 0;
  _mm_storeu_si128(&rc, _mm_load_si128(&xmmword_1047010));
  if ( v6 )
  {
    byte_108573C = 1;
    LOBYTE(v4) = BitmapItem_Create(&dword_1085724, 16, 16);
  }
  if ( dword_106A3BC || dword_106A3C0 )
  {
    v7 = a2;
    if ( a2 > 100.0 )
    {
      v7 = db_onehundred;
      a2 = db_onehundred;
    }
    if ( pGraphData->m_nItemID )
      v4 = swprintf(Dst, L"GPU Usage: %.0f%%", LODWORD(v7), HIDWORD(v7));
    else
      v4 = swprintf(Dst, L"CPU Usage: %.0f%%", LODWORD(v7), HIDWORD(v7));
    if ( a3 && a4 > 0.5 )
      LOBYTE(v4) = swprintf_s(&Dst[v4], 260 - v4, L"%c%s: %.0f%%", 10, *(a3 + 60), a4);
    v8 = (a2 / 100.0 * 16.0);
    if ( gConfig.bTrayCPUHistory )
    {
      v9 = GraphData_DrawChart(pGraphData, 0, &rc, 0xFFFFFFFF, 0, 0.0);
    }
    else
    {
      if ( a2 == -1.0 )
      {
        v8 = dword_1085740;
      }
      else if ( v8 == dword_1085740 )
      {
        return v4;
      }
      v10 = dword_1085728 * dword_108572C;
      if ( dword_1085734 && v10 )
      {
        memset32(
          dword_1085734,
          (gConfig.ColorGraphBk & 0xFF00) | (LOBYTE(gConfig.ColorGraphBk) << 16) | (gConfig.ColorGraphBk >> 16) & 0xFF,
          v10);
        v5 = v15;
      }
      rc.top = 16 - v8;
      if ( a2 <= 90.0 )
      {
        v11 = 4652870;
        if ( a2 > 70.0 )
          v11 = 10551295;
      }
      else
      {
        v11 = 4605695;
      }
      BitmapItem_SetRectColor(&dword_1085724, &rc, v11);
      piconinfo.hbmColor = dword_1085724;
      piconinfo.hbmMask = dword_1085724;
      piconinfo.fIcon = 1;
      piconinfo.xHotspot = 0;
      piconinfo.yHotspot = 0;
      v9 = CreateIconIndirect(&piconinfo);
    }
    v12 = v9;
    if ( v5->m_nItemID )
      sub_FC6910(ghMainWnd, dword_106A3C0, v9, Dst);
    else
      sub_FC6910(ghMainWnd, dword_106A3BC, v9, Dst);
    LOBYTE(v4) = DestroyIcon(v12);
    dword_1085740 = v8;
  }
  return v4;
}
// 103CDC0: using guessed type double db_onehundred;
// 1046C80: using guessed type wchar_t aCpuUsage0f[18];
// 1047010: using guessed type __int128 xmmword_1047010;
// 106A3BC: using guessed type int dword_106A3BC;
// 1085728: using guessed type int dword_1085728;
// 108572C: using guessed type int dword_108572C;
// 1085734: using guessed type int dword_1085734;
// 1085738: using guessed type int dword_1085738;
// 108573C: using guessed type char byte_108573C;
// 1085740: using guessed type int dword_1085740;
// FFFD50: using guessed type wchar_t Dst[260];

//----- (01000010) --------------------------------------------------------
CGraphData *__cdecl sub_1000010(CGraphData *a1, int a2, __int64 a3, __int64 a4, __int64 a5)
{
  bool v5; // zf
  CGraphData *result; // eax
  int v7; // ebx
  HICON v8; // esi
  RECT rc; // [esp+28h] [ebp-21Ch]
  __int16 Dst[260]; // [esp+38h] [ebp-20Ch]

  v5 = dword_106A3F4 == 0;
  result = a1;
  _mm_storeu_si128(&rc, _mm_load_si128(&xmmword_1047010));
  if ( !v5 )
  {
    v7 = swprintf(Dst, L"Disk\n");
    if ( a2 )
    {
      sub_FB2200(1, &Dst[v7], 260 - v7, a4, a3, a5);
      if ( v7 >= 0 )
        swprintf_s(&Dst[v7], 260 - v7, L"\n%s", *(a2 + 60));
    }
    v8 = GraphData_DrawChart(a1, 0, &rc, gConfig.ColorGraphBk, 0, 0.0);
    sub_FC6910(ghMainWnd, dword_106A3F4, v8, Dst);
    result = DestroyIcon(v8);
  }
  return result;
}
// 1047010: using guessed type __int128 xmmword_1047010;
// 1000010: using guessed type wchar_t Dst[260];

//----- (01000130) --------------------------------------------------------
CGraphData *__cdecl sub_1000130(CGraphData *a1, int a2, __int64 a3, __int64 a4, __int64 a5)
{
  bool v5; // zf
  CGraphData *result; // eax
  int v7; // eax
  int v8; // esi
  HICON v9; // esi
  RECT rc; // [esp+28h] [ebp-21Ch]
  __int16 Dst[260]; // [esp+38h] [ebp-20Ch]

  v5 = dword_106A3C8 == 0;
  result = a1;
  _mm_storeu_si128(&rc, _mm_load_si128(&xmmword_1047010));
  if ( !v5 )
  {
    v7 = swprintf(Dst, L"I/O\n");
    if ( a2 )
    {
      v8 = sub_FB2200(1, &Dst[v7], 260 - v7, a4, a3, a5) + v7;
      if ( v8 >= 0 )
        swprintf_s(&Dst[v8], 260 - v8, L"\n%s", *(a2 + 60));
    }
    v9 = GraphData_DrawChart(a1, 0, &rc, gConfig.ColorGraphBk, 0, 0.0);
    sub_FC6910(ghMainWnd, dword_106A3C8, v9, Dst);
    result = DestroyIcon(v9);
  }
  return result;
}
// 1047010: using guessed type __int128 xmmword_1047010;
// 1000130: using guessed type wchar_t Dst[260];

//----- (01000250) --------------------------------------------------------
CGraphData *__cdecl sub_1000250(CGraphData *a1, int a2, __int64 a3, __int64 a4, __int64 a5)
{
  bool v5; // zf
  CGraphData *result; // eax
  int v7; // eax
  wchar_t *v8; // esi
  size_t v9; // edi
  HICON v10; // esi
  RECT rc; // [esp+28h] [ebp-21Ch]
  __int16 Dst[260]; // [esp+38h] [ebp-20Ch]

  v5 = dword_106A600 == 0;
  result = a1;
  _mm_storeu_si128(&rc, _mm_load_si128(&xmmword_1047010));
  if ( !v5 )
  {
    v7 = swprintf(Dst, L"Network\n");
    if ( a2 )
    {
      v8 = &Dst[v7];
      v9 = 260 - v7;
      sub_FB2200(1, &Dst[v7], 260 - v7, a4, a3, a5);
      swprintf_s(v8, v9, L"\n%s", *(a2 + 60));
    }
    v10 = GraphData_DrawChart(a1, 0, &rc, gConfig.ColorGraphBk, 0, 0.0);
    sub_FC6910(ghMainWnd, dword_106A600, v10, Dst);
    result = DestroyIcon(v10);
  }
  return result;
}
// 1047010: using guessed type __int128 xmmword_1047010;
// 1000250: using guessed type wchar_t Dst[260];

//----- (01000360) --------------------------------------------------------
void __cdecl sub_1000360(CGraphData *pGraphData, __int64 a2)
{
  bool v2; // zf
  HICON v3; // esi
  RECT rc; // [esp+Ch] [ebp-21Ch]
  wchar_t Src; // [esp+1Ch] [ebp-20Ch]

  v2 = dword_106A3F0 == 0;
  _mm_storeu_si128(&rc, _mm_load_si128(&xmmword_1047010));
  if ( !v2 )
  {
    sub_FB2410(&Src, 0x104u, L"Physical Usage: ", a2);
    v3 = GraphData_DrawChart(pGraphData, 0, &rc, gConfig.ColorGraphBk, 0, 0.0);
    sub_FC6910(ghMainWnd, dword_106A3F0, v3, &Src);
    DestroyIcon(v3);
  }
}
// 1046D10: using guessed type wchar_t aPhysicalUsage[17];
// 1047010: using guessed type __int128 xmmword_1047010;

//----- (01000410) --------------------------------------------------------
double *__usercall sub_1000410@<eax>(double a1@<st0>, double st6_0@<st1>, HWND a2, int a3, double *a4, double *a5)
{
  double *result; // eax
  WPARAM v7; // edi
  HDC v8; // esi
  void *v9; // eax
  signed int v10; // esi
  signed int v11; // edx
  DWORD v12; // eax
  __int64 ArgList; // xmm0_8
  char v14; // al
  double v15; // xmm0_8
  int v16; // esi
  HDC v17; // ST04_4
  int v18; // eax
  int v19; // ecx
  HDC v20; // ebx
  char v21; // [esp+8h] [ebp-2D8h]
  struct _FILETIME LocalFileTime; // [esp+14h] [ebp-2CCh]
  double v23; // [esp+1Ch] [ebp-2C4h]
  HGDIOBJ h; // [esp+24h] [ebp-2BCh]
  int v25; // [esp+28h] [ebp-2B8h]
  int v26; // [esp+2Ch] [ebp-2B4h]
  HWND hWnd; // [esp+30h] [ebp-2B0h]
  HDC hdc; // [esp+34h] [ebp-2ACh]
  char v29; // [esp+3Bh] [ebp-2A5h]
  struct _SYSTEMTIME SystemTime; // [esp+3Ch] [ebp-2A4h]
  struct tagRECT rc; // [esp+4Ch] [ebp-294h]
  int lParam[32]; // [esp+5Ch] [ebp-284h]
  __int16 chText[256]; // [esp+DCh] [ebp-204h]

  result = a4;
  v7 = 0;
  hWnd = a2;
  v29 = 0;
  if ( !a2 )
  {
    dword_10610E8 = -1;
    dword_10610EC = -1;
    dword_10610F0 = -1;
    dword_10610F4 = -1;
    dword_10610F8 = -1;
    dword_10610FC = -1;
    dword_1061100 = -1;
    dword_1061104 = -1;
    qword_1061110 = dbl_103CDD8;
    qword_1061108 = dbl_103CDD8;
    qword_1061118 = dbl_103CDD8;
    return result;
  }
  sub_FF7400(0i64, a4, a5, &v23);
  *(a3 + 16) = st6_0;
  *(a3 + 32) = *a5 / v23 * 100.0;
  v8 = GetDC(ghWndStatusBar);
  hdc = v8;
  v9 = SendMessageW(hWnd, 0x31u, 0, 0);
  h = SelectObject(v8, v9);
  SendMessageW(ghWndStatusBar, 0x406u, 0x20u, lParam);
  v10 = 1;
  v11 = 32;
  v25 = 1;
  v26 = 32;
  do
  {
    v12 = gConfig.dwStatusBarColumns & v10;
    if ( gConfig.dwStatusBarColumns & v10 )
    {
      if ( v12 > 0x80 )
      {
        if ( v12 > 0x800 )
        {
          switch ( v12 )
          {
            case 0x1000u:
              v16 = sub_FFF9B0(chText, 0xFFFFFFFF, L"Refresh: ", v21);
              FileTimeToLocalFileTime(&gTimeQuerySystemInfo, &LocalFileTime);
              FileTimeToSystemTime(&LocalFileTime, &SystemTime);
              GetTimeFormatW(0x400u, 0, &SystemTime, 0, &chText[v16], 256 - v16);
              v10 = v25;
              break;
            case 0x2000u:
              if ( *(a3 + 32) == *&qword_1061128 )
              {
                v14 = v29;
                if ( !v29 )
                {
                  ++v7;
                  goto LABEL_86;
                }
              }
              wsprintf(chText, L"Physical Usage: %02.2f%%", *(a3 + 32));
              qword_1061128 = *(a3 + 32);
              break;
            case 0x4000u:
              if ( *(a3 + 40) == *&qword_1061130 )
              {
                v14 = v29;
                if ( !v29 )
                {
                  ++v7;
                  goto LABEL_86;
                }
              }
              wsprintf(chText, L"Own Physical Usage: %02.2f%%", *(a3 + 40));
              qword_1061130 = *(a3 + 40);
              break;
          }
        }
        else
        {
          switch ( v12 )
          {
            case 0x800u:
              if ( *(a3 + 68) == dword_10610FC )
              {
                v14 = v29;
                if ( !v29 )
                {
                  ++v7;
                  goto LABEL_86;
                }
              }
              wsprintf(chText, L"Own Handles: %d", *(a3 + 68));
              dword_10610FC = *(a3 + 68);
              break;
            case 0x100u:
              if ( *(a3 + 56) == dword_10610F0 )
              {
                v14 = v29;
                if ( !v29 )
                {
                  ++v7;
                  goto LABEL_86;
                }
              }
              wsprintf(chText, L"Threads: %d", *(a3 + 56));
              dword_10610F0 = *(a3 + 56);
              break;
            case 0x200u:
              if ( *(a3 + 60) == dword_10610F4 )
              {
                v14 = v29;
                if ( !v29 )
                {
                  ++v7;
                  goto LABEL_86;
                }
              }
              wsprintf(chText, L"Own Threads: %d", *(a3 + 60));
              dword_10610F4 = *(a3 + 60);
              break;
            case 0x400u:
              if ( *(a3 + 64) == dword_10610F8 )
              {
                v14 = v29;
                if ( !v29 )
                {
                  ++v7;
                  goto LABEL_86;
                }
              }
              wsprintf(chText, L"Handles: %d", *(a3 + 64));
              dword_10610F8 = *(a3 + 64);
              break;
          }
        }
      }
      else if ( v12 == 128 )
      {
        if ( *(a3 + 76) == dword_1061104 )
        {
          v14 = v29;
          if ( !v29 )
          {
            ++v7;
            goto LABEL_86;
          }
        }
        wsprintf(chText, L"Own .NET Processes: %d", *(a3 + 76));
        dword_1061104 = *(a3 + 76);
      }
      else
      {
        switch ( v12 )
        {
          case 1u:
            ArgList = *a3;
            if ( *a3 == *&qword_1061110 )
            {
              v14 = v29;
              if ( !v29 )
              {
                ++v7;
                goto LABEL_86;
              }
            }
            if ( gConfig.bShowCpuFractions )
              wsprintf(chText, L"CPU Usage: %02.2f%%", ArgList);
            else
              wsprintf(chText, L"CPU Usage: %0.0f%%", ArgList);
            qword_1061110 = *a3;
            break;
          case 2u:
            v15 = *(a3 + 8);
            if ( v15 == *&qword_1061108 )
            {
              v14 = v29;
              if ( !v29 )
              {
                ++v7;
                goto LABEL_86;
              }
            }
            if ( gConfig.bShowCpuFractions )
              wsprintf(chText, L"Own CPU Usage: %02.2f%%", SLOBYTE(v15));
            else
              wsprintf(chText, L"Own CPU Usage: %0.0f%%", SLOBYTE(v15));
            qword_1061108 = *(a3 + 8);
            break;
          case 4u:
            if ( *(a3 + 16) == *&qword_1061118 )
            {
              v14 = v29;
              if ( !v29 )
              {
                ++v7;
                goto LABEL_86;
              }
            }
            wsprintf(chText, L"Commit Charge: %02.2f%%", *(a3 + 16));
            qword_1061118 = *(a3 + 16);
            break;
          case 8u:
            if ( *(a3 + 24) == *&qword_1061120 )
            {
              v14 = v29;
              if ( !v29 )
              {
                ++v7;
                goto LABEL_86;
              }
            }
            wsprintf(chText, L"Own Commit Charge: %02.2f%%", *(a3 + 24));
            qword_1061120 = *(a3 + 24);
            break;
          case 0x10u:
            if ( *(a3 + 48) == dword_10610E8 )
            {
              v14 = v29;
              if ( !v29 )
              {
                ++v7;
                goto LABEL_86;
              }
            }
            wsprintf(chText, L"Processes: %d", *(a3 + 48));
            dword_10610E8 = *(a3 + 48);
            break;
          case 0x20u:
            if ( *(a3 + 52) == dword_10610EC )
            {
              v14 = v29;
              if ( !v29 )
              {
                ++v7;
                goto LABEL_86;
              }
            }
            wsprintf(chText, L"Own Processes: %d", *(a3 + 52));
            dword_10610EC = *(a3 + 52);
            break;
          case 0x40u:
            if ( *(a3 + 72) == dword_1061100 )
            {
              v14 = v29;
              if ( !v29 )
              {
                ++v7;
                goto LABEL_86;
              }
            }
            wsprintf(chText, &off_1046EFC, *(a3 + 72));
            dword_1061100 = *(a3 + 72);
            break;
          default:
            break;
        }
      }
      v17 = hdc;
      _mm_storeu_si128(&rc, 0i64);
      DrawTextW(v17, chText, -1, &rc, 0xD20u);
      v18 = rc.right + 10;
      rc.right += 10;
      if ( v7 )
        v19 = lParam[v7] - *(&rc.bottom + v7);
      else
        v19 = lParam[0];
      if ( v19 < v18 )
      {
        v29 = 1;
        lParam[v7] += v18 - v19;
      }
      SendMessageW(hWnd, 0x40Bu, v7, chText);
      v11 = v26;
      ++v7;
    }
    v14 = v29;
LABEL_86:
    v10 = __ROL4__(v10, 1);
    --v11;
    v25 = v10;
    v26 = v11;
  }
  while ( v11 );
  if ( v14 )
  {
    lParam[v7] = -1;
    SendMessageW(ghWndStatusBar, 0x404u, v7 + 1, lParam);
  }
  v20 = hdc;
  SelectObject(hdc, h);
  return ReleaseDC(ghWndStatusBar, v20);
}
// 103CDC0: using guessed type double db_onehundred;
// 1046D34: using guessed type wchar_t aCpuUsage022f[20];
// 1046D84: using guessed type wchar_t aOwnCpuUsage022[24];
// 10610E8: using guessed type int dword_10610E8;
// 10610EC: using guessed type int dword_10610EC;
// 10610F0: using guessed type int dword_10610F0;
// 10610F4: using guessed type int dword_10610F4;
// 10610F8: using guessed type int dword_10610F8;
// 10610FC: using guessed type int dword_10610FC;
// 1061100: using guessed type int dword_1061100;
// 1061104: using guessed type int dword_1061104;
// 1061108: using guessed type __int64 qword_1061108;
// 1061110: using guessed type __int64 qword_1061110;
// 1061118: using guessed type __int64 qword_1061118;
// 1061120: using guessed type __int64 qword_1061120;
// 1061128: using guessed type __int64 qword_1061128;
// 1061130: using guessed type __int64 qword_1061130;
// 1000410: using guessed type LPARAM lParam[32];
// 1000410: using guessed type WCHAR chText[256];

//----- (01000BB0) --------------------------------------------------------
HWND __cdecl InitToolbar(HWND hWnd, unsigned int nIDToolbar)
{
  unsigned int v3; // edi
  WPARAM nBandIndex; // edi
  unsigned int nIndex; // esi
  LRESULT v6; // eax
  bool fBreak; // zf
  LPARAM lParam; // [esp+0h] [ebp-1B0h]
  int v9; // [esp+4h] [ebp-1ACh]
  INITCOMMONCONTROLSEX picce; // [esp+Ch] [ebp-1A4h]
  tagREBARBANDINFOW RebarBandInfo; // [esp+14h] [ebp-19Ch]
  RECT rcItem1; // [esp+64h] [ebp-14Ch]
  RECT rcItem2; // [esp+74h] [ebp-13Ch]
  struct tagRECT rect; // [esp+84h] [ebp-12Ch]
  TBBUTTON buttons[14]; // [esp+94h] [ebp-11Ch]

  buttons[0].iBitmap = BMP_SAVE;
  buttons[0].idCommand = IDM_FILE_SAVE;
  *&buttons[0].fsState = 4;
  *&buttons[0].dwData = 0i64;
  buttons[1].iBitmap = 0;
  buttons[1].idCommand = 0;
  *&buttons[1].fsState = 0x104;
  *&buttons[1].dwData = 0i64;
  buttons[2].iBitmap = BMP_REFRESH;
  buttons[2].idCommand = IDM_VIEW_REFRESH_NOW;
  *&buttons[2].fsState = 4;
  *&buttons[2].dwData = 0i64;
  buttons[3].iBitmap = 0;
  buttons[3].idCommand = 0;
  *&buttons[3].fsState = 0x104;
  *&buttons[3].dwData = 0i64;
  buttons[4].iBitmap = BMP_VIEW_SYSTEM_INFORMATION;
  buttons[4].idCommand = IDM_TRAYMENU_CONTEXT_SYSTEM_INFORMATION;
  *&buttons[4].fsState = 4;
  *&buttons[4].dwData = 0i64;
  buttons[5].iBitmap = BMP_SHOW_PROCESS_TREE;
  buttons[5].idCommand = IDM_VIEW_SHOW_PROCESS_TREE;
  *&buttons[5].fsState = 4;
  *&buttons[5].dwData = 0i64;
  buttons[6].iBitmap = BMP_SHOW_LOWER_PANE;
  buttons[6].idCommand = IDM_VIEW_SHOW_LOWER_PANE;
  *&buttons[6].fsState = 4;
  *&buttons[6].dwData = 0i64;
  buttons[7].iBitmap = BMP_VIEW_HANDLES;
  buttons[7].idCommand = IDM_POPUP_DLL_PROPERTIES;
  *&buttons[7].fsState = 4;
  *&buttons[7].dwData = 0i64;
  buttons[8].iBitmap = 0;
  buttons[8].idCommand = 0;
  *&buttons[8].fsState = 260;
  *&buttons[8].dwData = 0i64;
  buttons[9].iBitmap = BMP_PROPERTIES;
  buttons[9].idCommand = IDM_VIEW_PROCESS_PROPERTIES;
  *&buttons[9].fsState = 4;
  *&buttons[9].dwData = 0i64;
  buttons[10].iBitmap = BMP_KILL_PROCESS;
  buttons[10].idCommand = IDM_PROCESS_KILL_PROCESS;
  *&buttons[10].fsState = 4;
  *&buttons[10].dwData = 0i64;
  buttons[11].iBitmap = 0;
  buttons[11].idCommand = 0;
  *&buttons[11].fsState = 260;
  *&buttons[11].dwData = 0i64;
  buttons[12].iBitmap = 2;
  buttons[12].idCommand = IDM_SEARCH_IN_PROCESS;
  *&buttons[12].fsState = 4;
  *&buttons[12].dwData = 0i64;
  buttons[13].iBitmap = BMP_FIND_PROCESS_BY_WINDOW;
  buttons[13].idCommand = IDM_FIND_PROCESS_BY_WINDOW;
  *&buttons[13].fsState = 4;
  *&buttons[13].dwData = 0i64;
  picce.dwSize = 8;
  picce.dwICC = 1540;
  InitCommonControlsEx(&picce);
  ghWndReBar = CreateWindowExW(
                 WS_EX_TOOLWINDOW,
                 L"ReBarWindow32",
                 0,
                 0x56800448u,
                 0,
                 0,
                 400,
                 275,
                 hWnd,
                 0,
                 ghInstance,
                 0);
  lParam = 12;
  v9 = 0;
  if ( !SendMessageW(ghWndReBar, RB_SETBARINFO, 0, &lParam) )
    return 0;
  ghWndToolbar = CreateToolbarEx(
                   ghWndReBar,
                   0x56000944u,
                   nIDToolbar,
                   12,
                   ghInstance,
                   108u,
                   buttons,
                   14,
                   0,
                   0,
                   0,
                   0,
                   20u);
  if ( !ghWndToolbar )
    return 0;
  v3 = GetButtonSize();
  SendMessageW(ghWndToolbar, TB_GETRECT, 0x9C49u, &rcItem1);
  SendMessageW(ghWndToolbar, TB_GETRECT, 0x9CADu, &rcItem2);
  UnionRect(&rect, &rcItem1, &rcItem2);
  memset(&RebarBandInfo, 0, sizeof(tagREBARBANDINFOW));
  RebarBandInfo.cbSize = sizeof(tagREBARBANDINFOW);
  RebarBandInfo.fMask = 0x173;
  RebarBandInfo.fStyle = 0x80;
  RebarBandInfo.hwndChild = ghWndToolbar;
  RebarBandInfo.cxMinChild = 0;
  RebarBandInfo.clrFore = GetSysColor(COLOR_BTNTEXT);
  RebarBandInfo.clrBack = GetSysColor(COLOR_BTNFACE);
  RebarBandInfo.cx = rect.right - rect.left;
  RebarBandInfo.cxMinChild = rect.right - rect.left;
  RebarBandInfo.cyMinChild = v3 >> 16;
  RebarBandInfo.wID = 0;
  SendMessageW(ghWndReBar, RB_INSERTBANDW, 0xFFFFFFFF, &RebarBandInfo);
  ghWndCPUGraph = CreateWindowExW(
                    0,
                    L"CpuGraphClassGraph",
                    &gszNullString,
                    0x56010004u,
                    0,
                    0,
                    0,
                    0,
                    ghWndReBar,
                    2000,
                    ghInstance,
                    gpGraphInfoOfCPU);
  RebarBandInfo.hwndChild = ghWndCPUGraph;
  RebarBandInfo.cx = MulDiv(75, gLogPixelSize.x, 96);
  RebarBandInfo.cxMinChild = 0;
  RebarBandInfo.wID = 1;
  SendMessageW(ghWndReBar, RB_INSERTBANDW, 0xFFFFFFFF, &RebarBandInfo);
  ghWndMemoryGraph = CreateWindowExW(
                       0,
                       L"CpuGraphClassGraph",
                       &gszNullString,
                       0x56010004u,
                       0,
                       0,
                       0,
                       0,
                       ghWndReBar,
                       2000,
                       ghInstance,
                       gpGraphInfoOfMemory);
  RebarBandInfo.hwndChild = ghWndMemoryGraph;
  RebarBandInfo.cx = MulDiv(75, gLogPixelSize.x, 96);
  RebarBandInfo.cxMinChild = 0;
  RebarBandInfo.wID = 2;
  SendMessageW(ghWndReBar, RB_INSERTBANDW, 0xFFFFFFFF, &RebarBandInfo);
  ghWndPhysicalMemoryGraph = CreateWindowExW(
                               0,
                               L"CpuGraphClassGraph",
                               &gszNullString,
                               0x56010004u,
                               0,
                               0,
                               0,
                               0,
                               ghWndReBar,
                               IDC_GRAPH_IN_REBAR,
                               ghInstance,
                               gpGraphInfoOfPhysicalMemory);
  RebarBandInfo.hwndChild = ghWndPhysicalMemoryGraph;
  RebarBandInfo.cx = MulDiv(75, gLogPixelSize.x, 96);
  RebarBandInfo.cxMinChild = 0;
  RebarBandInfo.wID = 3;
  SendMessageW(ghWndReBar, RB_INSERTBANDW, 0xFFFFFFFF, &RebarBandInfo);
  if ( gIOGraphInfo.pGraphData )
  {
    ghWndIOGraphCtrl = CreateWindowExW(
                         0,
                         L"CpuGraphClassGraph",
                         &gszNullString,
                         0x56010004u,
                         0,
                         0,
                         0,
                         0,
                         ghWndReBar,
                         2000,
                         ghInstance,
                         gIOGraphInfo.pGraphData);
    RebarBandInfo.hwndChild = ghWndIOGraphCtrl;
    RebarBandInfo.cx = MulDiv(75, gLogPixelSize.x, 96);
    RebarBandInfo.cxMinChild = 0;
    RebarBandInfo.wID = 4;
    SendMessageW(ghWndReBar, RB_INSERTBANDW, 0xFFFFFFFF, &RebarBandInfo);
  }
  if ( IsBuiltinAdministrative() && gNetworkGraphInfo.pGraphData )
  {
    ghWndNetworkGraph = CreateWindowExW(
                          0,
                          L"CpuGraphClassGraph",
                          &gszNullString,
                          0x56010004u,
                          0,
                          0,
                          0,
                          0,
                          ghWndReBar,
                          IDC_GRAPH_IN_REBAR,
                          ghInstance,
                          gNetworkGraphInfo.pGraphData);
    RebarBandInfo.hwndChild = ghWndNetworkGraph;
    RebarBandInfo.cx = MulDiv(75, gLogPixelSize.x, 96);
    RebarBandInfo.cxMinChild = 0;
    RebarBandInfo.wID = 5;
    SendMessageW(ghWndReBar, RB_INSERTBANDW, 0xFFFFFFFF, &RebarBandInfo);
  }
  if ( IsBuiltinAdministrative() && gDiskGraphInfo.pGraphData )
  {
    ghWndDiskGraph = CreateWindowExW(
                       0,
                       L"CpuGraphClassGraph",
                       &gszNullString,
                       0x56010004u,
                       0,
                       0,
                       0,
                       0,
                       ghWndReBar,
                       IDC_GRAPH_IN_REBAR,
                       ghInstance,
                       gDiskGraphInfo.pGraphData);
    RebarBandInfo.hwndChild = ghWndDiskGraph;
    RebarBandInfo.cx = MulDiv(75, gLogPixelSize.x, 96);
    RebarBandInfo.cxMinChild = 0;
    RebarBandInfo.wID = 6;
    SendMessageW(ghWndReBar, RB_INSERTBANDW, 0xFFFFFFFF, &RebarBandInfo);
  }
  if ( gdwAdapterRuntingTime )
  {
    ghWndGPUGraph = CreateWindowExW(
                      0,
                      L"CpuGraphClassGraph",
                      &gszNullString,
                      0x56010004u,
                      0,
                      0,
                      0,
                      0,
                      ghWndReBar,
                      IDC_GRAPH_IN_REBAR,
                      ghInstance,
                      gpGraphInfoOfGPU);
    RebarBandInfo.hwndChild = ghWndGPUGraph;
    RebarBandInfo.cx = MulDiv(75, gLogPixelSize.x, 96);
    RebarBandInfo.cxMinChild = 0;
    RebarBandInfo.wID = 7;
    SendMessageW(ghWndReBar, RB_INSERTBANDW, 0xFFFFFFFF, &RebarBandInfo);
  }
  if ( gConfig.ToolBandInfo[0].nWidth != -1 )
  {
    nBandIndex = 0;
    nIndex = 0;
    do
    {
      v6 = SendMessageW(ghWndReBar, RB_IDTOINDEX, gConfig.ToolBandInfo[nIndex].nID, 0);
      SendMessageW(ghWndReBar, RB_MOVEBAND, v6, nBandIndex);
      SendMessageW(ghWndReBar, RB_GETBANDINFOW, nBandIndex, &RebarBandInfo);
      fBreak = gConfig.ToolBandInfo[nIndex].fBreak == 0;
      RebarBandInfo.fMask = 0x141;              // RBBIM_STYLE|RBBIM_SIZE|RBBIM_ID
      if ( fBreak )
        RebarBandInfo.fStyle &= -2u;
      else
        RebarBandInfo.fStyle |= RBBS_BREAK;
      RebarBandInfo.cx = MulDiv(gConfig.ToolBandInfo[nIndex].nWidth, gLogPixelSize.x, 96);
      RebarBandInfo.wID = gConfig.ToolBandInfo[nIndex].nID;
      SendMessageW(ghWndReBar, RB_SETBANDINFOW, nBandIndex, &RebarBandInfo);
      ++nIndex;
      ++nBandIndex;
    }
    while ( nIndex < 8 );
  }
  return ghWndToolbar;
}

//----- (010013B0) --------------------------------------------------------
LPARAM GetButtonSize()
{
  int v0; // edi
  unsigned __int16 v1; // ax
  LPARAM v2; // esi

  v0 = GetSystemMetrics(50) << 16;
  v1 = GetSystemMetrics(49);
  SendMessageW(ghWndToolbar, 0x420u, 0, v0 | v1);
  v2 = SendMessageW(ghWndToolbar, 0x43Au, 0, 0);
  SendMessageW(ghWndToolbar, 0x420u, 0, 983056);
  SendMessageW(ghWndToolbar, 0x41Fu, 0, v2);
  return v2;
}

//----- (01001420) --------------------------------------------------------
_DWORD *__stdcall std::_List_buy<tagEventItem *,std::allocator<tagEventItem *>>::_Buynode<tagEventItem * const &>(EventList *a1, _DWORD *a2, _DWORD *a3)
{
  _DWORD *result; // eax

  result = std::_List_alloc<std::_List_base_types<tagEventItem *,std::allocator<tagEventItem *>>>::_Buynode0(a1, a2);
  if ( result != -8 )
    result[2] = *a3;
  return result;
}

//----- (01001440) --------------------------------------------------------
CSystemProcessInfoMapNode **__thiscall sub_1001440(CSystemProcessInfoMap *this, CSystemProcessInfoMapNode **a2, char a3, CSystemProcessInfoMapNode *a4, int *a5, int a6)
{
  CSystemProcessInfoMap *v6; // edi
  CSystemProcessInfoMapNode *v7; // eax
  CSystemProcessInfoMapNode *v8; // ebx
  std__Tree_node *v9; // eax
  std__Tree_node *v10; // eax
  std__Tree_node *v11; // ecx
  std__Tree_node *v12; // esi
  std__Tree_node *v13; // edx
  std__Tree_node *v14; // edx
  std__Tree_node *v15; // ecx
  std__Tree_node *v16; // edx
  std__Tree_node *v17; // esi
  std__Tree_node_For__bstr_t *v18; // ecx
  std__Tree_node *v19; // ecx
  std__Tree_node *v20; // edx
  std__Tree_node_For__bstr_t *v21; // ecx
  std__Tree_node *v22; // ecx
  std__Tree_node *v23; // ecx
  CSystemProcessInfoMapNode **result; // eax

  v6 = this;
  if ( this->_Size >= 0xAAAAAA9u )
    std::_Xlength_error("map/set<T> too long");
  v7 = sub_F91310(this, a5);
  ++v6->_Size;
  v8 = v7;
  v7->baseclass._Parent = a4;
  if ( a4 == v6->_Header )
  {
    v6->_Header->_Parent = v7;
    v6->_Header->_Left = v7;
    v9 = v6->_Header;
LABEL_8:
    v9->_Right = v8;
    goto LABEL_9;
  }
  if ( !a3 )
  {
    a4->baseclass._Right = v7;
    v9 = v6->_Header;
    if ( a4 != v6->_Header->_Right )
      goto LABEL_9;
    goto LABEL_8;
  }
  a4->baseclass._Left = v7;
  if ( a4 == v6->_Header->_Left )
    v6->_Header->_Left = v7;
LABEL_9:
  v10 = v8;
  if ( !v8->baseclass._Parent->baseclass._Color )
  {
    do
    {
      v11 = v10->_Parent;
      v12 = v11->_Parent;
      v13 = v12->_Left;
      if ( v11 == v12->_Left )
      {
        v13 = v12->_Right;
        if ( v13->_Color )
        {
          if ( v10 == v11->_Right )
          {
            v10 = v10->_Parent;
            v14 = v11->_Right;
            v11->_Right = v14->_Left;
            if ( !v14->_Left->_IsNil )
              v14->_Left->_Parent = v11;
            v14->_Parent = v11->_Parent;
            if ( v11 == v6->_Header->_Parent )
            {
              v6->_Header->_Parent = v14;
            }
            else
            {
              v15 = v11->_Parent;
              if ( v10 == v15->_Left )
                v15->_Left = v14;
              else
                v15->_Right = v14;
            }
            v14->_Left = v10;
            v10->_Parent = v14;
          }
          v10->_Parent->_Color = 1;
          v10->_Parent->_Parent->_Color = 0;
          v16 = v10->_Parent->_Parent;
          v17 = v16->_Left;
          v16->_Left = v16->_Left->_Right;
          v18 = v17->_Right;
          if ( !v18->_IsNil )
            v18->_Parent = v16;
          v17->_Parent = v16->_Parent;
          if ( v16 == v6->_Header->_Parent )
          {
            v6->_Header->_Parent = v17;
            v17->_Right = v16;
          }
          else
          {
            v19 = v16->_Parent;
            if ( v16 == v19->_Right )
              v19->_Right = v17;
            else
              v19->_Left = v17;
            v17->_Right = v16;
          }
LABEL_48:
          v16->_Parent = v17;
          continue;
        }
      }
      else if ( v13->_Color )
      {
        if ( v10 == v11->_Left )
        {
          v10 = v10->_Parent;
          v20 = v11->_Left;
          v11->_Left = v11->_Left->_Right;
          v21 = v20->_Right;
          if ( !v21->_IsNil )
            v21->_Parent = v10;
          v20->_Parent = v10->_Parent;
          if ( v10 == v6->_Header->_Parent )
          {
            v6->_Header->_Parent = v20;
          }
          else
          {
            v22 = v10->_Parent;
            if ( v10 == v22->_Right )
              v22->_Right = v20;
            else
              v22->_Left = v20;
          }
          v20->_Right = v10;
          v10->_Parent = v20;
        }
        v10->_Parent->_Color = 1;
        v10->_Parent->_Parent->_Color = 0;
        v16 = v10->_Parent->_Parent;
        v17 = v16->_Right;
        v16->_Right = v17->_Left;
        if ( !v17->_Left->_IsNil )
          v17->_Left->_Parent = v16;
        v17->_Parent = v16->_Parent;
        if ( v16 == v6->_Header->_Parent )
        {
          v6->_Header->_Parent = v17;
        }
        else
        {
          v23 = v16->_Parent;
          if ( v16 == v23->_Left )
            v23->_Left = v17;
          else
            v23->_Right = v17;
        }
        v17->_Left = v16;
        goto LABEL_48;
      }
      v11->_Color = 1;
      v13->_Color = 1;
      v10->_Parent->_Parent->_Color = 0;
      v10 = v10->_Parent->_Parent;
    }
    while ( !v10->_Parent->_Color );
  }
  v6->_Header->_Parent->_Color = 1;
  result = a2;
  *a2 = v8;
  return result;
}

//----- (01001650) --------------------------------------------------------
int __thiscall sub_1001650(CSystemProcessInfoMap *this, int a2, CSystemProcessInfoMapNode *a3, int *a4, int a5)
{
  CSystemProcessInfoMap *v5; // edx
  CSystemProcessInfoMapNode *v6; // ecx
  bool v7; // al
  int *v8; // ebx
  CSystemProcessInfoMapNode *v9; // esi
  Data_t_bstr_t *v10; // ecx
  Data_t_bstr_t *v11; // ecx
  CSystemProcessInfoMapNode *v12; // esi
  CSystemProcessInfoMapNode **v13; // eax
  CSystemProcessInfoMapNode *v14; // ecx
  int result; // eax
  Data_t_bstr_t *v16; // ecx
  Data_t_bstr_t *v17; // [esp-8h] [ebp-34h]
  Data_t_bstr_t *v18; // [esp-8h] [ebp-34h]
  Data_t_bstr_t *v19; // [esp-8h] [ebp-34h]
  Data_t_bstr_t *v20; // [esp-4h] [ebp-30h]
  Data_t_bstr_t *v21; // [esp-4h] [ebp-30h]
  Data_t_bstr_t *v22; // [esp-4h] [ebp-30h]
  int v23; // [esp+0h] [ebp-2Ch]
  CSystemProcessInfoMap *v24; // [esp+10h] [ebp-1Ch]
  int v25; // [esp+14h] [ebp-18h]
  CSystemProcessInfoMapNode *v26; // [esp+18h] [ebp-14h]
  int *v27; // [esp+1Ch] [ebp-10h]
  int v28; // [esp+28h] [ebp-4h]

  v27 = &v23;
  v5 = this;
  v24 = this;
  v6 = this->_Header;
  v7 = 1;
  v8 = a4;
  v28 = 0;
  v9 = v6->baseclass._Parent;
  v26 = v6;
  LOBYTE(v25) = 1;
  if ( !v9->baseclass._isnil )
  {
    do
    {
      v26 = v9;
      if ( a3 )
      {
        v20 = *v8;
        if ( *v8 )
          InterlockedIncrement((*v8 + 8));
        v10 = v9->_Keyvalue._Key;
        v17 = v10;
        if ( v10 )
          InterlockedIncrement(&v10->m_RefCount);
        v7 = sub_F914B0(v17, v20) == 0;
      }
      else
      {
        v11 = v9->_Keyvalue._Key;
        v21 = v11;
        if ( v11 )
          InterlockedIncrement(&v11->m_RefCount);
        v18 = *v8;
        if ( *v8 )
          InterlockedIncrement(&v18->m_RefCount);
        v7 = sub_F914B0(v18, v21);
      }
      LOBYTE(v25) = v7;
      if ( v7 )
        v9 = v9->baseclass._Left;
      else
        v9 = v9->baseclass._Right;
    }
    while ( !v9->baseclass._isnil );
    v6 = v26;
    v5 = v24;
  }
  v12 = v6;
  a3 = v6;
  if ( v7 )
  {
    if ( v6 == v5->_Header->_Left )
    {
      v13 = sub_1001440(v5, &a3, 1, v6, v8, a5);
LABEL_21:
      v14 = *v13;
      result = a2;
      *a2 = v14;
      *(a2 + 4) = 1;
      return result;
    }
    std::_Tree_unchecked_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<unsigned long const,_SYSTEM_PROCESSOR_IDLE_CYCLE_TIME_INFORMATION *>>>,std::_Iterator_base0>::operator--(&a3);
    v12 = a3;
  }
  v22 = *v8;
  if ( *v8 )
    InterlockedIncrement(&v22->m_RefCount);
  v16 = v12->_Keyvalue._Key;
  v19 = v16;
  if ( v16 )
    InterlockedIncrement(&v16->m_RefCount);
  if ( sub_F914B0(v19, v22) )
  {
    v13 = sub_1001440(v24, &a4, v25, v26, v8, a5);
    goto LABEL_21;
  }
  result = a2;
  *a2 = v12;
  *(a2 + 4) = 0;
  return result;
}
// 10081AA: using guessed type void __stdcall __noreturn _CxxThrowException(_DWORD, _DWORD);

//----- (010017E0) --------------------------------------------------------
char SubmitExeToVirusTotalDotCom()
{
  char result; // al

  result = AskForAgreementLicense(ghMainWnd, L"Process Explorer", 0, 0, aYouMustAgreeTo_2);
  gbAgreenmentLicensed = result;
  if ( result )
  {
    StartVirusTotalCheck();
    result = gbAgreenmentLicensed;
  }
  return result;
}
// 1061138: using guessed type wchar_t aYouMustAgreeTo_2[298];
// 1085774: using guessed type char gbAgreenmentLicensed;

//----- (01001820) --------------------------------------------------------
char __cdecl sub_1001820(ListItemData1 *a1)
{
  char result; // al

  result = 0;
  if ( a1 && (a1->field_4 == 1 || a1->field_4 == 4) )
    result = 1;
  return result;
}

//----- (01001840) --------------------------------------------------------
BOOL __cdecl sub_1001840(LPCWSTR lpFileName, wchar_t *Dest, int a3)
{
  wchar_t *v3; // edi
  BOOL v4; // ebx
  HANDLE v5; // eax
  void *v6; // esi
  DWORD v7; // eax
  DWORD v8; // ecx
  DWORD v9; // edx
  SIZE_T v10; // esi
  const BYTE *v11; // eax
  bool v12; // zf
  HCRYPTHASH v13; // ST08_4
  DWORD v14; // esi
  HANDLE v16; // [esp+Ch] [ebp-48h]
  const BYTE *dwFileOffsetHigh_4; // [esp+14h] [ebp-40h]
  DWORD v18; // [esp+18h] [ebp-3Ch]
  DWORD v19; // [esp+1Ch] [ebp-38h]
  LPFILETIME lpCreationTime; // [esp+20h] [ebp-34h]
  HCRYPTPROV phProv; // [esp+24h] [ebp-30h]
  HCRYPTHASH phHash; // [esp+28h] [ebp-2Ch]
  DWORD pdwDataLen; // [esp+2Ch] [ebp-28h]
  BYTE pbData; // [esp+30h] [ebp-24h]
  __int128 v25; // [esp+31h] [ebp-23h]
  __int64 v26; // [esp+41h] [ebp-13h]
  int v27; // [esp+49h] [ebp-Bh]
  __int16 v28; // [esp+4Dh] [ebp-7h]
  char v29; // [esp+4Fh] [ebp-5h]

  v3 = Dest;
  v4 = 0;
  phProv = 0;
  phHash = 0;
  v5 = CreateFileW(lpFileName, 0x80000000, 7u, 0, 3u, 0, 0);
  v6 = v5;
  v16 = v5;
  if ( v5 == -1 )
    return v4 != 0;
  GetFileTime(v5, a3, 0, 0);
  v4 = CryptAcquireContextW(&phProv, 0, 0, 0x18u, 0xF0000000);
  if ( !v4 )
  {
    v4 = CryptAcquireContextW(&phProv, 0, 0, 1u, 0xF0000000);
    if ( !v4 )
      goto LABEL_24;
  }
  if ( !CryptCreateHash(phProv, 0x8004u, 0, 0, &phHash) )
    goto LABEL_23;
  lpCreationTime = CreateFileMappingW(v6, 0, 2u, 0, 0, 0);
  if ( !lpCreationTime )
  {
    v4 = 0;
    goto LABEL_22;
  }
  v7 = GetFileSize(v6, 0);
  v19 = v7;
  v4 = 1;
  if ( !v7 )
    goto LABEL_16;
  v8 = 0;
  v9 = 0;
  v18 = 0;
  pdwDataLen = 0;
  while ( 1 )
  {
    v10 = v7;
    if ( v7 > 0x100000 )
      v10 = 0x100000;
    v11 = MapViewOfFile(lpCreationTime, 4u, v8, v9, v10);
    dwFileOffsetHigh_4 = v11;
    if ( !v11 )
      goto LABEL_13;
    if ( !CryptHashData(phHash, v11, v10, 0) )
      break;
    v11 = dwFileOffsetHigh_4;
LABEL_13:
    UnmapViewOfFile(v11);
    v8 = (v10 + __PAIR__(v18, pdwDataLen)) >> 32;
    v9 = v10 + pdwDataLen;
    pdwDataLen += v10;
    v7 = v19 - v10;
    v12 = v19 == v10;
    v18 = v8;
    v19 -= v10;
    if ( v12 )
      goto LABEL_16;
  }
  v4 = 0;
LABEL_16:
  CloseHandle(lpCreationTime);
  if ( v4 )
  {
    pbData = 0;
    v27 = 0;
    v13 = phHash;
    v28 = 0;
    _mm_storeu_si128(&v25, 0i64);
    v29 = 0;
    v26 = 0i64;
    pdwDataLen = 32;
    if ( CryptGetHashParam(v13, 2u, &pbData, &pdwDataLen, 0) )
    {
      v14 = 0;
      if ( pdwDataLen )
      {
        do
        {
          _swprintf(v3, L"%02X", *(&pbData + v14++));
          v3 += 2;
        }
        while ( v14 < pdwDataLen );
      }
    }
  }
LABEL_22:
  CryptDestroyHash(phHash);
  v6 = v16;
LABEL_23:
  CryptReleaseContext(phProv, 0);
LABEL_24:
  CloseHandle(v6);
  return v4 != 0;
}

//----- (01001A50) --------------------------------------------------------
int __cdecl sub_1001A50(int pHash, wchar_t *Dest)
{
  int result; // eax
  const wchar_t *v3; // edx
  const wchar_t *v4; // edx
  const wchar_t *v5; // edx
  char **v6; // edx
  char *v7; // edx
  char *v8; // ecx
  _DWORD *v9; // eax

  result = 0;
  *Dest = 0;
  if ( pHash )
  {
    result = *(pHash + 4) - 1;
    switch ( *(pHash + 4) )
    {
      case 1:
      case 6:
        v9 = *(pHash + 40);
        if ( v9 )
          result = _swprintf(Dest, L"%s", *v9);
        else
          result = _swprintf(Dest, L"%s", 0);
        break;
      case 2:
        v3 = L"Hash submitted...";
        do
        {
          result = *v3;
          ++v3;
          *(v3 + Dest - L"Hash submitted..." - 2) = result;
        }
        while ( result );
        break;
      case 3:
        v5 = L"File submitted...";
        do
        {
          result = *v5;
          ++v5;
          *(v5 + Dest - L"File submitted..." - 2) = result;
        }
        while ( result );
        break;
      case 4:
        v4 = L"Scanning file...";
        do
        {
          result = *v4;
          ++v4;
          *(v4 + Dest - L"Scanning file..." - 2) = result;
        }
        while ( result );
        break;
      case 5:
        v6 = *(pHash + 32);
        if ( v6 )
          v7 = *v6;
        else
          v7 = 0;
        v8 = (Dest - v7);
        do
        {
          result = *v7;
          v7 += 2;
          *&v7[v8 - 2] = result;
        }
        while ( result );
        break;
      default:
        return result;
    }
  }
  return result;
}
// 1032BBC: using guessed type wchar_t aHashSubmitted[18];
// 1032BE0: using guessed type wchar_t aScanningFile[17];
// 1032C04: using guessed type wchar_t aFileSubmitted[18];

//----- (01001B40) --------------------------------------------------------
void StartVirusTotalCheck()
{
  if ( !byte_10857B4 )
  {
    HttpInfo_Open(&gHttpInfo, ghMainWnd, L"Process Explorer", 0, 0, 0);
    InitializeCriticalSection(&stru_1085744);
    ghEventHandle = CreateEventW(0, 0, 0, 0);
    ghEventHandle2 = CreateEventW(0, 0, 0, 0);
    ghThreadHandle = _beginthreadex(0, 0, BackendThreadProc1, 0, 0, 0);
    ghEventHandle3 = CreateEventW(0, 0, 0, 0);
    ghThreadHandle2 = _beginthreadex(0, 0, BackendThreadProc2, 0, 0, 0);
    ghThreadHandle3 = _beginthreadex(0, 0, BackendThreadProc3, 0, 0, 0);
    byte_10857B4 = 1;
  }
}
// 1085760: using guessed type int ghThreadHandle;
// 1085768: using guessed type int ghThreadHandle2;
// 1085770: using guessed type int ghThreadHandle3;
// 10857B4: using guessed type char byte_10857B4;

//----- (01001C10) --------------------------------------------------------
char __cdecl sub_1001C10(ListItemData1 *a1)
{
  char result; // al
  int v2; // ecx

  result = 0;
  if ( !a1 || (v2 = a1->field_4, v2 == 1) || (v2 - 5) <= 1 )
    result = 1;
  return result;
}

//----- (01001C30) --------------------------------------------------------
void __cdecl sub_1001C30(DLLLISTITEMPARAM *pItemParam, char a2, int a3)
{
  DLLLISTITEMPARAM *pItemParam_1; // ebx
  _bstr_t *v4; // edi
  CHAR *v5; // ST0C_4
  int v6; // eax
  int v7; // ecx
  Data_t_bstr_t *v8; // eax
  int v9; // esi
  LONG (__stdcall *v10)(volatile LONG *); // ecx
  _DWORD *v11; // eax
  Data_t_bstr_t *v12; // esi
  OLECHAR *v13; // eax
  Data_t_bstr_t *v14; // eax
  BSTR v15; // eax
  DLLLISTITEMPARAM *v16; // eax
  _bstr_t v17; // [esp+10h] [ebp-28h]
  _bstr_t v18; // [esp+14h] [ebp-24h]
  char v19; // [esp+18h] [ebp-20h]
  OLECHAR *psz; // [esp+1Ch] [ebp-1Ch]
  DLLLISTITEMPARAM *pItemParam_2; // [esp+20h] [ebp-18h]
  _bstr_t *v22; // [esp+24h] [ebp-14h]
  _bstr_t v23; // [esp+28h] [ebp-10h]
  int v24; // [esp+34h] [ebp-4h]

  if ( gbAgreenmentLicensed )
  {
    EnterCriticalSection(&stru_1085744);
    pItemParam_1 = 0;
    v4 = 0;
    pItemParam_2 = 0;
    v22 = 0;
    v23.m_Data = 0;
    v24 = 0;
    if ( pItemParam->m_Type )
    {
      v5 = pItemParam->m_strPath.pszData;
      pItemParam_2 = pItemParam;
      _bstr_t::operator=(&v23, v5);
      psz = pItemParam->m_strLocation;
    }
    else
    {
      pItemParam_1 = pItemParam;
      _bstr_t::operator=(&v23, pItemParam[2].field_8);
      psz = pItemParam[2].field_2C;
    }
    v6 = *sub_1002F90(&gHttpInfo.field_1C, &v18, &v23);
    if ( v6 == gHttpInfo.field_1C
      || ((v7 = *(v6 + 20), !pItemParam_1) ? (pItemParam_2->m_HashData = v7) : (pItemParam_1[2].field_3C = v7),
          (v4 = *(v6 + 20), v22 = v4, v8 = v4[1].m_Data, v8 == 6) || v8 == 5) )
    {
      v9 = a3;
      if ( a3 != 2 )
      {
        v10 = InterlockedIncrement;
        if ( !v4 )
        {
          v11 = operator new(0x2Cu);
          if ( v11 )
            v4 = sub_F91350(v11);
          else
            v4 = 0;
          v12 = v23.m_Data;
          LOBYTE(v4->m_Data) = a2;
          v22 = v4;
          if ( &v4[5] != &v23 )
          {
            _bstr_t::_Free(v4 + 5);
            v4[5].m_Data = v12;
            if ( v12 )
              InterlockedIncrement(&v12->m_RefCount);
          }
          v13 = &gszNullString;
          if ( psz )
            v13 = psz;
          psz = _bstr_t::_bstr_t(&v18, v13);
          if ( &v4[2] != psz )
          {
            _bstr_t::_Free(v4 + 2);
            v14 = *psz;
            v4[2].m_Data = *psz;
            if ( v14 )
              InterlockedIncrement(&v14->m_RefCount);
          }
          _bstr_t::_Free(&v18);
          v18.m_Data = _bstr_t::_bstr_t(&psz, &gszNullString);
          if ( &v4[3] != v18.m_Data )
          {
            _bstr_t::_Free(v4 + 3);
            v15 = v18.m_Data->m_wstr;
            v4[3].m_Data = v18.m_Data->m_wstr;
            if ( v15 )
              InterlockedIncrement(v15 + 2);
          }
          _bstr_t::_Free(&psz);
          v17.m_Data = v12;
          if ( v12 )
            InterlockedIncrement(&v12->m_RefCount);
          v18.m_Data = v4;
          LOBYTE(v24) = 1;
          sub_1001650(&gHttpInfo.field_1C, &v19, 0, &v17, byte_1085775);
          LOBYTE(v24) = 0;
          _bstr_t::_Free(&v17);
          v10 = InterlockedIncrement;
          v9 = a3;
        }
        v4[1].m_Data = (3 - (v9 != 1));
        if ( pItemParam_1 )
        {
          pItemParam_1[2].field_3C = v4;
          v16 = (pItemParam_1 + 36);
        }
        else
        {
          v16 = pItemParam_2;
          pItemParam_2->m_HashData = v4;
        }
        v10(&v16->m_nRefCount);
        if ( v9 == 1 )
        {
          sub_F99380(&off_10857A4, &v22);
          SetEvent(ghEventHandle3);
        }
        else
        {
          sub_F917F0(&dword_108579C, &v22);
          SetEvent(ghEventHandle2);
        }
      }
    }
    LeaveCriticalSection(&stru_1085744);
    _bstr_t::_Free(&v23);
  }
}
// 1085774: using guessed type char gbAgreenmentLicensed;
// 1085775: using guessed type char byte_1085775;

//----- (01001EC0) --------------------------------------------------------
int __stdcall BackendThreadProc2(void *a1)
{
  void (__stdcall *v1)(LPCRITICAL_SECTION); // ebx
  void (__stdcall *v2)(LPCRITICAL_SECTION); // esi
  EventListNode *v3; // ST0C_4
  int *v4; // ecx
  _DWORD *v5; // edi
  int v6; // eax
  Data_t_bstr_t *v7; // eax
  Data_t_bstr_t *v8; // esi
  BSTR v9; // eax
  Data_t_bstr_t *v10; // ecx
  int v11; // eax
  bool v12; // bl
  const wchar_t **v13; // eax
  const wchar_t *v14; // eax
  EventListNode *v15; // ebx
  _DWORD *v16; // eax
  void (__stdcall *v17)(HWND, UINT, WPARAM, LPARAM); // ebx
  const wchar_t **v18; // eax
  const wchar_t *v19; // eax
  EventList *v20; // ebx
  _DWORD *v21; // eax
  int v22; // esi
  HANDLE Handles; // [esp+10h] [ebp-24h]
  HANDLE v25; // [esp+14h] [ebp-20h]
  void *v26; // [esp+18h] [ebp-1Ch]
  OLECHAR psz[2]; // [esp+1Ch] [ebp-18h]
  int a3; // [esp+20h] [ebp-14h]
  char v29; // [esp+27h] [ebp-Dh]
  int v30; // [esp+30h] [ebp-4h]

  Handles = ghEventHandle3;
  v25 = ghEventHandle;
  *psz = 0;
  v30 = 0;
  if ( WaitForMultipleObjects(2u, &Handles, 0, 0xFFFFFFFF) != 1 )
  {
    v1 = EnterCriticalSection;
    v2 = LeaveCriticalSection;
    while ( 1 )
    {
      v1(&stru_1085744);
      if ( dword_10857A8 )
        break;
LABEL_42:
      v2(&stru_1085744);
      if ( WaitForMultipleObjects(2u, &Handles, 0, 0xFFFFFFFF) == 1 )
        goto LABEL_43;
    }
    while ( 1 )
    {
      v3 = off_10857A4->_Myheader;
      v4 = off_10857A4->_Myheader->field_4;
      v6 = off_10857A4->_Myheader->field_0;
      a3 = off_10857A4->_Myheader[1].field_0;
      v5 = a3;
      *v4 = v6;
      *(v3->field_0 + 4) = v3->field_4;
      --dword_10857A8;
      j__free(v3);
      v2(&stru_1085744);
      sub_FA55A0(&gHttpInfo, (v5 + 2), psz);
      v1(&stru_1085744);
      v29 = 0;
      v7 = operator new(0xCu);
      v8 = v7;
      v26 = v7;
      LOBYTE(v30) = 1;
      if ( v7 )
      {
        v7->m_str = 0;
        v7->m_RefCount = 1;
        v9 = SysAllocString(&gszNullString);
        v8->m_wstr = v9;
        if ( !v9 )
          goto LABEL_6;
      }
      else
      {
        v8 = 0;
      }
      LOBYTE(v30) = 0;
      if ( !v8 )
LABEL_6:
        _com_issue_error(-2147024882);
      v10 = v5[8];
      if ( v10 == v8 )
        break;
      if ( v10 )
      {
        v11 = bstr_t::Data_t::Compare(v10, v8);
      }
      else
      {
        if ( !v8->m_wstr || !SysStringLen(v8->m_wstr) )
          break;
        v11 = -1;
      }
LABEL_16:
      v12 = v11 != 0;
      if ( !InterlockedDecrement(&v8->m_RefCount) )
      {
        if ( v8->m_wstr )
        {
          SysFreeString(v8->m_wstr);
          v8->m_wstr = 0;
        }
        if ( v8->m_str )
        {
          j_j__free(v8->m_str);
          v8->m_str = 0;
        }
        j__free(v8);
      }
      if ( !v12 )
      {
        v18 = v5[10];
        if ( v18 )
          v19 = *v18;
        else
          v19 = 0;
        if ( _wcsicmp(v19, L"Submitted") )
        {
          v5[1] = 1;
        }
        else
        {
          v20 = off_10857AC;
          v21 = std::_List_buy<tagEventItem *,std::allocator<tagEventItem *>>::_Buynode<tagEventItem * const &>(
                  off_10857AC,
                  off_10857AC->_Mysize,
                  &a3);
          if ( (357913940 - dword_10857B0) < 1 )
LABEL_52:
            std::_Xlength_error("list<T> too long");
          ++dword_10857B0;
          v20->_Mysize = v21;
          *v21[1] = v21;
          v5[1] = 4;
        }
        v29 = 1;
        goto LABEL_38;
      }
      v13 = v5[8];
      if ( v13 )
        v14 = *v13;
      else
        v14 = 0;
      if ( wcsstr(v14, L"throttle") )
      {
        v15 = off_10857A4->_Myheader;
        v16 = std::_List_buy<tagEventItem *,std::allocator<tagEventItem *>>::_Buynode<tagEventItem * const &>(
                off_10857A4->_Myheader,
                off_10857A4->_Myheader->field_4,
                &a3);
        if ( (357913940 - dword_10857A8) < 1 )
          goto LABEL_52;
        ++dword_10857A8;
        v15->field_4 = v16;
        *v16[1] = v16;
        SetEvent(ghEventHandle3);
LABEL_38:
        v17 = PostMessageW;
        goto LABEL_39;
      }
      v17 = PostMessageW;
      v5[1] = 5;
      v29 = 1;
      PostMessageW(ghMainWnd, 0x7F9u, 0, v5);
LABEL_39:
      v2 = LeaveCriticalSection;
      LeaveCriticalSection(&stru_1085744);
      if ( v29 )
        v17(ghMainWnd, 0x7F9u, 0, v5);
      v1 = EnterCriticalSection;
      EnterCriticalSection(&stru_1085744);
      if ( !dword_10857A8 )
        goto LABEL_42;
    }
    v11 = 0;
    goto LABEL_16;
  }
LABEL_43:
  v22 = *psz;
  if ( *psz && !InterlockedDecrement((*psz + 8)) && v22 )
  {
    if ( *v22 )
    {
      SysFreeString(*v22);
      *v22 = 0;
    }
    if ( *(v22 + 4) )
    {
      j_j__free(*(v22 + 4));
      *(v22 + 4) = 0;
    }
    j__free(v22);
  }
  return 0;
}
// F9C3D4: using guessed type int (__stdcall *)(_DWORD);
// 10857A8: using guessed type int dword_10857A8;
// 10857B0: using guessed type int dword_10857B0;

//----- (01002230) --------------------------------------------------------
int __stdcall BackendThreadProc1(int a1)
{
  int v1; // edi
  EventList *v2; // ebx
  void (__stdcall *v3)(LPCRITICAL_SECTION); // esi
  _DWORD *v4; // ST514_4
  _DWORD *v5; // ecx
  int v6; // ebx
  int v7; // eax
  OLECHAR **v8; // eax
  OLECHAR *v9; // eax
  _DWORD *v10; // ecx
  const WCHAR *v11; // ecx
  OLECHAR **v12; // eax
  OLECHAR *v13; // eax
  EventList *v14; // esi
  _DWORD *v15; // eax
  _DWORD *v16; // ecx
  DWORD v17; // eax
  void **v18; // edi
  void *v19; // esi
  void *v20; // esi
  EventList *v21; // esi
  EventListNode *v22; // ebx
  Data_t_bstr_t *v23; // eax
  Data_t_bstr_t *v24; // edi
  BSTR v25; // eax
  Data_t_bstr_t *v26; // ecx
  int v27; // eax
  const wchar_t **v28; // eax
  const wchar_t *v29; // eax
  _DWORD *v30; // eax
  OLECHAR **v31; // eax
  OLECHAR *v32; // eax
  const wchar_t **v33; // eax
  const wchar_t *v34; // eax
  _DWORD *v35; // eax
  _DWORD *v36; // eax
  EventList *v37; // eax
  EventListNode *v38; // esi
  EventList *v39; // eax
  EventListNode *v40; // esi
  HANDLE Handles; // [esp+10h] [ebp-B4h]
  HANDLE v43; // [esp+14h] [ebp-B0h]
  int v44; // [esp+18h] [ebp-ACh]
  EventList **v45; // [esp+1Ch] [ebp-A8h]
  int v46; // [esp+20h] [ebp-A4h]
  void *v47; // [esp+24h] [ebp-A0h]
  int a3; // [esp+28h] [ebp-9Ch]
  void *v49; // [esp+2Ch] [ebp-98h]
  bool v50; // [esp+32h] [ebp-92h]
  char v51; // [esp+33h] [ebp-91h]
  OLECHAR psz; // [esp+34h] [ebp-90h]
  int v53; // [esp+C0h] [ebp-4h]

  v1 = 0;
  Handles = ghEventHandle2;
  v43 = ghEventHandle;
  v46 = 0;
  v2 = std::_List_alloc<std::_List_base_types<tagEventItem *,std::allocator<tagEventItem *>>>::_Buynode0(0, 0);
  v45 = v2;
  v53 = 0;
  v44 = 0;
  while ( WaitForMultipleObjects(2u, &Handles, 0, 0xFFFFFFFF) != 1 )
  {
    v3 = LeaveCriticalSection;
    Sleep(0x1388u);
    EnterCriticalSection(&stru_1085744);
    if ( dword_10857A0 )
    {
      do
      {
        v4 = *dword_108579C;
        v5 = *(*dword_108579C + 4);
        v7 = **dword_108579C;
        a3 = *(*dword_108579C + 8);
        v6 = a3;
        *v5 = v7;
        *(*v4 + 4) = v4[1];
        --dword_10857A0;
        j__free(v4);
        v3(&stru_1085744);
        v8 = *(v6 + 16);
        if ( !v8 || (v9 = *v8) == 0 || !SysStringLen(v9) )
        {
          v10 = *(v6 + 20);
          v11 = (v10 ? *v10 : 0);
          if ( sub_1001840(v11, &psz, v6 + 24) )
            _bstr_t::operator=((v6 + 16), &psz);
        }
        v12 = *(v6 + 16);
        if ( v12 && (v13 = *v12) != 0 && SysStringLen(v13) )
        {
          ++v44;
          v14 = *v45;
          v15 = std::_List_buy<tagEventItem *,std::allocator<tagEventItem *>>::_Buynode<tagEventItem * const &>(
                  *v45,
                  (*v45)->_Mysize,
                  &a3);
          if ( (357913940 - v1) < 1 )
LABEL_89:
            std::_Xlength_error("list<T> too long");
          v14->_Mysize = v15;
          ++v1;
          v16 = v15[1];
          v46 = v1;
          *v16 = v15;
          sub_FA5160(&gHttpInfo, v6 + 8);
        }
        else
        {
          v17 = GetLastError();
          sub_FA4320(&v47, v17);
          v18 = (v6 + 32);
          if ( (v6 + 32) != &v47 )
          {
            v19 = *v18;
            if ( *v18 )
            {
              if ( !InterlockedDecrement(v19 + 2) && v19 )
              {
                if ( *v19 )
                {
                  SysFreeString(*v19);
                  *v19 = 0;
                }
                if ( *(v19 + 1) )
                {
                  j_j__free(*(v19 + 1));
                  *(v19 + 1) = 0;
                }
                j__free(v19);
              }
              *v18 = 0;
            }
            *v18 = v47;
            if ( v47 )
              InterlockedIncrement(v47 + 2);
          }
          *(v6 + 4) = 5;
          v20 = v47;
          if ( v47 )
          {
            if ( !InterlockedDecrement(v47 + 2) && v20 )
            {
              if ( *v20 )
              {
                SysFreeString(*v20);
                *v20 = 0;
              }
              if ( *(v20 + 1) )
              {
                j_j__free(*(v20 + 1));
                *(v20 + 1) = 0;
              }
              j__free(v20);
            }
            v47 = 0;
          }
          v1 = v46;
        }
        EnterCriticalSection(&stru_1085744);
        v3 = LeaveCriticalSection;
      }
      while ( dword_10857A0 );
      v2 = v45;
    }
    v3(&stru_1085744);
    sub_FA1FC0(&gHttpInfo);
    v21 = v2->_Myheader;
    if ( v2->_Myheader != v2 )
    {
      while ( 1 )
      {
        EnterCriticalSection(&stru_1085744);
        v22 = v21[1]._Myheader;
        v51 = 0;
        a3 = v22;
        v23 = operator new(0xCu);
        v24 = v23;
        v49 = v23;
        LOBYTE(v53) = 1;
        if ( v23 )
        {
          v23->m_str = 0;
          v23->m_RefCount = 1;
          v25 = SysAllocString(&gszNullString);
          v24->m_wstr = v25;
          if ( !v25 )
            goto LABEL_44;
        }
        else
        {
          v24 = 0;
        }
        LOBYTE(v53) = 0;
        if ( !v24 )
LABEL_44:
          _com_issue_error(-2147024882);
        v26 = v22[4].field_0;
        if ( v26 == v24 )
          break;
        if ( v26 )
        {
          v27 = bstr_t::Data_t::Compare(v26, v24);
        }
        else
        {
          if ( !v24->m_wstr || !SysStringLen(v24->m_wstr) )
            break;
          v27 = -1;
        }
LABEL_54:
        v50 = v27 != 0;
        if ( !InterlockedDecrement(&v24->m_RefCount) )
        {
          if ( v24->m_wstr )
          {
            SysFreeString(v24->m_wstr);
            v24->m_wstr = 0;
          }
          if ( v24->m_str )
          {
            j_j__free(v24->m_str);
            v24->m_str = 0;
          }
          j__free(v24);
        }
        if ( v50 )
        {
          v28 = v22[4].field_0;
          if ( v28 )
            v29 = *v28;
          else
            v29 = 0;
          if ( wcsstr(v29, L"Throttle") )
          {
            v49 = *dword_108579C;
            v30 = std::_List_buy<tagEventItem *,std::allocator<tagEventItem *>>::_Buynode<tagEventItem * const &>(
                    v49,
                    *(v49 + 1),
                    &a3);
            if ( (357913940 - dword_10857A0) < 1 )
              goto LABEL_89;
            ++dword_10857A0;
            *(v49 + 1) = v30;
            *v30[1] = v30;
            SetEvent(ghEventHandle2);
            goto LABEL_83;
          }
          v22->field_4 = 5;
        }
        else
        {
          v31 = v22[4].field_4;
          if ( v31 && (v32 = *v31) != 0 && SysStringLen(v32) )
          {
            v33 = v22[5].field_0;
            if ( v33 )
              v34 = *v33;
            else
              v34 = 0;
            if ( _wcsicmp(v34, L"Submitted") )
            {
              v22->field_4 = 1;
            }
            else
            {
              v49 = *dword_108579C;
              v35 = std::_List_buy<tagEventItem *,std::allocator<tagEventItem *>>::_Buynode<tagEventItem * const &>(
                      v49,
                      *(v49 + 1),
                      &a3);
              if ( (357913940 - dword_10857A0) < 1 )
                goto LABEL_89;
              ++dword_10857A0;
              *(v49 + 1) = v35;
              *v35[1] = v35;
              SetEvent(ghEventHandle2);
            }
          }
          else
          {
            v22->field_4 = 6;
            if ( gConfig.bVirusTotalSubmitUnknown && LOBYTE(v22->field_0) )
            {
              v22->field_4 = 3;
              v49 = off_10857A4;
              v36 = std::_List_buy<tagEventItem *,std::allocator<tagEventItem *>>::_Buynode<tagEventItem * const &>(
                      off_10857A4,
                      off_10857A4->_Mysize,
                      &a3);
              if ( (357913940 - dword_10857A8) < 1 )
                goto LABEL_89;
              ++dword_10857A8;
              *(v49 + 1) = v36;
              *v36[1] = v36;
              SetEvent(ghEventHandle3);
            }
          }
        }
        v51 = 1;
LABEL_83:
        LeaveCriticalSection(&stru_1085744);
        if ( v51 )
          PostMessageW(ghMainWnd, 0x7F9u, 0, v22);
        v21 = v21->_Myheader;
        v2 = v45;
        if ( v21 == v45 )
          goto LABEL_86;
      }
      v27 = 0;
      goto LABEL_54;
    }
LABEL_86:
    v37 = v2->_Myheader;
    v1 = 0;
    v2->_Myheader = v2;
    v2->_Mysize = v2;
    v46 = 0;
    if ( v37 != v2 )
    {
      do
      {
        v38 = v37->_Myheader;
        j__free(v37);
        v37 = v38;
      }
      while ( v38 != v2 );
    }
  }
  v39 = v2->_Myheader;
  v2->_Myheader = v2;
  v2->_Mysize = v2;
  if ( v39 != v2 )
  {
    do
    {
      v40 = v39->_Myheader;
      j__free(v39);
      v39 = v40;
    }
    while ( v40 != v2 );
  }
  j__free(v2);
  return 0;
}
// 10857A0: using guessed type int dword_10857A0;
// 10857A8: using guessed type int dword_10857A8;

//----- (01002860) --------------------------------------------------------
LRESULT __stdcall EditVTClassCallback(HWND hWnd, UINT uMsg, WPARAM wParam, LPARAM lParam, UINT_PTR uIdSubclass, DWORD_PTR dwRefData)
{
  HWND v6; // eax
  DLLINFOLISTITEMPARAM *v7; // eax
  int v8; // eax
  const WCHAR **v9; // eax
  const WCHAR *v10; // eax
  int v12; // eax
  HCURSOR v13; // eax

  v6 = GetParent(hWnd);
  v7 = GetWindowLongW(v6, GWLP_USERDATA);
  if ( v7->m_dwType )
    v8 = v7->m_ItemData1;
  else
    v8 = v7[2].field_3C;
  if ( uMsg != WM_MOUSEMOVE )
  {
    if ( uMsg == 514 && v8 && (*(v8 + 4) == 1 || *(v8 + 4) == 4) )
    {
      v9 = *(v8 + 36);
      if ( v9 )
        v10 = *v9;
      else
        v10 = 0;
      LaunchWebBrowser(hWnd, 0, v10);
    }
    return DefSubclassProc(hWnd, uMsg, wParam, lParam);
  }
  if ( !v8 )
    return DefSubclassProc(hWnd, uMsg, wParam, lParam);
  v12 = *(v8 + 4) - 1;
  if ( v12 )
  {
    if ( v12 != 3 )
      return DefSubclassProc(hWnd, uMsg, wParam, lParam);
  }
  v13 = LoadCursorW(ghInstance, L"HAND");
  SetCursor(v13);
  return 1;
}

//----- (01002910) --------------------------------------------------------
char __cdecl sub_1002910(ListItemData1 *a1)
{
  wchar_t **v1; // eax
  wchar_t *v2; // eax
  char result; // al
  int v4; // [esp+4h] [ebp-8h]
  int v5; // [esp+8h] [ebp-4h]

  v5 = 0;
  v4 = 0;
  if ( a1->field_4 != 1 )
    return 0;
  v1 = a1[5].field_0;
  if ( v1 )
    v2 = *v1;
  else
    v2 = 0;
  scan_fn(v2, L"%d/%d", &v5);
  result = 0;
  if ( v5 )
    result = 1;
  return result;
}
// 1032BB0: using guessed type wchar_t aDD[6];

//----- (01002970) --------------------------------------------------------
int __stdcall BackendThreadProc3(void *a1)
{
  DWORD (__stdcall *v1)(HANDLE, DWORD); // edi
  EventList *v2; // esi
  EventListNode *v3; // edi
  const wchar_t **v4; // eax
  const wchar_t *v5; // eax
  EventList *v6; // eax

  v1 = WaitForSingleObject;
  while ( v1(ghEventHandle, 0x2710u) == 258 )
  {
    if ( !sub_FA37E0(&gHttpInfo) )
    {
      v2 = off_10857AC->_Myheader;
      if ( off_10857AC->_Myheader != off_10857AC )
      {
        do
        {
          EnterCriticalSection(&stru_1085744);
          v3 = v2[1]._Myheader;
          v4 = v3[5].field_0;
          if ( v4 )
            v5 = *v4;
          else
            v5 = 0;
          if ( _wcsicmp(v5, L"Submitted") )
          {
            v6 = v2;
            v3->field_4 = 1;
            v2 = v2->_Myheader;
            *v6->_Mysize = v6->_Myheader;
            v6->_Myheader->field_4 = v6->_Mysize;
            --dword_10857B0;
            j__free(v6);
          }
          else
          {
            v2 = v2->_Myheader;
          }
          LeaveCriticalSection(&stru_1085744);
        }
        while ( v2 != off_10857AC );
        v1 = WaitForSingleObject;
      }
      PostMessageW(ghMainWnd, 0x7F9u, 0, 0);
    }
  }
  return 0;
}
// 10857B0: using guessed type int dword_10857B0;

//----- (01002A70) --------------------------------------------------------
_DWORD *__stdcall std::_List_alloc<std::_List_base_types<tagEventItem *,std::allocator<tagEventItem *>>>::_Buynode0(_DWORD *a1, _DWORD *a2)
{
  _DWORD *result; // eax
  _DWORD *v3; // ecx
  _DWORD *v4; // edx

  result = operator new(0xCu);
  if ( !result )
    std::_Xbad_alloc();
  v3 = a1;
  if ( a1 )
  {
    v4 = a2;
  }
  else
  {
    v3 = result;
    v4 = result;
  }
  *result = v3;
  if ( result != -4 )
    result[1] = v4;
  return result;
}

//----- (01002AB0) --------------------------------------------------------
void __stdcall sub_1002AB0(void *a1)
{
  _DWORD *v1; // edi
  void *i; // ebx
  int v3; // esi

  v1 = a1;
  for ( i = a1; !*(i + 13); v1 = i )
  {
    sub_1002AB0(*(i + 2));
    v3 = v1[4];
    i = *i;
    if ( v3 )
    {
      if ( !InterlockedDecrement((v3 + 8)) && v3 )
      {
        if ( *v3 )
        {
          SysFreeString(*v3);
          *v3 = 0;
        }
        if ( *(v3 + 4) )
        {
          j_j__free(*(v3 + 4));
          *(v3 + 4) = 0;
        }
        j__free(v3);
      }
      v1[4] = 0;
    }
    j__free(v1);
  }
}

//----- (01002B40) --------------------------------------------------------
_bstr_t *__thiscall sub_1002B40(void *this, _bstr_t *a2)
{
  _bstr_t *v2; // edi
  _bstr_t *v3; // esi
  Data_t_bstr_t *v4; // ecx
  Data_t_bstr_t *v6; // [esp-8h] [ebp-1Ch]
  Data_t_bstr_t *v7; // [esp-4h] [ebp-18h]

  v2 = *this;
  v3 = *(*this + 4);
  while ( !BYTE1(v3[3].m_Data) )
  {
    v7 = a2->m_Data;
    if ( a2->m_Data )
      InterlockedIncrement(&v7->m_RefCount);
    v4 = v3[4].m_Data;
    v6 = v4;
    if ( v4 )
      InterlockedIncrement(&v4->m_RefCount);
    if ( sub_F914B0(v6, v7) )
    {
      v3 = v3[2].m_Data;
    }
    else
    {
      v2 = v3;
      v3 = v3->m_Data;
    }
  }
  return v2;
}

//----- (01002BB0) --------------------------------------------------------
std__Tree_node *__thiscall sub_1002BB0(std__tree *this, std__Tree_node *a2)
{
  std__Tree_node *v2; // esi
  std__Tree_node *v3; // eax
  std__Tree_node *result; // eax

  v2 = a2->_Left;
  a2->_Left = a2->_Left->_Right;
  v3 = v2->_Right;
  if ( !v3->_IsNil )
    v3->_Parent = a2;
  v2->_Parent = a2->_Parent;
  result = this->_Mypair._Myval2._Myhead;
  if ( a2 == this->_Mypair._Myval2._Myhead->_Parent )
  {
    result->_Parent = v2;
    v2->_Right = a2;
    a2->_Parent = v2;
  }
  else
  {
    result = a2->_Parent;
    if ( a2 == result->_Right )
      result->_Right = v2;
    else
      result->_Left = v2;
    v2->_Right = a2;
    a2->_Parent = v2;
  }
  return result;
}

//----- (01002C10) --------------------------------------------------------
int **__thiscall sub_1002C10(int **this, int **a2, int **a3, int **a4)
{
  int **v4; // eax
  int **v5; // esi
  int *v6; // ecx
  int **v7; // eax
  int *v8; // ecx
  int **result; // eax
  int **v10; // ecx
  int *i; // edx
  int *v12; // eax
  char v13; // [esp+4h] [ebp-4h]

  v4 = a3;
  v5 = this;
  v6 = *this;
  if ( a3 != *v6 || a4 != v6 )
  {
    for ( ; a3 != a4; v4 = a3 )
    {
      v10 = v4;
      if ( !*(v4 + 13) )
      {
        i = v4[2];
        if ( *(i + 13) )
        {
          for ( i = v4[1]; !*(i + 13); i = i[1] )
          {
            if ( v4 != i[2] )
              break;
            v4 = i;
          }
        }
        else
        {
          v12 = *i;
          if ( !*(*i + 13) )
          {
            do
            {
              i = v12;
              v12 = *v12;
            }
            while ( !*(v12 + 13) );
          }
        }
        a3 = i;
      }
      sub_1002CD0(v5, &v13, v10);
    }
    *a2 = v4;
    result = a2;
  }
  else
  {
    sub_1002AB0(v6[1]);
    (*v5)[1] = *v5;
    **v5 = *v5;
    (*v5)[2] = *v5;
    v7 = *v5;
    v5[1] = 0;
    v8 = *v7;
    result = a2;
    *a2 = v8;
  }
  return result;
}

//----- (01002CD0) --------------------------------------------------------
_DWORD *__thiscall sub_1002CD0(_DWORD *this, _DWORD *a2, _DWORD *a3)
{
  std__tree *v3; // ebx
  _DWORD *v4; // edx
  std__Tree_node *v5; // edi
  std__Tree_node *v6; // ecx
  std__Tree_node *v7; // esi
  std__Tree_node *v8; // eax
  std__Tree_node *v9; // ecx
  std__Tree_node *v10; // eax
  std__Tree_node_For__bstr_t *v11; // eax
  std__Tree_node_For__bstr_t *i; // ecx
  std__Tree_node **v13; // eax
  bool v14; // cl
  std__Tree_node *v15; // ecx
  int v16; // esi
  unsigned int v17; // eax
  _DWORD *v18; // ecx
  _DWORD *result; // eax
  _DWORD *v20; // [esp+Ch] [ebp-8h]
  _DWORD *v21; // [esp+10h] [ebp-4h]

  v3 = this;
  v21 = a3;
  sub_F94CE0(&a3);
  v4 = v21;
  if ( *(*v21 + 13) )
  {
    v5 = v21[2];
  }
  else if ( *(v21[2] + 13) )
  {
    v5 = *v21;
  }
  else
  {
    v6 = a3;
    v20 = a3;
    v5 = a3[2];
    if ( a3 != v21 )
    {
      *(*v21 + 4) = a3;
      v6->_Left = *v21;
      if ( v6 == v21[2] )
      {
        v7 = v6;
      }
      else
      {
        v7 = v6->_Parent;
        if ( !v5->_IsNil )
          v5->_Parent = v7;
        v7->_Left = v5;
        v6->_Right = v21[2];
        *(v21[2] + 4) = v6;
      }
      if ( v3->_Mypair._Myval2._Myhead->_Parent == v21 )
      {
        v3->_Mypair._Myval2._Myhead->_Parent = v6;
      }
      else
      {
        v13 = v21[1];
        if ( *v13 == v21 )
          *v13 = v6;
        else
          v13[2] = v6;
      }
      v6->_Parent = v21[1];
      v14 = v6->_Color;
      *(v20 + 12) = *(v21 + 12);
      v4 = v21;
      *(v21 + 12) = v14;
      goto LABEL_37;
    }
  }
  v7 = v21[1];
  if ( !v5->_IsNil )
    v5->_Parent = v7;
  if ( v3->_Mypair._Myval2._Myhead->_Parent == v21 )
  {
    v3->_Mypair._Myval2._Myhead->_Parent = v5;
  }
  else if ( v7->_Left == v21 )
  {
    v7->_Left = v5;
  }
  else
  {
    v7->_Right = v5;
  }
  v8 = v3->_Mypair._Myval2._Myhead;
  if ( &v3->_Mypair._Myval2._Myhead->_Left->_Left == v21 )
  {
    if ( v5->_IsNil )
    {
      v9 = v7;
    }
    else
    {
      v10 = v5->_Left;
      v9 = v5;
      if ( !v5->_Left->_IsNil )
      {
        do
        {
          v9 = v10;
          v10 = v10->_Left;
        }
        while ( !v10->_IsNil );
      }
      v8 = v3->_Mypair._Myval2._Myhead;
    }
    v8->_Left = v9;
  }
  if ( v3->_Mypair._Myval2._Myhead->_Right == v21 )
  {
    if ( v5->_IsNil )
    {
      v3->_Mypair._Myval2._Myhead->_Right = v7;
    }
    else
    {
      v11 = v5->_Right;
      for ( i = v5; !v11->_IsNil; v11 = v11->_Right )
        i = v11;
      v3->_Mypair._Myval2._Myhead->_Right = i;
    }
  }
LABEL_37:
  if ( *(v4 + 12) != 1 )
    goto LABEL_62;
  if ( v5 == v3->_Mypair._Myval2._Myhead->_Parent )
    goto LABEL_61;
  while ( v5->_Color == 1 )
  {
    v15 = v7->_Left;
    if ( v5 == v7->_Left )
    {
      v15 = v7->_Right;
      if ( !v15->_Color )
      {
        v15->_Color = 1;
        v7->_Color = 0;
        sub_FF54B0(v3, v7);
        v15 = v7->_Right;
      }
      if ( v15->_IsNil )
        goto LABEL_55;
      if ( v15->_Left->_Color != 1 || v15->_Right->_Color != 1 )
      {
        if ( v15->_Right->_Color == 1 )
        {
          v15->_Left->_Color = 1;
          v15->_Color = 0;
          sub_1002BB0(v3, v15);
          v15 = v7->_Right;
        }
        v15->_Color = v7->_Color;
        v7->_Color = 1;
        v15->_Right->_Color = 1;
        sub_FF54B0(v3, v7);
        break;
      }
    }
    else
    {
      if ( !v15->_Color )
      {
        v15->_Color = 1;
        v7->_Color = 0;
        sub_1002BB0(v3, v7);
        v15 = v7->_Left;
      }
      if ( v15->_IsNil )
        goto LABEL_55;
      if ( v15->_Right->_Color != 1 || v15->_Left->_Color != 1 )
      {
        if ( v15->_Left->_Color == 1 )
        {
          v15->_Right->_Color = 1;
          v15->_Color = 0;
          sub_FF54B0(v3, v15);
          v15 = v7->_Left;
        }
        v15->_Color = v7->_Color;
        v7->_Color = 1;
        v15->_Left->_Color = 1;
        sub_1002BB0(v3, v7);
        break;
      }
    }
    v15->_Color = 0;
LABEL_55:
    v5 = v7;
    v7 = v7->_Parent;
    if ( v5 == v3->_Mypair._Myval2._Myhead->_Parent )
      break;
  }
  v4 = v21;
LABEL_61:
  v5->_Color = 1;
LABEL_62:
  v16 = v4[4];
  if ( v16 )
  {
    if ( !InterlockedDecrement((v16 + 8)) && v16 )
    {
      if ( *v16 )
      {
        SysFreeString(*v16);
        *v16 = 0;
      }
      if ( *(v16 + 4) )
      {
        j_j__free(*(v16 + 4));
        *(v16 + 4) = 0;
      }
      j__free(v16);
    }
    v4 = v21;
    v21[4] = 0;
  }
  j__free(v4);
  v17 = v3->_Mypair._Myval2._Mysize;
  v18 = a3;
  if ( v17 )
    v3->_Mypair._Myval2._Mysize = v17 - 1;
  result = a2;
  *a2 = v18;
  return result;
}

//----- (01002F90) --------------------------------------------------------
int *__thiscall sub_1002F90(int *this, int *a2, volatile LONG **a3)
{
  int *v3; // edi
  _bstr_t *v4; // eax
  int v5; // esi
  Data_t_bstr_t *v6; // ecx
  int *result; // eax
  Data_t_bstr_t *v8; // [esp-8h] [ebp-14h]
  Data_t_bstr_t *v9; // [esp-4h] [ebp-10h]

  v3 = this;
  v4 = sub_1002B40(this, a3);
  v5 = v4;
  if ( v4 == *v3 )
    goto LABEL_11;
  v6 = v4[4].m_Data;
  v9 = v6;
  if ( v6 )
    InterlockedIncrement(&v6->m_RefCount);
  v8 = *a3;
  if ( *a3 )
    InterlockedIncrement(&v8->m_RefCount);
  if ( sub_F914B0(v8, v9) )
  {
LABEL_11:
    result = a2;
    *a2 = *v3;
  }
  else
  {
    result = a2;
    *a2 = v5;
  }
  return result;
}

//----- (01003010) --------------------------------------------------------
HANDLE LoadSharedMemory()
{
  HANDLE v0; // eax
  void *v1; // ebx
  HANDLE result; // eax
  HANDLE v3; // eax
  char *v4; // esi
  DWORD (__stdcall *v5)(); // ebx
  const WCHAR *v6; // ecx
  HANDLE v7; // edi
  HANDLE v8; // ebx
  HANDLE hHandle; // [esp+8h] [ebp-8h]
  HANDLE hEvent; // [esp+Ch] [ebp-4h]

  LoadDbgHelp(L"Dbghelp.dll");
  v0 = CreateEventW(0, 0, 0, L"Procexp32bitServerEvent");
  v1 = v0;
  hHandle = v0;
  result = CreateEventW(0, 0, 0, L"Procexp32bitClientEvent");
  hEvent = result;
  if ( result )
  {
    if ( v1 )
    {
      v3 = CreateFileMappingW(0xFFFFFFFF, 0, 0x8000004u, 0, gSystemInfo.dwPageSize, L"Procexp32bitSection");
      v4 = MapViewOfFile(v3, 6u, 0, 0, gSystemInfo.dwPageSize);
      result = WaitForSingleObject(v1, 0xFFFFFFFF);
      if ( !result )
      {
        v5 = GetLastError;
        v6 = (v4 + 12);
        do
        {
          v7 = CreateFileW(v6, GENERIC_WRITE, 7u, 0, CREATE_ALWAYS, FILE_ATTRIBUTE_NORMAL, 0);
          if ( v7 == -1 )
          {
            *(v4 + 2) = v5();
          }
          else
          {
            v8 = OpenProcess(PROCESS_TRACE_MODE_EVENT_RECORD, 0, *v4);
            if ( v8 )
            {
              if ( !DumpFileProcess(v7, v8, v4[4]) )
                *(v4 + 2) = GetLastError();
              CloseHandle(v8);
              v5 = GetLastError;
            }
            else
            {
              v5 = GetLastError;
              *(v4 + 2) = GetLastError();
            }
            CloseHandle(v7);
          }
          SetEvent(hEvent);
          result = WaitForSingleObject(hHandle, 0xFFFFFFFF);
          v6 = (v4 + 12);
        }
        while ( !result );
      }
    }
  }
  return result;
}

//----- (01003150) --------------------------------------------------------
signed int sub_1003150()
{
  if ( GetVersion() < 6u )
    MessageBoxW(
      0,
      L"Usage: Process Explorer [/t] [/p:[r|h|l]] [/s:<PID>]\n"
       "\n"
       "/t\tStart minimized in the tray\n"
       "/p\tRun at priority: realtime (r), high (h), normal (n) or low (l)\n"
       "/s\tSelect the specified process\n",
      L"Process Explorer",
      0x40u);
  else
    MessageBoxW(
      0,
      L"Usage: Process Explorer [/e] [/t] [/p:[r|h|l]] [/s:<PID>]\n"
       "\n"
       "/e\tRequest UAC elevation\n"
       "/t\tStart minimized in the tray\n"
       "/p\tRun at priority: realtime (r), high (h), normal (n) or low (l)\n"
       "/s\tSelect the specified process\n",
      L"Process Explorer",
      0x40u);
  return -1;
}

//----- (01003190) --------------------------------------------------------
int __stdcall wWinMain(HINSTANCE hInstance, HINSTANCE hPrevInstance, LPWSTR lpCmdLine, int nShowCmd)
{
  HMODULE v4; // eax
  void (__stdcall *GetNativeSystemInfo)(); // eax
  int result; // eax
  __int16 dwVersion; // ax
  int dwPlatform; // eax
  HANDLE v9; // eax
  int nIndex_1; // esi
  wchar_t *pszArgs; // edx
  int nArgLength; // eax
  int nChar; // ecx
  int v14; // ecx
  int v15; // eax
  wchar_t *v16; // eax
  int v17; // esi
  wchar_t *v18; // ecx
  int v19; // edi
  wchar_t v20; // ax
  wchar_t *v21; // ecx
  int v22; // eax
  HANDLE v23; // eax
  DWORD v24; // eax
  HACCEL v25; // ebx
  HWND v26; // eax
  DWORD v27; // [esp-8h] [ebp-C0h]
  struct tagMSG Msg; // [esp+8h] [ebp-B0h]
  HINSTANCE hInst; // [esp+24h] [ebp-94h]
  const WCHAR *lpCmdLine_1; // [esp+28h] [ebp-90h]
  int nIndex; // [esp+2Ch] [ebp-8Ch]
  int v32; // [esp+30h] [ebp-88h]
  char v33; // [esp+33h] [ebp-85h]
  wchar_t *ppszArgs[32]; // [esp+34h] [ebp-84h]

  hInst = hInstance;
  lpCmdLine_1 = lpCmdLine;
  v33 = 0;
  v4 = LoadLibraryW(L"kernel32.dll");
  GetNativeSystemInfo = GetProcAddress(v4, "GetNativeSystemInfo");
  if ( GetNativeSystemInfo )
    GetNativeSystemInfo();
  else
    GetSystemInfo(&gSystemInfo);
  if ( Fake_IsWow64Process() )
  {
    _beginthread(LoadSharedMemory, 0, hInstance);
    if ( LaunchProcExplorer64(1, nShowCmd) )
      return 0;
    MessageBoxW(
      0,
      L"Unable to extract 64-bit image. Run Process Explorer from a writeable directory.",
      L"Process Explorer",
      0x10u);
    return 1;
  }
  gdwTebAddressOffset = 0xF60;
  dwVersion = GetVersion();
  if ( dwVersion >= 5u )
  {
    gdwVersion = 0;
    if ( dwVersion < 0xAu )
    {
      if ( dwVersion >= 6u )
      {
        dwPlatform = HIBYTE(dwVersion);
        if ( dwPlatform )
        {
          if ( dwPlatform == 1 )
            gdwVersion = WINDOWS_7;
          else
            gdwVersion = WINDOWS_8;
        }
        else
        {
          gdwVersion = WINDOWS_VISTA;
        }
      }
    }
    else
    {
      gdwVersion = WINDOWS_10;
    }
  }
  v9 = GetCurrentProcess();
  SetPriorityClass(v9, HIGH_PRIORITY_CLASS);
  nIndex_1 = 0;
  gszCmdLine = lpCmdLine;
  nIndex = 0;
  ppszArgs[0] = lpCmdLine;
  if ( *lpCmdLine )
  {
    do
    {
      pszArgs = ppszArgs[nIndex_1];
      nArgLength = 0;
      if ( *pszArgs )
      {
        nChar = 0;
        do
        {
          if ( pszArgs[nChar] == ' ' )
            break;
          nChar = ++nArgLength;
        }
        while ( pszArgs[nArgLength] );
        if ( nArgLength )
          nIndex = ++nIndex_1;
      }
      v14 = 2 * nArgLength;
      v15 = *(&v32 + nIndex_1);
      if ( !*(v15 + v14) )
        break;
      *(v15 + v14) = 0;
      nIndex_1 = nIndex;
      v16 = (v14 + *(&v32 + nIndex) + 2);
      ppszArgs[nIndex] = v16;
      if ( nIndex_1 == ' ' )
        break;
    }
    while ( *v16 );
  }
  if ( !LicenseCheck(L"Process Explorer", &nIndex, ppszArgs) )
    return 1;
  v17 = 0;
  if ( nIndex <= 0 )
  {
LABEL_61:
    if ( !CMainWnd::Create(hInst, nShowCmd) )
      return 0;
    v25 = LoadAcceleratorsW(hInst, L"PROCEXPLORER");
    if ( !GetMessageW(&Msg, 0, 0, 0) )
      return 0;
    while ( 1 )
    {
      v26 = ghWndThreadStack;
      if ( ghWndThreadStack )
      {
        if ( TranslateAcceleratorW(ghWndThreadStack, v25, &Msg) )
          goto LABEL_73;
        v26 = ghWndThreadStack;
      }
      if ( !ghFindDlg )
        goto LABEL_69;
      if ( !IsDialogMessageW(ghFindDlg, &Msg) )
      {
        v26 = ghWndThreadStack;
LABEL_69:
        if ( (!v26 || !IsDialogMessageW(v26, &Msg)) && !TranslateAcceleratorW(ghMainWnd, v25, &Msg) )
        {
          TranslateMessage(&Msg);
          DispatchMessageW(&Msg);
        }
      }
LABEL_73:
      if ( !GetMessageW(&Msg, 0, 0, 0) )
        return 0;
    }
  }
  while ( 2 )
  {
    v18 = ppszArgs[v17];
    v19 = (v18 + 1);
    do
    {
      v20 = *v18;
      ++v18;
    }
    while ( v20 );
    _wcsupr_s(ppszArgs[v17], ((v18 - v19) >> 1) + 1);
    v21 = ppszArgs[v17];
    v22 = *v21;
    if ( v22 != 47 && v22 != 45 )
    {
      if ( !wcsstr(v21, L"TASKMGR") )
        return sub_1003150();
LABEL_48:
      if ( v33 && !IsBuiltinAdministrative() )
      {
        v24 = sub_FC6180(lpCmdLine_1, nShowCmd, 0);
        if ( v24 )
        {
          if ( v24 != 1223 )
            ReportMsg(L"Error elevating", ghMainWnd);
          return 1;
        }
        return 0;
      }
      goto LABEL_61;
    }
    switch ( v21[1] )
    {
      case 0x45u:
        if ( GetVersion() < 6u )
          return sub_1003150();
        v33 = 1;
        goto LABEL_45;
      case 0x50u:
        if ( v21[2] == 58 )
        {
          switch ( v21[3] )
          {
            case 0x48u:
              goto LABEL_45;
            case 0x4Cu:
              v27 = 64;
              goto LABEL_44;
            case 0x4Eu:
              v27 = 32;
              goto LABEL_44;
            case 0x52u:
              v27 = 256;
LABEL_44:
              v23 = GetCurrentProcess();
              SetPriorityClass(v23, v27);
              goto LABEL_45;
            default:
              return sub_1003150();
          }
        }
        return sub_1003150();
      case 0x52u:
        if ( v21[2] != 84 )
          return sub_1003150();
        Command_ReplaceTaskManager(0);
        return 0;
      case 0x53u:
        if ( v21[2] != 58 )
          return sub_1003150();
        gdwProcessId_0 = _wtoi(v21 + 3);
        goto LABEL_45;
      case 0x54u:
        gbHide = 1;
LABEL_45:
        if ( ++v17 >= nIndex )
          goto LABEL_48;
        continue;
      default:
        if ( GetVersion() < 6u )
          MessageBoxW(
            0,
            L"Usage: Process Explorer [/t] [/p:[r|h|l]] [/s:<PID>]\n"
             "\n"
             "/t\tStart minimized in the tray\n"
             "/p\tRun at priority: realtime (r), high (h), normal (n) or low (l)\n"
             "/s\tSelect the specified process\n",
            L"Process Explorer",
            0x40u);
        else
          MessageBoxW(
            0,
            L"Usage: Process Explorer [/e] [/t] [/p:[r|h|l]] [/s:<PID>]\n"
             "\n"
             "/e\tRequest UAC elevation\n"
             "/t\tStart minimized in the tray\n"
             "/p\tRun at priority: realtime (r), high (h), normal (n) or low (l)\n"
             "/s\tSelect the specified process\n",
            L"Process Explorer",
            0x40u);
        result = -1;
        break;
    }
    return result;
  }
}
// 1041D84: using guessed type wchar_t aErrorElevating[16];
// 105E100: using guessed type int gdwProcessId_0;
// 1064E54: using guessed type int gdwVersion;
// 106A388: using guessed type char gbHide;
// 106A38C: using guessed type int gszCmdLine;
// 106B1CC: using guessed type int gdwTebAddressOffset;

//----- (010036C0) --------------------------------------------------------
wchar_t *__cdecl sub_10036C0(wchar_t *Src)
{
  size_t v2; // eax
  rsize_t v3; // ebx
  wchar_t *v4; // eax
  wchar_t *v5; // esi

  if ( !Src )
    return 0;
  v2 = wcsnlen(Src, 0xFFu);
  v3 = v2 + 1;
  v4 = malloc(2 * (v2 + 1));
  v5 = v4;
  if ( !v4 || !wcscpy_s(v4, v3, Src) )
    return v5;
  free(v5);
  return 0;
}

//----- (01003720) --------------------------------------------------------
int __cdecl sub_1003720(int a1, int a2, wchar_t *a3, int a4, int a5)
{
  int *v5; // edi
  void *v6; // esi
  int v8; // edi

  v5 = a1;
  if ( !a1 || !a2 || !a3 || !a4 || !a5 )
    return -2147024809;
  v6 = malloc(0x190u);
  if ( !v6 )
    return -2147024882;
  a1 = 0;
  v8 = sub_10037B0(v5, a2, v6, &a1);
  if ( !v8 )
    v8 = sub_10038A0(a3, v6, a1, a4, a5);
  free(v6);
  return v8;
}

//----- (010037B0) --------------------------------------------------------
int __cdecl sub_10037B0(int *a1, int a2, int a3, _DWORD *a4)
{
  int *v4; // ecx
  int v5; // edi
  _DWORD *v6; // esi
  int v7; // eax
  int result; // eax
  int *v9; // ecx
  int v10; // ebx
  int v11; // [esp+8h] [ebp-8h]
  int v12; // [esp+Ch] [ebp-4h]

  v4 = a1;
  if ( !a1 )
    return -2147024809;
  if ( !a2 )
    return -2147024809;
  v5 = a3;
  if ( !a3 )
    return -2147024809;
  v6 = a4;
  if ( !a4 )
    return -2147024809;
  v7 = *a1;
  a1 = 0;
  v12 = 0;
  v11 = 0;
  result = (*(v7 + 80))(v4, L"WQL", a2, 48, 0, &a1);
  if ( result >= 0 )
  {
    v9 = a1;
    if ( a1 )
    {
      while ( 1 )
      {
        v10 = (*(*v9 + 16))(v9, -1, 1, &v12, &v11);
        if ( v10 < 0 )
        {
          if ( a1 )
            (*(*a1 + 8))(a1);
          return v10;
        }
        if ( !v11 )
          break;
        *(v5 + 4 * (*v6)++) = v12;
        if ( *v6 >= 0x64u )
        {
          (*(*v12 + 8))(v12);
          break;
        }
        v9 = a1;
        if ( !a1 )
          goto LABEL_11;
      }
      if ( !a1 )
        goto LABEL_11;
      (*(*a1 + 8))(a1);
      result = 0;
    }
    else
    {
LABEL_11:
      result = 0;
    }
  }
  return result;
}

//----- (010038A0) --------------------------------------------------------
int __cdecl sub_10038A0(wchar_t *a1, int a2, int a3, int a4, int a5)
{
  unsigned int v5; // edi
  int v6; // esi
  VARIANTARG pvarg; // [esp+4h] [ebp-18h]
  unsigned int v9; // [esp+14h] [ebp-8h]
  int Value; // [esp+18h] [ebp-4h]

  if ( !a1 || !a2 || !a4 || !a5 )
    return -2147024809;
  VariantInit(&pvarg);
  v5 = 0;
  if ( !a3 )
    return 0;
  do
  {
    v6 = *(a2 + 4 * v5);
    *(a2 + 4 * v5) = 0;
    if ( (*(*v6 + 16))(v6, L"hostprocessidentifier", 0, &pvarg, 0, 0)
      || pvarg.vt != 3
      || !pvarg.lVal
      || (Value = 0, _set_errno(0), v9 = wcstoul(a1, 0, 10), _get_errno(&Value), v9 == -1)
      || Value
      || pvarg.lVal != v9 )
    {
      (*(*v6 + 8))(v6);
    }
    else
    {
      *(a4 + 4 * (*a5)++) = v6;
      if ( *a5 >= 0x64u )
      {
        (*(*v6 + 8))(v6);
        return 0;
      }
    }
    ++v5;
  }
  while ( v5 < a3 );
  return 0;
}
// 1047564: using guessed type wchar_t aHostprocesside[22];

//----- (010039A0) --------------------------------------------------------
MACRO_HRESULT __cdecl sub_10039A0(int *a1)
{
  int v2; // edi
  void **v3; // esi

  if ( !a1 )
    return E_INVALIDARG;
  v2 = *a1;
  while ( v2 )
  {
    v3 = v2;
    v2 = *(v2 + 12);
    free(*v3);
    free(v3[1]);
    free(v3[2]);
    free(v3);
  }
  *a1 = 0;
  return 0;
}

//----- (01003A00) --------------------------------------------------------
int __cdecl sub_1003A00(int ArgList, int a2)
{
  signed int v2; // ebx
  _DWORD *v3; // esi
  HRESULT v4; // eax
  int v5; // eax
  HRESULT v6; // eax
  _DWORD *v7; // eax
  int v8; // eax
  int v9; // edi
  int v10; // esi
  int v11; // ebx
  __m128i *v12; // eax
  __int64 v14; // [esp+8h] [ebp-2A0h]
  int v15; // [esp+10h] [ebp-298h]
  _DWORD *v16; // [esp+14h] [ebp-294h]
  int v17; // [esp+18h] [ebp-290h]
  LPVOID ppv; // [esp+1Ch] [ebp-28Ch]
  IUnknown *pProxy; // [esp+20h] [ebp-288h]
  wchar_t Dst; // [esp+24h] [ebp-284h]
  char v21; // [esp+9Ch] [ebp-20Ch]
  wchar_t Src; // [esp+224h] [ebp-84h]

  MakeDeviceName(&Src, L"%d", ArgList);
  if ( !a2 )
    return -2147024809;
  ppv = 0;
  v2 = 0;
  pProxy = 0;
  v3 = 0;
  v4 = CoCreateInstance(&CLSID_WbemLocator, 0, 1u, &IID_IWbemLocator, &ppv);
  if ( v4 < 0 )
  {
    v2 = v4;
    goto LABEL_24;
  }
  v5 = (*(*ppv + 12))(ppv, L"root/cimv2", 0, 0, 0, 0, 0, 0, &pProxy);
  if ( v5 < 0 )
  {
    v2 = v5;
    goto LABEL_24;
  }
  v6 = CoSetProxyBlanket(pProxy, 0xAu, 0, 0, 3u, 3u, 0, 0);
  if ( v6 < 0 )
  {
    v2 = v6;
    goto LABEL_24;
  }
  qmemcpy(&Dst, L"select * from msft_providers where HostProcessIdentifier = ", 0x78u);
  memset(&v21, 0, 0x186u);
  if ( wcscat_s(&Dst, 0xFFu, &Src) )
  {
    v2 = -2147418113;
    v3 = 0;
    goto LABEL_24;
  }
  v7 = malloc(0x190u);
  v3 = v7;
  v16 = v7;
  if ( !v7 )
  {
    v2 = -2147024882;
    goto LABEL_24;
  }
  v17 = 0;
  if ( sub_10037B0(pProxy, &Dst, v7, &v17) )
  {
    v8 = sub_1003720(pProxy, L"select * from msft_providers", &Src, v3, &v17);
    if ( v8 )
    {
      v2 = v8;
      goto LABEL_24;
    }
  }
  v9 = 0;
  if ( v17 > 0 )
  {
    while ( 1 )
    {
      v10 = v3[v9];
      v14 = 0i64;
      v15 = 0;
      if ( !sub_1003CB0(v10, ppv, &v14) )
      {
        v11 = v15;
        if ( v15 )
        {
          if ( v14 && HIDWORD(v14) )
          {
            v12 = malloc(0x10u);
            if ( !v12 )
            {
              (*(*v10 + 8))(v10);
              v3 = v16;
              v2 = -2147024882;
              break;
            }
            _mm_storel_epi64(v12, _mm_loadl_epi64(&v14));
            v12->m128i_i32[2] = v11;
            v12->m128i_i32[3] = *a2;
            *a2 = v12;
          }
        }
      }
      (*(*v10 + 8))(v10);
      v3 = v16;
      if ( ++v9 >= v17 )
      {
        v2 = 0;
        break;
      }
    }
  }
LABEL_24:
  if ( pProxy )
    pProxy->lpVtbl->Release(pProxy);
  if ( ppv )
    (*(*ppv + 8))(ppv);
  if ( v3 )
    free(v3);
  return v2;
}
// 1047494: using guessed type wchar_t aRootCimv2[11];
// 10474B0: using guessed type wchar_t aSelectFromMsft[60];
// 1047528: using guessed type wchar_t aSelectFromMsft_0[29];

//----- (01003CB0) --------------------------------------------------------
signed int __cdecl sub_1003CB0(int a1, int a2, void **a3)
{
  void **v3; // edi
  signed int v4; // ebx
  int v5; // eax
  int v6; // eax
  int v7; // eax
  int v8; // eax
  int v9; // eax
  int v10; // eax
  const wchar_t *v11; // esi
  wchar_t *v12; // eax
  wchar_t *v13; // eax
  wchar_t *v14; // eax
  VARIANTARG v16; // [esp+8h] [ebp-654h]
  VARIANTARG pvarg; // [esp+18h] [ebp-644h]
  VARIANTARG v18; // [esp+28h] [ebp-634h]
  DWORD cbData; // [esp+38h] [ebp-624h]
  int v20; // [esp+3Ch] [ebp-620h]
  int v21; // [esp+40h] [ebp-61Ch]
  HKEY phkResult; // [esp+44h] [ebp-618h]
  int v23; // [esp+48h] [ebp-614h]
  int v24; // [esp+4Ch] [ebp-610h]
  int v25; // [esp+50h] [ebp-60Ch]
  void **v26; // [esp+54h] [ebp-608h]
  wchar_t Data[256]; // [esp+58h] [ebp-604h]
  wchar_t Dst; // [esp+258h] [ebp-404h]
  char v29; // [esp+2B2h] [ebp-3AAh]
  WCHAR SubKey[8]; // [esp+458h] [ebp-204h]
  __int128 v31; // [esp+468h] [ebp-1F4h]
  __int128 v32; // [esp+478h] [ebp-1E4h]
  char v33; // [esp+488h] [ebp-1D4h]

  v20 = a2;
  v3 = a3;
  v26 = a3;
  if ( !a1 || !a2 || !a3 )
    return -2147024809;
  v23 = 0;
  v24 = 0;
  v4 = 0;
  v21 = 0;
  v25 = 0;
  VariantInit(&pvarg);
  VariantInit(&v18);
  v5 = (*(*a1 + 16))(a1, L"namespace", 0, &pvarg, 0, 0);
  if ( !v5 )
  {
    v6 = (*(*a1 + 16))(a1, L"provider", 0, &v18, 0, 0);
    if ( v6 )
    {
      v4 = v6;
      goto LABEL_38;
    }
    if ( v18.vt != 8 || pvarg.vt != 8 || !v18.lVal || !pvarg.lVal )
    {
      v4 = -2147418113;
      goto LABEL_38;
    }
    v7 = (*(*v20 + 12))(v20, pvarg.lVal, 0, 0, 0, 0, 0, 0, &v25);
    if ( v7 < 0 )
    {
      v4 = v7;
      goto LABEL_38;
    }
    qmemcpy(&Dst, L"select * from __win32provider where Name = '", 0x5Au);
    memset(&v29, 0, 0x1A4u);
    if ( !wcscat_s(&Dst, 0xFFu, v18.bstrVal) && !wcscat_s(&Dst, 0xFFu, L"'") )
    {
      v8 = (*(*v25 + 80))(v25, L"WQL", &Dst, 48, 0, &v23);
      if ( v8 )
      {
        v4 = v8;
LABEL_37:
        v3 = v26;
        goto LABEL_38;
      }
      v9 = (*(*v23 + 16))(v23, -1, 1, &v24, &v21);
      if ( v9 )
      {
        v4 = v9;
        goto LABEL_37;
      }
      VariantInit(&v16);
      v10 = (*(*v24 + 16))(v24, L"clsid", 0, &v16, 0, 0);
      if ( v10 )
      {
        v4 = v10;
        goto LABEL_37;
      }
      if ( v16.vt != 8 )
        goto LABEL_37;
      v11 = v16.bstrVal;
      if ( !v16.lVal )
        goto LABEL_37;
      _mm_storeu_si128(SubKey, _mm_loadu_si128(&xmmword_1047624));
      _mm_storeu_si128(&v31, _mm_loadu_si128(&xmmword_1047634));
      _mm_storeu_si128(&v32, _mm_loadu_si128(&xmmword_1047644));
      memset(&v33, 0, 0x1CEu);
      if ( !wcscat_s(SubKey, 0xFFu, v11)
        && !wcscat_s(SubKey, 0xFFu, L"\\InprocServer32")
        && !RegOpenKeyExW(HKEY_LOCAL_MACHINE, SubKey, 0, 0x20119u, &phkResult) )
      {
        memset(Data, 0, 0x1FEu);
        cbData = 510;
        if ( !RegQueryValueExW(phkResult, &gszNullString, 0, 0, Data, &cbData) )
        {
          v12 = sub_10036C0(v18.bstrVal);
          v3 = v26;
          *v26 = v12;
          if ( v12 )
          {
            v13 = sub_10036C0(pvarg.bstrVal);
            v3[1] = v13;
            if ( v13 )
            {
              v14 = sub_10036C0(Data);
              v3[2] = v14;
              if ( v14 )
                RegCloseKey(phkResult);
              else
                v4 = -2147024882;
            }
            else
            {
              v4 = -2147024882;
            }
          }
          else
          {
            v4 = -2147024882;
          }
          goto LABEL_38;
        }
      }
    }
    v4 = -2147418113;
    goto LABEL_37;
  }
  v4 = v5;
LABEL_38:
  if ( v24 )
    (*(*v24 + 8))(v24);
  if ( v23 )
    (*(*v23 + 8))(v23);
  if ( v25 )
    (*(*v25 + 8))(v25);
  VariantClear(&pvarg);
  VariantClear(&v18);
  if ( v4 )
  {
    if ( *v3 )
      free(*v3);
    if ( v3[1] )
      free(v3[1]);
    if ( v3[2] )
      free(v3[2]);
  }
  return v4;
}
// 1047590: using guessed type wchar_t aNamespace_0[10];
// 10475A4: using guessed type wchar_t aProvider[9];
// 10475B8: using guessed type wchar_t aSelectFromWin3[45];
// 1047618: using guessed type wchar_t aClsid_0[6];
// 1047624: using guessed type __int128 xmmword_1047624;
// 1047634: using guessed type __int128 xmmword_1047634;
// 1047644: using guessed type __int128 xmmword_1047644;

//----- (01004170) --------------------------------------------------------
void __stdcall __noreturn _com_issue_error(int a1)
{
  ATL::_com_error::_com_error(a1, 0);
}
// 106138C: using guessed type int (__cdecl *ATL::_com_error::_com_error)(_DWORD, _DWORD);

//----- (01004190) --------------------------------------------------------
_DWORD *__thiscall sub_1004190(_DWORD *this, int a2)
{
  _DWORD *v2; // esi
  int v3; // ecx

  v2 = this;
  *this = &ATL::_com_error::`vftable';
  this[1] = *(a2 + 4);
  v3 = *(a2 + 8);
  v2[2] = v3;
  v2[3] = 0;
  if ( v3 )
    (*(*v3 + 4))(v3);
  return v2;
}
// 1047BCC: using guessed type int (__thiscall *ATL::_com_error::`vftable')(void *, char);

//----- (010041D0) --------------------------------------------------------
HLOCAL __thiscall ATL::_com_error::~_com_error(ATL::_com_error *this)
{
  ATL::_com_error *v1; // esi
  int v2; // ecx
  HLOCAL result; // eax

  v1 = this;
  v2 = *(this + 2);
  *v1 = &ATL::_com_error::`vftable';
  if ( v2 )
    (*(*v2 + 8))(v2);
  result = *(v1 + 3);
  if ( result )
    result = LocalFree(*(v1 + 3));
  return result;
}
// 1047BCC: using guessed type int (__thiscall *ATL::_com_error::`vftable')(void *, char);

//----- (01004200) --------------------------------------------------------
HLOCAL *__thiscall ATL::_com_error::`scalar deleting destructor'(void *this, char a2)
{
  HLOCAL *v2; // esi
  int v3; // ecx

  v2 = this;
  v3 = *(this + 2);
  *v2 = &ATL::_com_error::`vftable';
  if ( v3 )
    (*(*v3 + 8))(v3);
  if ( v2[3] )
    LocalFree(v2[3]);
  if ( a2 & 1 )
    j__free(v2);
  return v2;
}
// 1047BCC: using guessed type int (__thiscall *ATL::_com_error::`vftable')(void *, char);

//----- (01004240) --------------------------------------------------------
void __cdecl __noreturn sub_1004240(int a1, int a2)
{
  int (__thiscall **v2)(void *, char); // [esp+0h] [ebp-10h]
  int v3; // [esp+4h] [ebp-Ch]
  int v4; // [esp+8h] [ebp-8h]
  int v5; // [esp+Ch] [ebp-4h]

  v3 = a1;
  v4 = a2;
  v2 = &ATL::_com_error::`vftable';
  v5 = 0;
  _CxxThrowException(&v2, &_TI1_AV_com_error__);
}
// 10081AA: using guessed type void __stdcall __noreturn _CxxThrowException(_DWORD, _DWORD);
// 1047BCC: using guessed type int (__thiscall *ATL::_com_error::`vftable')(void *, char);
// 1055BFC: using guessed type int _TI1_AV_com_error__;

//----- (01004270) --------------------------------------------------------
CHAR *__stdcall sub_1004270(LPCWSTR lpWideCharStr)
{
  unsigned int v2; // kr00_4
  int v3; // eax
  int v4; // ebx
  int v5; // eax
  CHAR *v6; // eax
  CHAR *v7; // esi
  int v8; // eax
  int v9; // [esp+0h] [ebp-20h]
  int *v10; // [esp+10h] [ebp-10h]
  int v11; // [esp+1Ch] [ebp-4h]

  v10 = &v9;
  if ( !lpWideCharStr )
    return 0;
  v2 = wcslen(lpWideCharStr);
  v3 = WideCharToMultiByte(0, 0, lpWideCharStr, v2 + 1, 0, 0, 0, 0);
  v4 = v3;
  if ( !v3 )
  {
    v5 = GetLastError();
    if ( v5 > 0 )
      v5 = v5 | 0x80070000;
    _com_issue_error(v5);
  }
  v11 = 0;
  v6 = operator new(v3);
  v7 = v6;
  v11 = -1;
  if ( !v6 )
    _com_issue_error(-2147024882);
  if ( !WideCharToMultiByte(0, 0, lpWideCharStr, v2 + 1, v6, v4, 0, 0) )
  {
    j__free(v7);
    v8 = GetLastError();
    if ( v8 > 0 )
      v8 = v8 | 0x80070000;
    _com_issue_error(v8);
  }
  return v7;
}

//----- (01004390) --------------------------------------------------------
BSTR __stdcall _com_util::ConvertBSTRToString(LPCSTR lpszText)
{
  int nLength; // eax
  int ret; // eax
  int ret_1; // edi
  int v5; // eax
  int v6; // eax
  void *v7; // esp
  WCHAR *pBuf; // esi
  int v9; // eax
  BSTR v10; // ebx
  WCHAR v11[8]; // [esp+0h] [ebp-38h]
  int v12; // [esp+10h] [ebp-28h]
  WCHAR *pWideString; // [esp+14h] [ebp-24h]
  int cbMultiByte; // [esp+18h] [ebp-20h]
  CPPEH_RECORD ms_exc; // [esp+20h] [ebp-18h]

  if ( !lpszText )
    return 0;
  nLength = lstrlenA(lpszText);
  cbMultiByte = nLength + 1;
  ret = MultiByteToWideChar(CP_ACP, 0, lpszText, nLength + 1, 0, 0);
  ret_1 = ret;
  v12 = ret;
  if ( !ret )
  {
    v5 = GetLastError();
    if ( v5 > 0 )
      v5 = v5 | 0x80070000;
    _com_issue_error(v5);
  }
  ms_exc.registration.TryLevel = 0;
  v6 = 2 * ret;
  if ( ret_1 >= 4096 )
  {
    pBuf = malloc(2 * ret_1);
    pWideString = pBuf;
  }
  else
  {
    v7 = alloca(v6);
    ms_exc.old_esp = v11;
    pBuf = v11;
    pWideString = v11;
  }
  ms_exc.registration.TryLevel = -2;
  if ( !pBuf )
    _com_issue_error(E_OUTOFMEMORY);
  if ( !MultiByteToWideChar(0, 0, lpszText, cbMultiByte, pBuf, ret_1) )
  {
    if ( ret_1 >= 4096 )
      free(pBuf);
    v9 = GetLastError();
    if ( v9 > 0 )
      v9 = v9 | 0x80070000;
    _com_issue_error(v9);
  }
  v10 = SysAllocString(pBuf);
  if ( ret_1 >= 4096 )
    free(pBuf);
  if ( !v10 )
    _com_issue_error(E_OUTOFMEMORY);
  return v10;
}

//----- (01004501) --------------------------------------------------------
std::exception *__thiscall sub_1004501(std::exception *this, struct exception *a2)
{
  std::exception *v2; // esi

  v2 = this;
  std::exception::exception(this, a2);
  *v2 = &std::bad_alloc::`vftable';
  return v2;
}
// 1047BD4: using guessed type void *std::bad_alloc::`vftable';

//----- (0100451C) --------------------------------------------------------
std::exception *__thiscall sub_100451C(std::exception *this, struct exception *a2)
{
  std::exception *v2; // esi

  v2 = this;
  std::exception::exception(this, a2);
  *v2 = &std::length_error::`vftable';
  return v2;
}
// 1047BFC: using guessed type void *std::length_error::`vftable';

//----- (01004537) --------------------------------------------------------
std::exception *__thiscall sub_1004537(std::exception *this, struct exception *a2)
{
  std::exception *v2; // esi

  v2 = this;
  std::exception::exception(this, a2);
  *v2 = &std::logic_error::`vftable';
  return v2;
}
// 1047BF0: using guessed type void *std::logic_error::`vftable';

//----- (01004552) --------------------------------------------------------
std::exception *__thiscall sub_1004552(std::exception *this, struct exception *a2)
{
  std::exception *v2; // esi

  v2 = this;
  std::exception::exception(this, a2);
  *v2 = &std::out_of_range::`vftable';
  return v2;
}
// 1047C08: using guessed type void *std::out_of_range::`vftable';

//----- (0100456D) --------------------------------------------------------
void __thiscall sub_100456D(std::exception *this)
{
  *this = &std::bad_alloc::`vftable';
  sub_1009D91(this);
}
// 1047BD4: using guessed type void *std::bad_alloc::`vftable';

//----- (01004585) --------------------------------------------------------
void *__thiscall sub_1004585(void *this, char a2)
{
  void *v2; // esi

  v2 = this;
  *this = &std::bad_alloc::`vftable';
  sub_1009D91(this);
  if ( a2 & 1 )
    j__free(v2);
  return v2;
}
// 1047BD4: using guessed type void *std::bad_alloc::`vftable';

//----- (010045AA) --------------------------------------------------------
void *__thiscall sub_10045AA(void *this, char a2)
{
  void *v2; // esi

  v2 = this;
  sub_1009D91(this);
  if ( a2 & 1 )
    j__free(v2);
  return v2;
}

//----- (0100465F) --------------------------------------------------------
int __cdecl sub_100465F(int a1)
{
  _DWORD *v1; // eax

  v1 = &unk_1047E68;
  if ( !"address family not supported" )
    return 0;
  while ( *v1 != a1 )
  {
    v1 += 2;
    if ( !v1[1] )
      return 0;
  }
  return v1[1];
}

//----- (01004689) --------------------------------------------------------
int __cdecl sub_1004689(int a1)
{
  int *v1; // eax

  v1 = &dword_1047C10;
  if ( !"permission denied" )
    return 0;
  while ( *v1 != a1 )
  {
    v1 += 2;
    if ( !v1[1] )
      return 0;
  }
  return v1[1];
}
// 1047C10: using guessed type int dword_1047C10;

//----- (01004C4A) --------------------------------------------------------
int sub_1004C4A()
{
  return *&dword_1085844;
}

//----- (01004F3E) --------------------------------------------------------
void __cdecl sub_1004F3E(LPCRITICAL_SECTION lpCriticalSection)
{
  EnterCriticalSection(lpCriticalSection);
}

//----- (01004F4C) --------------------------------------------------------
void __cdecl sub_1004F4C(LPCRITICAL_SECTION lpCriticalSection)
{
  LeaveCriticalSection(lpCriticalSection);
}

//----- (01004FDB) --------------------------------------------------------
CAtlBaseModule *__thiscall ATL::CAtlWinModule::CAtlWinModule(char *this)
{
  CAtlBaseModule *v1; // esi

  v1 = this;
  ATL::_ATL_WIN_MODULE70::_ATL_WIN_MODULE70(this);
  v1->baseclass.cbSize = 56;
  v1->baseclass.m_hInstResource = 16187392;
  v1->baseclass.m_hInst = 16187392;
  v1->baseclass.dwAtlBuildVer = 0xC00;
  v1->baseclass.pguidVer = &GUID_ATLVer110;
  if ( ATL::CComCriticalSection::Init(&v1->baseclass.m_csResource.m_Lock) < 0 )
  {
    if ( IsDebuggerPresent() )
      OutputDebugStringW(L"ERROR : Unable to initialize critical section in CAtlBaseModule\n");
    ATL::CAtlBaseModule::m_bInitFailed = 1;
  }
  return v1;
}
// 1048AF0: using guessed type GUID GUID_ATLVer110;
// 1085714: using guessed type char ATL::CAtlBaseModule::m_bInitFailed;

//----- (0100502E) --------------------------------------------------------
_DWORD *__thiscall ATL::_ATL_WIN_MODULE70::_ATL_WIN_MODULE70(_DWORD *this)
{
  _DWORD *v1; // esi
  _DWORD *result; // eax

  v1 = this;
  memset(this + 5, 0, 0x18u);
  v1[11] = 0;
  v1[12] = 0;
  result = v1;
  v1[13] = 0;
  return result;
}

//----- (01005051) --------------------------------------------------------
void __thiscall ATL::CAtlBaseModule::~CAtlBaseModule(int this)
{
  int v1; // esi
  void **v2; // ecx
  void **v3; // esi

  v1 = this;
  DeleteCriticalSection((this + 20));
  v2 = (v1 + 44);
  v3 = v2;
  if ( *v2 )
  {
    free(*v2);
    *v3 = 0;
  }
  v3[1] = 0;
  v3[2] = 0;
}

//----- (01005067) --------------------------------------------------------
int __thiscall ATL::CSimpleArray<HINSTANCE__ *,ATL::CSimpleArrayEqualHelper<HINSTANCE__ *>>::operator[](_DWORD *this, int a2)
{
  if ( a2 < 0 || a2 >= this[1] )
  {
    RaiseException(STATUS_ARRAY_BOUNDS_EXCEEDED, 1u, 0, 0);
    JUMPOUT(loc_1005090);
  }
  return *this + 4 * a2;
}

//----- (01005091) --------------------------------------------------------
CHAR *__thiscall ATL::CAtlBaseModule::GetHInstanceAt(CAtlBaseModule *this, int a2)
{
  CAtlBaseModule *v2; // esi
  struct _RTL_CRITICAL_SECTION *v3; // edi
  HINSTANCE v4; // esi

  v2 = this;
  v3 = &this->baseclass.m_csResource.m_Lock;
  EnterCriticalSection(&this->baseclass.m_csResource.m_Lock);
  if ( a2 > v2->baseclass.m_rgResourceInstance.m_nSize || a2 < 0 )
  {
    v4 = 0;
  }
  else if ( a2 == v2->baseclass.m_rgResourceInstance.m_nSize )
  {
    v4 = v2->baseclass.m_hInstResource;
  }
  else
  {
    v4 = *ATL::CSimpleArray<HINSTANCE__ *,ATL::CSimpleArrayEqualHelper<HINSTANCE__ *>>::operator[](
            &v2->baseclass.m_rgResourceInstance.m_aT,
            a2);
  }
  LeaveCriticalSection(v3);
  return v4;
}

//----- (01007B15) --------------------------------------------------------
void **sub_1007B15()
{
  return &off_1061568;
}
// 1061568: using guessed type void *off_1061568;

//----- (010089CE) --------------------------------------------------------
int __thiscall sub_10089CE(_DWORD *this)
{
  *this = &type_info::`vftable';
  return unknown_libname_8(this);
}
// 1015348: using guessed type _DWORD __cdecl unknown_libname_8(_DWORD);
// 1048BE8: using guessed type void *type_info::`vftable';

//----- (010089FA) --------------------------------------------------------
void *__thiscall sub_10089FA(void *this, char a2)
{
  void *v2; // esi

  v2 = this;
  sub_10089CE(this);
  if ( a2 & 1 )
    j__free(v2);
  return v2;
}

//----- (0100918B) --------------------------------------------------------
int sub_100918B()
{
  return flsall(1);
}
// 10091ED: using guessed type _DWORD __cdecl flsall(_DWORD);

//----- (01009CF7) --------------------------------------------------------
std::exception *__thiscall sub_1009CF7(std::exception *this, struct exception *a2)
{
  std::exception *v2; // esi

  v2 = this;
  std::exception::exception(this, a2);
  *v2 = &std::bad_cast::`vftable';
  return v2;
}
// 1048FEC: using guessed type void *std::bad_cast::`vftable';

//----- (01009D12) --------------------------------------------------------
std::exception *__thiscall sub_1009D12(std::exception *this, char *a2)
{
  std::exception *v2; // esi

  v2 = this;
  std::exception::exception(this, &a2);
  *v2 = &std::bad_cast::`vftable';
  return v2;
}
// 1048FEC: using guessed type void *std::bad_cast::`vftable';

//----- (01009D91) --------------------------------------------------------
void __thiscall sub_1009D91(std::exception *this)
{
  *this = &std::exception::`vftable';
  std::exception::_Tidy(this);
}
// 1048FCC: using guessed type void *std::exception::`vftable';

//----- (01009DCF) --------------------------------------------------------
void *__thiscall sub_1009DCF(void *this, char a2)
{
  void *v2; // esi

  v2 = this;
  *this = &std::exception::`vftable';
  std::exception::_Tidy(this);
  if ( a2 & 1 )
    j__free(v2);
  return v2;
}
// 1048FCC: using guessed type void *std::exception::`vftable';

//----- (0100B822) --------------------------------------------------------
std::exception *__thiscall sub_100B822(std::exception *this, struct exception *a2)
{
  std::exception *v2; // esi

  v2 = this;
  std::exception::exception(this, a2);
  *v2 = &std::bad_exception::`vftable';
  return v2;
}
// 1048FFC: using guessed type void *std::bad_exception::`vftable';

//----- (0100B83D) --------------------------------------------------------
void __thiscall sub_100B83D(std::exception *this)
{
  *this = &std::bad_exception::`vftable';
  sub_1009D91(this);
}
// 1048FFC: using guessed type void *std::bad_exception::`vftable';

//----- (0100B848) --------------------------------------------------------
void *__thiscall sub_100B848(void *this, char a2)
{
  void *v2; // esi

  v2 = this;
  *this = &std::bad_exception::`vftable';
  sub_1009D91(this);
  if ( a2 & 1 )
    j__free(v2);
  return v2;
}
// 1048FFC: using guessed type void *std::bad_exception::`vftable';

//----- (0100D342) --------------------------------------------------------
void __cdecl sub_100D342(DWORD dwMilliseconds)
{
  Sleep(dwMilliseconds);
}

//----- (0100F821) --------------------------------------------------------
void *__cdecl sub_100F821(void *a1)
{
  void *result; // eax

  result = a1;
  dword_1085EBC = a1;
  return result;
}

//----- (0100F8CF) --------------------------------------------------------
void *__cdecl sub_100F8CF(void *a1)
{
  void *result; // eax

  result = a1;
  dword_1085EC4 = a1;
  return result;
}

//----- (0100FAF6) --------------------------------------------------------
DWORD sub_100FAF6()
{
  return dwTlsIndex;
}

//----- (0101007A) --------------------------------------------------------
void sub_101007A()
{
  dword_10869AC = 0;
}
// 10869AC: using guessed type int dword_10869AC;

//----- (0101533B) --------------------------------------------------------
void *__cdecl sub_101533B(void *a1)
{
  void *result; // eax

  result = a1;
  dword_1086628 = a1;
  return result;
}

//----- (01017C9C) --------------------------------------------------------
void sub_1017C9C()
{
  void (**i)(void); // esi

  for ( i = &unk_104F88C; i < &unk_104F88C; ++i )
  {
    if ( *i )
      (*i)();
  }
}

//----- (01017CBC) --------------------------------------------------------
void __cdecl sub_1017CBC()
{
  void (**i)(void); // esi

  for ( i = &unk_104F894; i < &unk_104F894; ++i )
  {
    if ( *i )
      (*i)();
  }
}

//----- (01017CDC) --------------------------------------------------------
PVOID sub_1017CDC()
{
  return DecodePointer(dword_108663C);
}

//----- (01017EFA) --------------------------------------------------------
int __cdecl sub_1017EFA(int a1)
{
  int result; // eax

  result = a1;
  dword_1086648 = a1;
  return result;
}
// 1086648: using guessed type int dword_1086648;

//----- (01018B73) --------------------------------------------------------
HANDLE sub_1018B73()
{
  HANDLE result; // eax

  result = hObject;
  if ( hObject != -1 && hObject != -2 )
    result = CloseHandle(hObject);
  return result;
}

//----- (01019F90) --------------------------------------------------------
int sub_1019F90()
{
  __crtSetUnhandledExceptionFilter(__CxxUnhandledExceptionFilter);
  return 0;
}

//----- (0101A2BD) --------------------------------------------------------
int __cdecl sub_101A2BD(int a1)
{
  int result; // eax

  result = a1;
  dword_1085EC8 = a1;
  return result;
}
// 1085EC8: using guessed type int dword_1085EC8;

//----- (0101B1A0) --------------------------------------------------------
int *sub_101B1A0()
{
  return &dword_1062434;
}
// 1062434: using guessed type int dword_1062434;

//----- (0101B1A6) --------------------------------------------------------
int *sub_101B1A6()
{
  return &dword_1062438;
}
// 1062438: using guessed type int dword_1062438;

//----- (0101B1AC) --------------------------------------------------------
int *sub_101B1AC()
{
  return &dword_1062430;
}
// 1062430: using guessed type int dword_1062430;

//----- (0101B1B2) --------------------------------------------------------
void **sub_101B1B2()
{
  return &off_10624C0;
}
// 10624C0: using guessed type void *off_10624C0;

//----- (0101B1B8) --------------------------------------------------------
signed int __cdecl sub_101B1B8(_DWORD *a1)
{
  signed int result; // eax

  if ( a1 )
  {
    *a1 = dword_1062434;
    result = 0;
  }
  else
  {
    *_errno() = 22;
    _invalid_parameter_noinfo();
    result = 22;
  }
  return result;
}
// 100F859: using guessed type int _invalid_parameter_noinfo(void);
// 1062434: using guessed type int dword_1062434;

//----- (0101B1E2) --------------------------------------------------------
signed int __cdecl sub_101B1E2(_DWORD *a1)
{
  signed int result; // eax

  if ( a1 )
  {
    *a1 = dword_1062438;
    result = 0;
  }
  else
  {
    *_errno() = 22;
    _invalid_parameter_noinfo();
    result = 22;
  }
  return result;
}
// 100F859: using guessed type int _invalid_parameter_noinfo(void);
// 1062438: using guessed type int dword_1062438;

//----- (0101B20C) --------------------------------------------------------
signed int __cdecl sub_101B20C(_DWORD *a1)
{
  signed int result; // eax

  if ( a1 )
  {
    *a1 = dword_1062430;
    result = 0;
  }
  else
  {
    *_errno() = 22;
    _invalid_parameter_noinfo();
    result = 22;
  }
  return result;
}
// 100F859: using guessed type int _invalid_parameter_noinfo(void);
// 1062430: using guessed type int dword_1062430;

//----- (0101B5FC) --------------------------------------------------------
int __cdecl sub_101B5FC(const WCHAR *a1, int a2, int a3)
{
  int v3; // esi
  PVOID v4; // edi
  HMODULE v5; // edi
  FARPROC v6; // eax
  FARPROC v7; // eax
  FARPROC v8; // eax
  FARPROC v9; // eax
  FARPROC v10; // eax
  PVOID v12; // eax
  int v13; // eax
  int v14; // edi
  int (*v15)(void); // eax
  int (__stdcall *v16)(int); // eax
  int (__stdcall *v17)(int, LPCWSTR, int, int); // eax
  char v19; // [esp+Ch] [ebp-24h]
  int v20; // [esp+10h] [ebp-20h]
  LPCWSTR lpOutputString; // [esp+14h] [ebp-1Ch]
  int (__stdcall *v22)(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD); // [esp+18h] [ebp-18h]
  int (*v23)(void); // [esp+1Ch] [ebp-14h]
  char v24; // [esp+20h] [ebp-10h]
  char v25; // [esp+28h] [ebp-8h]

  lpOutputString = a1;
  v3 = 0;
  v20 = a2;
  v4 = EncodePointer(0);
  v22 = v4;
  v23 = __crtIsPackagedApp();
  if ( !dword_108694C )
  {
    v5 = LoadLibraryExW(L"USER32.DLL", 0, 0x800u);
    if ( !v5 )
    {
      if ( GetLastError() != 87 )
        return 0;
      v5 = LoadLibraryExW(L"USER32.DLL", 0, 0);
      if ( !v5 )
        return 0;
    }
    v6 = GetProcAddress(v5, "MessageBoxW");
    if ( !v6 )
      return 0;
    dword_108694C = EncodePointer(v6);
    v7 = GetProcAddress(v5, "GetActiveWindow");
    dword_1086950 = EncodePointer(v7);
    v8 = GetProcAddress(v5, "GetLastActivePopup");
    dword_1086954 = EncodePointer(v8);
    v9 = GetProcAddress(v5, "GetUserObjectInformationW");
    dword_108695C = EncodePointer(v9);
    if ( dword_108695C )
    {
      v10 = GetProcAddress(v5, "GetProcessWindowStation");
      dword_1086958 = EncodePointer(v10);
    }
    v4 = v22;
  }
  if ( IsDebuggerPresent() )
  {
    if ( lpOutputString )
      OutputDebugStringW(lpOutputString);
    if ( v23 )
      return 4;
  }
  else if ( v23 )
  {
    DecodePointer(dword_108694C);
    return 3;
  }
  if ( dword_1086958 == v4
    || dword_108695C == v4
    || (v23 = DecodePointer(dword_1086958), v12 = DecodePointer(dword_108695C), v22 = v12, !v23)
    || !v12
    || (v13 = v23()) != 0 && v22(v13, 1, &v24, 12, &v19) && v25 & 1 )
  {
    if ( dword_1086950 != v4 )
    {
      v15 = DecodePointer(dword_1086950);
      if ( v15 )
      {
        v3 = v15();
        if ( v3 )
        {
          if ( dword_1086954 != v4 )
          {
            v16 = DecodePointer(dword_1086954);
            if ( v16 )
              v3 = v16(v3);
          }
        }
      }
    }
    v14 = a3;
  }
  else
  {
    v14 = a3 | 0x200000;
  }
  v17 = DecodePointer(dword_108694C);
  if ( v17 )
    return v17(v3, lpOutputString, v20, v14);
  return 0;
}
// 100D069: using guessed type int __crtIsPackagedApp(void);

//----- (0101F550) --------------------------------------------------------
int sub_101F550()
{
  return 0;
}

//----- (0101FE30) --------------------------------------------------------
signed int __cdecl sub_101FE30(unsigned __int16 *a1, int *a2)
{
  signed int v2; // ebx
  int *v3; // edi
  int v4; // edx
  int v5; // esi
  int v6; // eax
  int v7; // edx
  char v8; // cl
  bool i; // zf
  int v10; // edx
  unsigned int v11; // eax
  bool v12; // cf
  unsigned int v13; // eax
  signed int v14; // ecx
  int j; // edx
  unsigned int v16; // eax
  unsigned int v17; // eax
  int v18; // ecx
  int v19; // eax
  unsigned int v20; // edx
  int *v21; // edx
  int v22; // eax
  signed int v23; // ecx
  int v24; // edx
  int v25; // ecx
  char v26; // cl
  bool k; // zf
  int v28; // edx
  unsigned int v29; // eax
  signed int v30; // ecx
  unsigned int v31; // eax
  int l; // edx
  unsigned int v33; // eax
  unsigned int v34; // eax
  int v35; // edx
  int v36; // ecx
  int v37; // eax
  unsigned int v38; // edx
  int *v39; // edx
  signed int v40; // ecx
  int v41; // ecx
  int v42; // edi
  unsigned int v43; // edx
  unsigned int v44; // eax
  int v45; // edx
  int *v46; // edx
  signed int v47; // ecx
  int v48; // ecx
  signed int v49; // esi
  unsigned int v50; // edx
  int *v51; // edx
  signed int v52; // ecx
  int v53; // esi
  int v54; // eax
  int v56; // [esp+Ch] [ebp-44h]
  int v57; // [esp+14h] [ebp-3Ch]
  int v58; // [esp+14h] [ebp-3Ch]
  unsigned int v59; // [esp+18h] [ebp-38h]
  int v60; // [esp+18h] [ebp-38h]
  int v61; // [esp+18h] [ebp-38h]
  int v62; // [esp+1Ch] [ebp-34h]
  int v63; // [esp+1Ch] [ebp-34h]
  int v64; // [esp+1Ch] [ebp-34h]
  int v65; // [esp+20h] [ebp-30h]
  char v66; // [esp+20h] [ebp-30h]
  signed int v67; // [esp+24h] [ebp-2Ch]
  int v68; // [esp+28h] [ebp-28h]
  char v69; // [esp+28h] [ebp-28h]
  int v70; // [esp+28h] [ebp-28h]
  int v71; // [esp+2Ch] [ebp-24h]
  unsigned int v72; // [esp+2Ch] [ebp-24h]
  int v73; // [esp+30h] [ebp-20h]
  int v74; // [esp+30h] [ebp-20h]
  int v75; // [esp+30h] [ebp-20h]
  int v76; // [esp+30h] [ebp-20h]
  int v77; // [esp+30h] [ebp-20h]
  int v78; // [esp+34h] [ebp-1Ch]
  int v79; // [esp+38h] [ebp-18h]
  int v80; // [esp+3Ch] [ebp-14h]
  int v81; // [esp+40h] [ebp-10h]
  int v82; // [esp+44h] [ebp-Ch]
  int v83; // [esp+48h] [ebp-8h]

  v2 = 0;
  v3 = a2;
  v56 = a1[5] & 0x8000;
  v4 = (a1[5] & 0x7FFF) - 0x3FFF;
  v81 = *(a1 + 3);
  v82 = *(a1 + 1);
  v73 = v4;
  v83 = *a1 << 16;
  if ( v4 == -16383 )
  {
    v5 = 0;
    v6 = 0;
    while ( !*(&v81 + v6) )
    {
      if ( ++v6 >= 3 )
        goto LABEL_84;
    }
    v81 = 0;
    v82 = 0;
    v83 = 0;
  }
  else
  {
    v71 = v4;
    v78 = v81;
    v62 = dword_1062570 - 1;
    v67 = 0;
    v79 = v82;
    v80 = v83;
    v7 = dword_1062570 / 32;
    v57 = dword_1062570 / 32;
    v65 = 31 - dword_1062570 % 32;
    v8 = v65;
    if ( (1 << v65) & *(&v81 + dword_1062570 / 32) )
    {
      for ( i = (~(-1 << v65) & *(&v81 + v7)) == 0; i; i = *(&v81 + v7) == 0 )
      {
        if ( ++v7 >= 3 )
          goto LABEL_24;
      }
      v10 = v62 / 32;
      v67 = 0;
      v59 = 1 << (31 - v62 % 32);
      v11 = *(&v81 + v62 / 32);
      v12 = v11 + v59 < v11;
      v13 = v11 + v59;
      v14 = 0;
      if ( v12 || v13 < v59 )
      {
        v14 = 1;
        v67 = 1;
      }
      *(&v81 + v10) = v13;
      for ( j = v10 - 1; j >= 0; *(&v81 + j--) = v17 )
      {
        if ( !v14 )
          break;
        v16 = *(&v81 + j);
        v14 = 0;
        v67 = 0;
        v12 = v16 + 1 < v16;
        v17 = v16 + 1;
        if ( v12 || v17 < 1 )
        {
          v14 = 1;
          v67 = 1;
        }
      }
      v8 = v65;
LABEL_24:
      v7 = v57;
    }
    *(&v81 + v7) &= -1 << v8;
    if ( v7 + 1 < 3 )
      memset(&v81 + v7 + 1, 0, 4 * (3 - (v7 + 1)));
    v18 = v73;
    if ( v67 )
      v18 = v73 + 1;
    if ( v18 >= dword_106256C - dword_1062570 )
    {
      if ( v18 > dword_106256C )
      {
        if ( v18 < dword_1062568 )
        {
          v81 &= 0x7FFFFFFFu;
          v61 = v18 + dword_106257C;
          v70 = dword_1062574 / 32;
          v48 = dword_1062574 % 32;
          v77 = 0;
          v49 = 0;
          do
          {
            v50 = *(&v81 + v49);
            *(&v81 + v49++) = v77 | (v50 >> v48);
            v77 = (~(-1 << v48) & v50) << (32 - v48);
          }
          while ( v49 < 3 );
          v5 = v61;
          v51 = &v83 - v70;
          v2 = 0;
          v52 = 2;
          do
          {
            if ( v52 < v70 )
              *(&v81 + v52) = 0;
            else
              *(&v81 + v52) = *v51;
            --v51;
            --v52;
          }
          while ( v52 >= 0 );
        }
        else
        {
          v82 = 0;
          v83 = 0;
          v81 = 2147483648;
          v64 = dword_1062574 / 32;
          v41 = dword_1062574 % 32;
          v60 = dword_1062574 % 32;
          v76 = 0;
          v42 = ~(-1 << dword_1062574 % 32);
          v69 = 32 - dword_1062574 % 32;
          do
          {
            v43 = *(&v81 + v2);
            v44 = v43;
            v45 = v76 | (v43 >> v41);
            LOBYTE(v41) = v60;
            *(&v81 + v2++) = v45;
            v76 = (v42 & v44) << v69;
          }
          while ( v2 < 3 );
          v46 = &v83 - v64;
          v47 = 2;
          do
          {
            if ( v47 < v64 )
              *(&v81 + v47) = 0;
            else
              *(&v81 + v47) = *v46;
            --v46;
            --v47;
          }
          while ( v47 >= 0 );
          v5 = dword_1062568 + dword_106257C;
          v2 = 1;
        }
        goto LABEL_83;
      }
      v81 = v78;
      v82 = v79;
      v58 = (dword_106256C - v71) / 32;
      v83 = v80;
      v19 = (dword_106256C - v71) % 32;
      v74 = 0;
      do
      {
        v20 = *(&v81 + v2);
        *(&v81 + v2++) = v74 | (v20 >> v19);
        v74 = (~(-1 << v19) & v20) << (32 - v19);
      }
      while ( v2 < 3 );
      v21 = &v83 - v58;
      v22 = v58;
      v23 = 2;
      do
      {
        if ( v23 < v22 )
        {
          *(&v81 + v23) = 0;
        }
        else
        {
          *(&v81 + v23) = *v21;
          v22 = v58;
        }
        --v21;
        --v23;
      }
      while ( v23 >= 0 );
      v24 = (v62 + 1) / 32;
      v25 = (v62 + 1) % 32;
      v66 = 31 - v25;
      v26 = 31 - v25;
      if ( (1 << v26) & *(&v81 + v24) )
      {
        for ( k = (~(-1 << v26) & *(&v81 + v24)) == 0; k; k = *(&v81 + v24) == 0 )
        {
          if ( ++v24 >= 3 )
            goto LABEL_56;
        }
        v28 = v62 / 32;
        v29 = *(&v81 + v62 / 32);
        v30 = 0;
        v72 = 1 << (31 - v62 % 32);
        v12 = v29 + v72 < v29;
        v31 = v29 + v72;
        if ( v12 || v31 < v72 )
          v30 = 1;
        *(&v81 + v28) = v31;
        for ( l = v28 - 1; l >= 0; *(&v81 + l--) = v34 )
        {
          if ( !v30 )
            break;
          v33 = *(&v81 + l);
          v30 = 0;
          v12 = v33 + 1 < v33;
          v34 = v33 + 1;
          if ( v12 || v34 < 1 )
            v30 = 1;
        }
        v26 = v66;
LABEL_56:
        v24 = (v62 + 1) / 32;
      }
      *(&v81 + v24) &= -1 << v26;
      v35 = v24 + 1;
      if ( v35 < 3 )
        memset(&v81 + v35, 0, 4 * (3 - v35));
      v68 = (dword_1062574 + 1) / 32;
      v36 = (dword_1062574 + 1) % 32;
      v37 = 0;
      v75 = 0;
      v63 = 0;
      do
      {
        v38 = *(&v81 + v37);
        *(&v81 + v63) = v75 | (v38 >> v36);
        v75 = (~(-1 << v36) & v38) << (32 - v36);
        v37 = v63 + 1;
        v63 = v37;
      }
      while ( v37 < 3 );
      v39 = &v83 - v68;
      v40 = 2;
      do
      {
        if ( v40 < v68 )
          *(&v81 + v40) = 0;
        else
          *(&v81 + v40) = *v39;
        --v39;
        --v40;
      }
      while ( v40 >= 0 );
    }
    else
    {
      v81 = 0;
      v82 = 0;
      v83 = 0;
    }
    v5 = 0;
  }
  v2 = 2;
LABEL_83:
  v3 = a2;
LABEL_84:
  v53 = v81 | (v56 != 0 ? 0x80000000 : 0) | (v5 << (31 - dword_1062574));
  if ( dword_1062578 == 64 )
  {
    v54 = v82;
    v3[1] = v53;
    *v3 = v54;
  }
  else if ( dword_1062578 == 32 )
  {
    *v3 = v53;
  }
  return v2;
}
// 1062568: using guessed type int dword_1062568;
// 106256C: using guessed type int dword_106256C;
// 1062570: using guessed type int dword_1062570;
// 1062574: using guessed type int dword_1062574;
// 1062578: using guessed type int dword_1062578;
// 106257C: using guessed type int dword_106257C;

//----- (010203A2) --------------------------------------------------------
signed int __cdecl sub_10203A2(unsigned __int16 *a1, int *a2)
{
  signed int v2; // ebx
  int *v3; // edi
  int v4; // edx
  int v5; // esi
  int v6; // eax
  int v7; // edx
  char v8; // cl
  bool i; // zf
  int v10; // edx
  unsigned int v11; // eax
  bool v12; // cf
  unsigned int v13; // eax
  signed int v14; // ecx
  int j; // edx
  unsigned int v16; // eax
  unsigned int v17; // eax
  int v18; // ecx
  int v19; // eax
  unsigned int v20; // edx
  int *v21; // edx
  int v22; // eax
  signed int v23; // ecx
  int v24; // edx
  int v25; // ecx
  char v26; // cl
  bool k; // zf
  int v28; // edx
  unsigned int v29; // eax
  signed int v30; // ecx
  unsigned int v31; // eax
  int l; // edx
  unsigned int v33; // eax
  unsigned int v34; // eax
  int v35; // edx
  int v36; // ecx
  int v37; // eax
  unsigned int v38; // edx
  int *v39; // edx
  signed int v40; // ecx
  int v41; // ecx
  int v42; // edi
  unsigned int v43; // edx
  unsigned int v44; // eax
  int v45; // edx
  int *v46; // edx
  signed int v47; // ecx
  int v48; // ecx
  signed int v49; // esi
  unsigned int v50; // edx
  int *v51; // edx
  signed int v52; // ecx
  int v53; // esi
  int v54; // eax
  int v56; // [esp+Ch] [ebp-44h]
  int v57; // [esp+14h] [ebp-3Ch]
  int v58; // [esp+14h] [ebp-3Ch]
  unsigned int v59; // [esp+18h] [ebp-38h]
  int v60; // [esp+18h] [ebp-38h]
  int v61; // [esp+18h] [ebp-38h]
  int v62; // [esp+1Ch] [ebp-34h]
  int v63; // [esp+1Ch] [ebp-34h]
  int v64; // [esp+1Ch] [ebp-34h]
  int v65; // [esp+20h] [ebp-30h]
  char v66; // [esp+20h] [ebp-30h]
  signed int v67; // [esp+24h] [ebp-2Ch]
  int v68; // [esp+28h] [ebp-28h]
  char v69; // [esp+28h] [ebp-28h]
  int v70; // [esp+28h] [ebp-28h]
  int v71; // [esp+2Ch] [ebp-24h]
  unsigned int v72; // [esp+2Ch] [ebp-24h]
  int v73; // [esp+30h] [ebp-20h]
  int v74; // [esp+30h] [ebp-20h]
  int v75; // [esp+30h] [ebp-20h]
  int v76; // [esp+30h] [ebp-20h]
  int v77; // [esp+30h] [ebp-20h]
  int v78; // [esp+34h] [ebp-1Ch]
  int v79; // [esp+38h] [ebp-18h]
  int v80; // [esp+3Ch] [ebp-14h]
  int v81; // [esp+40h] [ebp-10h]
  int v82; // [esp+44h] [ebp-Ch]
  int v83; // [esp+48h] [ebp-8h]

  v2 = 0;
  v3 = a2;
  v56 = a1[5] & 0x8000;
  v4 = (a1[5] & 0x7FFF) - 0x3FFF;
  v81 = *(a1 + 3);
  v82 = *(a1 + 1);
  v73 = v4;
  v83 = *a1 << 16;
  if ( v4 == -16383 )
  {
    v5 = 0;
    v6 = 0;
    while ( !*(&v81 + v6) )
    {
      if ( ++v6 >= 3 )
        goto LABEL_84;
    }
    v81 = 0;
    v82 = 0;
    v83 = 0;
  }
  else
  {
    v71 = v4;
    v78 = v81;
    v62 = dword_1062588 - 1;
    v67 = 0;
    v79 = v82;
    v80 = v83;
    v7 = dword_1062588 / 32;
    v57 = dword_1062588 / 32;
    v65 = 31 - dword_1062588 % 32;
    v8 = v65;
    if ( (1 << v65) & *(&v81 + dword_1062588 / 32) )
    {
      for ( i = (~(-1 << v65) & *(&v81 + v7)) == 0; i; i = *(&v81 + v7) == 0 )
      {
        if ( ++v7 >= 3 )
          goto LABEL_24;
      }
      v10 = v62 / 32;
      v67 = 0;
      v59 = 1 << (31 - v62 % 32);
      v11 = *(&v81 + v62 / 32);
      v12 = v11 + v59 < v11;
      v13 = v11 + v59;
      v14 = 0;
      if ( v12 || v13 < v59 )
      {
        v14 = 1;
        v67 = 1;
      }
      *(&v81 + v10) = v13;
      for ( j = v10 - 1; j >= 0; *(&v81 + j--) = v17 )
      {
        if ( !v14 )
          break;
        v16 = *(&v81 + j);
        v14 = 0;
        v67 = 0;
        v12 = v16 + 1 < v16;
        v17 = v16 + 1;
        if ( v12 || v17 < 1 )
        {
          v14 = 1;
          v67 = 1;
        }
      }
      v8 = v65;
LABEL_24:
      v7 = v57;
    }
    *(&v81 + v7) &= -1 << v8;
    if ( v7 + 1 < 3 )
      memset(&v81 + v7 + 1, 0, 4 * (3 - (v7 + 1)));
    v18 = v73;
    if ( v67 )
      v18 = v73 + 1;
    if ( v18 >= dword_1062584 - dword_1062588 )
    {
      if ( v18 > dword_1062584 )
      {
        if ( v18 < dword_1062580 )
        {
          v81 &= 0x7FFFFFFFu;
          v61 = v18 + dword_1062594;
          v70 = dword_106258C / 32;
          v48 = dword_106258C % 32;
          v77 = 0;
          v49 = 0;
          do
          {
            v50 = *(&v81 + v49);
            *(&v81 + v49++) = v77 | (v50 >> v48);
            v77 = (~(-1 << v48) & v50) << (32 - v48);
          }
          while ( v49 < 3 );
          v5 = v61;
          v51 = &v83 - v70;
          v2 = 0;
          v52 = 2;
          do
          {
            if ( v52 < v70 )
              *(&v81 + v52) = 0;
            else
              *(&v81 + v52) = *v51;
            --v51;
            --v52;
          }
          while ( v52 >= 0 );
        }
        else
        {
          v82 = 0;
          v83 = 0;
          v81 = 2147483648;
          v64 = dword_106258C / 32;
          v41 = dword_106258C % 32;
          v60 = dword_106258C % 32;
          v76 = 0;
          v42 = ~(-1 << dword_106258C % 32);
          v69 = 32 - dword_106258C % 32;
          do
          {
            v43 = *(&v81 + v2);
            v44 = v43;
            v45 = v76 | (v43 >> v41);
            LOBYTE(v41) = v60;
            *(&v81 + v2++) = v45;
            v76 = (v42 & v44) << v69;
          }
          while ( v2 < 3 );
          v46 = &v83 - v64;
          v47 = 2;
          do
          {
            if ( v47 < v64 )
              *(&v81 + v47) = 0;
            else
              *(&v81 + v47) = *v46;
            --v46;
            --v47;
          }
          while ( v47 >= 0 );
          v5 = dword_1062580 + dword_1062594;
          v2 = 1;
        }
        goto LABEL_83;
      }
      v81 = v78;
      v82 = v79;
      v58 = (dword_1062584 - v71) / 32;
      v83 = v80;
      v19 = (dword_1062584 - v71) % 32;
      v74 = 0;
      do
      {
        v20 = *(&v81 + v2);
        *(&v81 + v2++) = v74 | (v20 >> v19);
        v74 = (~(-1 << v19) & v20) << (32 - v19);
      }
      while ( v2 < 3 );
      v21 = &v83 - v58;
      v22 = v58;
      v23 = 2;
      do
      {
        if ( v23 < v22 )
        {
          *(&v81 + v23) = 0;
        }
        else
        {
          *(&v81 + v23) = *v21;
          v22 = v58;
        }
        --v21;
        --v23;
      }
      while ( v23 >= 0 );
      v24 = (v62 + 1) / 32;
      v25 = (v62 + 1) % 32;
      v66 = 31 - v25;
      v26 = 31 - v25;
      if ( (1 << v26) & *(&v81 + v24) )
      {
        for ( k = (~(-1 << v26) & *(&v81 + v24)) == 0; k; k = *(&v81 + v24) == 0 )
        {
          if ( ++v24 >= 3 )
            goto LABEL_56;
        }
        v28 = v62 / 32;
        v29 = *(&v81 + v62 / 32);
        v30 = 0;
        v72 = 1 << (31 - v62 % 32);
        v12 = v29 + v72 < v29;
        v31 = v29 + v72;
        if ( v12 || v31 < v72 )
          v30 = 1;
        *(&v81 + v28) = v31;
        for ( l = v28 - 1; l >= 0; *(&v81 + l--) = v34 )
        {
          if ( !v30 )
            break;
          v33 = *(&v81 + l);
          v30 = 0;
          v12 = v33 + 1 < v33;
          v34 = v33 + 1;
          if ( v12 || v34 < 1 )
            v30 = 1;
        }
        v26 = v66;
LABEL_56:
        v24 = (v62 + 1) / 32;
      }
      *(&v81 + v24) &= -1 << v26;
      v35 = v24 + 1;
      if ( v35 < 3 )
        memset(&v81 + v35, 0, 4 * (3 - v35));
      v68 = (dword_106258C + 1) / 32;
      v36 = (dword_106258C + 1) % 32;
      v37 = 0;
      v75 = 0;
      v63 = 0;
      do
      {
        v38 = *(&v81 + v37);
        *(&v81 + v63) = v75 | (v38 >> v36);
        v75 = (~(-1 << v36) & v38) << (32 - v36);
        v37 = v63 + 1;
        v63 = v37;
      }
      while ( v37 < 3 );
      v39 = &v83 - v68;
      v40 = 2;
      do
      {
        if ( v40 < v68 )
          *(&v81 + v40) = 0;
        else
          *(&v81 + v40) = *v39;
        --v39;
        --v40;
      }
      while ( v40 >= 0 );
    }
    else
    {
      v81 = 0;
      v82 = 0;
      v83 = 0;
    }
    v5 = 0;
  }
  v2 = 2;
LABEL_83:
  v3 = a2;
LABEL_84:
  v53 = v81 | (v56 != 0 ? 0x80000000 : 0) | (v5 << (31 - dword_106258C));
  if ( dword_1062590 == 64 )
  {
    v54 = v82;
    v3[1] = v53;
    *v3 = v54;
  }
  else if ( dword_1062590 == 32 )
  {
    *v3 = v53;
  }
  return v2;
}
// 1062580: using guessed type int dword_1062580;
// 1062584: using guessed type int dword_1062584;
// 1062588: using guessed type int dword_1062588;
// 106258C: using guessed type int dword_106258C;
// 1062590: using guessed type int dword_1062590;
// 1062594: using guessed type int dword_1062594;

//----- (01021B17) --------------------------------------------------------
signed int __cdecl sub_1021B17(_DWORD *a1)
{
  signed int result; // eax

  if ( a1 )
  {
    *a1 = dword_10869A4;
    result = 0;
  }
  else
  {
    *_errno() = 22;
    _invalid_parameter_noinfo();
    result = 22;
  }
  return result;
}
// 100F859: using guessed type int _invalid_parameter_noinfo(void);
// 10869A4: using guessed type int dword_10869A4;

//----- (01021C0E) --------------------------------------------------------
HANDLE sub_1021C0E()
{
  HANDLE result; // eax

  result = hConsoleOutput;
  if ( hConsoleOutput != -1 && hConsoleOutput != -2 )
    result = CloseHandle(hConsoleOutput);
  return result;
}

//----- (01023624) --------------------------------------------------------
int __cdecl SEH_402480(EXCEPTION_RECORD *a1, struct EHRegistrationNode *a2, struct _CONTEXT *a3, void *a4)
{
  return __CxxFrameHandler3(a1, a2, a3, a4);
}
// 1005CD1: using guessed type _DWORD __cdecl __CxxFrameHandler3(PEXCEPTION_RECORD ExceptionRecord, struct EHRegistrationNode *, struct _CONTEXT *, void *);

//----- (010237AA) --------------------------------------------------------
int __cdecl SEH_402D60(EXCEPTION_RECORD *a1, struct EHRegistrationNode *a2, struct _CONTEXT *a3, void *a4)
{
  return __CxxFrameHandler3(a1, a2, a3, a4);
}
// 1005CD1: using guessed type _DWORD __cdecl __CxxFrameHandler3(PEXCEPTION_RECORD ExceptionRecord, struct EHRegistrationNode *, struct _CONTEXT *, void *);

//----- (010237E9) --------------------------------------------------------
int __cdecl SEH_403440(EXCEPTION_RECORD *a1, struct EHRegistrationNode *a2, struct _CONTEXT *a3, void *a4)
{
  return __CxxFrameHandler3(a1, a2, a3, a4);
}
// 1005CD1: using guessed type _DWORD __cdecl __CxxFrameHandler3(PEXCEPTION_RECORD ExceptionRecord, struct EHRegistrationNode *, struct _CONTEXT *, void *);

//----- (01023810) --------------------------------------------------------
int __cdecl SEH_4035A0(EXCEPTION_RECORD *a1, struct EHRegistrationNode *a2, struct _CONTEXT *a3, void *a4)
{
  return __CxxFrameHandler3(a1, a2, a3, a4);
}
// 1005CD1: using guessed type _DWORD __cdecl __CxxFrameHandler3(PEXCEPTION_RECORD ExceptionRecord, struct EHRegistrationNode *, struct _CONTEXT *, void *);

//----- (01023830) --------------------------------------------------------
int __cdecl SEH_4038F0(EXCEPTION_RECORD *a1, struct EHRegistrationNode *a2, struct _CONTEXT *a3, void *a4)
{
  return __CxxFrameHandler3(a1, a2, a3, a4);
}
// 1005CD1: using guessed type _DWORD __cdecl __CxxFrameHandler3(PEXCEPTION_RECORD ExceptionRecord, struct EHRegistrationNode *, struct _CONTEXT *, void *);

//----- (01023869) --------------------------------------------------------
int __cdecl SEH_4314F0(EXCEPTION_RECORD *a1, struct EHRegistrationNode *a2, struct _CONTEXT *a3, void *a4)
{
  return __CxxFrameHandler3(a1, a2, a3, a4);
}
// 1005CD1: using guessed type _DWORD __cdecl __CxxFrameHandler3(PEXCEPTION_RECORD ExceptionRecord, struct EHRegistrationNode *, struct _CONTEXT *, void *);

//----- (01023898) --------------------------------------------------------
int __cdecl SEH_403D40(EXCEPTION_RECORD *a1, struct EHRegistrationNode *a2, struct _CONTEXT *a3, void *a4)
{
  return __CxxFrameHandler3(a1, a2, a3, a4);
}
// 1005CD1: using guessed type _DWORD __cdecl __CxxFrameHandler3(PEXCEPTION_RECORD ExceptionRecord, struct EHRegistrationNode *, struct _CONTEXT *, void *);

//----- (010238CB) --------------------------------------------------------
int __cdecl SEH_404130(EXCEPTION_RECORD *a1, struct EHRegistrationNode *a2, struct _CONTEXT *a3, void *a4)
{
  return __CxxFrameHandler3(a1, a2, a3, a4);
}
// 1005CD1: using guessed type _DWORD __cdecl __CxxFrameHandler3(PEXCEPTION_RECORD ExceptionRecord, struct EHRegistrationNode *, struct _CONTEXT *, void *);

//----- (01023910) --------------------------------------------------------
int __cdecl SEH_404890(EXCEPTION_RECORD *a1, struct EHRegistrationNode *a2, struct _CONTEXT *a3, void *a4)
{
  return __CxxFrameHandler3(a1, a2, a3, a4);
}
// 1005CD1: using guessed type _DWORD __cdecl __CxxFrameHandler3(PEXCEPTION_RECORD ExceptionRecord, struct EHRegistrationNode *, struct _CONTEXT *, void *);

//----- (01023950) --------------------------------------------------------
int __cdecl SEH_404AC0(EXCEPTION_RECORD *a1, struct EHRegistrationNode *a2, struct _CONTEXT *a3, void *a4)
{
  return __CxxFrameHandler3(a1, a2, a3, a4);
}
// 1005CD1: using guessed type _DWORD __cdecl __CxxFrameHandler3(PEXCEPTION_RECORD ExceptionRecord, struct EHRegistrationNode *, struct _CONTEXT *, void *);

//----- (01023978) --------------------------------------------------------
int __cdecl SEH_404F20(EXCEPTION_RECORD *a1, struct EHRegistrationNode *a2, struct _CONTEXT *a3, void *a4)
{
  return __CxxFrameHandler3(a1, a2, a3, a4);
}
// 1005CD1: using guessed type _DWORD __cdecl __CxxFrameHandler3(PEXCEPTION_RECORD ExceptionRecord, struct EHRegistrationNode *, struct _CONTEXT *, void *);

//----- (010239C1) --------------------------------------------------------
int __cdecl SEH_404FB0(EXCEPTION_RECORD *a1, struct EHRegistrationNode *a2, struct _CONTEXT *a3, void *a4)
{
  return __CxxFrameHandler3(a1, a2, a3, a4);
}
// 1005CD1: using guessed type _DWORD __cdecl __CxxFrameHandler3(PEXCEPTION_RECORD ExceptionRecord, struct EHRegistrationNode *, struct _CONTEXT *, void *);

//----- (01023A00) --------------------------------------------------------
int __cdecl SEH_4052B0(EXCEPTION_RECORD *a1, struct EHRegistrationNode *a2, struct _CONTEXT *a3, void *a4)
{
  return __CxxFrameHandler3(a1, a2, a3, a4);
}
// 1005CD1: using guessed type _DWORD __cdecl __CxxFrameHandler3(PEXCEPTION_RECORD ExceptionRecord, struct EHRegistrationNode *, struct _CONTEXT *, void *);

//----- (01023A30) --------------------------------------------------------
int __cdecl SEH_405520(EXCEPTION_RECORD *a1, struct EHRegistrationNode *a2, struct _CONTEXT *a3, void *a4)
{
  return __CxxFrameHandler3(a1, a2, a3, a4);
}
// 1005CD1: using guessed type _DWORD __cdecl __CxxFrameHandler3(PEXCEPTION_RECORD ExceptionRecord, struct EHRegistrationNode *, struct _CONTEXT *, void *);

//----- (01023A79) --------------------------------------------------------
int __cdecl SEH_405C70(EXCEPTION_RECORD *a1, struct EHRegistrationNode *a2, struct _CONTEXT *a3, void *a4)
{
  return __CxxFrameHandler3(a1, a2, a3, a4);
}
// 1005CD1: using guessed type _DWORD __cdecl __CxxFrameHandler3(PEXCEPTION_RECORD ExceptionRecord, struct EHRegistrationNode *, struct _CONTEXT *, void *);

//----- (01023AAB) --------------------------------------------------------
int __cdecl SEH_406440(EXCEPTION_RECORD *a1, struct EHRegistrationNode *a2, struct _CONTEXT *a3, void *a4)
{
  return __CxxFrameHandler3(a1, a2, a3, a4);
}
// 1005CD1: using guessed type _DWORD __cdecl __CxxFrameHandler3(PEXCEPTION_RECORD ExceptionRecord, struct EHRegistrationNode *, struct _CONTEXT *, void *);

//----- (01023AF0) --------------------------------------------------------
int __cdecl SEH_406090(EXCEPTION_RECORD *a1, struct EHRegistrationNode *a2, struct _CONTEXT *a3, void *a4)
{
  return __CxxFrameHandler3(a1, a2, a3, a4);
}
// 1005CD1: using guessed type _DWORD __cdecl __CxxFrameHandler3(PEXCEPTION_RECORD ExceptionRecord, struct EHRegistrationNode *, struct _CONTEXT *, void *);

//----- (01023B50) --------------------------------------------------------
int __cdecl SEH_4067A0(EXCEPTION_RECORD *a1, struct EHRegistrationNode *a2, struct _CONTEXT *a3, void *a4)
{
  return __CxxFrameHandler3(a1, a2, a3, a4);
}
// 1005CD1: using guessed type _DWORD __cdecl __CxxFrameHandler3(PEXCEPTION_RECORD ExceptionRecord, struct EHRegistrationNode *, struct _CONTEXT *, void *);

//----- (01023B78) --------------------------------------------------------
int __cdecl SEH_406CC0(EXCEPTION_RECORD *a1, struct EHRegistrationNode *a2, struct _CONTEXT *a3, void *a4)
{
  return __CxxFrameHandler3(a1, a2, a3, a4);
}
// 1005CD1: using guessed type _DWORD __cdecl __CxxFrameHandler3(PEXCEPTION_RECORD ExceptionRecord, struct EHRegistrationNode *, struct _CONTEXT *, void *);

//----- (01023BB8) --------------------------------------------------------
int __cdecl SEH_406DD0(EXCEPTION_RECORD *a1, struct EHRegistrationNode *a2, struct _CONTEXT *a3, void *a4)
{
  return __CxxFrameHandler3(a1, a2, a3, a4);
}
// 1005CD1: using guessed type _DWORD __cdecl __CxxFrameHandler3(PEXCEPTION_RECORD ExceptionRecord, struct EHRegistrationNode *, struct _CONTEXT *, void *);

//----- (01023C38) --------------------------------------------------------
int __cdecl SEH_4070E0(EXCEPTION_RECORD *a1, struct EHRegistrationNode *a2, struct _CONTEXT *a3, void *a4)
{
  return __CxxFrameHandler3(a1, a2, a3, a4);
}
// 1005CD1: using guessed type _DWORD __cdecl __CxxFrameHandler3(PEXCEPTION_RECORD ExceptionRecord, struct EHRegistrationNode *, struct _CONTEXT *, void *);

//----- (01023C81) --------------------------------------------------------
int __cdecl SEH_407CC0(EXCEPTION_RECORD *a1, struct EHRegistrationNode *a2, struct _CONTEXT *a3, void *a4)
{
  return __CxxFrameHandler3(a1, a2, a3, a4);
}
// 1005CD1: using guessed type _DWORD __cdecl __CxxFrameHandler3(PEXCEPTION_RECORD ExceptionRecord, struct EHRegistrationNode *, struct _CONTEXT *, void *);

//----- (01023CD1) --------------------------------------------------------
int __cdecl SEH_4085A0(EXCEPTION_RECORD *a1, struct EHRegistrationNode *a2, struct _CONTEXT *a3, void *a4)
{
  return __CxxFrameHandler3(a1, a2, a3, a4);
}
// 1005CD1: using guessed type _DWORD __cdecl __CxxFrameHandler3(PEXCEPTION_RECORD ExceptionRecord, struct EHRegistrationNode *, struct _CONTEXT *, void *);

//----- (01023E47) --------------------------------------------------------
int __cdecl SEH_4087A0(EXCEPTION_RECORD *a1, struct EHRegistrationNode *a2, struct _CONTEXT *a3, void *a4)
{
  return __CxxFrameHandler3(a1, a2, a3, a4);
}
// 1005CD1: using guessed type _DWORD __cdecl __CxxFrameHandler3(PEXCEPTION_RECORD ExceptionRecord, struct EHRegistrationNode *, struct _CONTEXT *, void *);

//----- (0102403E) --------------------------------------------------------
int __cdecl SEH_409270(EXCEPTION_RECORD *a1, struct EHRegistrationNode *a2, struct _CONTEXT *a3, void *a4)
{
  return __CxxFrameHandler3(a1, a2, a3, a4);
}
// 1005CD1: using guessed type _DWORD __cdecl __CxxFrameHandler3(PEXCEPTION_RECORD ExceptionRecord, struct EHRegistrationNode *, struct _CONTEXT *, void *);

//----- (0102420F) --------------------------------------------------------
int __cdecl SEH_409B70(EXCEPTION_RECORD *a1, struct EHRegistrationNode *a2, struct _CONTEXT *a3, void *a4)
{
  return __CxxFrameHandler3(a1, a2, a3, a4);
}
// 1005CD1: using guessed type _DWORD __cdecl __CxxFrameHandler3(PEXCEPTION_RECORD ExceptionRecord, struct EHRegistrationNode *, struct _CONTEXT *, void *);

//----- (01024238) --------------------------------------------------------
int __cdecl SEH_425730(EXCEPTION_RECORD *a1, struct EHRegistrationNode *a2, struct _CONTEXT *a3, void *a4)
{
  return __CxxFrameHandler3(a1, a2, a3, a4);
}
// 1005CD1: using guessed type _DWORD __cdecl __CxxFrameHandler3(PEXCEPTION_RECORD ExceptionRecord, struct EHRegistrationNode *, struct _CONTEXT *, void *);

//----- (010243B3) --------------------------------------------------------
int __cdecl SEH_40AB10(EXCEPTION_RECORD *a1, struct EHRegistrationNode *a2, struct _CONTEXT *a3, void *a4)
{
  return __CxxFrameHandler3(a1, a2, a3, a4);
}
// 1005CD1: using guessed type _DWORD __cdecl __CxxFrameHandler3(PEXCEPTION_RECORD ExceptionRecord, struct EHRegistrationNode *, struct _CONTEXT *, void *);

//----- (01024910) --------------------------------------------------------
int __cdecl SEH_40B220(EXCEPTION_RECORD *a1, struct EHRegistrationNode *a2, struct _CONTEXT *a3, void *a4)
{
  return __CxxFrameHandler3(a1, a2, a3, a4);
}
// 1005CD1: using guessed type _DWORD __cdecl __CxxFrameHandler3(PEXCEPTION_RECORD ExceptionRecord, struct EHRegistrationNode *, struct _CONTEXT *, void *);

//----- (010249A0) --------------------------------------------------------
int __cdecl SEH_40F2D0(EXCEPTION_RECORD *a1, struct EHRegistrationNode *a2, struct _CONTEXT *a3, void *a4)
{
  return __CxxFrameHandler3(a1, a2, a3, a4);
}
// 1005CD1: using guessed type _DWORD __cdecl __CxxFrameHandler3(PEXCEPTION_RECORD ExceptionRecord, struct EHRegistrationNode *, struct _CONTEXT *, void *);

//----- (010249D8) --------------------------------------------------------
int __cdecl SEH_40F610(EXCEPTION_RECORD *a1, struct EHRegistrationNode *a2, struct _CONTEXT *a3, void *a4)
{
  return __CxxFrameHandler3(a1, a2, a3, a4);
}
// 1005CD1: using guessed type _DWORD __cdecl __CxxFrameHandler3(PEXCEPTION_RECORD ExceptionRecord, struct EHRegistrationNode *, struct _CONTEXT *, void *);

//----- (01024A00) --------------------------------------------------------
int __cdecl SEH_40F9D0(EXCEPTION_RECORD *a1, struct EHRegistrationNode *a2, struct _CONTEXT *a3, void *a4)
{
  return __CxxFrameHandler3(a1, a2, a3, a4);
}
// 1005CD1: using guessed type _DWORD __cdecl __CxxFrameHandler3(PEXCEPTION_RECORD ExceptionRecord, struct EHRegistrationNode *, struct _CONTEXT *, void *);

//----- (01024A20) --------------------------------------------------------
int __cdecl SEH_40FD00(EXCEPTION_RECORD *a1, struct EHRegistrationNode *a2, struct _CONTEXT *a3, void *a4)
{
  return __CxxFrameHandler3(a1, a2, a3, a4);
}
// 1005CD1: using guessed type _DWORD __cdecl __CxxFrameHandler3(PEXCEPTION_RECORD ExceptionRecord, struct EHRegistrationNode *, struct _CONTEXT *, void *);

//----- (01024A40) --------------------------------------------------------
int __cdecl SEH_40FDF0(EXCEPTION_RECORD *a1, struct EHRegistrationNode *a2, struct _CONTEXT *a3, void *a4)
{
  return __CxxFrameHandler3(a1, a2, a3, a4);
}
// 1005CD1: using guessed type _DWORD __cdecl __CxxFrameHandler3(PEXCEPTION_RECORD ExceptionRecord, struct EHRegistrationNode *, struct _CONTEXT *, void *);

//----- (01024A92) --------------------------------------------------------
int __cdecl SEH_410460(EXCEPTION_RECORD *a1, struct EHRegistrationNode *a2, struct _CONTEXT *a3, void *a4)
{
  return __CxxFrameHandler3(a1, a2, a3, a4);
}
// 1005CD1: using guessed type _DWORD __cdecl __CxxFrameHandler3(PEXCEPTION_RECORD ExceptionRecord, struct EHRegistrationNode *, struct _CONTEXT *, void *);

//----- (01024C1A) --------------------------------------------------------
int __cdecl SEH_410790(EXCEPTION_RECORD *a1, struct EHRegistrationNode *a2, struct _CONTEXT *a3, void *a4)
{
  return __CxxFrameHandler3(a1, a2, a3, a4);
}
// 1005CD1: using guessed type _DWORD __cdecl __CxxFrameHandler3(PEXCEPTION_RECORD ExceptionRecord, struct EHRegistrationNode *, struct _CONTEXT *, void *);

//----- (01024C48) --------------------------------------------------------
int __cdecl SEH_411150(EXCEPTION_RECORD *a1, struct EHRegistrationNode *a2, struct _CONTEXT *a3, void *a4)
{
  return __CxxFrameHandler3(a1, a2, a3, a4);
}
// 1005CD1: using guessed type _DWORD __cdecl __CxxFrameHandler3(PEXCEPTION_RECORD ExceptionRecord, struct EHRegistrationNode *, struct _CONTEXT *, void *);

//----- (01024E28) --------------------------------------------------------
int __cdecl SEH_411610(EXCEPTION_RECORD *a1, struct EHRegistrationNode *a2, struct _CONTEXT *a3, void *a4)
{
  return __CxxFrameHandler3(a1, a2, a3, a4);
}
// 1005CD1: using guessed type _DWORD __cdecl __CxxFrameHandler3(PEXCEPTION_RECORD ExceptionRecord, struct EHRegistrationNode *, struct _CONTEXT *, void *);

//----- (01025006) --------------------------------------------------------
int __cdecl SEH_412090(EXCEPTION_RECORD *a1, struct EHRegistrationNode *a2, struct _CONTEXT *a3, void *a4)
{
  return __CxxFrameHandler3(a1, a2, a3, a4);
}
// 1005CD1: using guessed type _DWORD __cdecl __CxxFrameHandler3(PEXCEPTION_RECORD ExceptionRecord, struct EHRegistrationNode *, struct _CONTEXT *, void *);

//----- (01025187) --------------------------------------------------------
int __cdecl SEH_413160(EXCEPTION_RECORD *a1, struct EHRegistrationNode *a2, struct _CONTEXT *a3, void *a4)
{
  return __CxxFrameHandler3(a1, a2, a3, a4);
}
// 1005CD1: using guessed type _DWORD __cdecl __CxxFrameHandler3(PEXCEPTION_RECORD ExceptionRecord, struct EHRegistrationNode *, struct _CONTEXT *, void *);

//----- (01025307) --------------------------------------------------------
int __cdecl SEH_413A80(EXCEPTION_RECORD *a1, struct EHRegistrationNode *a2, struct _CONTEXT *a3, void *a4)
{
  return __CxxFrameHandler3(a1, a2, a3, a4);
}
// 1005CD1: using guessed type _DWORD __cdecl __CxxFrameHandler3(PEXCEPTION_RECORD ExceptionRecord, struct EHRegistrationNode *, struct _CONTEXT *, void *);

//----- (01025509) --------------------------------------------------------
int __cdecl SEH_414200(EXCEPTION_RECORD *a1, struct EHRegistrationNode *a2, struct _CONTEXT *a3, void *a4)
{
  return __CxxFrameHandler3(a1, a2, a3, a4);
}
// 1005CD1: using guessed type _DWORD __cdecl __CxxFrameHandler3(PEXCEPTION_RECORD ExceptionRecord, struct EHRegistrationNode *, struct _CONTEXT *, void *);

//----- (0102580D) --------------------------------------------------------
int __cdecl SEH_414FF0(EXCEPTION_RECORD *a1, struct EHRegistrationNode *a2, struct _CONTEXT *a3, void *a4)
{
  return __CxxFrameHandler3(a1, a2, a3, a4);
}
// 1005CD1: using guessed type _DWORD __cdecl __CxxFrameHandler3(PEXCEPTION_RECORD ExceptionRecord, struct EHRegistrationNode *, struct _CONTEXT *, void *);

//----- (01025A24) --------------------------------------------------------
int __cdecl SEH_415FF0(EXCEPTION_RECORD *a1, struct EHRegistrationNode *a2, struct _CONTEXT *a3, void *a4)
{
  return __CxxFrameHandler3(a1, a2, a3, a4);
}
// 1005CD1: using guessed type _DWORD __cdecl __CxxFrameHandler3(PEXCEPTION_RECORD ExceptionRecord, struct EHRegistrationNode *, struct _CONTEXT *, void *);

//----- (01025AE0) --------------------------------------------------------
int __cdecl SEH_416A10(EXCEPTION_RECORD *a1, struct EHRegistrationNode *a2, struct _CONTEXT *a3, void *a4)
{
  return __CxxFrameHandler3(a1, a2, a3, a4);
}
// 1005CD1: using guessed type _DWORD __cdecl __CxxFrameHandler3(PEXCEPTION_RECORD ExceptionRecord, struct EHRegistrationNode *, struct _CONTEXT *, void *);

//----- (01025B20) --------------------------------------------------------
int __cdecl SEH_416E10(EXCEPTION_RECORD *a1, struct EHRegistrationNode *a2, struct _CONTEXT *a3, void *a4)
{
  return __CxxFrameHandler3(a1, a2, a3, a4);
}
// 1005CD1: using guessed type _DWORD __cdecl __CxxFrameHandler3(PEXCEPTION_RECORD ExceptionRecord, struct EHRegistrationNode *, struct _CONTEXT *, void *);

//----- (01025C9F) --------------------------------------------------------
int __cdecl SEH_417000(EXCEPTION_RECORD *a1, struct EHRegistrationNode *a2, struct _CONTEXT *a3, void *a4)
{
  return __CxxFrameHandler3(a1, a2, a3, a4);
}
// 1005CD1: using guessed type _DWORD __cdecl __CxxFrameHandler3(PEXCEPTION_RECORD ExceptionRecord, struct EHRegistrationNode *, struct _CONTEXT *, void *);

//----- (01025E4B) --------------------------------------------------------
int __cdecl SEH_4177C0(EXCEPTION_RECORD *a1, struct EHRegistrationNode *a2, struct _CONTEXT *a3, void *a4)
{
  return __CxxFrameHandler3(a1, a2, a3, a4);
}
// 1005CD1: using guessed type _DWORD __cdecl __CxxFrameHandler3(PEXCEPTION_RECORD ExceptionRecord, struct EHRegistrationNode *, struct _CONTEXT *, void *);

//----- (01025E78) --------------------------------------------------------
int __cdecl SEH_417FE0(EXCEPTION_RECORD *a1, struct EHRegistrationNode *a2, struct _CONTEXT *a3, void *a4)
{
  return __CxxFrameHandler3(a1, a2, a3, a4);
}
// 1005CD1: using guessed type _DWORD __cdecl __CxxFrameHandler3(PEXCEPTION_RECORD ExceptionRecord, struct EHRegistrationNode *, struct _CONTEXT *, void *);

//----- (01026013) --------------------------------------------------------
int __cdecl SEH_418050(EXCEPTION_RECORD *a1, struct EHRegistrationNode *a2, struct _CONTEXT *a3, void *a4)
{
  return __CxxFrameHandler3(a1, a2, a3, a4);
}
// 1005CD1: using guessed type _DWORD __cdecl __CxxFrameHandler3(PEXCEPTION_RECORD ExceptionRecord, struct EHRegistrationNode *, struct _CONTEXT *, void *);

//----- (01026048) --------------------------------------------------------
int __cdecl SEH_418A90(EXCEPTION_RECORD *a1, struct EHRegistrationNode *a2, struct _CONTEXT *a3, void *a4)
{
  return __CxxFrameHandler3(a1, a2, a3, a4);
}
// 1005CD1: using guessed type _DWORD __cdecl __CxxFrameHandler3(PEXCEPTION_RECORD ExceptionRecord, struct EHRegistrationNode *, struct _CONTEXT *, void *);

//----- (010261C7) --------------------------------------------------------
int __cdecl SEH_418C20(EXCEPTION_RECORD *a1, struct EHRegistrationNode *a2, struct _CONTEXT *a3, void *a4)
{
  return __CxxFrameHandler3(a1, a2, a3, a4);
}
// 1005CD1: using guessed type _DWORD __cdecl __CxxFrameHandler3(PEXCEPTION_RECORD ExceptionRecord, struct EHRegistrationNode *, struct _CONTEXT *, void *);

//----- (010261F8) --------------------------------------------------------
int __cdecl SEH_4193C0(EXCEPTION_RECORD *a1, struct EHRegistrationNode *a2, struct _CONTEXT *a3, void *a4)
{
  return __CxxFrameHandler3(a1, a2, a3, a4);
}
// 1005CD1: using guessed type _DWORD __cdecl __CxxFrameHandler3(PEXCEPTION_RECORD ExceptionRecord, struct EHRegistrationNode *, struct _CONTEXT *, void *);

//----- (01026399) --------------------------------------------------------
int __cdecl SEH_419580(EXCEPTION_RECORD *a1, struct EHRegistrationNode *a2, struct _CONTEXT *a3, void *a4)
{
  return __CxxFrameHandler3(a1, a2, a3, a4);
}
// 1005CD1: using guessed type _DWORD __cdecl __CxxFrameHandler3(PEXCEPTION_RECORD ExceptionRecord, struct EHRegistrationNode *, struct _CONTEXT *, void *);

//----- (01026533) --------------------------------------------------------
int __cdecl SEH_41A120(EXCEPTION_RECORD *a1, struct EHRegistrationNode *a2, struct _CONTEXT *a3, void *a4)
{
  return __CxxFrameHandler3(a1, a2, a3, a4);
}
// 1005CD1: using guessed type _DWORD __cdecl __CxxFrameHandler3(PEXCEPTION_RECORD ExceptionRecord, struct EHRegistrationNode *, struct _CONTEXT *, void *);

//----- (01026568) --------------------------------------------------------
int __cdecl SEH_41AD20(EXCEPTION_RECORD *a1, struct EHRegistrationNode *a2, struct _CONTEXT *a3, void *a4)
{
  return __CxxFrameHandler3(a1, a2, a3, a4);
}
// 1005CD1: using guessed type _DWORD __cdecl __CxxFrameHandler3(PEXCEPTION_RECORD ExceptionRecord, struct EHRegistrationNode *, struct _CONTEXT *, void *);

//----- (0102659B) --------------------------------------------------------
int __cdecl SEH_45ED60(EXCEPTION_RECORD *a1, struct EHRegistrationNode *a2, struct _CONTEXT *a3, void *a4)
{
  return __CxxFrameHandler3(a1, a2, a3, a4);
}
// 1005CD1: using guessed type _DWORD __cdecl __CxxFrameHandler3(PEXCEPTION_RECORD ExceptionRecord, struct EHRegistrationNode *, struct _CONTEXT *, void *);

//----- (01026802) --------------------------------------------------------
int __cdecl SEH_41B1A0(EXCEPTION_RECORD *a1, struct EHRegistrationNode *a2, struct _CONTEXT *a3, void *a4)
{
  return __CxxFrameHandler3(a1, a2, a3, a4);
}
// 1005CD1: using guessed type _DWORD __cdecl __CxxFrameHandler3(PEXCEPTION_RECORD ExceptionRecord, struct EHRegistrationNode *, struct _CONTEXT *, void *);

//----- (0102699B) --------------------------------------------------------
int __cdecl SEH_41D790(EXCEPTION_RECORD *a1, struct EHRegistrationNode *a2, struct _CONTEXT *a3, void *a4)
{
  return __CxxFrameHandler3(a1, a2, a3, a4);
}
// 1005CD1: using guessed type _DWORD __cdecl __CxxFrameHandler3(PEXCEPTION_RECORD ExceptionRecord, struct EHRegistrationNode *, struct _CONTEXT *, void *);

//----- (01026BBC) --------------------------------------------------------
int __cdecl SEH_41E3A0(EXCEPTION_RECORD *a1, struct EHRegistrationNode *a2, struct _CONTEXT *a3, void *a4)
{
  return __CxxFrameHandler3(a1, a2, a3, a4);
}
// 1005CD1: using guessed type _DWORD __cdecl __CxxFrameHandler3(PEXCEPTION_RECORD ExceptionRecord, struct EHRegistrationNode *, struct _CONTEXT *, void *);

//----- (01026BF8) --------------------------------------------------------
int __cdecl SEH_41EFE0(EXCEPTION_RECORD *a1, struct EHRegistrationNode *a2, struct _CONTEXT *a3, void *a4)
{
  return __CxxFrameHandler3(a1, a2, a3, a4);
}
// 1005CD1: using guessed type _DWORD __cdecl __CxxFrameHandler3(PEXCEPTION_RECORD ExceptionRecord, struct EHRegistrationNode *, struct _CONTEXT *, void *);

//----- (01026C38) --------------------------------------------------------
int __cdecl SEH_41F0E0(EXCEPTION_RECORD *a1, struct EHRegistrationNode *a2, struct _CONTEXT *a3, void *a4)
{
  return __CxxFrameHandler3(a1, a2, a3, a4);
}
// 1005CD1: using guessed type _DWORD __cdecl __CxxFrameHandler3(PEXCEPTION_RECORD ExceptionRecord, struct EHRegistrationNode *, struct _CONTEXT *, void *);

//----- (01026F3B) --------------------------------------------------------
int __cdecl SEH_41F260(EXCEPTION_RECORD *a1, struct EHRegistrationNode *a2, struct _CONTEXT *a3, void *a4)
{
  return __CxxFrameHandler3(a1, a2, a3, a4);
}
// 1005CD1: using guessed type _DWORD __cdecl __CxxFrameHandler3(PEXCEPTION_RECORD ExceptionRecord, struct EHRegistrationNode *, struct _CONTEXT *, void *);

//----- (0102704E) --------------------------------------------------------
int __cdecl SEH_420760(EXCEPTION_RECORD *a1, struct EHRegistrationNode *a2, struct _CONTEXT *a3, void *a4)
{
  return __CxxFrameHandler3(a1, a2, a3, a4);
}
// 1005CD1: using guessed type _DWORD __cdecl __CxxFrameHandler3(PEXCEPTION_RECORD ExceptionRecord, struct EHRegistrationNode *, struct _CONTEXT *, void *);

//----- (010270E8) --------------------------------------------------------
int __cdecl SEH_420EA0(EXCEPTION_RECORD *a1, struct EHRegistrationNode *a2, struct _CONTEXT *a3, void *a4)
{
  return __CxxFrameHandler3(a1, a2, a3, a4);
}
// 1005CD1: using guessed type _DWORD __cdecl __CxxFrameHandler3(PEXCEPTION_RECORD ExceptionRecord, struct EHRegistrationNode *, struct _CONTEXT *, void *);

//----- (01027120) --------------------------------------------------------
int __cdecl SEH_4211B0(EXCEPTION_RECORD *a1, struct EHRegistrationNode *a2, struct _CONTEXT *a3, void *a4)
{
  return __CxxFrameHandler3(a1, a2, a3, a4);
}
// 1005CD1: using guessed type _DWORD __cdecl __CxxFrameHandler3(PEXCEPTION_RECORD ExceptionRecord, struct EHRegistrationNode *, struct _CONTEXT *, void *);

//----- (0102714A) --------------------------------------------------------
int __cdecl SEH_4013A0(EXCEPTION_RECORD *a1, struct EHRegistrationNode *a2, struct _CONTEXT *a3, void *a4)
{
  return __CxxFrameHandler3(a1, a2, a3, a4);
}
// 1005CD1: using guessed type _DWORD __cdecl __CxxFrameHandler3(PEXCEPTION_RECORD ExceptionRecord, struct EHRegistrationNode *, struct _CONTEXT *, void *);

//----- (01027178) --------------------------------------------------------
int __cdecl SEH_421590(EXCEPTION_RECORD *a1, struct EHRegistrationNode *a2, struct _CONTEXT *a3, void *a4)
{
  return __CxxFrameHandler3(a1, a2, a3, a4);
}
// 1005CD1: using guessed type _DWORD __cdecl __CxxFrameHandler3(PEXCEPTION_RECORD ExceptionRecord, struct EHRegistrationNode *, struct _CONTEXT *, void *);

//----- (010272D4) --------------------------------------------------------
int __cdecl SEH_421860(EXCEPTION_RECORD *a1, struct EHRegistrationNode *a2, struct _CONTEXT *a3, void *a4)
{
  return __CxxFrameHandler3(a1, a2, a3, a4);
}
// 1005CD1: using guessed type _DWORD __cdecl __CxxFrameHandler3(PEXCEPTION_RECORD ExceptionRecord, struct EHRegistrationNode *, struct _CONTEXT *, void *);

//----- (01027308) --------------------------------------------------------
int __cdecl SEH_422060(EXCEPTION_RECORD *a1, struct EHRegistrationNode *a2, struct _CONTEXT *a3, void *a4)
{
  return __CxxFrameHandler3(a1, a2, a3, a4);
}
// 1005CD1: using guessed type _DWORD __cdecl __CxxFrameHandler3(PEXCEPTION_RECORD ExceptionRecord, struct EHRegistrationNode *, struct _CONTEXT *, void *);

//----- (0102747C) --------------------------------------------------------
int __cdecl SEH_422110(EXCEPTION_RECORD *a1, struct EHRegistrationNode *a2, struct _CONTEXT *a3, void *a4)
{
  return __CxxFrameHandler3(a1, a2, a3, a4);
}
// 1005CD1: using guessed type _DWORD __cdecl __CxxFrameHandler3(PEXCEPTION_RECORD ExceptionRecord, struct EHRegistrationNode *, struct _CONTEXT *, void *);

//----- (0102764A) --------------------------------------------------------
int __cdecl SEH_4227D0(EXCEPTION_RECORD *a1, struct EHRegistrationNode *a2, struct _CONTEXT *a3, void *a4)
{
  return __CxxFrameHandler3(a1, a2, a3, a4);
}
// 1005CD1: using guessed type _DWORD __cdecl __CxxFrameHandler3(PEXCEPTION_RECORD ExceptionRecord, struct EHRegistrationNode *, struct _CONTEXT *, void *);

//----- (0102782A) --------------------------------------------------------
int __cdecl SEH_423190(EXCEPTION_RECORD *a1, struct EHRegistrationNode *a2, struct _CONTEXT *a3, void *a4)
{
  return __CxxFrameHandler3(a1, a2, a3, a4);
}
// 1005CD1: using guessed type _DWORD __cdecl __CxxFrameHandler3(PEXCEPTION_RECORD ExceptionRecord, struct EHRegistrationNode *, struct _CONTEXT *, void *);

//----- (01027860) --------------------------------------------------------
int __cdecl SEH_424040(EXCEPTION_RECORD *a1, struct EHRegistrationNode *a2, struct _CONTEXT *a3, void *a4)
{
  return __CxxFrameHandler3(a1, a2, a3, a4);
}
// 1005CD1: using guessed type _DWORD __cdecl __CxxFrameHandler3(PEXCEPTION_RECORD ExceptionRecord, struct EHRegistrationNode *, struct _CONTEXT *, void *);

//----- (01027880) --------------------------------------------------------
int __cdecl SEH_424270(EXCEPTION_RECORD *a1, struct EHRegistrationNode *a2, struct _CONTEXT *a3, void *a4)
{
  return __CxxFrameHandler3(a1, a2, a3, a4);
}
// 1005CD1: using guessed type _DWORD __cdecl __CxxFrameHandler3(PEXCEPTION_RECORD ExceptionRecord, struct EHRegistrationNode *, struct _CONTEXT *, void *);

//----- (010278A0) --------------------------------------------------------
int __cdecl SEH_4244A0(EXCEPTION_RECORD *a1, struct EHRegistrationNode *a2, struct _CONTEXT *a3, void *a4)
{
  return __CxxFrameHandler3(a1, a2, a3, a4);
}
// 1005CD1: using guessed type _DWORD __cdecl __CxxFrameHandler3(PEXCEPTION_RECORD ExceptionRecord, struct EHRegistrationNode *, struct _CONTEXT *, void *);

//----- (010278C0) --------------------------------------------------------
int __cdecl SEH_4245C0(EXCEPTION_RECORD *a1, struct EHRegistrationNode *a2, struct _CONTEXT *a3, void *a4)
{
  return __CxxFrameHandler3(a1, a2, a3, a4);
}
// 1005CD1: using guessed type _DWORD __cdecl __CxxFrameHandler3(PEXCEPTION_RECORD ExceptionRecord, struct EHRegistrationNode *, struct _CONTEXT *, void *);

//----- (010278FE) --------------------------------------------------------
int __cdecl SEH_424740(EXCEPTION_RECORD *a1, struct EHRegistrationNode *a2, struct _CONTEXT *a3, void *a4)
{
  return __CxxFrameHandler3(a1, a2, a3, a4);
}
// 1005CD1: using guessed type _DWORD __cdecl __CxxFrameHandler3(PEXCEPTION_RECORD ExceptionRecord, struct EHRegistrationNode *, struct _CONTEXT *, void *);

//----- (01027938) --------------------------------------------------------
int __cdecl SEH_424920(EXCEPTION_RECORD *a1, struct EHRegistrationNode *a2, struct _CONTEXT *a3, void *a4)
{
  return __CxxFrameHandler3(a1, a2, a3, a4);
}
// 1005CD1: using guessed type _DWORD __cdecl __CxxFrameHandler3(PEXCEPTION_RECORD ExceptionRecord, struct EHRegistrationNode *, struct _CONTEXT *, void *);

//----- (01027998) --------------------------------------------------------
int __cdecl SEH_424FE0(EXCEPTION_RECORD *a1, struct EHRegistrationNode *a2, struct _CONTEXT *a3, void *a4)
{
  return __CxxFrameHandler3(a1, a2, a3, a4);
}
// 1005CD1: using guessed type _DWORD __cdecl __CxxFrameHandler3(PEXCEPTION_RECORD ExceptionRecord, struct EHRegistrationNode *, struct _CONTEXT *, void *);

//----- (010279D0) --------------------------------------------------------
int __cdecl SEH_425120(EXCEPTION_RECORD *a1, struct EHRegistrationNode *a2, struct _CONTEXT *a3, void *a4)
{
  return __CxxFrameHandler3(a1, a2, a3, a4);
}
// 1005CD1: using guessed type _DWORD __cdecl __CxxFrameHandler3(PEXCEPTION_RECORD ExceptionRecord, struct EHRegistrationNode *, struct _CONTEXT *, void *);

//----- (010279F8) --------------------------------------------------------
int __cdecl SEH_425350(EXCEPTION_RECORD *a1, struct EHRegistrationNode *a2, struct _CONTEXT *a3, void *a4)
{
  return __CxxFrameHandler3(a1, a2, a3, a4);
}
// 1005CD1: using guessed type _DWORD __cdecl __CxxFrameHandler3(PEXCEPTION_RECORD ExceptionRecord, struct EHRegistrationNode *, struct _CONTEXT *, void *);

//----- (01027A28) --------------------------------------------------------
int __cdecl SEH_425440(EXCEPTION_RECORD *a1, struct EHRegistrationNode *a2, struct _CONTEXT *a3, void *a4)
{
  return __CxxFrameHandler3(a1, a2, a3, a4);
}
// 1005CD1: using guessed type _DWORD __cdecl __CxxFrameHandler3(PEXCEPTION_RECORD ExceptionRecord, struct EHRegistrationNode *, struct _CONTEXT *, void *);

//----- (01027A58) --------------------------------------------------------
int __cdecl SEH_425850(EXCEPTION_RECORD *a1, struct EHRegistrationNode *a2, struct _CONTEXT *a3, void *a4)
{
  return __CxxFrameHandler3(a1, a2, a3, a4);
}
// 1005CD1: using guessed type _DWORD __cdecl __CxxFrameHandler3(PEXCEPTION_RECORD ExceptionRecord, struct EHRegistrationNode *, struct _CONTEXT *, void *);

//----- (01027A99) --------------------------------------------------------
int __cdecl SEH_425940(EXCEPTION_RECORD *a1, struct EHRegistrationNode *a2, struct _CONTEXT *a3, void *a4)
{
  return __CxxFrameHandler3(a1, a2, a3, a4);
}
// 1005CD1: using guessed type _DWORD __cdecl __CxxFrameHandler3(PEXCEPTION_RECORD ExceptionRecord, struct EHRegistrationNode *, struct _CONTEXT *, void *);

//----- (01027AC8) --------------------------------------------------------
int __cdecl SEH_425AB0(EXCEPTION_RECORD *a1, struct EHRegistrationNode *a2, struct _CONTEXT *a3, void *a4)
{
  return __CxxFrameHandler3(a1, a2, a3, a4);
}
// 1005CD1: using guessed type _DWORD __cdecl __CxxFrameHandler3(PEXCEPTION_RECORD ExceptionRecord, struct EHRegistrationNode *, struct _CONTEXT *, void *);

//----- (01027BBA) --------------------------------------------------------
int __cdecl SEH_425D10(EXCEPTION_RECORD *a1, struct EHRegistrationNode *a2, struct _CONTEXT *a3, void *a4)
{
  return __CxxFrameHandler3(a1, a2, a3, a4);
}
// 1005CD1: using guessed type _DWORD __cdecl __CxxFrameHandler3(PEXCEPTION_RECORD ExceptionRecord, struct EHRegistrationNode *, struct _CONTEXT *, void *);

//----- (01027BF8) --------------------------------------------------------
int __cdecl SEH_426830(EXCEPTION_RECORD *a1, struct EHRegistrationNode *a2, struct _CONTEXT *a3, void *a4)
{
  return __CxxFrameHandler3(a1, a2, a3, a4);
}
// 1005CD1: using guessed type _DWORD __cdecl __CxxFrameHandler3(PEXCEPTION_RECORD ExceptionRecord, struct EHRegistrationNode *, struct _CONTEXT *, void *);

//----- (01027C28) --------------------------------------------------------
int __cdecl SEH_4269A0(EXCEPTION_RECORD *a1, struct EHRegistrationNode *a2, struct _CONTEXT *a3, void *a4)
{
  return __CxxFrameHandler3(a1, a2, a3, a4);
}
// 1005CD1: using guessed type _DWORD __cdecl __CxxFrameHandler3(PEXCEPTION_RECORD ExceptionRecord, struct EHRegistrationNode *, struct _CONTEXT *, void *);

//----- (01027C50) --------------------------------------------------------
int __cdecl SEH_426BB0(EXCEPTION_RECORD *a1, struct EHRegistrationNode *a2, struct _CONTEXT *a3, void *a4)
{
  return __CxxFrameHandler3(a1, a2, a3, a4);
}
// 1005CD1: using guessed type _DWORD __cdecl __CxxFrameHandler3(PEXCEPTION_RECORD ExceptionRecord, struct EHRegistrationNode *, struct _CONTEXT *, void *);

//----- (01027C78) --------------------------------------------------------
int __cdecl SEH_427AC0(EXCEPTION_RECORD *a1, struct EHRegistrationNode *a2, struct _CONTEXT *a3, void *a4)
{
  return __CxxFrameHandler3(a1, a2, a3, a4);
}
// 1005CD1: using guessed type _DWORD __cdecl __CxxFrameHandler3(PEXCEPTION_RECORD ExceptionRecord, struct EHRegistrationNode *, struct _CONTEXT *, void *);

//----- (01027CAB) --------------------------------------------------------
int __cdecl SEH_45E760(EXCEPTION_RECORD *a1, struct EHRegistrationNode *a2, struct _CONTEXT *a3, void *a4)
{
  return __CxxFrameHandler3(a1, a2, a3, a4);
}
// 1005CD1: using guessed type _DWORD __cdecl __CxxFrameHandler3(PEXCEPTION_RECORD ExceptionRecord, struct EHRegistrationNode *, struct _CONTEXT *, void *);

//----- (01027CE6) --------------------------------------------------------
int __cdecl SEH_428730(EXCEPTION_RECORD *a1, struct EHRegistrationNode *a2, struct _CONTEXT *a3, void *a4)
{
  return __CxxFrameHandler3(a1, a2, a3, a4);
}
// 1005CD1: using guessed type _DWORD __cdecl __CxxFrameHandler3(PEXCEPTION_RECORD ExceptionRecord, struct EHRegistrationNode *, struct _CONTEXT *, void *);

//----- (01027D45) --------------------------------------------------------
int __cdecl SEH_428970(EXCEPTION_RECORD *a1, struct EHRegistrationNode *a2, struct _CONTEXT *a3, void *a4)
{
  return __CxxFrameHandler3(a1, a2, a3, a4);
}
// 1005CD1: using guessed type _DWORD __cdecl __CxxFrameHandler3(PEXCEPTION_RECORD ExceptionRecord, struct EHRegistrationNode *, struct _CONTEXT *, void *);

//----- (01027D80) --------------------------------------------------------
int __cdecl SEH_429580(EXCEPTION_RECORD *a1, struct EHRegistrationNode *a2, struct _CONTEXT *a3, void *a4)
{
  return __CxxFrameHandler3(a1, a2, a3, a4);
}
// 1005CD1: using guessed type _DWORD __cdecl __CxxFrameHandler3(PEXCEPTION_RECORD ExceptionRecord, struct EHRegistrationNode *, struct _CONTEXT *, void *);

//----- (01027DA8) --------------------------------------------------------
int __cdecl SEH_42A1F0(EXCEPTION_RECORD *a1, struct EHRegistrationNode *a2, struct _CONTEXT *a3, void *a4)
{
  return __CxxFrameHandler3(a1, a2, a3, a4);
}
// 1005CD1: using guessed type _DWORD __cdecl __CxxFrameHandler3(PEXCEPTION_RECORD ExceptionRecord, struct EHRegistrationNode *, struct _CONTEXT *, void *);

//----- (01027DDB) --------------------------------------------------------
int __cdecl SEH_42FAF0(EXCEPTION_RECORD *a1, struct EHRegistrationNode *a2, struct _CONTEXT *a3, void *a4)
{
  return __CxxFrameHandler3(a1, a2, a3, a4);
}
// 1005CD1: using guessed type _DWORD __cdecl __CxxFrameHandler3(PEXCEPTION_RECORD ExceptionRecord, struct EHRegistrationNode *, struct _CONTEXT *, void *);

//----- (01027E10) --------------------------------------------------------
int __cdecl SEH_431240(EXCEPTION_RECORD *a1, struct EHRegistrationNode *a2, struct _CONTEXT *a3, void *a4)
{
  return __CxxFrameHandler3(a1, a2, a3, a4);
}
// 1005CD1: using guessed type _DWORD __cdecl __CxxFrameHandler3(PEXCEPTION_RECORD ExceptionRecord, struct EHRegistrationNode *, struct _CONTEXT *, void *);

//----- (01027E60) --------------------------------------------------------
int __cdecl SEH_431560(EXCEPTION_RECORD *a1, struct EHRegistrationNode *a2, struct _CONTEXT *a3, void *a4)
{
  return __CxxFrameHandler3(a1, a2, a3, a4);
}
// 1005CD1: using guessed type _DWORD __cdecl __CxxFrameHandler3(PEXCEPTION_RECORD ExceptionRecord, struct EHRegistrationNode *, struct _CONTEXT *, void *);

//----- (01027EDE) --------------------------------------------------------
int __cdecl SEH_4318A0(EXCEPTION_RECORD *a1, struct EHRegistrationNode *a2, struct _CONTEXT *a3, void *a4)
{
  return __CxxFrameHandler3(a1, a2, a3, a4);
}
// 1005CD1: using guessed type _DWORD __cdecl __CxxFrameHandler3(PEXCEPTION_RECORD ExceptionRecord, struct EHRegistrationNode *, struct _CONTEXT *, void *);

//----- (01027F83) --------------------------------------------------------
int __cdecl SEH_431BC0(EXCEPTION_RECORD *a1, struct EHRegistrationNode *a2, struct _CONTEXT *a3, void *a4)
{
  return __CxxFrameHandler3(a1, a2, a3, a4);
}
// 1005CD1: using guessed type _DWORD __cdecl __CxxFrameHandler3(PEXCEPTION_RECORD ExceptionRecord, struct EHRegistrationNode *, struct _CONTEXT *, void *);

//----- (01028191) --------------------------------------------------------
int __cdecl SEH_431FC0(EXCEPTION_RECORD *a1, struct EHRegistrationNode *a2, struct _CONTEXT *a3, void *a4)
{
  return __CxxFrameHandler3(a1, a2, a3, a4);
}
// 1005CD1: using guessed type _DWORD __cdecl __CxxFrameHandler3(PEXCEPTION_RECORD ExceptionRecord, struct EHRegistrationNode *, struct _CONTEXT *, void *);

//----- (0102825C) --------------------------------------------------------
int __cdecl SEH_4337E0(EXCEPTION_RECORD *a1, struct EHRegistrationNode *a2, struct _CONTEXT *a3, void *a4)
{
  return __CxxFrameHandler3(a1, a2, a3, a4);
}
// 1005CD1: using guessed type _DWORD __cdecl __CxxFrameHandler3(PEXCEPTION_RECORD ExceptionRecord, struct EHRegistrationNode *, struct _CONTEXT *, void *);

//----- (010282B1) --------------------------------------------------------
int __cdecl SEH_434530(EXCEPTION_RECORD *a1, struct EHRegistrationNode *a2, struct _CONTEXT *a3, void *a4)
{
  return __CxxFrameHandler3(a1, a2, a3, a4);
}
// 1005CD1: using guessed type _DWORD __cdecl __CxxFrameHandler3(PEXCEPTION_RECORD ExceptionRecord, struct EHRegistrationNode *, struct _CONTEXT *, void *);

//----- (010282E9) --------------------------------------------------------
int __cdecl SEH_434810(EXCEPTION_RECORD *a1, struct EHRegistrationNode *a2, struct _CONTEXT *a3, void *a4)
{
  return __CxxFrameHandler3(a1, a2, a3, a4);
}
// 1005CD1: using guessed type _DWORD __cdecl __CxxFrameHandler3(PEXCEPTION_RECORD ExceptionRecord, struct EHRegistrationNode *, struct _CONTEXT *, void *);

//----- (01028320) --------------------------------------------------------
int __cdecl SEH_434AA0(EXCEPTION_RECORD *a1, struct EHRegistrationNode *a2, struct _CONTEXT *a3, void *a4)
{
  return __CxxFrameHandler3(a1, a2, a3, a4);
}
// 1005CD1: using guessed type _DWORD __cdecl __CxxFrameHandler3(PEXCEPTION_RECORD ExceptionRecord, struct EHRegistrationNode *, struct _CONTEXT *, void *);

//----- (01028358) --------------------------------------------------------
int __cdecl SEH_434F00(EXCEPTION_RECORD *a1, struct EHRegistrationNode *a2, struct _CONTEXT *a3, void *a4)
{
  return __CxxFrameHandler3(a1, a2, a3, a4);
}
// 1005CD1: using guessed type _DWORD __cdecl __CxxFrameHandler3(PEXCEPTION_RECORD ExceptionRecord, struct EHRegistrationNode *, struct _CONTEXT *, void *);

//----- (010285A0) --------------------------------------------------------
int __cdecl SEH_4355A0(EXCEPTION_RECORD *a1, struct EHRegistrationNode *a2, struct _CONTEXT *a3, void *a4)
{
  return __CxxFrameHandler3(a1, a2, a3, a4);
}
// 1005CD1: using guessed type _DWORD __cdecl __CxxFrameHandler3(PEXCEPTION_RECORD ExceptionRecord, struct EHRegistrationNode *, struct _CONTEXT *, void *);

//----- (010285D0) --------------------------------------------------------
int __cdecl SEH_437DF0(EXCEPTION_RECORD *a1, struct EHRegistrationNode *a2, struct _CONTEXT *a3, void *a4)
{
  return __CxxFrameHandler3(a1, a2, a3, a4);
}
// 1005CD1: using guessed type _DWORD __cdecl __CxxFrameHandler3(PEXCEPTION_RECORD ExceptionRecord, struct EHRegistrationNode *, struct _CONTEXT *, void *);

//----- (010285F8) --------------------------------------------------------
int __cdecl SEH_438150(EXCEPTION_RECORD *a1, struct EHRegistrationNode *a2, struct _CONTEXT *a3, void *a4)
{
  return __CxxFrameHandler3(a1, a2, a3, a4);
}
// 1005CD1: using guessed type _DWORD __cdecl __CxxFrameHandler3(PEXCEPTION_RECORD ExceptionRecord, struct EHRegistrationNode *, struct _CONTEXT *, void *);

//----- (0102866A) --------------------------------------------------------
int __cdecl SEH_438360(EXCEPTION_RECORD *a1, struct EHRegistrationNode *a2, struct _CONTEXT *a3, void *a4)
{
  return __CxxFrameHandler3(a1, a2, a3, a4);
}
// 1005CD1: using guessed type _DWORD __cdecl __CxxFrameHandler3(PEXCEPTION_RECORD ExceptionRecord, struct EHRegistrationNode *, struct _CONTEXT *, void *);

//----- (01028698) --------------------------------------------------------
int __cdecl SEH_438570(EXCEPTION_RECORD *a1, struct EHRegistrationNode *a2, struct _CONTEXT *a3, void *a4)
{
  return __CxxFrameHandler3(a1, a2, a3, a4);
}
// 1005CD1: using guessed type _DWORD __cdecl __CxxFrameHandler3(PEXCEPTION_RECORD ExceptionRecord, struct EHRegistrationNode *, struct _CONTEXT *, void *);

//----- (010286C8) --------------------------------------------------------
int __cdecl SEH_438630(EXCEPTION_RECORD *a1, struct EHRegistrationNode *a2, struct _CONTEXT *a3, void *a4)
{
  return __CxxFrameHandler3(a1, a2, a3, a4);
}
// 1005CD1: using guessed type _DWORD __cdecl __CxxFrameHandler3(PEXCEPTION_RECORD ExceptionRecord, struct EHRegistrationNode *, struct _CONTEXT *, void *);

//----- (01028735) --------------------------------------------------------
int __cdecl SEH_438CE0(EXCEPTION_RECORD *a1, struct EHRegistrationNode *a2, struct _CONTEXT *a3, void *a4)
{
  return __CxxFrameHandler3(a1, a2, a3, a4);
}
// 1005CD1: using guessed type _DWORD __cdecl __CxxFrameHandler3(PEXCEPTION_RECORD ExceptionRecord, struct EHRegistrationNode *, struct _CONTEXT *, void *);

//----- (0102876B) --------------------------------------------------------
int __cdecl SEH_439090(EXCEPTION_RECORD *a1, struct EHRegistrationNode *a2, struct _CONTEXT *a3, void *a4)
{
  return __CxxFrameHandler3(a1, a2, a3, a4);
}
// 1005CD1: using guessed type _DWORD __cdecl __CxxFrameHandler3(PEXCEPTION_RECORD ExceptionRecord, struct EHRegistrationNode *, struct _CONTEXT *, void *);

//----- (010287A0) --------------------------------------------------------
int __cdecl SEH_4391F0(EXCEPTION_RECORD *a1, struct EHRegistrationNode *a2, struct _CONTEXT *a3, void *a4)
{
  return __CxxFrameHandler3(a1, a2, a3, a4);
}
// 1005CD1: using guessed type _DWORD __cdecl __CxxFrameHandler3(PEXCEPTION_RECORD ExceptionRecord, struct EHRegistrationNode *, struct _CONTEXT *, void *);

//----- (010287D0) --------------------------------------------------------
int __cdecl SEH_4392D0(EXCEPTION_RECORD *a1, struct EHRegistrationNode *a2, struct _CONTEXT *a3, void *a4)
{
  return __CxxFrameHandler3(a1, a2, a3, a4);
}
// 1005CD1: using guessed type _DWORD __cdecl __CxxFrameHandler3(PEXCEPTION_RECORD ExceptionRecord, struct EHRegistrationNode *, struct _CONTEXT *, void *);

//----- (010287F8) --------------------------------------------------------
int __cdecl SEH_439D10(EXCEPTION_RECORD *a1, struct EHRegistrationNode *a2, struct _CONTEXT *a3, void *a4)
{
  return __CxxFrameHandler3(a1, a2, a3, a4);
}
// 1005CD1: using guessed type _DWORD __cdecl __CxxFrameHandler3(PEXCEPTION_RECORD ExceptionRecord, struct EHRegistrationNode *, struct _CONTEXT *, void *);

//----- (01028828) --------------------------------------------------------
int __cdecl SEH_439E70(EXCEPTION_RECORD *a1, struct EHRegistrationNode *a2, struct _CONTEXT *a3, void *a4)
{
  return __CxxFrameHandler3(a1, a2, a3, a4);
}
// 1005CD1: using guessed type _DWORD __cdecl __CxxFrameHandler3(PEXCEPTION_RECORD ExceptionRecord, struct EHRegistrationNode *, struct _CONTEXT *, void *);

//----- (01028850) --------------------------------------------------------
int __cdecl SEH_43B100(EXCEPTION_RECORD *a1, struct EHRegistrationNode *a2, struct _CONTEXT *a3, void *a4)
{
  return __CxxFrameHandler3(a1, a2, a3, a4);
}
// 1005CD1: using guessed type _DWORD __cdecl __CxxFrameHandler3(PEXCEPTION_RECORD ExceptionRecord, struct EHRegistrationNode *, struct _CONTEXT *, void *);

//----- (01028889) --------------------------------------------------------
int __cdecl SEH_43B460(EXCEPTION_RECORD *a1, struct EHRegistrationNode *a2, struct _CONTEXT *a3, void *a4)
{
  return __CxxFrameHandler3(a1, a2, a3, a4);
}
// 1005CD1: using guessed type _DWORD __cdecl __CxxFrameHandler3(PEXCEPTION_RECORD ExceptionRecord, struct EHRegistrationNode *, struct _CONTEXT *, void *);

//----- (010288D0) --------------------------------------------------------
int __cdecl SEH_43B780(EXCEPTION_RECORD *a1, struct EHRegistrationNode *a2, struct _CONTEXT *a3, void *a4)
{
  return __CxxFrameHandler3(a1, a2, a3, a4);
}
// 1005CD1: using guessed type _DWORD __cdecl __CxxFrameHandler3(PEXCEPTION_RECORD ExceptionRecord, struct EHRegistrationNode *, struct _CONTEXT *, void *);

//----- (0102894F) --------------------------------------------------------
int __cdecl SEH_43BF00(EXCEPTION_RECORD *a1, struct EHRegistrationNode *a2, struct _CONTEXT *a3, void *a4)
{
  return __CxxFrameHandler3(a1, a2, a3, a4);
}
// 1005CD1: using guessed type _DWORD __cdecl __CxxFrameHandler3(PEXCEPTION_RECORD ExceptionRecord, struct EHRegistrationNode *, struct _CONTEXT *, void *);

//----- (010289A4) --------------------------------------------------------
int __cdecl SEH_43D080(EXCEPTION_RECORD *a1, struct EHRegistrationNode *a2, struct _CONTEXT *a3, void *a4)
{
  return __CxxFrameHandler3(a1, a2, a3, a4);
}
// 1005CD1: using guessed type _DWORD __cdecl __CxxFrameHandler3(PEXCEPTION_RECORD ExceptionRecord, struct EHRegistrationNode *, struct _CONTEXT *, void *);

//----- (010289C8) --------------------------------------------------------
int __cdecl SEH_43D1D0(EXCEPTION_RECORD *a1, struct EHRegistrationNode *a2, struct _CONTEXT *a3, void *a4)
{
  return __CxxFrameHandler3(a1, a2, a3, a4);
}
// 1005CD1: using guessed type _DWORD __cdecl __CxxFrameHandler3(PEXCEPTION_RECORD ExceptionRecord, struct EHRegistrationNode *, struct _CONTEXT *, void *);

//----- (01028A19) --------------------------------------------------------
int __cdecl SEH_43D3B0(EXCEPTION_RECORD *a1, struct EHRegistrationNode *a2, struct _CONTEXT *a3, void *a4)
{
  return __CxxFrameHandler3(a1, a2, a3, a4);
}
// 1005CD1: using guessed type _DWORD __cdecl __CxxFrameHandler3(PEXCEPTION_RECORD ExceptionRecord, struct EHRegistrationNode *, struct _CONTEXT *, void *);

//----- (01028A5E) --------------------------------------------------------
int __cdecl SEH_43D590(EXCEPTION_RECORD *a1, struct EHRegistrationNode *a2, struct _CONTEXT *a3, void *a4)
{
  return __CxxFrameHandler3(a1, a2, a3, a4);
}
// 1005CD1: using guessed type _DWORD __cdecl __CxxFrameHandler3(PEXCEPTION_RECORD ExceptionRecord, struct EHRegistrationNode *, struct _CONTEXT *, void *);

//----- (01028AD5) --------------------------------------------------------
int __cdecl SEH_43D670(EXCEPTION_RECORD *a1, struct EHRegistrationNode *a2, struct _CONTEXT *a3, void *a4)
{
  return __CxxFrameHandler3(a1, a2, a3, a4);
}
// 1005CD1: using guessed type _DWORD __cdecl __CxxFrameHandler3(PEXCEPTION_RECORD ExceptionRecord, struct EHRegistrationNode *, struct _CONTEXT *, void *);

//----- (01028B03) --------------------------------------------------------
int __cdecl SEH_43DF10(EXCEPTION_RECORD *a1, struct EHRegistrationNode *a2, struct _CONTEXT *a3, void *a4)
{
  return __CxxFrameHandler3(a1, a2, a3, a4);
}
// 1005CD1: using guessed type _DWORD __cdecl __CxxFrameHandler3(PEXCEPTION_RECORD ExceptionRecord, struct EHRegistrationNode *, struct _CONTEXT *, void *);

//----- (01028B3E) --------------------------------------------------------
int __cdecl SEH_43E1A0(EXCEPTION_RECORD *a1, struct EHRegistrationNode *a2, struct _CONTEXT *a3, void *a4)
{
  return __CxxFrameHandler3(a1, a2, a3, a4);
}
// 1005CD1: using guessed type _DWORD __cdecl __CxxFrameHandler3(PEXCEPTION_RECORD ExceptionRecord, struct EHRegistrationNode *, struct _CONTEXT *, void *);

//----- (01028B7B) --------------------------------------------------------
int __cdecl SEH_43EAD0(EXCEPTION_RECORD *a1, struct EHRegistrationNode *a2, struct _CONTEXT *a3, void *a4)
{
  return __CxxFrameHandler3(a1, a2, a3, a4);
}
// 1005CD1: using guessed type _DWORD __cdecl __CxxFrameHandler3(PEXCEPTION_RECORD ExceptionRecord, struct EHRegistrationNode *, struct _CONTEXT *, void *);

//----- (01028BAB) --------------------------------------------------------
int __cdecl SEH_43EBA0(EXCEPTION_RECORD *a1, struct EHRegistrationNode *a2, struct _CONTEXT *a3, void *a4)
{
  return __CxxFrameHandler3(a1, a2, a3, a4);
}
// 1005CD1: using guessed type _DWORD __cdecl __CxxFrameHandler3(PEXCEPTION_RECORD ExceptionRecord, struct EHRegistrationNode *, struct _CONTEXT *, void *);

//----- (01028BE0) --------------------------------------------------------
int __cdecl SEH_43EEA0(EXCEPTION_RECORD *a1, struct EHRegistrationNode *a2, struct _CONTEXT *a3, void *a4)
{
  return __CxxFrameHandler3(a1, a2, a3, a4);
}
// 1005CD1: using guessed type _DWORD __cdecl __CxxFrameHandler3(PEXCEPTION_RECORD ExceptionRecord, struct EHRegistrationNode *, struct _CONTEXT *, void *);

//----- (01028C75) --------------------------------------------------------
int __cdecl SEH_43F0A0(EXCEPTION_RECORD *a1, struct EHRegistrationNode *a2, struct _CONTEXT *a3, void *a4)
{
  return __CxxFrameHandler3(a1, a2, a3, a4);
}
// 1005CD1: using guessed type _DWORD __cdecl __CxxFrameHandler3(PEXCEPTION_RECORD ExceptionRecord, struct EHRegistrationNode *, struct _CONTEXT *, void *);

//----- (01028CA8) --------------------------------------------------------
int __cdecl SEH_43FFF0(EXCEPTION_RECORD *a1, struct EHRegistrationNode *a2, struct _CONTEXT *a3, void *a4)
{
  return __CxxFrameHandler3(a1, a2, a3, a4);
}
// 1005CD1: using guessed type _DWORD __cdecl __CxxFrameHandler3(PEXCEPTION_RECORD ExceptionRecord, struct EHRegistrationNode *, struct _CONTEXT *, void *);

//----- (01028CD8) --------------------------------------------------------
int __cdecl SEH_469E00(EXCEPTION_RECORD *a1, struct EHRegistrationNode *a2, struct _CONTEXT *a3, void *a4)
{
  return __CxxFrameHandler3(a1, a2, a3, a4);
}
// 1005CD1: using guessed type _DWORD __cdecl __CxxFrameHandler3(PEXCEPTION_RECORD ExceptionRecord, struct EHRegistrationNode *, struct _CONTEXT *, void *);

//----- (01028D16) --------------------------------------------------------
int __cdecl SEH_445F60(EXCEPTION_RECORD *a1, struct EHRegistrationNode *a2, struct _CONTEXT *a3, void *a4)
{
  return __CxxFrameHandler3(a1, a2, a3, a4);
}
// 1005CD1: using guessed type _DWORD __cdecl __CxxFrameHandler3(PEXCEPTION_RECORD ExceptionRecord, struct EHRegistrationNode *, struct _CONTEXT *, void *);

//----- (01028EBE) --------------------------------------------------------
int __cdecl SEH_446270(EXCEPTION_RECORD *a1, struct EHRegistrationNode *a2, struct _CONTEXT *a3, void *a4)
{
  return __CxxFrameHandler3(a1, a2, a3, a4);
}
// 1005CD1: using guessed type _DWORD __cdecl __CxxFrameHandler3(PEXCEPTION_RECORD ExceptionRecord, struct EHRegistrationNode *, struct _CONTEXT *, void *);

//----- (01028FC9) --------------------------------------------------------
int __cdecl SEH_451E50(EXCEPTION_RECORD *a1, struct EHRegistrationNode *a2, struct _CONTEXT *a3, void *a4)
{
  return __CxxFrameHandler3(a1, a2, a3, a4);
}
// 1005CD1: using guessed type _DWORD __cdecl __CxxFrameHandler3(PEXCEPTION_RECORD ExceptionRecord, struct EHRegistrationNode *, struct _CONTEXT *, void *);

//----- (0102902D) --------------------------------------------------------
int __cdecl SEH_4526B0(EXCEPTION_RECORD *a1, struct EHRegistrationNode *a2, struct _CONTEXT *a3, void *a4)
{
  return __CxxFrameHandler3(a1, a2, a3, a4);
}
// 1005CD1: using guessed type _DWORD __cdecl __CxxFrameHandler3(PEXCEPTION_RECORD ExceptionRecord, struct EHRegistrationNode *, struct _CONTEXT *, void *);

//----- (01029081) --------------------------------------------------------
int __cdecl SEH_457640(EXCEPTION_RECORD *a1, struct EHRegistrationNode *a2, struct _CONTEXT *a3, void *a4)
{
  return __CxxFrameHandler3(a1, a2, a3, a4);
}
// 1005CD1: using guessed type _DWORD __cdecl __CxxFrameHandler3(PEXCEPTION_RECORD ExceptionRecord, struct EHRegistrationNode *, struct _CONTEXT *, void *);

//----- (010290B1) --------------------------------------------------------
int __cdecl SEH_457740(EXCEPTION_RECORD *a1, struct EHRegistrationNode *a2, struct _CONTEXT *a3, void *a4)
{
  return __CxxFrameHandler3(a1, a2, a3, a4);
}
// 1005CD1: using guessed type _DWORD __cdecl __CxxFrameHandler3(PEXCEPTION_RECORD ExceptionRecord, struct EHRegistrationNode *, struct _CONTEXT *, void *);

//----- (010290F6) --------------------------------------------------------
int __cdecl SEH_4577E0(EXCEPTION_RECORD *a1, struct EHRegistrationNode *a2, struct _CONTEXT *a3, void *a4)
{
  return __CxxFrameHandler3(a1, a2, a3, a4);
}
// 1005CD1: using guessed type _DWORD __cdecl __CxxFrameHandler3(PEXCEPTION_RECORD ExceptionRecord, struct EHRegistrationNode *, struct _CONTEXT *, void *);

//----- (01029138) --------------------------------------------------------
int __cdecl SEH_457DD0(EXCEPTION_RECORD *a1, struct EHRegistrationNode *a2, struct _CONTEXT *a3, void *a4)
{
  return __CxxFrameHandler3(a1, a2, a3, a4);
}
// 1005CD1: using guessed type _DWORD __cdecl __CxxFrameHandler3(PEXCEPTION_RECORD ExceptionRecord, struct EHRegistrationNode *, struct _CONTEXT *, void *);

//----- (010291C3) --------------------------------------------------------
int __cdecl SEH_4580C0(EXCEPTION_RECORD *a1, struct EHRegistrationNode *a2, struct _CONTEXT *a3, void *a4)
{
  return __CxxFrameHandler3(a1, a2, a3, a4);
}
// 1005CD1: using guessed type _DWORD __cdecl __CxxFrameHandler3(PEXCEPTION_RECORD ExceptionRecord, struct EHRegistrationNode *, struct _CONTEXT *, void *);

//----- (010291F0) --------------------------------------------------------
int __cdecl SEH_458AE0(EXCEPTION_RECORD *a1, struct EHRegistrationNode *a2, struct _CONTEXT *a3, void *a4)
{
  return __CxxFrameHandler3(a1, a2, a3, a4);
}
// 1005CD1: using guessed type _DWORD __cdecl __CxxFrameHandler3(PEXCEPTION_RECORD ExceptionRecord, struct EHRegistrationNode *, struct _CONTEXT *, void *);

//----- (01029218) --------------------------------------------------------
int __cdecl SEH_458C80(EXCEPTION_RECORD *a1, struct EHRegistrationNode *a2, struct _CONTEXT *a3, void *a4)
{
  return __CxxFrameHandler3(a1, a2, a3, a4);
}
// 1005CD1: using guessed type _DWORD __cdecl __CxxFrameHandler3(PEXCEPTION_RECORD ExceptionRecord, struct EHRegistrationNode *, struct _CONTEXT *, void *);

//----- (01029248) --------------------------------------------------------
int __cdecl SEH_458D10(EXCEPTION_RECORD *a1, struct EHRegistrationNode *a2, struct _CONTEXT *a3, void *a4)
{
  return __CxxFrameHandler3(a1, a2, a3, a4);
}
// 1005CD1: using guessed type _DWORD __cdecl __CxxFrameHandler3(PEXCEPTION_RECORD ExceptionRecord, struct EHRegistrationNode *, struct _CONTEXT *, void *);

//----- (010292D3) --------------------------------------------------------
int __cdecl SEH_458E20(EXCEPTION_RECORD *a1, struct EHRegistrationNode *a2, struct _CONTEXT *a3, void *a4)
{
  return __CxxFrameHandler3(a1, a2, a3, a4);
}
// 1005CD1: using guessed type _DWORD __cdecl __CxxFrameHandler3(PEXCEPTION_RECORD ExceptionRecord, struct EHRegistrationNode *, struct _CONTEXT *, void *);

//----- (0102930B) --------------------------------------------------------
int __cdecl SEH_459500(EXCEPTION_RECORD *a1, struct EHRegistrationNode *a2, struct _CONTEXT *a3, void *a4)
{
  return __CxxFrameHandler3(a1, a2, a3, a4);
}
// 1005CD1: using guessed type _DWORD __cdecl __CxxFrameHandler3(PEXCEPTION_RECORD ExceptionRecord, struct EHRegistrationNode *, struct _CONTEXT *, void *);

//----- (010293FF) --------------------------------------------------------
int __cdecl SEH_459C50(EXCEPTION_RECORD *a1, struct EHRegistrationNode *a2, struct _CONTEXT *a3, void *a4)
{
  return __CxxFrameHandler3(a1, a2, a3, a4);
}
// 1005CD1: using guessed type _DWORD __cdecl __CxxFrameHandler3(PEXCEPTION_RECORD ExceptionRecord, struct EHRegistrationNode *, struct _CONTEXT *, void *);

//----- (01029452) --------------------------------------------------------
int __cdecl SEH_45A570(EXCEPTION_RECORD *a1, struct EHRegistrationNode *a2, struct _CONTEXT *a3, void *a4)
{
  return __CxxFrameHandler3(a1, a2, a3, a4);
}
// 1005CD1: using guessed type _DWORD __cdecl __CxxFrameHandler3(PEXCEPTION_RECORD ExceptionRecord, struct EHRegistrationNode *, struct _CONTEXT *, void *);

//----- (01029504) --------------------------------------------------------
int __cdecl SEH_45B0A0(EXCEPTION_RECORD *a1, struct EHRegistrationNode *a2, struct _CONTEXT *a3, void *a4)
{
  return __CxxFrameHandler3(a1, a2, a3, a4);
}
// 1005CD1: using guessed type _DWORD __cdecl __CxxFrameHandler3(PEXCEPTION_RECORD ExceptionRecord, struct EHRegistrationNode *, struct _CONTEXT *, void *);

//----- (0102954B) --------------------------------------------------------
int __cdecl SEH_45B680(EXCEPTION_RECORD *a1, struct EHRegistrationNode *a2, struct _CONTEXT *a3, void *a4)
{
  return __CxxFrameHandler3(a1, a2, a3, a4);
}
// 1005CD1: using guessed type _DWORD __cdecl __CxxFrameHandler3(PEXCEPTION_RECORD ExceptionRecord, struct EHRegistrationNode *, struct _CONTEXT *, void *);

//----- (01029580) --------------------------------------------------------
int __cdecl SEH_45B8A0(EXCEPTION_RECORD *a1, struct EHRegistrationNode *a2, struct _CONTEXT *a3, void *a4)
{
  return __CxxFrameHandler3(a1, a2, a3, a4);
}
// 1005CD1: using guessed type _DWORD __cdecl __CxxFrameHandler3(PEXCEPTION_RECORD ExceptionRecord, struct EHRegistrationNode *, struct _CONTEXT *, void *);

//----- (010295A0) --------------------------------------------------------
int __cdecl SEH_45C840(EXCEPTION_RECORD *a1, struct EHRegistrationNode *a2, struct _CONTEXT *a3, void *a4)
{
  return __CxxFrameHandler3(a1, a2, a3, a4);
}
// 1005CD1: using guessed type _DWORD __cdecl __CxxFrameHandler3(PEXCEPTION_RECORD ExceptionRecord, struct EHRegistrationNode *, struct _CONTEXT *, void *);

//----- (010295CB) --------------------------------------------------------
int __cdecl SEH_45EE00(EXCEPTION_RECORD *a1, struct EHRegistrationNode *a2, struct _CONTEXT *a3, void *a4)
{
  return __CxxFrameHandler3(a1, a2, a3, a4);
}
// 1005CD1: using guessed type _DWORD __cdecl __CxxFrameHandler3(PEXCEPTION_RECORD ExceptionRecord, struct EHRegistrationNode *, struct _CONTEXT *, void *);

//----- (0102964C) --------------------------------------------------------
int __cdecl SEH_45D510(EXCEPTION_RECORD *a1, struct EHRegistrationNode *a2, struct _CONTEXT *a3, void *a4)
{
  return __CxxFrameHandler3(a1, a2, a3, a4);
}
// 1005CD1: using guessed type _DWORD __cdecl __CxxFrameHandler3(PEXCEPTION_RECORD ExceptionRecord, struct EHRegistrationNode *, struct _CONTEXT *, void *);

//----- (010296B2) --------------------------------------------------------
int __cdecl SEH_45DCE0(EXCEPTION_RECORD *a1, struct EHRegistrationNode *a2, struct _CONTEXT *a3, void *a4)
{
  return __CxxFrameHandler3(a1, a2, a3, a4);
}
// 1005CD1: using guessed type _DWORD __cdecl __CxxFrameHandler3(PEXCEPTION_RECORD ExceptionRecord, struct EHRegistrationNode *, struct _CONTEXT *, void *);

//----- (010296F9) --------------------------------------------------------
int __cdecl SEH_45E4E0(EXCEPTION_RECORD *a1, struct EHRegistrationNode *a2, struct _CONTEXT *a3, void *a4)
{
  return __CxxFrameHandler3(a1, a2, a3, a4);
}
// 1005CD1: using guessed type _DWORD __cdecl __CxxFrameHandler3(PEXCEPTION_RECORD ExceptionRecord, struct EHRegistrationNode *, struct _CONTEXT *, void *);

//----- (0102972B) --------------------------------------------------------
int __cdecl SEH_45E8B0(EXCEPTION_RECORD *a1, struct EHRegistrationNode *a2, struct _CONTEXT *a3, void *a4)
{
  return __CxxFrameHandler3(a1, a2, a3, a4);
}
// 1005CD1: using guessed type _DWORD __cdecl __CxxFrameHandler3(PEXCEPTION_RECORD ExceptionRecord, struct EHRegistrationNode *, struct _CONTEXT *, void *);

//----- (01029758) --------------------------------------------------------
int __cdecl SEH_466900(EXCEPTION_RECORD *a1, struct EHRegistrationNode *a2, struct _CONTEXT *a3, void *a4)
{
  return __CxxFrameHandler3(a1, a2, a3, a4);
}
// 1005CD1: using guessed type _DWORD __cdecl __CxxFrameHandler3(PEXCEPTION_RECORD ExceptionRecord, struct EHRegistrationNode *, struct _CONTEXT *, void *);

//----- (01029780) --------------------------------------------------------
int __cdecl SEH_469AF0(EXCEPTION_RECORD *a1, struct EHRegistrationNode *a2, struct _CONTEXT *a3, void *a4)
{
  return __CxxFrameHandler3(a1, a2, a3, a4);
}
// 1005CD1: using guessed type _DWORD __cdecl __CxxFrameHandler3(PEXCEPTION_RECORD ExceptionRecord, struct EHRegistrationNode *, struct _CONTEXT *, void *);

//----- (010297A0) --------------------------------------------------------
int __cdecl SEH_469C10(EXCEPTION_RECORD *a1, struct EHRegistrationNode *a2, struct _CONTEXT *a3, void *a4)
{
  return __CxxFrameHandler3(a1, a2, a3, a4);
}
// 1005CD1: using guessed type _DWORD __cdecl __CxxFrameHandler3(PEXCEPTION_RECORD ExceptionRecord, struct EHRegistrationNode *, struct _CONTEXT *, void *);

//----- (010297C8) --------------------------------------------------------
int __cdecl SEH_469EA0(EXCEPTION_RECORD *a1, struct EHRegistrationNode *a2, struct _CONTEXT *a3, void *a4)
{
  return __CxxFrameHandler3(a1, a2, a3, a4);
}
// 1005CD1: using guessed type _DWORD __cdecl __CxxFrameHandler3(PEXCEPTION_RECORD ExceptionRecord, struct EHRegistrationNode *, struct _CONTEXT *, void *);

//----- (010297FE) --------------------------------------------------------
int __cdecl SEH_46A670(EXCEPTION_RECORD *a1, struct EHRegistrationNode *a2, struct _CONTEXT *a3, void *a4)
{
  return __CxxFrameHandler3(a1, a2, a3, a4);
}
// 1005CD1: using guessed type _DWORD __cdecl __CxxFrameHandler3(PEXCEPTION_RECORD ExceptionRecord, struct EHRegistrationNode *, struct _CONTEXT *, void *);

//----- (0102983E) --------------------------------------------------------
int __cdecl SEH_46ADD0(EXCEPTION_RECORD *a1, struct EHRegistrationNode *a2, struct _CONTEXT *a3, void *a4)
{
  return __CxxFrameHandler3(a1, a2, a3, a4);
}
// 1005CD1: using guessed type _DWORD __cdecl __CxxFrameHandler3(PEXCEPTION_RECORD ExceptionRecord, struct EHRegistrationNode *, struct _CONTEXT *, void *);

//----- (0102987B) --------------------------------------------------------
int __cdecl SEH_46B930(EXCEPTION_RECORD *a1, struct EHRegistrationNode *a2, struct _CONTEXT *a3, void *a4)
{
  return __CxxFrameHandler3(a1, a2, a3, a4);
}
// 1005CD1: using guessed type _DWORD __cdecl __CxxFrameHandler3(PEXCEPTION_RECORD ExceptionRecord, struct EHRegistrationNode *, struct _CONTEXT *, void *);

//----- (010298D1) --------------------------------------------------------
int __cdecl SEH_46BC50(EXCEPTION_RECORD *a1, struct EHRegistrationNode *a2, struct _CONTEXT *a3, void *a4)
{
  return __CxxFrameHandler3(a1, a2, a3, a4);
}
// 1005CD1: using guessed type _DWORD __cdecl __CxxFrameHandler3(PEXCEPTION_RECORD ExceptionRecord, struct EHRegistrationNode *, struct _CONTEXT *, void *);

//----- (01029908) --------------------------------------------------------
int __cdecl SEH_46C350(EXCEPTION_RECORD *a1, struct EHRegistrationNode *a2, struct _CONTEXT *a3, void *a4)
{
  return __CxxFrameHandler3(a1, a2, a3, a4);
}
// 1005CD1: using guessed type _DWORD __cdecl __CxxFrameHandler3(PEXCEPTION_RECORD ExceptionRecord, struct EHRegistrationNode *, struct _CONTEXT *, void *);

//----- (01029938) --------------------------------------------------------
int __cdecl SEH_46DAF0(EXCEPTION_RECORD *a1, struct EHRegistrationNode *a2, struct _CONTEXT *a3, void *a4)
{
  return __CxxFrameHandler3(a1, a2, a3, a4);
}
// 1005CD1: using guessed type _DWORD __cdecl __CxxFrameHandler3(PEXCEPTION_RECORD ExceptionRecord, struct EHRegistrationNode *, struct _CONTEXT *, void *);

//----- (01029976) --------------------------------------------------------
int __cdecl SEH_46DD60(EXCEPTION_RECORD *a1, struct EHRegistrationNode *a2, struct _CONTEXT *a3, void *a4)
{
  return __CxxFrameHandler3(a1, a2, a3, a4);
}
// 1005CD1: using guessed type _DWORD __cdecl __CxxFrameHandler3(PEXCEPTION_RECORD ExceptionRecord, struct EHRegistrationNode *, struct _CONTEXT *, void *);

//----- (010299B3) --------------------------------------------------------
int __cdecl SEH_46EC30(EXCEPTION_RECORD *a1, struct EHRegistrationNode *a2, struct _CONTEXT *a3, void *a4)
{
  return __CxxFrameHandler3(a1, a2, a3, a4);
}
// 1005CD1: using guessed type _DWORD __cdecl __CxxFrameHandler3(PEXCEPTION_RECORD ExceptionRecord, struct EHRegistrationNode *, struct _CONTEXT *, void *);

//----- (01029A01) --------------------------------------------------------
int __cdecl SEH_4703E0(EXCEPTION_RECORD *a1, struct EHRegistrationNode *a2, struct _CONTEXT *a3, void *a4)
{
  return __CxxFrameHandler3(a1, a2, a3, a4);
}
// 1005CD1: using guessed type _DWORD __cdecl __CxxFrameHandler3(PEXCEPTION_RECORD ExceptionRecord, struct EHRegistrationNode *, struct _CONTEXT *, void *);

//----- (01029A3B) --------------------------------------------------------
int __cdecl SEH_4723A0(EXCEPTION_RECORD *a1, struct EHRegistrationNode *a2, struct _CONTEXT *a3, void *a4)
{
  return __CxxFrameHandler3(a1, a2, a3, a4);
}
// 1005CD1: using guessed type _DWORD __cdecl __CxxFrameHandler3(PEXCEPTION_RECORD ExceptionRecord, struct EHRegistrationNode *, struct _CONTEXT *, void *);

//----- (01029A6E) --------------------------------------------------------
int __cdecl SEH_472810(EXCEPTION_RECORD *a1, struct EHRegistrationNode *a2, struct _CONTEXT *a3, void *a4)
{
  return __CxxFrameHandler3(a1, a2, a3, a4);
}
// 1005CD1: using guessed type _DWORD __cdecl __CxxFrameHandler3(PEXCEPTION_RECORD ExceptionRecord, struct EHRegistrationNode *, struct _CONTEXT *, void *);

//----- (01029B48) --------------------------------------------------------
int __cdecl SEH_472C20(EXCEPTION_RECORD *a1, struct EHRegistrationNode *a2, struct _CONTEXT *a3, void *a4)
{
  return __CxxFrameHandler3(a1, a2, a3, a4);
}
// 1005CD1: using guessed type _DWORD __cdecl __CxxFrameHandler3(PEXCEPTION_RECORD ExceptionRecord, struct EHRegistrationNode *, struct _CONTEXT *, void *);

//----- (01029B7E) --------------------------------------------------------
int __cdecl SEH_473C50(EXCEPTION_RECORD *a1, struct EHRegistrationNode *a2, struct _CONTEXT *a3, void *a4)
{
  return __CxxFrameHandler3(a1, a2, a3, a4);
}
// 1005CD1: using guessed type _DWORD __cdecl __CxxFrameHandler3(PEXCEPTION_RECORD ExceptionRecord, struct EHRegistrationNode *, struct _CONTEXT *, void *);

//----- (01029BBB) --------------------------------------------------------
int __cdecl SEH_474990(EXCEPTION_RECORD *a1, struct EHRegistrationNode *a2, struct _CONTEXT *a3, void *a4)
{
  return __CxxFrameHandler3(a1, a2, a3, a4);
}
// 1005CD1: using guessed type _DWORD __cdecl __CxxFrameHandler3(PEXCEPTION_RECORD ExceptionRecord, struct EHRegistrationNode *, struct _CONTEXT *, void *);

//----- (01029BEE) --------------------------------------------------------
int __cdecl SEH_4766A0(EXCEPTION_RECORD *a1, struct EHRegistrationNode *a2, struct _CONTEXT *a3, void *a4)
{
  return __CxxFrameHandler3(a1, a2, a3, a4);
}
// 1005CD1: using guessed type _DWORD __cdecl __CxxFrameHandler3(PEXCEPTION_RECORD ExceptionRecord, struct EHRegistrationNode *, struct _CONTEXT *, void *);

//----- (01029C2E) --------------------------------------------------------
int __cdecl SEH_477710(EXCEPTION_RECORD *a1, struct EHRegistrationNode *a2, struct _CONTEXT *a3, void *a4)
{
  return __CxxFrameHandler3(a1, a2, a3, a4);
}
// 1005CD1: using guessed type _DWORD __cdecl __CxxFrameHandler3(PEXCEPTION_RECORD ExceptionRecord, struct EHRegistrationNode *, struct _CONTEXT *, void *);

//----- (01029C6E) --------------------------------------------------------
int __cdecl SEH_478E00(EXCEPTION_RECORD *a1, struct EHRegistrationNode *a2, struct _CONTEXT *a3, void *a4)
{
  return __CxxFrameHandler3(a1, a2, a3, a4);
}
// 1005CD1: using guessed type _DWORD __cdecl __CxxFrameHandler3(PEXCEPTION_RECORD ExceptionRecord, struct EHRegistrationNode *, struct _CONTEXT *, void *);

//----- (01029CAB) --------------------------------------------------------
int __cdecl SEH_479A30(EXCEPTION_RECORD *a1, struct EHRegistrationNode *a2, struct _CONTEXT *a3, void *a4)
{
  return __CxxFrameHandler3(a1, a2, a3, a4);
}
// 1005CD1: using guessed type _DWORD __cdecl __CxxFrameHandler3(PEXCEPTION_RECORD ExceptionRecord, struct EHRegistrationNode *, struct _CONTEXT *, void *);

//----- (01029CEE) --------------------------------------------------------
int __cdecl SEH_47ACF0(EXCEPTION_RECORD *a1, struct EHRegistrationNode *a2, struct _CONTEXT *a3, void *a4)
{
  return __CxxFrameHandler3(a1, a2, a3, a4);
}
// 1005CD1: using guessed type _DWORD __cdecl __CxxFrameHandler3(PEXCEPTION_RECORD ExceptionRecord, struct EHRegistrationNode *, struct _CONTEXT *, void *);

//----- (01029D2B) --------------------------------------------------------
int __cdecl SEH_47D5B0(EXCEPTION_RECORD *a1, struct EHRegistrationNode *a2, struct _CONTEXT *a3, void *a4)
{
  return __CxxFrameHandler3(a1, a2, a3, a4);
}
// 1005CD1: using guessed type _DWORD __cdecl __CxxFrameHandler3(PEXCEPTION_RECORD ExceptionRecord, struct EHRegistrationNode *, struct _CONTEXT *, void *);

//----- (01029D70) --------------------------------------------------------
int __cdecl SEH_4808E0(EXCEPTION_RECORD *a1, struct EHRegistrationNode *a2, struct _CONTEXT *a3, void *a4)
{
  return __CxxFrameHandler3(a1, a2, a3, a4);
}
// 1005CD1: using guessed type _DWORD __cdecl __CxxFrameHandler3(PEXCEPTION_RECORD ExceptionRecord, struct EHRegistrationNode *, struct _CONTEXT *, void *);

//----- (01029D9E) --------------------------------------------------------
int __cdecl SEH_4809B0(EXCEPTION_RECORD *a1, struct EHRegistrationNode *a2, struct _CONTEXT *a3, void *a4)
{
  return __CxxFrameHandler3(a1, a2, a3, a4);
}
// 1005CD1: using guessed type _DWORD __cdecl __CxxFrameHandler3(PEXCEPTION_RECORD ExceptionRecord, struct EHRegistrationNode *, struct _CONTEXT *, void *);

//----- (01029DDE) --------------------------------------------------------
int __cdecl SEH_4818B0(EXCEPTION_RECORD *a1, struct EHRegistrationNode *a2, struct _CONTEXT *a3, void *a4)
{
  return __CxxFrameHandler3(a1, a2, a3, a4);
}
// 1005CD1: using guessed type _DWORD __cdecl __CxxFrameHandler3(PEXCEPTION_RECORD ExceptionRecord, struct EHRegistrationNode *, struct _CONTEXT *, void *);

//----- (01029E1E) --------------------------------------------------------
int __cdecl SEH_482010(EXCEPTION_RECORD *a1, struct EHRegistrationNode *a2, struct _CONTEXT *a3, void *a4)
{
  return __CxxFrameHandler3(a1, a2, a3, a4);
}
// 1005CD1: using guessed type _DWORD __cdecl __CxxFrameHandler3(PEXCEPTION_RECORD ExceptionRecord, struct EHRegistrationNode *, struct _CONTEXT *, void *);

//----- (01029E5E) --------------------------------------------------------
int __cdecl SEH_4825E0(EXCEPTION_RECORD *a1, struct EHRegistrationNode *a2, struct _CONTEXT *a3, void *a4)
{
  return __CxxFrameHandler3(a1, a2, a3, a4);
}
// 1005CD1: using guessed type _DWORD __cdecl __CxxFrameHandler3(PEXCEPTION_RECORD ExceptionRecord, struct EHRegistrationNode *, struct _CONTEXT *, void *);

//----- (01029E9B) --------------------------------------------------------
int __cdecl SEH_483260(EXCEPTION_RECORD *a1, struct EHRegistrationNode *a2, struct _CONTEXT *a3, void *a4)
{
  return __CxxFrameHandler3(a1, a2, a3, a4);
}
// 1005CD1: using guessed type _DWORD __cdecl __CxxFrameHandler3(PEXCEPTION_RECORD ExceptionRecord, struct EHRegistrationNode *, struct _CONTEXT *, void *);

//----- (01029ECE) --------------------------------------------------------
int __cdecl SEH_483AF0(EXCEPTION_RECORD *a1, struct EHRegistrationNode *a2, struct _CONTEXT *a3, void *a4)
{
  return __CxxFrameHandler3(a1, a2, a3, a4);
}
// 1005CD1: using guessed type _DWORD __cdecl __CxxFrameHandler3(PEXCEPTION_RECORD ExceptionRecord, struct EHRegistrationNode *, struct _CONTEXT *, void *);

//----- (01029F3D) --------------------------------------------------------
int __cdecl SEH_483FC0(EXCEPTION_RECORD *a1, struct EHRegistrationNode *a2, struct _CONTEXT *a3, void *a4)
{
  return __CxxFrameHandler3(a1, a2, a3, a4);
}
// 1005CD1: using guessed type _DWORD __cdecl __CxxFrameHandler3(PEXCEPTION_RECORD ExceptionRecord, struct EHRegistrationNode *, struct _CONTEXT *, void *);

//----- (01029F70) --------------------------------------------------------
int __cdecl SEH_491650(EXCEPTION_RECORD *a1, struct EHRegistrationNode *a2, struct _CONTEXT *a3, void *a4)
{
  return __CxxFrameHandler3(a1, a2, a3, a4);
}
// 1005CD1: using guessed type _DWORD __cdecl __CxxFrameHandler3(PEXCEPTION_RECORD ExceptionRecord, struct EHRegistrationNode *, struct _CONTEXT *, void *);

//----- (01029F9A) --------------------------------------------------------
int __cdecl SEH_401FF0(EXCEPTION_RECORD *a1, struct EHRegistrationNode *a2, struct _CONTEXT *a3, void *a4)
{
  return __CxxFrameHandler3(a1, a2, a3, a4);
}
// 1005CD1: using guessed type _DWORD __cdecl __CxxFrameHandler3(PEXCEPTION_RECORD ExceptionRecord, struct EHRegistrationNode *, struct _CONTEXT *, void *);

//----- (01029FD0) --------------------------------------------------------
int __cdecl SEH_491C30(EXCEPTION_RECORD *a1, struct EHRegistrationNode *a2, struct _CONTEXT *a3, void *a4)
{
  return __CxxFrameHandler3(a1, a2, a3, a4);
}
// 1005CD1: using guessed type _DWORD __cdecl __CxxFrameHandler3(PEXCEPTION_RECORD ExceptionRecord, struct EHRegistrationNode *, struct _CONTEXT *, void *);

//----- (0102A003) --------------------------------------------------------
int __cdecl SEH_491EC0(EXCEPTION_RECORD *a1, struct EHRegistrationNode *a2, struct _CONTEXT *a3, void *a4)
{
  return __CxxFrameHandler3(a1, a2, a3, a4);
}
// 1005CD1: using guessed type _DWORD __cdecl __CxxFrameHandler3(PEXCEPTION_RECORD ExceptionRecord, struct EHRegistrationNode *, struct _CONTEXT *, void *);

//----- (0102A039) --------------------------------------------------------
int __cdecl SEH_492230(EXCEPTION_RECORD *a1, struct EHRegistrationNode *a2, struct _CONTEXT *a3, void *a4)
{
  return __CxxFrameHandler3(a1, a2, a3, a4);
}
// 1005CD1: using guessed type _DWORD __cdecl __CxxFrameHandler3(PEXCEPTION_RECORD ExceptionRecord, struct EHRegistrationNode *, struct _CONTEXT *, void *);

//----- (0102A070) --------------------------------------------------------
int __cdecl SEH_494270(EXCEPTION_RECORD *a1, struct EHRegistrationNode *a2, struct _CONTEXT *a3, void *a4)
{
  return __CxxFrameHandler3(a1, a2, a3, a4);
}
// 1005CD1: using guessed type _DWORD __cdecl __CxxFrameHandler3(PEXCEPTION_RECORD ExceptionRecord, struct EHRegistrationNode *, struct _CONTEXT *, void *);

//----- (0102A093) --------------------------------------------------------
int __cdecl sub_102A093(EXCEPTION_RECORD *a1, struct EHRegistrationNode *a2, struct _CONTEXT *a3, void *a4)
{
  return __CxxFrameHandler3(a1, a2, a3, a4);
}
// 1005CD1: using guessed type _DWORD __cdecl __CxxFrameHandler3(PEXCEPTION_RECORD ExceptionRecord, struct EHRegistrationNode *, struct _CONTEXT *, void *);

//----- (0102A0AE) --------------------------------------------------------
int __cdecl sub_102A0AE(EXCEPTION_RECORD *a1, struct EHRegistrationNode *a2, struct _CONTEXT *a3, void *a4)
{
  return __CxxFrameHandler3(a1, a2, a3, a4);
}
// 1005CD1: using guessed type _DWORD __cdecl __CxxFrameHandler3(PEXCEPTION_RECORD ExceptionRecord, struct EHRegistrationNode *, struct _CONTEXT *, void *);

//----- (0102A0D0) --------------------------------------------------------
void __cdecl sub_102A0D0()
{
  `eh vector destructor iterator'(word_1064900, 0x28u, 20, sub_F73850);
}
// 1064900: using guessed type __int16 word_1064900[400];

//----- (0102A0F0) --------------------------------------------------------
void __thiscall sub_102A0F0(void *this)
{
  void *v1; // [esp-2h] [ebp-4h]

  v1 = this;
  if ( garrAccountInfo.baseclass_0._Mypair._Myval2._Myfirst )
  {
    nullsub_1(garrAccountInfo.baseclass_0._Mypair._Myval2._Myfirst, garrAccountInfo.baseclass_0._Mypair._Myval2._Mylast);
    ATL::CAtlStringMgr::Clone((&v1 + 3));
    j__free(garrAccountInfo.baseclass_0._Mypair._Myval2._Myfirst);
    garrAccountInfo.baseclass_0._Mypair._Myval2._Myfirst = 0;
    garrAccountInfo.baseclass_0._Mypair._Myval2._Mylast = 0;
    garrAccountInfo.baseclass_0._Mypair._Myval2._Myend = 0;
  }
}
// F7FB30: using guessed type _DWORD __stdcall nullsub_1(_DWORD, _DWORD);

//----- (0102A150) --------------------------------------------------------
void __cdecl sub_102A150()
{
  free(gpszTipText);
}

//----- (0102A160) --------------------------------------------------------
void __cdecl sub_102A160()
{
  void *v0; // esi

  v0 = dword_10648F8;
  if ( dword_10648F8 )
  {
    if ( !InterlockedDecrement(dword_10648F8 + 2) && v0 )
    {
      if ( *v0 )
      {
        SysFreeString(*v0);
        *v0 = 0;
      }
      if ( *(v0 + 1) )
      {
        j_j__free(*(v0 + 1));
        *(v0 + 1) = 0;
      }
      j__free(v0);
    }
    dword_10648F8 = 0;
  }
}

//----- (0102A1C0) --------------------------------------------------------
void __cdecl sub_102A1C0()
{
  void *v0; // esi

  v0 = dword_10648F4;
  if ( dword_10648F4 )
  {
    if ( !InterlockedDecrement(dword_10648F4 + 2) && v0 )
    {
      if ( *v0 )
      {
        SysFreeString(*v0);
        *v0 = 0;
      }
      if ( *(v0 + 1) )
      {
        j_j__free(*(v0 + 1));
        *(v0 + 1) = 0;
      }
      j__free(v0);
    }
    dword_10648F4 = 0;
  }
}

//----- (0102A220) --------------------------------------------------------
void __cdecl sub_102A220()
{
  free(dword_4F48E4);
}

//----- (0102A230) --------------------------------------------------------
void __cdecl sub_102A230()
{
  free(gpszSystemPathInfo);
}

//----- (0102A240) --------------------------------------------------------
void __cdecl sub_102A240()
{
  free(dword_4F48FC);
}

//----- (0102A250) --------------------------------------------------------
void __cdecl dynamic_atexit_destructor_for__gKeyNameMap__()
{
  std__Tree_node *v0; // esi
  int a2; // [esp+4h] [ebp-8h]
  char v2; // [esp+Bh] [ebp-1h]

  std::_Tree<std::_Tmap_traits<wchar_t const *,tagKeyName,std::less<wchar_t const *>,std::allocator<std::pair<wchar_t const * const,tagKeyName>>,0>>::erase(
    &gKeyNameMap,
    &a2,
    gKeyNameMap._Mypair._Myval2._Myhead->_Left,
    gKeyNameMap._Mypair._Myval2._Myhead);
  v0 = gKeyNameMap._Mypair._Myval2._Myhead;
  ATL::CAtlStringMgr::Clone(&v2);
  nullsub_2(v0);
  ATL::CAtlStringMgr::Clone(&v2);
  nullsub_2(&v0->_Parent);
  ATL::CAtlStringMgr::Clone(&v2);
  nullsub_2(&v0->_Right);
  ATL::CAtlStringMgr::Clone(&v2);
  j__free(v0);
}
// F97A90: using guessed type _DWORD __stdcall nullsub_2(_DWORD);

//----- (0102A2D0) --------------------------------------------------------
void __cdecl sub_102A2D0()
{
  free(dword_4F48F0);
}

//----- (0102A2E0) --------------------------------------------------------
void __cdecl sub_102A2E0()
{
  free(*&gpszText1);
}

//----- (0102A2F0) --------------------------------------------------------
void __cdecl sub_102A2F0()
{
  free(dword_4F4C54);
}

//----- (0102A300) --------------------------------------------------------
void __cdecl sub_102A300()
{
  free(dword_4F4C50);
}

//----- (0102A310) --------------------------------------------------------
void __cdecl sub_102A310()
{
  _DWORD **v0; // eax
  _DWORD *v1; // ecx
  _DWORD *v2; // esi
  _DWORD **v3; // eax
  _DWORD *v4; // ecx
  _DWORD *v5; // esi

  v0 = *(&dword_1064CD0 + 4);
  v1 = *v0;
  *v0 = v0;
  *(*(&dword_1064CD0 + 4) + 4) = *(&dword_1064CD0 + 4);
  *(&dword_1064CD0 + 5) = 0;
  if ( v1 != *(&dword_1064CD0 + 4) )
  {
    do
    {
      v2 = *v1;
      j__free(v1);
      v1 = v2;
    }
    while ( v2 != *(&dword_1064CD0 + 4) );
  }
  j__free(*(&dword_1064CD0 + 4));
  v3 = *(&dword_1064CD0 + 2);
  v4 = *v3;
  *v3 = v3;
  *(*(&dword_1064CD0 + 2) + 4) = *(&dword_1064CD0 + 2);
  *(&dword_1064CD0 + 3) = 0;
  if ( v4 != *(&dword_1064CD0 + 2) )
  {
    do
    {
      v5 = *v4;
      j__free(v4);
      v4 = v5;
    }
    while ( v5 != *(&dword_1064CD0 + 2) );
  }
  j__free(*(&dword_1064CD0 + 2));
}
// 1064CD0: using guessed type int dword_1064CD0;

//----- (0102A320) --------------------------------------------------------
void __cdecl sub_102A320()
{
  void **v0; // edi
  char *v1; // ebx
  void **v2; // esi
  char v3; // [esp+8h] [ebp-4h]
  char v4; // [esp+9h] [ebp-3h]
  char v5; // [esp+Ah] [ebp-2h]
  char v6; // [esp+Bh] [ebp-1h]

  v0 = *gList1;
  *gList1 = gList1;
  *(gList1 + 1) = gList1;
  v1 = gList1;
  *(&gList1 + 1) = 0;
  if ( v0 != gList1 )
  {
    do
    {
      v2 = *v0;
      ATL::CAtlStringMgr::Clone(&v6);
      nullsub_2(v0);
      ATL::CAtlStringMgr::Clone(&v5);
      nullsub_2(v0 + 1);
      ATL::CAtlStringMgr::Clone(&v4);
      nullsub_2(v0 + 2);
      ATL::CAtlStringMgr::Clone(&v3);
      j__free(v0);
      v1 = gList1;
      v0 = v2;
    }
    while ( v2 != gList1 );
  }
  ATL::CAtlStringMgr::Clone(&v4);
  nullsub_2(v1);
  ATL::CAtlStringMgr::Clone(&v4);
  nullsub_2(v1 + 4);
  ATL::CAtlStringMgr::Clone(&v3);
  j__free(v1);
}
// F97A90: using guessed type _DWORD __stdcall nullsub_2(_DWORD);

//----- (0102A3F0) --------------------------------------------------------
void __cdecl sub_102A3F0()
{
  void **v0; // edi
  char *v1; // ebx
  void **v2; // esi
  char v3; // [esp+8h] [ebp-4h]
  char v4; // [esp+9h] [ebp-3h]
  char v5; // [esp+Ah] [ebp-2h]
  char v6; // [esp+Bh] [ebp-1h]

  v0 = *gList2;
  *gList2 = gList2;
  *(gList2 + 1) = gList2;
  v1 = gList2;
  *(&gList2 + 1) = 0;
  if ( v0 != gList2 )
  {
    do
    {
      v2 = *v0;
      ATL::CAtlStringMgr::Clone(&v6);
      nullsub_2(v0);
      ATL::CAtlStringMgr::Clone(&v5);
      nullsub_2(v0 + 1);
      ATL::CAtlStringMgr::Clone(&v4);
      nullsub_2(v0 + 2);
      ATL::CAtlStringMgr::Clone(&v3);
      j__free(v0);
      v1 = gList2;
      v0 = v2;
    }
    while ( v2 != gList2 );
  }
  ATL::CAtlStringMgr::Clone(&v4);
  nullsub_2(v1);
  ATL::CAtlStringMgr::Clone(&v4);
  nullsub_2(v1 + 4);
  ATL::CAtlStringMgr::Clone(&v3);
  j__free(v1);
}
// F97A90: using guessed type _DWORD __stdcall nullsub_2(_DWORD);

//----- (0102A4C0) --------------------------------------------------------
void __cdecl sub_102A4C0()
{
  void **v0; // edi
  char *v1; // ebx
  void **v2; // esi
  char v3; // [esp+8h] [ebp-4h]
  char v4; // [esp+9h] [ebp-3h]
  char v5; // [esp+Ah] [ebp-2h]
  char v6; // [esp+Bh] [ebp-1h]

  v0 = *gList3;
  *gList3 = gList3;
  *(gList3 + 1) = gList3;
  v1 = gList3;
  *(&gList3 + 1) = 0;
  if ( v0 != gList3 )
  {
    do
    {
      v2 = *v0;
      ATL::CAtlStringMgr::Clone(&v6);
      nullsub_2(v0);
      ATL::CAtlStringMgr::Clone(&v5);
      nullsub_2(v0 + 1);
      ATL::CAtlStringMgr::Clone(&v4);
      nullsub_2(v0 + 2);
      ATL::CAtlStringMgr::Clone(&v3);
      j__free(v0);
      v1 = gList3;
      v0 = v2;
    }
    while ( v2 != gList3 );
  }
  ATL::CAtlStringMgr::Clone(&v4);
  nullsub_2(v1);
  ATL::CAtlStringMgr::Clone(&v4);
  nullsub_2(v1 + 4);
  ATL::CAtlStringMgr::Clone(&v3);
  j__free(v1);
}
// F97A90: using guessed type _DWORD __stdcall nullsub_2(_DWORD);

//----- (0102A590) --------------------------------------------------------
void __cdecl sub_102A590()
{
  char *v0; // esi
  char v1; // [esp+4h] [ebp-8h]
  char v2; // [esp+Bh] [ebp-1h]

  sub_1002C10(&gMap5, &v1, *gMap5, gMap5);
  v0 = gMap5;
  ATL::CAtlStringMgr::Clone(&v2);
  nullsub_2(v0);
  ATL::CAtlStringMgr::Clone(&v2);
  nullsub_2(v0 + 4);
  ATL::CAtlStringMgr::Clone(&v2);
  nullsub_2(v0 + 8);
  ATL::CAtlStringMgr::Clone(&v2);
  j__free(v0);
}
// F97A90: using guessed type _DWORD __stdcall nullsub_2(_DWORD);

//----- (0102A610) --------------------------------------------------------
void __cdecl sub_102A610()
{
  off_105AA3C[0] = &std::error_category::`vftable';
}
// 1032D74: using guessed type void *std::error_category::`vftable';
// 105AA3C: using guessed type int (__thiscall **off_105AA3C[3])(void *, char);

//----- (0102A620) --------------------------------------------------------
void __cdecl sub_102A620()
{
  off_105AA40[0] = &std::error_category::`vftable';
}
// 1032D74: using guessed type void *std::error_category::`vftable';
// 105AA40: using guessed type int (__thiscall **off_105AA40[2])(void *, char);

//----- (0102A630) --------------------------------------------------------
void __cdecl sub_102A630()
{
  off_105AA44 = &std::error_category::`vftable';
}
// 1032D74: using guessed type void *std::error_category::`vftable';
// 105AA44: using guessed type int (__thiscall **off_105AA44)(void *, char);

//----- (0102A640) --------------------------------------------------------
void __cdecl sub_102A640()
{
  free(gActiveScriptEventConsumer.baseclass.m_pszURL);
  free(gActiveScriptEventConsumer.baseclass.m_pszDescription);
}
// 1064D28: using guessed type struct ActiveScriptEventConsumer gActiveScriptEventConsumer;

//----- (0102A660) --------------------------------------------------------
void __cdecl sub_102A660()
{
  free(gCommandLineEventConsumer.baseclass.m_pszURL);
  free(gCommandLineEventConsumer.baseclass.m_pszDescription);
}
// 1064D1C: using guessed type struct CommandLineEventConsumer gCommandLineEventConsumer;

//----- (0102A680) --------------------------------------------------------
void __cdecl sub_102A680()
{
  char *v0; // esi
  char v1; // [esp+4h] [ebp-8h]
  char v2; // [esp+Bh] [ebp-1h]

  sub_F97560(&gMap6, &v1, *gMap6, gMap6);
  v0 = gMap6;
  ATL::CAtlStringMgr::Clone(&v2);
  nullsub_2(v0);
  ATL::CAtlStringMgr::Clone(&v2);
  nullsub_2(v0 + 4);
  ATL::CAtlStringMgr::Clone(&v2);
  nullsub_2(v0 + 8);
  ATL::CAtlStringMgr::Clone(&v2);
  j__free(v0);
}
// F97A90: using guessed type _DWORD __stdcall nullsub_2(_DWORD);

//----- (0102A700) --------------------------------------------------------
void __cdecl sub_102A700()
{
  if ( ghUxthemeModule )
    FreeLibrary(ghUxthemeModule);
}

//----- (0102A720) --------------------------------------------------------
void __cdecl sub_102A720()
{
  int *v0; // edi
  int *v1; // ebx
  int *v2; // esi
  char v3; // [esp+8h] [ebp-4h]
  char v4; // [esp+9h] [ebp-3h]
  char v5; // [esp+Ah] [ebp-2h]
  char v6; // [esp+Bh] [ebp-1h]

  v0 = *gBstrList;
  *gBstrList = gBstrList;
  gBstrList[1] = gBstrList;
  v1 = gBstrList;
  *(&gBstrList + 1) = 0;
  if ( v0 != gBstrList )
  {
    do
    {
      v2 = *v0;
      ATL::CAtlStringMgr::Clone(&v6);
      nullsub_2(v0);
      ATL::CAtlStringMgr::Clone(&v5);
      nullsub_2(v0 + 1);
      ATL::CAtlStringMgr::Clone(&v4);
      nullsub_2(v0 + 2);
      ATL::CAtlStringMgr::Clone(&v3);
      j__free(v0);
      v1 = gBstrList;
      v0 = v2;
    }
    while ( v2 != gBstrList );
  }
  ATL::CAtlStringMgr::Clone(&v4);
  nullsub_2(v1);
  ATL::CAtlStringMgr::Clone(&v4);
  nullsub_2(v1 + 1);
  ATL::CAtlStringMgr::Clone(&v3);
  j__free(v1);
}
// F97A90: using guessed type _DWORD __stdcall nullsub_2(_DWORD);

//----- (0102A7F0) --------------------------------------------------------
void __cdecl sub_102A7F0()
{
  strHeap.baseclass.vtptr = &ATL::CWin32Heap::`vftable';
  if ( strHeap.m_bOwnHeap )
  {
    if ( strHeap.m_hHeap )
      HeapDestroy(strHeap.m_hHeap);
  }
}
// 103C4F8: using guessed type void *ATL::CWin32Heap::`vftable';

//----- (0102A820) --------------------------------------------------------
void __cdecl sub_102A820()
{
  strMgr.baseclass.vtptr = &ATL::CAtlStringMgr::`vftable';
  byte_1064DF4 = 0;
}
// 103C510: using guessed type void *ATL::CAtlStringMgr::`vftable';
// 1064DF4: using guessed type char byte_1064DF4;

//----- (0102A840) --------------------------------------------------------
void __cdecl sub_102A840()
{
  std__list_node *v0; // edi
  std__list_node *v1; // ebx
  std__list_node *v2; // esi
  char v3; // [esp+8h] [ebp-4h]
  char v4; // [esp+9h] [ebp-3h]
  char v5; // [esp+Ah] [ebp-2h]
  char v6; // [esp+Bh] [ebp-1h]

  v0 = gAdapterLuidList._Mypair._Myval2._Myhead->_Next;
  gAdapterLuidList._Mypair._Myval2._Myhead->_Next = gAdapterLuidList._Mypair._Myval2._Myhead;
  gAdapterLuidList._Mypair._Myval2._Myhead->_Prev = gAdapterLuidList._Mypair._Myval2._Myhead;
  v1 = gAdapterLuidList._Mypair._Myval2._Myhead;
  gAdapterLuidList._Mypair._Myval2._Mysize = 0;
  if ( v0 != gAdapterLuidList._Mypair._Myval2._Myhead )
  {
    do
    {
      v2 = v0->_Next;
      ATL::CAtlStringMgr::Clone(&v6);
      nullsub_2(v0);
      ATL::CAtlStringMgr::Clone(&v5);
      nullsub_2(&v0->_Prev);
      ATL::CAtlStringMgr::Clone(&v4);
      nullsub_2(&v0->_Myval);
      ATL::CAtlStringMgr::Clone(&v3);
      j__free(v0);
      v1 = gAdapterLuidList._Mypair._Myval2._Myhead;
      v0 = v2;
    }
    while ( v2 != gAdapterLuidList._Mypair._Myval2._Myhead );
  }
  ATL::CAtlStringMgr::Clone(&v4);
  nullsub_2(v1);
  ATL::CAtlStringMgr::Clone(&v4);
  nullsub_2(&v1->_Prev);
  ATL::CAtlStringMgr::Clone(&v3);
  j__free(v1);
}
// F97A90: using guessed type _DWORD __stdcall nullsub_2(_DWORD);

//----- (0102A910) --------------------------------------------------------
void __cdecl sub_102A910()
{
  Data_t_bstr_t *v0; // esi

  v0 = a2.m_Data;
  if ( a2.m_Data )
  {
    if ( !InterlockedDecrement(&a2.m_Data->m_RefCount) && v0 )
    {
      if ( v0->m_wstr )
      {
        SysFreeString(v0->m_wstr);
        v0->m_wstr = 0;
      }
      if ( v0->m_str )
      {
        j_j__free(v0->m_str);
        v0->m_str = 0;
      }
      j__free(v0);
    }
    a2.m_Data = 0;
  }
}

//----- (0102A970) --------------------------------------------------------
void __cdecl sub_102A970()
{
  Data_t_bstr_t *v0; // esi

  v0 = stru_1069E50.m_Data;
  if ( stru_1069E50.m_Data )
  {
    if ( !InterlockedDecrement(&stru_1069E50.m_Data->m_RefCount) && v0 )
    {
      if ( v0->m_wstr )
      {
        SysFreeString(v0->m_wstr);
        v0->m_wstr = 0;
      }
      if ( v0->m_str )
      {
        j_j__free(v0->m_str);
        v0->m_str = 0;
      }
      j__free(v0);
    }
    stru_1069E50.m_Data = 0;
  }
}

//----- (0102A9D0) --------------------------------------------------------
void __cdecl sub_102A9D0()
{
  PerformanceInfoInMemory::~PerformanceInfoInMemory(&gPerformanceInfoInMemory);
}

//----- (0102A9E0) --------------------------------------------------------
void __cdecl sub_102A9E0()
{
  PerformanceInfo::~PerformanceInfo(&gPerformanceInfo.m_pBuffer);
}

//----- (0102A9F0) --------------------------------------------------------
void __cdecl sub_102A9F0()
{
  Data_t_bstr_t *v0; // esi

  v0 = gNullString.m_Data;
  if ( gNullString.m_Data )
  {
    if ( !InterlockedDecrement(&gNullString.m_Data->m_RefCount) && v0 )
    {
      if ( v0->m_wstr )
      {
        SysFreeString(v0->m_wstr);
        v0->m_wstr = 0;
      }
      if ( v0->m_str )
      {
        j_j__free(v0->m_str);
        v0->m_str = 0;
      }
      j__free(v0);
    }
    gNullString.m_Data = 0;
  }
}

//----- (0102AA50) --------------------------------------------------------
void __cdecl sub_102AA50()
{
  IWbemServices *v0; // edi
  char *v1; // ebx
  IWbemServices *v2; // esi
  char v3; // [esp+8h] [ebp-4h]
  char v4; // [esp+9h] [ebp-3h]
  char v5; // [esp+Ah] [ebp-2h]
  char v6; // [esp+Bh] [ebp-1h]

  v0 = (*(&gWbemServiceList + 1))->lpVtbl;
  (*(&gWbemServiceList + 1))->lpVtbl = *(&gWbemServiceList + 1);
  (*(&gWbemServiceList + 1))[1].lpVtbl = *(&gWbemServiceList + 1);
  v1 = *(&gWbemServiceList + 1);
  *(&gWbemServiceList + 2) = 0;
  if ( v0 != *(&gWbemServiceList + 1) )
  {
    do
    {
      v2 = v0->lpVtbl;
      ATL::CAtlStringMgr::Clone(&v6);
      nullsub_2(v0);
      ATL::CAtlStringMgr::Clone(&v5);
      nullsub_2(&v0[1]);
      ATL::CAtlStringMgr::Clone(&v4);
      nullsub_2(&v0[2]);
      ATL::CAtlStringMgr::Clone(&v3);
      j__free(v0);
      v1 = *(&gWbemServiceList + 1);
      v0 = v2;
    }
    while ( v2 != *(&gWbemServiceList + 1) );
  }
  ATL::CAtlStringMgr::Clone(&v4);
  nullsub_2(v1);
  ATL::CAtlStringMgr::Clone(&v4);
  nullsub_2(v1 + 4);
  ATL::CAtlStringMgr::Clone(&v3);
  j__free(v1);
}
// F97A90: using guessed type _DWORD __stdcall nullsub_2(_DWORD);

//----- (0102AB20) --------------------------------------------------------
void __cdecl sub_102AB20()
{
  std__Tree_node *v0; // esi
  int *a2; // [esp+4h] [ebp-8h]
  char v2; // [esp+Bh] [ebp-1h]

  sub_FF5510(&gThreadProcessMap, &a2, gThreadProcessMap._Header->_Left, gThreadProcessMap._Header);
  v0 = gThreadProcessMap._Header;
  ATL::CAtlStringMgr::Clone(&v2);
  nullsub_2(v0);
  ATL::CAtlStringMgr::Clone(&v2);
  nullsub_2(&v0->_Parent);
  ATL::CAtlStringMgr::Clone(&v2);
  nullsub_2(&v0->_Right);
  ATL::CAtlStringMgr::Clone(&v2);
  j__free(v0);
}
// F97A90: using guessed type _DWORD __stdcall nullsub_2(_DWORD);

//----- (0102ABA0) --------------------------------------------------------
void __cdecl sub_102ABA0()
{
  Data_t_bstr_t *v0; // esi

  v0 = gDiskGraphInfo.strName.m_Data;
  if ( gDiskGraphInfo.strName.m_Data )
  {
    if ( !InterlockedDecrement(&gDiskGraphInfo.strName.m_Data->m_RefCount) && v0 )
    {
      if ( v0->m_wstr )
      {
        SysFreeString(v0->m_wstr);
        v0->m_wstr = 0;
      }
      if ( v0->m_str )
      {
        j_j__free(v0->m_str);
        v0->m_str = 0;
      }
      j__free(v0);
    }
    gDiskGraphInfo.strName.m_Data = 0;
  }
}

//----- (0102AC00) --------------------------------------------------------
void __cdecl sub_102AC00()
{
  Data_t_bstr_t *v0; // esi

  v0 = gIOGraphInfo.strName.m_Data;
  if ( gIOGraphInfo.strName.m_Data )
  {
    if ( !InterlockedDecrement(&gIOGraphInfo.strName.m_Data->m_RefCount) && v0 )
    {
      if ( v0->m_wstr )
      {
        SysFreeString(v0->m_wstr);
        v0->m_wstr = 0;
      }
      if ( v0->m_str )
      {
        j_j__free(v0->m_str);
        v0->m_str = 0;
      }
      j__free(v0);
    }
    gIOGraphInfo.strName.m_Data = 0;
  }
}

//----- (0102AC60) --------------------------------------------------------
void __cdecl sub_102AC60()
{
  Data_t_bstr_t *v0; // esi

  v0 = gNetworkGraphInfo.strName.m_Data;
  if ( gNetworkGraphInfo.strName.m_Data )
  {
    if ( !InterlockedDecrement(&gNetworkGraphInfo.strName.m_Data->m_RefCount) && v0 )
    {
      if ( v0->m_wstr )
      {
        SysFreeString(v0->m_wstr);
        v0->m_wstr = 0;
      }
      if ( v0->m_str )
      {
        j_j__free(v0->m_str);
        v0->m_str = 0;
      }
      j__free(v0);
    }
    gNetworkGraphInfo.strName.m_Data = 0;
  }
}

//----- (0102ACC0) --------------------------------------------------------
void __cdecl sub_102ACC0()
{
  std__Tree_node *v0; // esi
  int *a2; // [esp+4h] [ebp-8h]
  char v2; // [esp+Bh] [ebp-1h]

  sub_FF5510(&gMap2, &a2, gMap2._Header->_Left, gMap2._Header);
  v0 = gMap2._Header;
  ATL::CAtlStringMgr::Clone(&v2);
  nullsub_2(v0);
  ATL::CAtlStringMgr::Clone(&v2);
  nullsub_2(&v0->_Parent);
  ATL::CAtlStringMgr::Clone(&v2);
  nullsub_2(&v0->_Right);
  ATL::CAtlStringMgr::Clone(&v2);
  j__free(v0);
}
// F97A90: using guessed type _DWORD __stdcall nullsub_2(_DWORD);

//----- (0102AD40) --------------------------------------------------------
void __cdecl sub_102AD40()
{
  std__Tree_node *v0; // esi
  int *a2; // [esp+4h] [ebp-8h]
  char v2; // [esp+Bh] [ebp-1h]

  sub_FF5510(&gMap3, &a2, gMap3._Header->_Left, gMap3._Header);
  v0 = gMap3._Header;
  ATL::CAtlStringMgr::Clone(&v2);
  nullsub_2(v0);
  ATL::CAtlStringMgr::Clone(&v2);
  nullsub_2(&v0->_Parent);
  ATL::CAtlStringMgr::Clone(&v2);
  nullsub_2(&v0->_Right);
  ATL::CAtlStringMgr::Clone(&v2);
  j__free(v0);
}
// F97A90: using guessed type _DWORD __stdcall nullsub_2(_DWORD);

//----- (0102ADC0) --------------------------------------------------------
void __cdecl sub_102ADC0()
{
  if ( hdc )
    DeleteDC(hdc);
  if ( dword_1085724 )
    DeleteObject(dword_1085724);
}

//----- (0102ADF0) --------------------------------------------------------
void __cdecl HttpInfo_Release()
{
  std__list_node *v0; // eax
  std__list_node *v1; // ecx
  std__list_node *v2; // esi
  std__list_node *v3; // eax
  std__list_node *v4; // ecx
  std__list_node *v5; // esi

  v0 = gHttpInfo.m_List2._Mypair._Myval2._Myhead;
  v1 = v0->_Next;
  v0->_Next = v0;
  gHttpInfo.m_List2._Mypair._Myval2._Myhead->_Prev = gHttpInfo.m_List2._Mypair._Myval2._Myhead;
  gHttpInfo.m_List2._Mypair._Myval2._Mysize = 0;
  if ( v1 != gHttpInfo.m_List2._Mypair._Myval2._Myhead )
  {
    do
    {
      v2 = v1->_Next;
      j__free(v1);
      v1 = v2;
    }
    while ( v2 != gHttpInfo.m_List2._Mypair._Myval2._Myhead );
  }
  j__free(gHttpInfo.m_List2._Mypair._Myval2._Myhead);
  v3 = gHttpInfo.m_List._Mypair._Myval2._Myhead;
  v4 = v3->_Next;
  v3->_Next = v3;
  gHttpInfo.m_List._Mypair._Myval2._Myhead->_Prev = gHttpInfo.m_List._Mypair._Myval2._Myhead;
  gHttpInfo.m_List._Mypair._Myval2._Mysize = 0;
  if ( v4 != gHttpInfo.m_List._Mypair._Myval2._Myhead )
  {
    do
    {
      v5 = v4->_Next;
      j__free(v4);
      v4 = v5;
    }
    while ( v5 != gHttpInfo.m_List._Mypair._Myval2._Myhead );
  }
  j__free(gHttpInfo.m_List._Mypair._Myval2._Myhead);
}

//----- (0102AE00) --------------------------------------------------------
void __cdecl sub_102AE00()
{
  EventList *v0; // edi
  EventList *v1; // ebx
  EventList *v2; // esi
  char v3; // [esp+8h] [ebp-4h]
  char v4; // [esp+9h] [ebp-3h]
  char v5; // [esp+Ah] [ebp-2h]
  char v6; // [esp+Bh] [ebp-1h]

  v0 = off_10857A4->_Myheader;
  off_10857A4->_Myheader = off_10857A4;
  off_10857A4->_Mysize = off_10857A4;
  v1 = off_10857A4;
  dword_10857A8 = 0;
  if ( v0 != off_10857A4 )
  {
    do
    {
      v2 = v0->_Myheader;
      ATL::CAtlStringMgr::Clone(&v6);
      nullsub_2(v0);
      ATL::CAtlStringMgr::Clone(&v5);
      nullsub_2(&v0->_Mysize);
      ATL::CAtlStringMgr::Clone(&v4);
      nullsub_2(&v0[1]);
      ATL::CAtlStringMgr::Clone(&v3);
      j__free(v0);
      v1 = off_10857A4;
      v0 = v2;
    }
    while ( v2 != off_10857A4 );
  }
  ATL::CAtlStringMgr::Clone(&v4);
  nullsub_2(v1);
  ATL::CAtlStringMgr::Clone(&v4);
  nullsub_2(&v1->_Mysize);
  ATL::CAtlStringMgr::Clone(&v3);
  j__free(v1);
}
// F97A90: using guessed type _DWORD __stdcall nullsub_2(_DWORD);
// 10857A8: using guessed type int dword_10857A8;

//----- (0102AED0) --------------------------------------------------------
void __cdecl sub_102AED0()
{
  void **v0; // edi
  char *v1; // ebx
  void **v2; // esi
  char v3; // [esp+8h] [ebp-4h]
  char v4; // [esp+9h] [ebp-3h]
  char v5; // [esp+Ah] [ebp-2h]
  char v6; // [esp+Bh] [ebp-1h]

  v0 = *dword_108579C;
  *dword_108579C = dword_108579C;
  *(dword_108579C + 1) = dword_108579C;
  v1 = dword_108579C;
  dword_10857A0 = 0;
  if ( v0 != dword_108579C )
  {
    do
    {
      v2 = *v0;
      ATL::CAtlStringMgr::Clone(&v6);
      nullsub_2(v0);
      ATL::CAtlStringMgr::Clone(&v5);
      nullsub_2(v0 + 1);
      ATL::CAtlStringMgr::Clone(&v4);
      nullsub_2(v0 + 2);
      ATL::CAtlStringMgr::Clone(&v3);
      j__free(v0);
      v1 = dword_108579C;
      v0 = v2;
    }
    while ( v2 != dword_108579C );
  }
  ATL::CAtlStringMgr::Clone(&v4);
  nullsub_2(v1);
  ATL::CAtlStringMgr::Clone(&v4);
  nullsub_2(v1 + 4);
  ATL::CAtlStringMgr::Clone(&v3);
  j__free(v1);
}
// F97A90: using guessed type _DWORD __stdcall nullsub_2(_DWORD);
// 10857A0: using guessed type int dword_10857A0;

//----- (0102AFA0) --------------------------------------------------------
void __cdecl sub_102AFA0()
{
  EventList *v0; // edi
  EventList *v1; // ebx
  EventList *v2; // esi
  char v3; // [esp+8h] [ebp-4h]
  char v4; // [esp+9h] [ebp-3h]
  char v5; // [esp+Ah] [ebp-2h]
  char v6; // [esp+Bh] [ebp-1h]

  v0 = off_10857AC->_Myheader;
  off_10857AC->_Myheader = off_10857AC;
  off_10857AC->_Mysize = off_10857AC;
  v1 = off_10857AC;
  dword_10857B0 = 0;
  if ( v0 != off_10857AC )
  {
    do
    {
      v2 = v0->_Myheader;
      ATL::CAtlStringMgr::Clone(&v6);
      nullsub_2(v0);
      ATL::CAtlStringMgr::Clone(&v5);
      nullsub_2(&v0->_Mysize);
      ATL::CAtlStringMgr::Clone(&v4);
      nullsub_2(&v0[1]);
      ATL::CAtlStringMgr::Clone(&v3);
      j__free(v0);
      v1 = off_10857AC;
      v0 = v2;
    }
    while ( v2 != off_10857AC );
  }
  ATL::CAtlStringMgr::Clone(&v4);
  nullsub_2(v1);
  ATL::CAtlStringMgr::Clone(&v4);
  nullsub_2(&v1->_Mysize);
  ATL::CAtlStringMgr::Clone(&v3);
  j__free(v1);
}
// F97A90: using guessed type _DWORD __stdcall nullsub_2(_DWORD);
// 10857B0: using guessed type int dword_10857B0;

//----- (0102B070) --------------------------------------------------------
void __cdecl sub_102B070()
{
  char *v0; // esi
  char v1; // [esp+4h] [ebp-8h]
  char v2; // [esp+Bh] [ebp-1h]

  sub_1002C10(&gHttpInfo.field_1C, &v1, *gHttpInfo.field_1C, gHttpInfo.field_1C);
  v0 = gHttpInfo.field_1C;
  ATL::CAtlStringMgr::Clone(&v2);
  nullsub_2(v0);
  ATL::CAtlStringMgr::Clone(&v2);
  nullsub_2(v0 + 4);
  ATL::CAtlStringMgr::Clone(&v2);
  nullsub_2(v0 + 8);
  ATL::CAtlStringMgr::Clone(&v2);
  j__free(v0);
}
// F97A90: using guessed type _DWORD __stdcall nullsub_2(_DWORD);

//----- (0102B0F0) --------------------------------------------------------
void __cdecl sub_102B0F0()
{
  VariantClear(&pvarg);
}

//----- (0102B0FC) --------------------------------------------------------
void __cdecl sub_102B0FC()
{
  struct _RTL_CRITICAL_SECTION *v0; // esi

  if ( _InterlockedExchangeAdd(&unk_10613A0, 0xFFFFFFFF) < 0 )
  {
    v0 = &stru_10857E0;
    do
    {
      _Mtxdst(v0);
      ++v0;
    }
    while ( v0 < &dword_1085840 );
  }
}
// 1085840: using guessed type int dword_1085840;

//----- (0102B106) --------------------------------------------------------
void __cdecl sub_102B106()
{
  std::_Fac_tidy_reg_t::~_Fac_tidy_reg_t(&unk_108585A);
}

//----- (0102B110) --------------------------------------------------------
void __cdecl sub_102B110()
{
  std::locale::~locale(&dword_1085864);
}
// 1085864: using guessed type int dword_1085864;

//----- (0102B11A) --------------------------------------------------------
void __cdecl sub_102B11A()
{
  _Init_atexit::~_Init_atexit(&unk_10858F3);
}

//----- (0102B124) --------------------------------------------------------
void __cdecl sub_102B124()
{
  struct _RTL_CRITICAL_SECTION *v0; // esi

  if ( _InterlockedExchangeAdd(&unk_10613A0, 0xFFFFFFFF) < 0 )
  {
    v0 = &stru_10857E0;
    do
    {
      _Mtxdst(v0);
      ++v0;
    }
    while ( v0 < &dword_1085840 );
  }
}
// 1085840: using guessed type int dword_1085840;

//----- (0102B12E) --------------------------------------------------------
void __cdecl ATL::_dynamic_atexit_destructor_for___AtlBaseModule__()
{
  ATL::CAtlBaseModule::~CAtlBaseModule(&ATL::_AtlBaseModule);
}

// ALL OK, 1648 function(s) have been successfully decompiled

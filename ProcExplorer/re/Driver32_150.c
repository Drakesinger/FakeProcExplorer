/* This file has been generated by the Hex-Rays decompiler.
   Copyright (c) 2007-2017 Hex-Rays <info@hex-rays.com>

   Detected compiler: Visual C++
*/

#include <windows.h>
#include <defs.h>


//-------------------------------------------------------------------------
// Function declarations

#define __thiscall __cdecl // Test compile in C mode

NTSTATUS __stdcall DriverEntry(PDRIVER_OBJECT DriverObject, PUNICODE_STRING RegistryPath);
NTSTATUS __stdcall PE_DuplicateProcessHandle(HANDLE ProcessHandle, HANDLE SourceHandle, ACCESS_MASK DesiredAccess, PHANDLE TargetHandle);
NTSTATUS __stdcall sub_10001840(XOBJECT *a1);
int __stdcall PEDriver_ControlDispatcher(PFILE_OBJECT FileObject, ULONG bFlags, PIRP MasterIrp, ULONG Options, PHANDLE ProcessHandle, ULONG MaxCount, ULONG uBytesRead, IO_STATUS_BLOCK *IoStatus, ULONG uValue);
NTSTATUS __stdcall PEDriver_Hook(int a1, PIRP Irp);
int __stdcall sub_10001E70(char a1, XOBJECT *a2, void *Dst, int Length); // idb
NTSTATUS __stdcall sub_100020E0(HANDLE Handle, int a2, XOBJECT *Object); // idb
NTSTATUS __thiscall sub_100021D0(void *this, HANDLE Handle, PHANDLE ObjectHandle, int a4); // idb
NTSTATUS __fastcall sub_10002240(int a1, int a2, char a3, XOBJECT *Object, _DWORD *a5, int *a6);
int __stdcall sub_10002610(char a1, int a2, int a3, _DWORD *a4);
signed int __stdcall sub_100028B0(unsigned int *a1, unsigned int a2, int a3);
PVOID __stdcall XGetObjectByName(LPCWSTR lpszName);
NTSTATUS __stdcall sub_10002A40(int a1, PHANDLE TargetHandle);
NTSTATUS __stdcall sub_10002A60(HANDLE Handle, PVOID ProcessInformation, int a3);
NTSTATUS __stdcall sub_10002AF0(int NewIrql, void *Dst, int a3);
void __stdcall PEDriver_Unload(int a1);
NTSTATUS __thiscall sub_10002C70(void *this, HANDLE Handle, PHANDLE ObjectHandle, int DesiredAccess); // idb
PVOID sub_10002CC0();
// int __stdcall ObOpenObjectByName(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD); weak
// void *__cdecl memcpy(void *Dst, const void *Src, size_t MaxCount);
// void *__cdecl memset(void *Dst, int Val, size_t Size);
// void __fastcall KfLowerIrql(KIRQL NewIrql);
// KIRQL __fastcall KfRaiseIrql(KIRQL NewIrql);
// NTSTATUS __stdcall RtlUnicodeStringToAnsiString(PANSI_STRING DestinationString, PCUNICODE_STRING SourceString, BOOLEAN AllocateDestinationString);
// void __stdcall RtlFreeAnsiString(PANSI_STRING AnsiString);
// NTSTATUS __stdcall KeWaitForSingleObject(PVOID Object, KWAIT_REASON WaitReason, KPROCESSOR_MODE WaitMode, BOOLEAN Alertable, PLARGE_INTEGER Timeout);
// PVOID __stdcall ExAllocatePoolWithTag(POOL_TYPE PoolType, SIZE_T NumberOfBytes, ULONG Tag);
// void __stdcall ExFreePoolWithTag(PVOID P, ULONG Tag);
// KPROCESSOR_MODE ExGetPreviousMode(void);
// PVOID __stdcall MmGetSystemRoutineAddress(PUNICODE_STRING SystemRoutineName);
// int __fastcall SeCaptureSubjectContext(_DWORD, _DWORD, _DWORD); weak
// int __stdcall SeReleaseSubjectContext(_DWORD); weak
// void __fastcall IofCompleteRequest(PIRP Irp, CCHAR PriorityBoost);
// NTSTATUS __stdcall IoCreateSymbolicLink(PUNICODE_STRING SymbolicLinkName, PUNICODE_STRING DeviceName);
// void __stdcall IoDeleteDevice(PDEVICE_OBJECT DeviceObject);
// NTSTATUS __stdcall IoDeleteSymbolicLink(PUNICODE_STRING SymbolicLinkName);
// NTSTATUS __stdcall ObReferenceObjectByHandle(HANDLE Handle, ACCESS_MASK DesiredAccess, POBJECT_TYPE ObjectType, KPROCESSOR_MODE AccessMode, PVOID *Object, POBJECT_HANDLE_INFORMATION HandleInformation);
// LONG_PTR __fastcall ObfDereferenceObject(PVOID Object);
// NTSTATUS __stdcall ZwClose(HANDLE Handle);
// BOOLEAN __stdcall MmIsAddressValid(PVOID VirtualAddress);
// NTSTATUS __stdcall ZwOpenProcess(PHANDLE ProcessHandle, ACCESS_MASK DesiredAccess, POBJECT_ATTRIBUTES ObjectAttributes, PCLIENT_ID ClientId);
// void __stdcall RtlInitUnicodeString(PUNICODE_STRING DestinationString, PCWSTR SourceString);
// int __stdcall KeUnstackDetachProcess(_DWORD); weak
// int __stdcall SePrivilegeCheck(_DWORD, _DWORD, _DWORD); weak
// int __stdcall PsLookupProcessByProcessId(HANDLE ProcessId, PEPROCESS *Process);
// int __stdcall ObOpenObjectByPointer(PVOID Object, ULONG HandleAttributes, _ACCESS_STATE *PassedAccessState, ACCESS_MASK DesiredAccess, POBJECT_TYPE ObjectType, DWORD AcessMask, PHANDLE ObjectHandle);
// int __stdcall ObQueryNameString(PVOID Object, POBJECT_NAME_INFORMATION NameInfo, ULONG Length, PULONG ReturnLength);
// NTSTATUS __stdcall ZwQueryObject(HANDLE Handle, OBJECT_INFORMATION_CLASS ObjectInformationClass, PVOID ObjectInformation, ULONG ObjectInformationLength, PULONG ReturnLength);
// NTSTATUS __stdcall NtDuplicateObject(HANDLE SourceProcessHandle, HANDLE SourceHandle, HANDLE TargetProcessHandle, PHANDLE TargetHandle, ACCESS_MASK DesiredAccess, ULONG HandleAttributes, ULONG Options);
// NTSTATUS __stdcall ZwOpenProcessToken(HANDLE ProcessHandle, ACCESS_MASK DesiredAccess, PHANDLE TokenHandle);
// NTSTATUS __stdcall ZwQueryInformationProcess(HANDLE ProcessHandle, PROCESSINFOCLASS ProcessInformationClass, PVOID ProcessInformation, ULONG ProcessInformationLength, PULONG ReturnLength);
// NTSTATUS __stdcall ZwQuerySystemInformation(SYSTEM_INFORMATION_CLASS SystemInformationClass, PVOID SystemInformation, SIZE_T Length, PSIZE_T ResultLength);
// int __stdcall ObCloseHandle(_DWORD, _DWORD); weak
// char *__cdecl strncpy(char *Dest, const char *Source, size_t Count);
// int __stdcall KeStackAttachProcess(PEPROCESS ProcessId, KAPC_STATE *ApcState);
// void *__cdecl memmove(void *Dst, const void *Src, size_t MaxCount);
NTSTATUS __stdcall IoValidateDeviceIoControlAccess(PIRP Irp, ULONG RequiredAccess);
// PVOID __stdcall WdmlibInit();
int Fake_IoCreateDevice();
// int __stdcall IoDevObjCreateDeviceSecure(PDRIVER_OBJECT DriverObject, ULONG DeviceExtensionSize, PUNICODE_STRING DeviceName, int, int, BOOLEAN Exclusive, ULONG DeviceType, ULONG DeviceCharacteristics, int); idb

//-------------------------------------------------------------------------
// Data declarations

// extern POBJECT_TYPE *IoFileObjectType;
// extern _UNKNOWN PsProcessType; weak
// extern _UNKNOWN PsThreadType; weak
// extern _UNKNOWN NtBuildNumber; weak
wchar_t aDosdevicesProc[23] = L"\\DosDevices\\PROCEXP152"; // weak
wchar_t aDeviceProcexp1[19] = L"\\Device\\PROCEXP152"; // weak
int (__stdcall *PsAcquireProcessExitSynchronization)(_DWORD) = NULL; // weak
int (__stdcall *PsReleaseProcessExitSynchronization)(_DWORD) = NULL; // weak
int (*MmGetMaximumNonPagedPoolInBytes)(void) = NULL; // weak
char sbLibInited = '\0'; // weak
int (*IoCreateDeviceSecure)(void) = NULL; // weak
POBJECT_TYPE (__stdcall *ObGetObjectType)(LPCWSTR) = NULL;
POBJECT_TYPE gpObjectType = NULL; // idb
int gNtBuildNumber = 0; // weak


//----- (100013E0) --------------------------------------------------------
NTSTATUS __stdcall DriverEntry(PDRIVER_OBJECT DriverObject, PUNICODE_STRING RegistryPath)
{
  PDRIVER_OBJECT pExtensionObject; // esi
  unsigned int dwNtBuildNumber; // eax
  struct _DRIVER_OBJECT *v4; // eax
  struct _DRIVER_OBJECT *pDriverObject; // esi
  int Status; // edi
  NTSTATUS v8; // eax
  LSA_UNICODE_STRING SymbolicLinkName; // [esp+Ch] [ebp-C4h]
  LSA_UNICODE_STRING v10; // [esp+14h] [ebp-BCh]
  LSA_UNICODE_STRING v11; // [esp+1Ch] [ebp-B4h]
  LSA_UNICODE_STRING DeviceName; // [esp+24h] [ebp-ACh]
  PDEVICE_OBJECT DeviceObject; // [esp+2Ch] [ebp-A4h]
  LSA_UNICODE_STRING DestinationString; // [esp+30h] [ebp-A0h]
  WCHAR v15[8]; // [esp+38h] [ebp-98h]
  __int128 v16; // [esp+48h] [ebp-88h]
  __int128 v17; // [esp+58h] [ebp-78h]
  __int64 v18; // [esp+68h] [ebp-68h]
  int v19; // [esp+70h] [ebp-60h]
  WCHAR v20[8]; // [esp+74h] [ebp-5Ch]
  __int128 v21; // [esp+84h] [ebp-4Ch]
  __int64 v22; // [esp+94h] [ebp-3Ch]
  int v23; // [esp+9Ch] [ebp-34h]
  wchar_t v24; // [esp+A0h] [ebp-30h]
  WCHAR SourceString[8]; // [esp+A4h] [ebp-2Ch]
  __int128 v26; // [esp+B4h] [ebp-1Ch]
  int v27; // [esp+C4h] [ebp-Ch]
  wchar_t v28; // [esp+C8h] [ebp-8h]

  v27 = *(_DWORD *)L"52";
  _mm_storeu_si128((__m128i *)SourceString, _mm_loadu_si128((const __m128i *)L"\\Device\\PROCEXP152"));
  v28 = aDeviceProcexp1[18];
  v23 = *(_DWORD *)L"52";
  _mm_storeu_si128((__m128i *)&v26, _mm_loadu_si128((const __m128i *)L"PROCEXP152"));
  v24 = aDosdevicesProc[22];
  v19 = *(_DWORD *)L"2";
  _mm_storeu_si128((__m128i *)v20, _mm_loadu_si128((const __m128i *)L"\\DosDevices\\PROCEXP152"));
  pExtensionObject = DriverObject;
  _mm_storeu_si128((__m128i *)&v21, _mm_loadu_si128((const __m128i *)L"ces\\PROCEXP152"));
  v22 = *(_QWORD *)L"EXP152";
  _mm_storeu_si128((__m128i *)v15, _mm_loadu_si128((const __m128i *)L"\\DosDevices\\Global\\PROCEXP152"));
  _mm_storeu_si128((__m128i *)&v16, _mm_loadu_si128((const __m128i *)L"ces\\Global\\PROCEXP152"));
  _mm_storeu_si128((__m128i *)&v17, _mm_loadu_si128((const __m128i *)L"al\\PROCEXP152"));
  v18 = *(_QWORD *)L"XP152";
  dwNtBuildNumber = NtBuildNumber & 0xFFFFFFF;
  gNtBuildNumber = NtBuildNumber & 0xFFFFFFF;
  if ( (NtBuildNumber & 0xFFFFFFFu) >= 6000 )
  {
    RtlInitUnicodeString(&DestinationString, L"PsAcquireProcessExitSynchronization");
    PsAcquireProcessExitSynchronization = (int (__stdcall *)(_DWORD))MmGetSystemRoutineAddress(&DestinationString);
    RtlInitUnicodeString(&DestinationString, L"PsReleaseProcessExitSynchronization");
    PsReleaseProcessExitSynchronization = (int (__stdcall *)(_DWORD))MmGetSystemRoutineAddress(&DestinationString);
    RtlInitUnicodeString(&DestinationString, L"MmGetMaximumNonPagedPoolInBytes");
    MmGetMaximumNonPagedPoolInBytes = (int (*)(void))MmGetSystemRoutineAddress(&DestinationString);
    dwNtBuildNumber = gNtBuildNumber;
  }
  if ( dwNtBuildNumber >= 7000 )
  {
    RtlInitUnicodeString(&DestinationString, L"ObGetObjectType");
    ObGetObjectType = (POBJECT_TYPE (__stdcall *)(LPCWSTR))MmGetSystemRoutineAddress(&DestinationString);
  }
  gpObjectType = (POBJECT_TYPE)XGetObjectByName(L"Mutant");
  if ( !RegistryPath )
  {
    v4 = (struct _DRIVER_OBJECT *)ExAllocatePoolWithTag(0, 0x150u, 'XcrP');
    pDriverObject = v4;
    if ( !v4 )
      return STATUS_NO_MEMORY;
    memset(v4, 0, 0x150u);
    pDriverObject[1].MajorFunction[0] = (PDRIVER_DISPATCH)PEDriver_Hook;
    pExtensionObject = pDriverObject + 1;
    pExtensionObject->MajorFunction[1] = (PDRIVER_DISPATCH)PEDriver_Hook;
    pExtensionObject->MajorFunction[2] = (PDRIVER_DISPATCH)PEDriver_Hook;
    pExtensionObject->MajorFunction[3] = (PDRIVER_DISPATCH)PEDriver_Hook;
    pExtensionObject->MajorFunction[4] = (PDRIVER_DISPATCH)PEDriver_Hook;
    pExtensionObject->MajorFunction[5] = (PDRIVER_DISPATCH)PEDriver_Hook;
    pExtensionObject->MajorFunction[6] = (PDRIVER_DISPATCH)PEDriver_Hook;
    pExtensionObject->MajorFunction[7] = (PDRIVER_DISPATCH)PEDriver_Hook;
    pExtensionObject->MajorFunction[8] = (PDRIVER_DISPATCH)PEDriver_Hook;
    pExtensionObject->MajorFunction[9] = (PDRIVER_DISPATCH)PEDriver_Hook;
    pExtensionObject->MajorFunction[10] = (PDRIVER_DISPATCH)PEDriver_Hook;
    pExtensionObject->MajorFunction[11] = (PDRIVER_DISPATCH)PEDriver_Hook;
    pExtensionObject->MajorFunction[12] = (PDRIVER_DISPATCH)PEDriver_Hook;
    pExtensionObject->MajorFunction[13] = (PDRIVER_DISPATCH)PEDriver_Hook;
    pExtensionObject->MajorFunction[14] = (PDRIVER_DISPATCH)PEDriver_Hook;
    pExtensionObject->MajorFunction[15] = (PDRIVER_DISPATCH)PEDriver_Hook;
    pExtensionObject->MajorFunction[16] = (PDRIVER_DISPATCH)PEDriver_Hook;
    pExtensionObject->MajorFunction[17] = (PDRIVER_DISPATCH)PEDriver_Hook;
    pExtensionObject->MajorFunction[18] = (PDRIVER_DISPATCH)PEDriver_Hook;
    pExtensionObject->MajorFunction[19] = (PDRIVER_DISPATCH)PEDriver_Hook;
    pExtensionObject->MajorFunction[20] = (PDRIVER_DISPATCH)PEDriver_Hook;
    pExtensionObject->MajorFunction[21] = (PDRIVER_DISPATCH)PEDriver_Hook;
    pExtensionObject->MajorFunction[22] = (PDRIVER_DISPATCH)PEDriver_Hook;
    pExtensionObject->MajorFunction[23] = (PDRIVER_DISPATCH)PEDriver_Hook;
    pExtensionObject->MajorFunction[24] = (PDRIVER_DISPATCH)PEDriver_Hook;
    pExtensionObject->MajorFunction[25] = (PDRIVER_DISPATCH)PEDriver_Hook;
    pExtensionObject->MajorFunction[26] = (PDRIVER_DISPATCH)PEDriver_Hook;
    pExtensionObject->MajorFunction[27] = (PDRIVER_DISPATCH)PEDriver_Hook;
  }
  RtlInitUnicodeString(&DeviceName, SourceString);
  RtlInitUnicodeString(&v10, L"D:P(A;;GA;;;SY)(A;;GA;;;BA)");
  Status = Fake_IoCreateDevice();
  if ( Status < 0 )
    goto LABEL_16;
  DeviceObject->Flags &= -0x81u;
  RtlInitUnicodeString(&v11, v20);
  if ( RegistryPath )
  {
    v8 = IoCreateSymbolicLink(&v11, &DeviceName);
  }
  else
  {
    RtlInitUnicodeString(&SymbolicLinkName, v15);
    Status = IoCreateSymbolicLink(&SymbolicLinkName, &DeviceName);
    if ( Status >= 0 )
      goto LABEL_15;
    v8 = IoCreateSymbolicLink(&v11, &DeviceName);
  }
  Status = v8;
LABEL_15:
  pExtensionObject->MajorFunction[IRP_MJ_DEVICE_CONTROL] = (PDRIVER_DISPATCH)PEDriver_Hook;
  pExtensionObject->MajorFunction[IRP_MJ_CLOSE] = (PDRIVER_DISPATCH)PEDriver_Hook;
  pExtensionObject->MajorFunction[IRP_MJ_CREATE] = (PDRIVER_DISPATCH)PEDriver_Hook;
  pExtensionObject->DriverUnload = (PDRIVER_UNLOAD)PEDriver_Unload;
  if ( Status < 0 )
  {
LABEL_16:
    if ( DeviceObject )
      IoDeleteDevice(DeviceObject);
  }
  return Status;
}
// 10003158: using guessed type wchar_t aDosdevicesProc[23];
// 100031A4: using guessed type wchar_t aDeviceProcexp1[19];
// 100031CC: using guessed type wchar_t aDosdevicesGlob[30];
// 1000419C: using guessed type int (__stdcall *PsAcquireProcessExitSynchronization)(_DWORD);
// 100041A0: using guessed type int (__stdcall *PsReleaseProcessExitSynchronization)(_DWORD);
// 100041A4: using guessed type int (*MmGetMaximumNonPagedPoolInBytes)(void);
// 100041C0: using guessed type int gNtBuildNumber;

//----- (10001790) --------------------------------------------------------
NTSTATUS __stdcall PE_DuplicateProcessHandle(HANDLE ProcessHandle, HANDLE SourceHandle, ACCESS_MASK DesiredAccess, PHANDLE TargetHandle)
{
  NTSTATUS result; // eax
  ULONG v5; // ecx
  NTSTATUS v6; // esi
  struct _OBJECT_ATTRIBUTES ObjectAttributes; // [esp+0h] [ebp-20h]
  struct _CLIENT_ID ClientId; // [esp+18h] [ebp-8h]

  ClientId.UniqueProcess = ProcessHandle;
  ClientId.UniqueThread = 0;
  ObjectAttributes.Length = 24;
  ObjectAttributes.RootDirectory = 0;
  ObjectAttributes.Attributes = OBJ_KERNEL_HANDLE;
  ObjectAttributes.ObjectName = 0;
  ObjectAttributes.SecurityDescriptor = 0;
  ObjectAttributes.SecurityQualityOfService = 0;
  result = ZwOpenProcess(&ProcessHandle, PROCESS_DUP_HANDLE, &ObjectAttributes, &ClientId);
  if ( result >= 0 )
  {
    v5 = 0;
    if ( !DesiredAccess )
      v5 = DUPLICATE_SAME_ACCESS;
    v6 = NtDuplicateObject(ProcessHandle, SourceHandle, (HANDLE)0xFFFFFFFF, TargetHandle, DesiredAccess, 0, v5);
    ZwClose(ProcessHandle);
    if ( v6 >= 0 )
      result = 0;
    else
      result = v6;
  }
  return result;
}

//----- (10001840) --------------------------------------------------------
NTSTATUS __stdcall sub_10001840(XOBJECT *a1)
{
  NTSTATUS result; // eax
  NTSTATUS v2; // edi
  PVOID v3; // ecx
  struct _OBJECT_HANDLE_INFORMATION HandleInformation; // [esp+10h] [ebp-48h]
  PVOID Object; // [esp+18h] [ebp-40h]
  NTSTATUS v6; // [esp+1Ch] [ebp-3Ch]
  PVOID ProcessId; // [esp+20h] [ebp-38h]
  PEPROCESS Process; // [esp+24h] [ebp-34h]
  CPPEH_RECORD ms_exc; // [esp+40h] [ebp-18h]

  result = PsLookupProcessByProcessId((HANDLE)a1->m_ProcessId, (PEPROCESS *)&ProcessId);
  v6 = result;
  if ( result >= 0 )
  {
    ms_exc.registration.TryLevel = 0;
    KeStackAttachProcess((PEPROCESS)ProcessId, (KAPC_STATE *)&Process);
    v2 = ObReferenceObjectByHandle(a1->m_Handle, 0, 0, 1, &Object, &HandleInformation);
    v6 = v2;
    if ( v2 >= 0 )
    {
      v3 = Object;
      if ( Object == (PVOID)a1->m_Objet )
      {
        ObCloseHandle(a1->m_Handle, 1);
        v3 = Object;
      }
      ObfDereferenceObject(v3);
    }
    ms_exc.registration.TryLevel = -2;
    KeUnstackDetachProcess(&Process);
    ObfDereferenceObject(ProcessId);
    result = v2;
  }
  return result;
}
// 10003058: using guessed type int __stdcall KeUnstackDetachProcess(_DWORD);
// 10003080: using guessed type int __stdcall ObCloseHandle(_DWORD, _DWORD);

//----- (10001920) --------------------------------------------------------
int __stdcall PEDriver_ControlDispatcher(PFILE_OBJECT FileObject, ULONG bFlags, PIRP MasterIrp, ULONG Options, PHANDLE ProcessHandle, ULONG MaxCount, ULONG uBytesRead, IO_STATUS_BLOCK *IoStatus, ULONG uValue)
{
  int v9; // edx
  ULONG_PTR *v10; // edi
  NTSTATUS v11; // eax
  NTSTATUS v12; // eax
  NTSTATUS v13; // eax
  HANDLE v14; // ST0C_4
  int v15; // eax
  char v16; // ST00_1
  char v17; // ST00_1
  HANDLE *v18; // edx
  struct _OBJECT_ATTRIBUTES ObjectAttributes; // [esp+Ch] [ebp-150h]
  struct _CLIENT_ID ClientId; // [esp+24h] [ebp-138h]
  XOBJECT *MasterIrpIn; // [esp+2Ch] [ebp-130h]
  HANDLE *ImageEnd; // [esp+30h] [ebp-12Ch]
  HANDLE Handle; // [esp+34h] [ebp-128h]
  _RTL_PROCESS_MODULES ModulesInfo; // [esp+38h] [ebp-124h]

  MasterIrpIn = (XOBJECT *)MasterIrp;
  LOBYTE(Handle) = 1;
  IoStatus->Information = 0;
  v10 = &IoStatus->Information;
  IoStatus->Status = 0;
  switch ( uBytesRead )
  {
    case 0x83350000:
      LOBYTE(Handle) = 0;
      goto LABEL_28;
    case 0x83350004:
      if ( Options != 0x10 || MaxCount )
        goto LABEL_7;
      v11 = sub_10001840((XOBJECT *)MasterIrp);
      goto LABEL_57;
    case 0x83350008:
      if ( Options != 4 || MaxCount != 4 )
        goto LABEL_7;
      if ( *(_DWORD *)&MasterIrp->Type > 152u )
        return STATUS_REVISION_MISMATCH;
      *ProcessHandle = (HANDLE)152;
      *v10 = 4;
LABEL_58:
      if ( IoStatus->Status == 259 )
        IoStatus->Status = STATUS_UNSUCCESSFUL;
      return IoStatus->Status;
    case 0x8335000C:
      // CTRLCODE_QUERY_PROCESS_TOKENHANDLE
      if ( Options != 4 || MaxCount != 4 )
        goto LABEL_7;
      v12 = sub_10002C70(MasterIrp, *(HANDLE *)&MasterIrp->Type, &Handle, 0x10000000);
      IoStatus->Status = v12;
      if ( v12 >= 0 )
      {
        v13 = ZwOpenProcessToken(Handle, 8u, ProcessHandle);
        v14 = Handle;
        IoStatus->Status = v13;
        ZwClose(v14);
      }
      *v10 = 4;
      goto LABEL_58;
    case 0x83350014:
      if ( Options != 16 || MaxCount != 4 )
        goto LABEL_7;
      v11 = sub_10002A40((int)MasterIrp, ProcessHandle);
      *v10 = 4;
      goto LABEL_57;
    case 0x83350020:
      if ( Options != 4 )
        goto LABEL_7;
      if ( MaxCount != 4 )
        goto LABEL_7;
      v15 = *(_DWORD *)&MasterIrp->Type;
      if ( **(_WORD **)&MasterIrp->Type != 5 || *(_WORD *)(v15 + 2) != 128 )
        goto LABEL_7;
      *ProcessHandle = *(HANDLE *)(v15 + 16);
      *v10 = 4;
      goto LABEL_58;
    case 0x83350024:
      if ( Options != 8 )
        goto LABEL_7;
      *v10 = MaxCount;
      v11 = sub_10002AF0((int)MasterIrp, ProcessHandle, (int)&IoStatus->Information);
      goto LABEL_57;
    case 0x83350028:
      if ( Options != 4 || MaxCount != 12 )
        goto LABEL_7;
      v11 = sub_100020E0(*(HANDLE *)&MasterIrp->Type, (int)ProcessHandle, (XOBJECT *)&IoStatus->Information);
      goto LABEL_57;
    case 0x8335002C:
      if ( Options != 4 || MaxCount != 4 )
        goto LABEL_7;
      v11 = sub_100021D0(MasterIrp, *(HANDLE *)&MasterIrp->Type, ProcessHandle, (int)&IoStatus->Information);
      goto LABEL_57;
    case 0x83350034:
      // CTRLCODE_QUERY_PROCESS_DEPPOLICY
      if ( Options != 4 || MaxCount != 4 )
        goto LABEL_7;
      v11 = sub_10002A60(*(HANDLE *)&MasterIrp->Type, ProcessHandle, (int)&IoStatus->Information);
      goto LABEL_57;
    case 0x8335003C:
      // CTRLCODE_QUERY_PROCESS_HANDLE
      if ( Options != 4 || MaxCount != 4 )
        goto LABEL_7;
      ClientId.UniqueProcess = *(HANDLE *)&MasterIrp->Type;
      ClientId.UniqueThread = 0;
      ObjectAttributes.Length = 24;
      ObjectAttributes.RootDirectory = 0;
      ObjectAttributes.Attributes = 0;
      ObjectAttributes.ObjectName = 0;
      ObjectAttributes.SecurityDescriptor = 0;
      ObjectAttributes.SecurityQualityOfService = 0;
      v11 = ZwOpenProcess(ProcessHandle, 0x10000000u, &ObjectAttributes, &ClientId);
      *v10 = 4;
      goto LABEL_57;
    case 0x83350040:
      LOBYTE(Handle) = 0;
      goto LABEL_32;
    case 0x83350044:
      // 检索系统模块
      if ( Options != 4 || MaxCount < 4 )
        goto LABEL_7;
      ModulesInfo.Modules[0].ImageBase = 0;
      if ( ZwQuerySystemInformation(SystemModuleInformation, &ModulesInfo, sizeof(_RTL_PROCESS_MODULES), 0) < 0 )
      {
        // 第一个模块一定是ntoskrnl.exe
        ImageEnd = (HANDLE *)((char *)ModulesInfo.Modules[0].ImageBase + ModulesInfo.Modules[0].ImageSize);
        v18 = (HANDLE *)MasterIrpIn->m_ProcessId;
        if ( (PVOID)MasterIrpIn->m_ProcessId < ModulesInfo.Modules[0].ImageBase
          || v18 > ImageEnd
          || (HANDLE *)((char *)v18 + MaxCount) > ImageEnd )
        {
LABEL_7:
          IoStatus->Status = STATUS_INVALID_PARAMETER;
        }
        else
        {
          if ( MaxCount == 4 )
          {
            *ProcessHandle = *v18;
            *v10 = 4;
          }
          else
          {
            memcpy(ProcessHandle, v18, MaxCount);
            *v10 = MaxCount;
          }
          IoStatus->Status = 0;
        }
      }
      else
      {
        IoStatus->Status = STATUS_NO_MEMORY;
      }
      break;
    case 0x83350048:
LABEL_28:
      if ( Options != 16 || MaxCount < 8 )
        goto LABEL_7;
      v16 = (char)Handle;
      *v10 = MaxCount;
      v11 = sub_10002240((int)MasterIrp, v9, v16, (XOBJECT *)MasterIrp, ProcessHandle, (int *)&IoStatus->Information);
      goto LABEL_57;
    case 0x8335004C:
LABEL_32:
      if ( Options != 16 || MaxCount < 8 )
        goto LABEL_7;
      v17 = (char)Handle;
      *v10 = MaxCount;
      v11 = sub_10002610(v17, (int)MasterIrp, (int)ProcessHandle, &IoStatus->Information);
LABEL_57:
      IoStatus->Status = v11;
      goto LABEL_58;
    case 0x83350050:
      if ( MaxCount != 4 )
        goto LABEL_7;
      if ( MmGetMaximumNonPagedPoolInBytes )
      {
        *ProcessHandle = (HANDLE)MmGetMaximumNonPagedPoolInBytes();
        *v10 = 4;
        IoStatus->Status = 0;
      }
      else
      {
        IoStatus->Status = STATUS_INVALID_ADDRESS;
      }
      break;
    default:
      IoStatus->Status = STATUS_ILLEGAL_FUNCTION;
      break;
  }
  return IoStatus->Status;
}
/* Orphan comments:
CTRLCODE_QUERY_PROCESS_DEPPOLICY
*/
// 100041A4: using guessed type int (*MmGetMaximumNonPagedPoolInBytes)(void);

//----- (10001DA0) --------------------------------------------------------
NTSTATUS __stdcall PEDriver_Hook(int a1, PIRP Irp)
{
  int v2; // edi
  _IO_STACK_LOCATION *CurrentStackLocation; // ecx
  _IRP *MasterIrp; // edx
  unsigned __int8 v5; // al
  char v7; // [esp+8h] [ebp-28h]
  int v8; // [esp+18h] [ebp-18h]
  int v9; // [esp+1Ch] [ebp-14h]
  int v10; // [esp+20h] [ebp-10h]
  int v11; // [esp+24h] [ebp-Ch]
  int v12; // [esp+28h] [ebp-8h]

  v2 = 0;
  CurrentStackLocation = Irp->Tail.Overlay.CurrentStackLocation;
  MasterIrp = Irp->AssociatedIrp.MasterIrp;
  Irp->IoStatus.Information = 0;
  if ( CurrentStackLocation->MajorFunction )
  {
    if ( CurrentStackLocation->MajorFunction == 14 )
      v2 = PEDriver_ControlDispatcher(
             CurrentStackLocation->FileObject,
             1u,
             MasterIrp,
             CurrentStackLocation->Parameters.Create.Options,
             (PHANDLE)MasterIrp,
             CurrentStackLocation->Parameters.Read.Length,
             CurrentStackLocation->Parameters.Read.ByteOffset.LowPart,
             &Irp->IoStatus,
             a1);
    else
      v2 = -1073741808;
  }
  else
  {
    v8 = 1;
    v9 = 1;
    v10 = 20;
    v11 = 0;
    v12 = 0;
    SeCaptureSubjectContext(CurrentStackLocation, MasterIrp, &v7);
    v5 = ExGetPreviousMode();
    if ( !(unsigned __int8)SePrivilegeCheck(&v8, &v7, v5) )
      v2 = -1073741790;
    SeReleaseSubjectContext(&v7);
  }
  Irp->IoStatus.Status = v2;
  IofCompleteRequest(Irp, 0);
  return v2;
}
// 10003028: using guessed type int __fastcall SeCaptureSubjectContext(_DWORD, _DWORD, _DWORD);
// 1000302C: using guessed type int __stdcall SeReleaseSubjectContext(_DWORD);
// 1000305C: using guessed type int __stdcall SePrivilegeCheck(_DWORD, _DWORD, _DWORD);

//----- (10001E70) --------------------------------------------------------
int __stdcall sub_10001E70(char a1, XOBJECT *a2, void *Dst, int Length)
{
  struct _OBJECT_NAME_INFORMATION *NameInfo; // esi
  char *v5; // ebx
  __int16 v6; // ax
  char v7; // cl
  void *v8; // eax
  int result; // eax
  unsigned int v10; // eax
  NTSTATUS v11; // esi
  struct _STRING DestinationString; // [esp+10h] [ebp-24h]
  char *v13; // [esp+18h] [ebp-1Ch]
  CPPEH_RECORD ms_exc; // [esp+1Ch] [ebp-18h]

  NameInfo = (struct _OBJECT_NAME_INFORMATION *)Dst;
  v13 = (char *)Dst;
  v5 = (char *)Dst;
  if ( !(a2->field_2C & 2) )
    return STATUS_UNSUCCESSFUL;
  v6 = *(_WORD *)a2->m_Objet;
  if ( v6 == 7 || v6 == 8 )
    return STATUS_UNSUCCESSFUL;
  v7 = a1;
  if ( a1 )
    *(_WORD *)Dst = 0;
  else
    *(_BYTE *)Dst = 0;
  ms_exc.registration.TryLevel = 0;
  v8 = (void *)a2->m_Objet;
  if ( v8 )
  {
    result = ObQueryNameString(v8, NameInfo, Length, (PULONG)&Dst);
    if ( result < 0 )
    {
LABEL_9:
      ms_exc.registration.TryLevel = -2;
      return result;
    }
    if ( a1 )
    {
      Dst = (void *)((unsigned int)NameInfo->Name.Length >> 1);
      memmove(NameInfo, NameInfo->Name.Buffer, 2 * (_DWORD)Dst);
      *(&NameInfo->Name.Length + (_DWORD)Dst) = 0;
      NameInfo = (struct _OBJECT_NAME_INFORMATION *)((char *)NameInfo + 2 * (_DWORD)Dst);
    }
    else
    {
      result = RtlUnicodeStringToAnsiString(&DestinationString, &NameInfo->Name, 1u);
      if ( result < 0 )
        goto LABEL_9;
      memcpy(NameInfo, DestinationString.Buffer, DestinationString.Length);
      *((_BYTE *)&NameInfo->Name.Length + DestinationString.Length) = 0;
      Dst = (void *)DestinationString.Length;
      RtlFreeAnsiString(&DestinationString);
      v5 = (char *)Dst + (_DWORD)NameInfo;
    }
    v7 = a1;
  }
  v10 = (unsigned int)LOWORD(a2->field_30) >> 1;
  Dst = (void *)v10;
  if ( !v10 )
  {
LABEL_26:
    ms_exc.registration.TryLevel = -2;
    return 0;
  }
  if ( !v7 )
  {
    v11 = RtlUnicodeStringToAnsiString(&DestinationString, (PCUNICODE_STRING)&a2->field_30, 1u);
    if ( v11 < 0
      || (&v13[Length] >= &v5[DestinationString.Length + 1] ? (memcpy(
                                                                 v5,
                                                                 DestinationString.Buffer,
                                                                 DestinationString.Length),
                                                               v5[DestinationString.Length] = 0) : (v11 = 0xC0000004),
          RtlFreeAnsiString(&DestinationString),
          v11 < 0) )
    {
      ms_exc.registration.TryLevel = -2;
      return v11;
    }
    goto LABEL_26;
  }
  if ( &v13[Length] >= (char *)&NameInfo->Name.MaximumLength + 2 * v10 )
  {
    memcpy(NameInfo, (const void *)a2->field_34, 2 * v10);
    *(&NameInfo->Name.Length + (_DWORD)Dst) = 0;
    ms_exc.registration.TryLevel = -2;
    result = 0;
  }
  else
  {
    ms_exc.registration.TryLevel = -2;
    result = STATUS_INFO_LENGTH_MISMATCH;
  }
  return result;
}

//----- (100020E0) --------------------------------------------------------
NTSTATUS __stdcall sub_100020E0(HANDLE Handle, int a2, XOBJECT *Object)
{
  XOBJECT *v3; // ebx
  NTSTATUS result; // eax
  int v5; // esi
  BOOLEAN v6; // al
  XOBJECT *v7; // ecx
  LARGE_INTEGER Timeout; // [esp+4h] [ebp-8h]

  v3 = Object;
  Object->m_ProcessId = 0;
  Timeout.QuadPart = 0i64;
  result = ObReferenceObjectByHandle(Handle, 0, PsThreadType, 1, (PVOID *)&Object, 0);
  if ( result >= 0 )
  {
    if ( KeWaitForSingleObject(Object, 0, 0, 0, &Timeout) )
    {
      if ( (unsigned int)gNtBuildNumber < 7900 )
      {
        if ( (unsigned int)gNtBuildNumber < 6000 )
        {
          if ( gNtBuildNumber == 3790 )
            v5 = Object->field_20;
          else
            v5 = Object->field_28;
        }
        else
        {
          v5 = Object->field_30;
        }
      }
      else
      {
        v5 = Object->field_48;
      }
      *(_DWORD *)(a2 + 4) = v5 + 0xC;
      v6 = MmIsAddressValid((PVOID)(v5 + 0xC));
      v7 = Object;
      if ( v6 )
      {
        *(_DWORD *)(a2 + 8) = **(_DWORD **)(a2 + 4);
        *(_DWORD *)a2 = *(_DWORD *)(v5 + 8);
        ObfDereferenceObject(v7);
        v3->m_ProcessId = 0xC;
        result = 0;
      }
      else
      {
        ObfDereferenceObject(Object);
        result = STATUS_ACCESS_VIOLATION;
      }
    }
    else
    {
      result = STATUS_THREAD_IS_TERMINATING;
    }
  }
  return result;
}
// 100041C0: using guessed type int gNtBuildNumber;

//----- (100021D0) --------------------------------------------------------
NTSTATUS __thiscall sub_100021D0(void *this, HANDLE Handle, PHANDLE ObjectHandle, int a4)
{
  NTSTATUS Status; // eax
  PVOID v5; // ecx
  void *v6; // edx
  PVOID Object; // [esp+0h] [ebp-4h]

  Object = this;
  Status = ObReferenceObjectByHandle(Handle, 0, gpObjectType, 1, &Object, 0);
  if ( Status >= 0 )
  {
    v5 = Object;
    v6 = (void *)*((_DWORD *)Object + 6);
    if ( v6 )
    {
      ObOpenObjectByPointer(v6, OBJ_KERNEL_HANDLE, 0, 0x10000000u, PsThreadType, 0, ObjectHandle);
      v5 = Object;
    }
    else
    {
      *ObjectHandle = 0;
    }
    ObfDereferenceObject(v5);
    *(_DWORD *)a4 = 4;
    Status = 0;
  }
  return Status;
}

//----- (10002240) --------------------------------------------------------
NTSTATUS __fastcall sub_10002240(int a1, int a2, char a3, XOBJECT *Object, _DWORD *a5, int *a6)
{
  int v6; // eax
  struct _OBJECT_NAME_INFORMATION *ObjectNameInfo; // esi
  HANDLE v8; // eax
  void *ProcessId; // ecx
  POBJECT_TYPE *v10; // eax
  NTSTATUS result; // eax
  XOBJECT *pObject; // eax
  MACRO_STATUS_CLUSTER v13; // esi
  int v14; // eax
  signed int v15; // eax
  HANDLE v16; // ecx
  _WORD *v17; // edi
  int Status; // ebx
  __int16 v19; // ax
  int v20; // edi
  char *v21; // ecx
  unsigned int v22; // edi
  unsigned int v23; // ecx
  int v24; // esi
  __int16 v25; // ax
  struct _STRING DestinationString; // [esp+10h] [ebp-70h]
  struct _OBJECT_NAME_INFORMATION *v27; // [esp+18h] [ebp-68h]
  ULONG Length; // [esp+1Ch] [ebp-64h]
  XOBJECT *ObjectIn; // [esp+20h] [ebp-60h]
  HANDLE Handle; // [esp+24h] [ebp-5Ch]
  ULONG ReturnLength; // [esp+28h] [ebp-58h]
  _DWORD *v32; // [esp+2Ch] [ebp-54h]
  HANDLE TargetHandle; // [esp+30h] [ebp-50h]
  int v34; // [esp+34h] [ebp-4Ch]
  PEPROCESS Process; // [esp+38h] [ebp-48h]
  int *v36; // [esp+3Ch] [ebp-44h]
  PVOID Objecta; // [esp+40h] [ebp-40h]
  NTSTATUS v38; // [esp+44h] [ebp-3Ch]
  char v39; // [esp+4Ah] [ebp-36h]
  char v40; // [esp+4Bh] [ebp-35h]
  PKAPC_STATE ApcState; // [esp+4Ch] [ebp-34h]
  CPPEH_RECORD ms_exc; // [esp+68h] [ebp-18h]

  ObjectIn = Object;
  v32 = a5;
  v36 = a6;
  v6 = *a6;
  Length = *a6 - 8;
  v40 = 0;
  Objecta = 0;
  LOBYTE(a1) = 0;
  v34 = a1;
  v39 = 0;
  ObjectNameInfo = (struct _OBJECT_NAME_INFORMATION *)(a5 + 1);
  v27 = (struct _OBJECT_NAME_INFORMATION *)(a5 + 1);
  *a6 = v6 - Length;
  v8 = Object->m_Handle;
  Handle = Object->m_Handle;
  ProcessId = (void *)Object->m_ProcessId;
  if ( Object->m_ProcessId < 8u || PsAcquireProcessExitSynchronization )
  {
    result = PsLookupProcessByProcessId(ProcessId, &Process);
    v13 = result;
    v38 = result;
    if ( result < 0 )
      return result;
    if ( PsAcquireProcessExitSynchronization )
    {
      v14 = PsAcquireProcessExitSynchronization(Process);// PsAcquireProcessExitSynchronization/PsReleaseProcessExitSynchronization组合来申请和释放process rundown
      v13 = v14;
      v38 = v14;
      v15 = (unsigned __int8)v34;
      if ( v38 >= 0 )
        v15 = 1;
      v34 = v15;
      v39 = v15;
    }
    if ( (v13 & 0x80000000) == 0 )
    {
      KeStackAttachProcess(Process, (KAPC_STATE *)&ApcState);
      ms_exc.registration.TryLevel = 0;
      v16 = Handle;
      if ( Object->m_ProcessId < 8u )
        v16 = (HANDLE)((unsigned int)Handle | 0x80000000);
      v13 = ObReferenceObjectByHandle(v16, 0, 0, Object->m_ProcessId >= 8u, &Objecta, 0);
      v38 = v13;
      if ( (v13 & 0x80000000) == 0 && Objecta != (PVOID)Object->m_Objet )
      {
        ObfDereferenceObject(Objecta);
        v13 = STATUS_INVALID_PARAMETER;
        v38 = STATUS_INVALID_PARAMETER;
      }
      ms_exc.registration.TryLevel = -2;
      KeUnstackDetachProcess(&ApcState);
      if ( (_BYTE)v34 && PsReleaseProcessExitSynchronization )
        PsReleaseProcessExitSynchronization(Process);
    }
    ObfDereferenceObject((PVOID)Process);
    if ( (v13 & 0x80000000) != 0 )
      return v13;
    pObject = (XOBJECT *)Objecta;
    ObjectNameInfo = v27;
  }
  else
  {
    if ( PE_DuplicateProcessHandle(ProcessId, v8, 0, &TargetHandle) < 0 )
      return STATUS_ACCESS_DENIED;
    if ( LOBYTE(Object->field_8) )
      v10 = IoFileObjectType;
    else
      v10 = 0;
    if ( ObReferenceObjectByHandle(TargetHandle, 0, (POBJECT_TYPE)v10, 1, &Objecta, 0) < 0 )
    {
      ObCloseHandle(TargetHandle, 1);
      return STATUS_ACCESS_DENIED;
    }
    ObCloseHandle(TargetHandle, 1);
    pObject = (XOBJECT *)Objecta;
    if ( Objecta != (PVOID)Object->m_Objet )
    {
      ObfDereferenceObject(Objecta);
      return STATUS_ACCESS_DENIED;
    }
  }
  *a5 = 0;
  v17 = a5 + 1;
  if ( a3 )
    *v17 = 0;
  else
    *(_BYTE *)v17 = 0;
  ms_exc.registration.TryLevel = 1;
  if ( !LOBYTE(ObjectIn->field_8) || LOWORD(pObject->m_ProcessId) != 5 )
    goto LABEL_46;
  if ( BYTE1(pObject->field_28) )
    *a5 |= 1u;
  if ( BYTE2(pObject->field_28) )
    *a5 |= 2u;
  if ( HIBYTE(pObject->field_28) )
    *a5 |= 4u;
  Status = sub_10001E70(a3, pObject, a5 + 1, Length);
  v38 = Status;
  if ( Status < 0 )
  {
    pObject = (XOBJECT *)Objecta;
LABEL_46:
    Status = ObQueryNameString(pObject, ObjectNameInfo, Length, &ReturnLength);
    v38 = Status;
    if ( Status < 0 )
      goto LABEL_58;
    v23 = ObjectNameInfo->Name.Length;
    if ( !(_WORD)v23 )
      goto LABEL_58;
    if ( a3 )
    {
      ReturnLength = v23 >> 1;
      memmove(v17, ObjectNameInfo->Name.Buffer, 2 * (v23 >> 1));
      *((_WORD *)v32 + ReturnLength + 2) = 0;
    }
    else
    {
      Status = RtlUnicodeStringToAnsiString(&DestinationString, &ObjectNameInfo->Name, 1u);
      v38 = Status;
      if ( Status >= 0 )
      {
        v24 = DestinationString.Length;
        memcpy(v17, DestinationString.Buffer, DestinationString.Length);
        *((_BYTE *)v32 + v24 + 4) = 0;
        RtlFreeAnsiString(&DestinationString);
      }
    }
    if ( a3 )
    {
      do
      {
        v25 = *v17;
        ++v17;
      }
      while ( v25 );
      v20 = 2 * (((char *)v17 - ((char *)a5 + 6)) >> 1) + 10;
      goto LABEL_57;
    }
    v21 = (char *)a5 + 5;
    v22 = (unsigned int)v17 + strlen((const char *)v17) + 1;
    goto LABEL_56;
  }
  if ( a3 )
  {
    do
    {
      v19 = *v17;
      ++v17;
    }
    while ( v19 );
    v20 = 2 * (((char *)v17 - ((char *)a5 + 6)) >> 1) + 10;
    goto LABEL_57;
  }
  v21 = (char *)a5 + 5;
  v22 = (unsigned int)v17 + strlen((const char *)v17) + 1;
LABEL_56:
  v20 = v22 - (_DWORD)v21 + 9;
LABEL_57:
  *v36 = v20;
LABEL_58:
  ObfDereferenceObject(Objecta);
  return Status;
}
// 10003058: using guessed type int __stdcall KeUnstackDetachProcess(_DWORD);
// 10003080: using guessed type int __stdcall ObCloseHandle(_DWORD, _DWORD);
// 1000419C: using guessed type int (__stdcall *PsAcquireProcessExitSynchronization)(_DWORD);
// 100041A0: using guessed type int (__stdcall *PsReleaseProcessExitSynchronization)(_DWORD);

//----- (10002610) --------------------------------------------------------
int __stdcall sub_10002610(char a1, int a2, int a3, _DWORD *a4)
{
  NTSTATUS v4; // ebx
  unsigned int v5; // esi
  int result; // eax
  UNICODE_STRING *v7; // eax
  UNICODE_STRING *v8; // edi
  _DWORD *v9; // esi
  ULONG v10; // esi
  __int16 *v11; // edi
  int v12; // ecx
  __int16 v13; // ax
  PVOID v14; // ST10_4
  ULONG v15; // eax
  const char *v16; // ST10_4
  char *v17; // esi
  unsigned int v18; // kr00_4
  struct _STRING DestinationString; // [esp+Ch] [ebp-40h]
  unsigned int v20; // [esp+14h] [ebp-38h]
  PVOID P; // [esp+18h] [ebp-34h]
  int v22; // [esp+1Ch] [ebp-30h]
  PVOID v23; // [esp+20h] [ebp-2Ch]
  PVOID Object; // [esp+24h] [ebp-28h]
  ULONG ReturnLength; // [esp+28h] [ebp-24h]
  _DWORD *v26; // [esp+2Ch] [ebp-20h]
  PEPROCESS Process; // [esp+30h] [ebp-1Ch]

  v22 = a3;
  v26 = a4;
  v4 = -1073741811;
  v20 = *a4 - 8;
  v23 = 0;
  v5 = *(_DWORD *)(a2 + 12);
  if ( *(_DWORD *)a2 >= 8u && !PsAcquireProcessExitSynchronization )
  {
    v9 = v26;
    goto LABEL_35;
  }
  result = PsLookupProcessByProcessId(*(HANDLE *)a2, (PEPROCESS *)&Object);
  if ( result < 0 )
    return result;
  if ( !PsAcquireProcessExitSynchronization || (v4 = PsAcquireProcessExitSynchronization(Object), v4 >= 0) )
  {
    KeStackAttachProcess((PEPROCESS)Object, (KAPC_STATE *)&Process);
    if ( *(_DWORD *)a2 < 8u )
      v5 |= 0x80000000;
    if ( ObReferenceObjectByHandle((HANDLE)v5, 0, 0, *(_DWORD *)a2 >= 8u, &v23, 0) >= 0 && v23 != *(PVOID *)(a2 + 4) )
    {
      ObfDereferenceObject(v23);
      v23 = 0;
    }
    if ( PsReleaseProcessExitSynchronization )
      PsReleaseProcessExitSynchronization(Object);
    ObfDereferenceObject(Object);
    if ( !v23 )
    {
      KeUnstackDetachProcess(&Process);
      return -1073741790;
    }
    v4 = ZwQueryObject((HANDLE)v5, ObjectTypeInformation, 0, 0, &ReturnLength);
    if ( v4 != -1073741820 )
      goto LABEL_19;
    v7 = (UNICODE_STRING *)ExAllocatePoolWithTag(PagedPool, ReturnLength, 0x58637250u);
    v8 = v7;
    P = v7;
    if ( !v7 )
    {
      v4 = -1073741801;
LABEL_19:
      v9 = v26;
      goto LABEL_20;
    }
    v4 = ZwQueryObject((HANDLE)v5, ObjectTypeInformation, v7, ReturnLength, 0);
    if ( v4 >= 0 )
    {
      if ( a1 )
      {
        v10 = v20 - 2;
        ReturnLength = v20 - 2;
        if ( v20 - 2 > v8->Length )
          v10 = v8->Length;
        v11 = (__int16 *)(v22 + 4);
        ReturnLength = v10;
        *v11 = 0;
        memcpy(v11, *((const void **)P + 1), v10);
        *(_WORD *)(v22 + 2 * (v10 >> 1) + 4) = 0;
        v12 = (int)(v11 + 1);
        do
        {
          v13 = *v11;
          ++v11;
        }
        while ( v13 );
        v9 = v26;
        v14 = P;
        *v26 = 2 * (((signed int)v11 - v12) >> 1) + 10;
        ExFreePoolWithTag(v14, 0);
        goto LABEL_20;
      }
      v4 = RtlUnicodeStringToAnsiString(&DestinationString, v8, 1u);
      if ( v4 >= 0 )
      {
        v15 = DestinationString.Length;
        if ( v20 <= DestinationString.Length )
          v15 = v20 - 1;
        v16 = DestinationString.Buffer;
        v17 = (char *)(v22 + 4);
        ReturnLength = v15;
        *v17 = 0;
        strncpy(v17, v16, v15);
        *(_BYTE *)(v22 + ReturnLength + 4) = 0;
        RtlFreeAnsiString(&DestinationString);
        v18 = strlen(v17);
        v9 = v26;
        *v26 = v18 + 9;
        ExFreePoolWithTag(v8, 0);
LABEL_20:
        ObfDereferenceObject(v23);
        KeUnstackDetachProcess(&Process);
        if ( v4 >= 0 )
          return v4;
LABEL_35:
        *v9 = 0;
        return v4;
      }
    }
    v9 = v26;
    ExFreePoolWithTag(v8, 0);
    goto LABEL_20;
  }
  ObfDereferenceObject(Object);
  return v4;
}
// 10003058: using guessed type int __stdcall KeUnstackDetachProcess(_DWORD);
// 1000419C: using guessed type int (__stdcall *PsAcquireProcessExitSynchronization)(_DWORD);
// 100041A0: using guessed type int (__stdcall *PsReleaseProcessExitSynchronization)(_DWORD);

//----- (100028B0) --------------------------------------------------------
signed int __stdcall sub_100028B0(unsigned int *a1, unsigned int a2, int a3)
{
  unsigned int v3; // esi
  unsigned int *v4; // ecx
  unsigned int v5; // edx

  if ( !a1 )
    return -1073741811;
  v3 = 0;
  if ( !*a1 )
    return -1073741811;
  v4 = a1 + 3;
  while ( 1 )
  {
    v5 = *v4;
    if ( a2 >= *v4 && a2 < v5 + v4[1] && a2 + a3 >= v5 )
      break;
    ++v3;
    v4 += 71;
    if ( v3 >= *a1 )
      return -1073741811;
  }
  return 0;
}

//----- (10002910) --------------------------------------------------------
PVOID __stdcall XGetObjectByName(LPCWSTR lpszName)
{
  struct _OBJECT_TYPE *pObjectType; // edi
  size_t NameLen; // ebx
  WCHAR *pszName; // eax
  int v5; // esi
  NTSTATUS Status; // esi
  OBJECT_ATTRIBUTES ObjectAttributes; // [esp+0h] [ebp-28h]
  UNICODE_STRING strObjectName; // [esp+18h] [ebp-10h]
  PVOID Object; // [esp+20h] [ebp-8h]
  HANDLE Handle; // [esp+24h] [ebp-4h]

  if ( !ObGetObjectType )
    return 0;
  pObjectType = ObGetObjectType(PsProcessType);
  NameLen = 2 * wcslen(lpszName);
  pszName = (WCHAR *)ExAllocatePoolWithTag(PagedPool, NameLen + 26, 'TOEP');
  strObjectName.Buffer = pszName;
  if ( !pszName )
    return 0;
  strObjectName.Length = NameLen + 26;
  strObjectName.MaximumLength = NameLen + 26;
  memcpy(pszName, L"\\ObjectTypes\\", 26u);
  memcpy(strObjectName.Buffer + 13, lpszName, NameLen);
  ObjectAttributes.Length = sizeof(OBJECT_ATTRIBUTES);
  ObjectAttributes.RootDirectory = 0;
  ObjectAttributes.ObjectName = &strObjectName;
  ObjectAttributes.Attributes = OBJ_KERNEL_HANDLE;
  ObjectAttributes.SecurityDescriptor = 0;
  ObjectAttributes.SecurityQualityOfService = 0;
  v5 = ObOpenObjectByName(&ObjectAttributes, pObjectType, 0, 0, OBJECT_TYPE_ALL_ACCESS, 0, &Handle);
  ExFreePoolWithTag(strObjectName.Buffer, 0);
  if ( v5 < 0 )
    return 0;
  Status = ObReferenceObjectByHandle(Handle, OBJECT_TYPE_ALL_ACCESS, pObjectType, 0, &Object, 0);
  ZwClose(Handle);
  if ( Status < 0 )
    return 0;
  ObfDereferenceObject(Object);
  return Object;
}
// 10002E02: using guessed type int __stdcall ObOpenObjectByName(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 10003188: using guessed type wchar_t aObjecttypes[14];

//----- (10002A40) --------------------------------------------------------
NTSTATUS __stdcall sub_10002A40(int a1, PHANDLE TargetHandle)
{
  return PE_DuplicateProcessHandle(*(HANDLE *)a1, *(HANDLE *)(a1 + 12), 0x10000000u, TargetHandle);
}

//----- (10002A60) --------------------------------------------------------
NTSTATUS __stdcall sub_10002A60(HANDLE Handle, PVOID ProcessInformation, int a3)
{
  NTSTATUS result; // eax
  NTSTATUS v4; // esi
  ULONG ReturnLength; // [esp+8h] [ebp-24h]
  PVOID Object; // [esp+Ch] [ebp-20h]
  PEPROCESS Process; // [esp+10h] [ebp-1Ch]

  *(_DWORD *)ProcessInformation = -1;
  result = ObReferenceObjectByHandle(Handle, 0x400u, PsProcessType, 1, &Object, 0);
  if ( result >= 0 )
  {
    KeStackAttachProcess((PEPROCESS)Object, (KAPC_STATE *)&Process);
    v4 = ZwQueryInformationProcess((HANDLE)0xFFFFFFFF, ProcessExecuteFlags, ProcessInformation, 4u, &ReturnLength);
    KeUnstackDetachProcess(&Process);
    ObfDereferenceObject(Object);
    result = v4;
    if ( v4 >= 0 )
      *(_DWORD *)a3 = ReturnLength;
  }
  return result;
}
// 10003058: using guessed type int __stdcall KeUnstackDetachProcess(_DWORD);

//----- (10002AF0) --------------------------------------------------------
NTSTATUS __stdcall sub_10002AF0(int NewIrql, void *Dst, int a3)
{
  NTSTATUS result; // eax
  int v4; // ecx
  unsigned int v5; // esi
  KIRQL v6; // al
  unsigned int v7; // ebx
  size_t v8; // edi
  _BYTE *v9; // esi
  int v10; // ebx
  _BYTE *v11; // ebx
  unsigned int *P; // [esp+4h] [ebp-Ch]
  unsigned int v13; // [esp+8h] [ebp-8h]
  XOBJECT *Object; // [esp+Ch] [ebp-4h]
  KIRQL v15; // [esp+1Bh] [ebp+Bh]
  int v16; // [esp+20h] [ebp+10h]

  result = ObReferenceObjectByHandle(*(HANDLE *)NewIrql, 0, PsThreadType, 1, (PVOID *)&Object, 0);
  if ( result >= 0 )
  {
    if ( (unsigned int)gNtBuildNumber < 0x1770 )
    {
      v4 = Object->field_18;
      v5 = Object->field_1C;
    }
    else
    {
      v4 = Object->field_28;
      v5 = Object->field_2C;
    }
    v13 = v4;
    P = (unsigned int *)sub_10002CC0();
    v6 = KfRaiseIrql(2u);
    v7 = *(_DWORD *)(NewIrql + 4);
    v15 = v6;
    v8 = *(_DWORD *)a3;
    if ( sub_100028B0(P, v7, *(_DWORD *)a3) >= 0 || v8 + v7 <= v13 && v7 >= v5 )
    {
      if ( v8 )
      {
        v9 = Dst;
        v10 = v7 - (_DWORD)Dst;
        v16 = v10;
        do
        {
          v11 = &v9[v10];
          if ( MmIsAddressValid(v11) )
            *v9 = *v11;
          else
            *v9 = 0;
          v10 = v16;
          ++v9;
          --v8;
        }
        while ( v8 );
      }
    }
    else
    {
      memset(Dst, 0, v8);
    }
    KfLowerIrql(v15);
    ObfDereferenceObject(Object);
    if ( P )
      ExFreePoolWithTag(P, 0);
    result = 0;
  }
  else
  {
    *(_DWORD *)a3 = 0;
  }
  return result;
}
// 100041C0: using guessed type int gNtBuildNumber;

//----- (10002BF0) --------------------------------------------------------
void __stdcall PEDriver_Unload(int a1)
{
  LSA_UNICODE_STRING DestinationString; // [esp+0h] [ebp-3Ch]
  WCHAR SourceString[8]; // [esp+8h] [ebp-34h]
  __int128 v3; // [esp+18h] [ebp-24h]
  __int64 v4; // [esp+28h] [ebp-14h]
  int v5; // [esp+30h] [ebp-Ch]
  wchar_t v6; // [esp+34h] [ebp-8h]

  v5 = *(_DWORD *)L"52";
  _mm_storeu_si128((__m128i *)SourceString, _mm_loadu_si128((const __m128i *)L"\\DosDevices\\PROCEXP152"));
  v6 = aDosdevicesProc[22];
  _mm_storeu_si128((__m128i *)&v3, _mm_loadu_si128((const __m128i *)L"ces\\PROCEXP152"));
  v4 = *(_QWORD *)L"EXP152";
  RtlInitUnicodeString(&DestinationString, SourceString);
  IoDeleteSymbolicLink(&DestinationString);
  IoDeleteDevice(*(PDEVICE_OBJECT *)(a1 + 4));
}
// 10003158: using guessed type wchar_t aDosdevicesProc[23];

//----- (10002C70) --------------------------------------------------------
NTSTATUS __thiscall sub_10002C70(void *this, HANDLE Handle, PHANDLE ObjectHandle, int DesiredAccess)
{
  NTSTATUS result; // eax
  int v5; // esi
  PVOID Object; // [esp+0h] [ebp-4h]

  Object = this;
  result = ObReferenceObjectByHandle(Handle, 0, 0, 1, &Object, 0);
  if ( result >= 0 )
  {
    v5 = ObOpenObjectByPointer(Object, 0x200u, 0, DesiredAccess, 0, 0, ObjectHandle);
    ObfDereferenceObject(Object);
    result = v5;
  }
  return result;
}

//----- (10002CC0) --------------------------------------------------------
PVOID sub_10002CC0()
{
  PVOID result; // eax
  PVOID v1; // esi
  SIZE_T Length; // [esp+8h] [ebp-4h]

  Length = 1000;
  result = ExAllocatePoolWithTag(0, 0x3E8u, 0x58637250u);
  v1 = result;
  if ( result )
  {
    do
    {
      if ( !ZwQuerySystemInformation(SystemModuleInformation, v1, Length, &Length) )
        break;
      ExFreePoolWithTag(v1, 0);
      Length += 1000;
      v1 = ExAllocatePoolWithTag(0, Length, 0x58637250u);
    }
    while ( v1 );
    result = v1;
  }
  return result;
}

//----- (1000505A) --------------------------------------------------------
int Fake_IoCreateDevice()
{
  if ( !sbLibInited )
    WdmlibInit();
  return IoCreateDeviceSecure();
}
// 100041A8: using guessed type char sbLibInited;
// 100041AC: using guessed type int (*IoCreateDeviceSecure)(void);

// ALL OK, 19 function(s) have been successfully decompiled
